For alot of purposes, this display will be used at low resolutions...
	and/or viewed from a distance.

In those cases, the vertical-resolution is so high that it's somewhat easy
to create intermediate colors by alternating between two.

the halfColors script takes in the original palette created for GIMP
and creates a new palette containing every combination of colors that can
be generated by alternating rows.
(even more "colors" could be generated by considering more than two rows,
 but this is a good start)

The result is over 1000 colors, which should be plenty for most purposes.

But it comes at a cost.

Gimp can easily take the original 48-color palette and convert an image
to fit that palette, using "Image -> Mode -> Indexed" and tell it to use
the 48-color palette. But this only works if the palette has less than 256
colors. Yay!

I'm no Gimp expert, but I've done quite a bit of looking, and it seems this
same methodology applied to an arbitrary palette of more than 256 colors
is just not possible

So, what can be done...?

I dunno. A Gimp Script, maybe. ImageMagick? Something custom...?

Could reduce the number of colors *significantly* by making a lot of
assumptions. The most-obvious is: e.g. red has 4 shades, 0=black, 1, 2, 3.
So why consider alternating rows between red=0 and red=2? Why not just use
red=1? The logic is sound, but the result isn't quite valid. I like to
pretend that the four shades of red are evenly-spaced from black to full-
brightness, but the fact is the pseudo-LVDS signals I'm generating aren't
capable of such precision. Just take a look at the 48-color gimp-palette.
('cat LCDdirectLVDS_48c.gpl', or use NotePad or TextEdit, etc...)

The truth is, red=1 is actually 55% bright, nowhere near 1/3rd. And red=2
is 81% bright, well above 66%. 
Alternating red=0 and red=2 would result in 40% bright, which is actually 
*dimmer* than red=1. (whew! I hadn't realized it was so
dramatic!)
It also gets more complicated by e.g. the fact that increasing the Red 
value *also* affects the Green value, etc. (wait, didn't Green affect Blue
even more dramatically, as well? I'm not seeing it in my .gpl file...)

Suffice to say, it'd be nice to use all available possibilities.

As it stands, they can be coded by hand... as in the TET_GRADIENT example.

(
 Whoops, there are a lot of duplicate-values: 
 r0g0b0 + r0g1b2             = r0g1b0     + r0g0b2  = 0,88,125
 black  + dark greenish-blue = dark green + blue	 = 0,88,125
 
 I wonder if this would be indiscernable, or it could be that one might
 look better than the other depending on surrounding context...

 e.g. in a gradient?
)


One good reason for this, if nothing else...
Blue... Blue=0 == Blue=1, combined with the fact that Blue=2 and Blue=3 
are close... in many cases it looks like we've only two options for blue:
full-on or full-off (the difference between 2 and 3 is discernable when
near each other)

UPDATE:
After duplicate-value-removal we've got ~600 colors

These are rough-values, since other colors can affect the values...

Blue:
RGB	fb		fb2.0	fb2.4
60		0		0		0
125	0+2	1     1
157	0+3	2		
190	2		3		2
222	2+3	4
255	3		5		3


Green:
28		0		0		0
92		0+1
125	0+2	1		1
141	0+3
157	1		2
189	1+2	3		2
206	1+3
222	2		4
238	2+3
255	3		5		3

Red:
0		0		0		0
70		0+1	
103	0+2
127	0+3	1		1
141	1		2
173	1+2			2
198	1+3	3
206	2
230	2+3	4
255	3		5		3

(1/3 = 85, 2/3 = 170, 3/3 = 255)


I think it's just luck these happened to work out so algorithmically
(e.g. 0, 0+1, 0+2, 0+3 are all < 1)

And I'm not certain how we get >600 colors when these are all combinations
6 blue, 10 green, 10 red -> 600, must be a few *very similar* colors
due to ... nah, I don't get it.

and it only *slightly* creeps me out to consider matching the number of
colors in each channel 6^3... guess it's no worse than the number of color-
bits per channel...

and, wait... weren't there some odd combinations that also equated?
000 + 012
010 + 002
Heh, it's not so odd a combo when viewed in that way
green's either 1+0 or 0+1

HAH I can't seem to get any combination of my parsers to give 216 colors...


Or an easy-ish implementation would be to have the row-seg-buffer, when
given the value "blue=1" to alternate on its own... would require very
little overhead, and almost ziltch as far as front-end coding...

HAH! It's all fucked up... even the 48-color palette is listing two very different green values as r0g2b0
