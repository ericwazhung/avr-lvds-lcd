These are notes from previous versions that are no longer current
They may be worth looking into again at another time...
They are in no particular order... a/o the first version of this file
 the notes are (mostly) in the order found in main.c prior to v25







The following circuit worked with the LTN but not the IAXG
It had problems with skinny-bits 
(e.g. /H-active, DE inactive, /V inactive -> one high bit: /V)
The AVR PWM output was not fully-swinging, due to slew-rate

one and two high bits:   5V >-----------------------------
                                            .
                                  .        . .
                         0V _____. .______.   .___________

The same is true, but flipped, for single-low-bits
LTN accepted this, because the H and V signals are unused

// Same circuit is used for both CLOCK and DVHB (RX2) LVDS signals:
//
//                                             | LCD
// AVR PWM output:      R1         RXCLK+/RX2+ |       |---
//        0-3.3V >----/\/\/\----+------------------+---| + ---
//                              |              |   \   |      ---_
//                              \  RXCLK-/RX2- |   /   |      ---
//                          R2  /    1.2V >--------+--O| - ---
//                              \              |       |---
//                              /              |
//                              |              |
//                              V              |
//                             GND
//
//THESE VALUES: from v13...
//              Apparently DE bit was not detected, was detecting another
//              bit as DE...
// R1 and R2 are implemented with two 200ohm potentiometers
//    R1 set to 99ohms
//    R2 set to 200ohms
//
//
//
//1.2V is set by a simple voltage-divider fed into a voltage-follower:
//
//       ^
//       |
//       /     ______________
//   R1  \    |              |
//       /    | |---         |
//       \    --| - ---      |
//       |      |       >----+-----> 1.2V (shared by RXCLK- and RX2-)
//       +------| + ---
//       |      |---
//       \        LM324
//   R2  /  
//       \                       ///
//       /
//       |
//       V
//      GND
//
//   R1/R2 are implemented with a 1K potentiometer
//   22uF caps are placed across R1 (because In+ is next to LM324's V+ pin)
//             as well as at the output to GND, along with a .1uF
//
//Red and Green signals are implemented as follows:
//       ^
//       |
//       /
//   R1  \     R1 = 1k || 2k
//       /
//       \                       ///
//       |
//       +-------------------->  RX0+ AND RX1+
//       |
//470pF ---
//      ---
//       |
//       +----+--------------->  RX0- AND RX1-
//       |    |
//       \    |
//   R2  /   --- 47uF
//       \   ---
//       /    |
//       |    |
//       V    V
//      GND
//
//      R2 = 680 || 680

The last circuit was overkill, For unused Red/Green inputs
 simply tie RXin+ to VCC via 150ohms and RXin- to GND via 150ohms



   //PWM1X DOES appear to affect the output
   // REGARDLESS of whether we're in a PWM mode (vs normal)
   // It seems to merely invert the outputs
   // so regardless of the mode, deadtimer, etc...
   // if OCWx is high, the output is low and vice-versa
   //clrbit(PWM1X, TCCR1B);




Most of this information is still in main.c but with the current
timing scheme (the Reset bit has been moved since the below was written)
There may be pieces here that could be useful still...
//THESE ARE OLD NOTES THAT SHOULD BE REVISITED A/O v5->v10
// DE option 1:
//
//  Assuming OCW1A: cleared on match, set at BOTTOM
//    (the alternative is not an option, as it would require a delay
//     from the falling-edge of OCW1A, at Reset.
//     This delay only occurs on /OC1A, but /OC1A is only enabled when
//     OCW1A is cleared-on-match, set-at-bottom)
//
//        OCR1A=5 (or earlier for Bn?)
//             |
//             v         Reset
//                       |____ ____ ____ ____ ____
//  OCW1A:     \    .    /    .    .    .    .    \   //blah
//              ¯¯¯¯ ¯¯¯¯
//              ____ ____|____ ____ ____ ____ ____
//   DE:       X    .    .    \ B5 X B4 X B3 X B2 X
//                       |     ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//              _DE_  !V   !H
//                             ____ ____ ____ ____
//   OC1A:     \    .    .    /    .    .    .    \   //blah
//              ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//   OC1A (prior to inversion) is 
//       falling-edge simultaneous, rising-edge delayed
//
//   The output pin should be inverted using PWM1X:
//              ____ ____ ____
//   OC1A:     /    .    .    \    .    .    .    /
//   (PWM1X=1)                 ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//                          ^-- one TCNT delayed output (Dead Timer)
//                              (could use larger delay for Blue Bits)
//                              (could also move OCR1A earlier...)
//
//  So:
//    FastPWM
//    1<=DeadTimerRising<(=?)5 (>1 for blue pixels?) 
//        (==5 cancelled by OCR1A match?)
//    inverted with PWM1X
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    OCR1A = 5 (or 1<=OCR1A<5 for blue pixels?)
//
//  Alternatives:
//    Don't see any...
//
// NothingActive (Nothing Active):
//
//     Same as DE with OCR1A=6
//             OCR1A=6
//                  |
//                  v    Reset
//              ____     |____ ____ ____ ____ ____
//  OCW1A:     .    \    /    .    .    .    .    .
//                   ¯¯¯¯
//                   ____|____ ____ ____ ____ ____
//  NotActive  X    /    .    \ xx X xx X xx X xx X
//              ¯¯¯¯     |     ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//              !DE  !V    !H
//  So:
//    FastPWM
//    1<=DeadTimerRising<=5
//    inverted with PWM1X
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    OCR1A == 6
//
// H (only): 
//   Pretty simple...
//
//             OCR1A=6
//                  |
//                  v    Reset
//              ____     |____ ____ ____ ____ ____
//  OCW1A:     .    \    /    .    .    .    .    .
//                   ¯¯¯¯
//  
//                   ____|     ____ ____ ____ ____
//  H (only):  X    /    \    / xx X xx X xx X xx X
//              ¯¯¯¯     |¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//                   ____|
//  H (only):  .    /    \    .    .    .    .    .
//              ¯¯¯¯     |¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//              !DE  !V    _H_
//  So:
//    FastPWM
//    DeadTimer _OFF_ -> Horiz
//    inverted with PWM1X
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    OCR1A == 6
//
//  Alternatively:
//    set OCW1A mode to match->set, Bottom->cleared
//    clear PWM1X (not compatible with other PWM channels...)
// V (without H):
//
//   SEE ALTERNATIVE 2!
//                      OCR1A=1
//                           |
//                   Reset   v
//                       |____
//  OCW1A:     .    .    /    \    .    .    .    .
//              ¯¯¯¯ ¯¯¯¯      ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//                       |____ ____ ____ ____ ____
//  V w/o H:   X    .    /    \ xx X xx X xx X xx X
//              ¯¯¯¯ ¯¯¯¯|     ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//               !DE  _V_  !H
//  So:
//    FastPWM
//    DeadTimer OFF
//    NOT inverted with PWM1X
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    OCR1A = 1 (or at least < 5 (==5?))
//
//  Alternatively:
//    OCW1A: set @ OCR1A, cleared @ BOTTOM, PWM1X inverts... (?)
//    TODO: Use alternative... (PWM1X inverts ALL pwm channels)
//
//                      OCR1A=1
//                           |
//                   Reset   v
//              ____ ____|     ____ ____ ____ ____
//  OCW1A:     .    .    \    /    .    .    .    .
//                        ¯¯¯¯
//                       |____ ____ ____ ____ ____
//  V w/o H:   X    .    /    \ xx X xx X xx X xx X
//              ¯¯¯¯ ¯¯¯¯|     ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//               !DE  _V_  !H
//  So:
//    FastPWM
//    OFF <= DeadTimer <= (5 - OCR1A)
//    inverted with PWM1X
//    ***OCW1A: cleared at BOTTOM, set at OCR1A
//        ??? What is the effect of changing this while running?
//    1 <= OCR1A <= 5

// BUT WAIT!
// Alternative 2:
//    Remove edge-change
//        (complementary-mode is required for dead-timer,
//         but cannot change the OCW1A edges in this mode)
//    Not really possible...
//    Instead of using set@BOT as default, use COMPLEMENTARY as default
//    and HERE ONLY change to NON-COMPLEMENTARY, clr@BOT
//    No other changes necessary...



// V (with H):
//  (Identical to DE, but inverted) 
//  ( All LOW OK )
//
// SEE ALTERNATIVE:
//
//        OCR1A=5 (or earlier)
//             |
//             v         Reset
//                       |____ ____ ____ ____ ____
//  OCW1A:     \    .    /    .    .    .    .    \   //blah
//              ¯¯¯¯ ¯¯¯¯
//                       |     ____ ____ ____ ____
//  V w/ H:    X    .    .    / xx X xx X xx X xx X
//              ¯¯¯¯ ¯¯¯¯|¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯
//               !DE  _V_  _H_
//  So:
//    FastPWM
//    DeadTimerRising=1
//    NOT inverted with PWM1X
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    OCR1A = 5 (or less)
//  
// Alternative 1:
//
//    Remove PWM1X change, as this affects all pwm channels
//    ALL LOW OK
//    OCW1A: set @ BOTTOM, cleared @ OCR1A
//    Due to PWM1X inverting, output will be cleared at BOTTOM
//    Set OCR1A > (=?) OCR1C so it won't be set...
//
//        (previous???)
//             |                                HERE
//             v         Reset                    |         Reset
//                       |____ ____ ____ ____ ____ ____ ____|
//  OCW1A:     \    .    /    .    .    .    .    .    .    .
//              ¯¯¯¯ ¯¯¯¯                         |
//              ____ ____|                        |
//  V w/ H:    /    .    \    .    .    .    .    .    .    .
//                       |¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯ ¯¯¯¯|¯¯¯¯ ¯¯¯¯
//               !DE  _V_  _H_                      !DE  _V_
// CRAP!
// TODO: WHAT is the effect of ALL these settings-changes?
//       e.g. "HERE" above...
//        on first reset, we'll have whatever H value (possibly previous?)
//        What kinds of glitches???
//        (e.g. clearing a dead-timer before _H_ completes...)
//         or changing a dead-timer while it's running?
//
// Ignoring all that, for now..
//   So:
//     FastPWM
//     DeadTimer OFF (H -> Low)
//     inverted with PWM1X
//     OCW1A: set @ BOTTOM, cleared @ OCR1A
//     OCR1A > (=?) OCR1C
//
//
// ISSUES:
//    Using Dead-Timer does not allow for use of complementary outputs
//      as complementary LVDS inputs...
//
//    Options: 
//      // Use OC1B identically configured (except for ~PWM1X)
//      //   Delay due to extra set-up instructions likely to cause issues
//      // NOT AN OPTION. DeadTimer affects all Channels, as does PWM1X
//
//      We're going to have to fake differential signalling...
//         e.g. use a voltage-divider on the inverted pin:
//         (I suppose the pin could be changed and we wouldn't need PWM1X?)
//
//    This is necessary for all lvds signals (including clock)
//       due to dead-timer...
//    Clock: Will have to be on the opposite PWM channel
//       To avoid H/D/V's dead-timer affecting the clock.
//       Since OC1A is used for H/D/V signalling
//       /OC1B (inverted OC1B) will have to be used for clocking
//    ROUGHLY:
//
//      3.3V
//       ^
//       |
//       /
//       \                                                  //blah
//       /
//       |
//       +--------                    |---
//       |        \           --+-----|   ---
//       /         \         /  |     | +    ---
//       \          \ ____  /   /     |         ---
//       /           =)   )=    \ 100 |            ==----------
//       |          / ¯¯¯¯  \   / ohms|         ---
//      GND        /         \  |     | -    ---
//                /           --+----O|   ---
//    SIGL >------                    |---
//
//  OC1A Output:
//  __|\___ SIG3 = OC1A
//    |/    (0-3.3V)
//
//
//   SIG3 >---/\/\/---+----> SIGL
//                    |
//                    /
//                    \  (Necessary? Is it even useful?)
//                    /
//                    |
//                   GND
Turns out the output driver is not fast enough for this, see slew rate notes



Not sure whether there's anything worth saving here:
The states refer to lvdsStates (still noted in main.c)
//state2
// ¯.¯,¯.B.B.B.B
void lvds_DE(void)
{
// i   FastPWM
//  * 1<=DeadTimerRising<(=?)5 (>1 for blue pixels?) 
//        (==5 cancelled by OCR1A match?)
      DT1 = (1<<4);
// i   inverted with PWM1X
//  * OCW1A: set @ BOTTOM, cleared @ OCR1A
      lvds_clrOnCompare();
//  * OCR1A = 5 (or 1<=OCR1A<5 for blue pixels?)
      OCR1A = 4; //1; //4;//5;
}

//state1
// _.¯,_.X.X.X.X
//    What about: OCW set @ 0, rising dead-time = 5, OCR @ 6?
void lvds_HOnly(void)
{
// i   FastPWM
//  * DeadTimer _OFF_ -> Horiz
      DT1 = 0;
// i   inverted with PWM1X
//  * OCW1A: set @ BOTTOM, cleared @ OCR1A
      lvds_clrOnCompare();
//  * OCR1A == 6
      OCR1A = 5;// 6;
}

//state0
// _.¯,¯.X.X.X.X
void lvds_NothingActive(void)
{
// i   FastPWM
//  * 1<=DeadTimerRising<=5
      DT1 = (1<<4);
// i   inverted with PWM1X
//  * OCW1A: set @ BOTTOM, cleared @ OCR1A
      lvds_clrOnCompare();
//  * OCR1A == 6
      OCR1A = 5; //6; DIDN'T I ALREADY CHANGE THESE?
                  // Think I had notes about it, too... 
                  // in another version? (dud?)
}

//state3
// _._,¯.X.X.X.X
void lvds_VwithoutH(void)
{
// i   FastPWM
//  * OFF <= DeadTimer <= (5 - OCR1A)
      DT1 = 0;
// i   inverted with PWM1X
//  **OCW1A: cleared at BOTTOM, set at OCR1A
//        ??? What is the effect of changing this while running?
      lvds_setOnCompare();
//  * 1 <= OCR1A <= 5 //SHOULDN'T THIS BE FOUR?
      OCR1A = 1;//4;//1
      //NOTE: OCR1A = 1 corresponds to TWO bit-times
      //      OCR1A = 0 corresponds to ZERO
      // Thank goodness the later bits are don't-cares, eh?
}

//state4
// _._,_.X.X.X.X
// _._,_._._._._
void lvds_VwithH(void)
{  
   //VwithH is surrounded COMPLETELY by VwithoutH
   // Since VwithoutH has to be setOnCompare
   //  it makes more sense to change this to setOnCompare as well
   // and compare at 0...

   //UNTESTED
   DT1 = 0;
   lvds_setOnCompare();
   OCR1A = 0;

*/
/*
// i   FastPWM
//  * DeadTimer OFF (H -> Low)
      DT1 = 0;
// i   inverted with PWM1X
//  * OCW1A: set @ BOTTOM, cleared @ OCR1A
      lvds_clrOnCompare();
//  * OCR1A > (=?) OCR1C
      OCR1A = 0xff;   

   //DeadTimer OFF (HSync -> Low)
   // TODO: DeadTimer affects ALL PWM outputs!
   // Though it's only ever used on the positive (?) output
   // (for timing, anyhow)
   // So other LVDS lines could be driven as below on the negative output.
   //DT1 = 0;
   //OCW1A: set @ BOTTOM, cleared @ OCR1A
   //  Alternatively: Use 0,1 for /OCW1A (and don't activate its output?)
   //writeMasked(((1<<COM1A1) | (0<<COM1A0)),
   //            ((1<<COM1A1) | (1<<COM1A0)),
   //            TCCR1A);
               
   //We don't want the pin state to change in this case...
//   OCR1A = 0xff
*/
//}  









The following are (mostly) PRE-LVDS notes: 
i.e. TFT with TTL rather than LVDS input: (LCDdirect vs LCDdirectLVDS)
There may still be some useful info here.
Also, it may be plausible to use this info to combine LCDdirect and LCDdirectLVDS code...?
In any case, it may make more sense to view it in context in <v24


//Apparently loading takes exactly the same amount of time as
// is the limit for OCR1A weird.
// if loading is enabled, interrupts will occur back-to-back
//  and some may be missed
#define NOLOAD

// Timing:
//   Pins:
//     Pixel Clock (tied directly to 30MHz oscillator, XTAL2 pin 12)
//     Hsync        can be free-running
//     DataEnable   only high during valid pixel data
//     Vsync        Low for ~6 hsyncs before the next screen refresh

/*
// Obviously, we can't handle each individual pixel clock
//   So NUMCLKS is pixel-clocks per for-loop in Hsync_withDE()
//  Found experimentally and by looking at the output assembly...
// 10 is cool, "graybar greens and blues"
// I think 7 was too... "jello"
// 18 "pinks and blues"
// 36 is the highest non-blank, 5 is the lowest-ish
// The above are from version 10... version 11 invalidates 'em
// 6 "changing channels"
// 12 "beat-ish"
#define NUMCLKS 10
*/


// Values here are measured from the display's original application...
//   All signals are 3.3V except Pixel Clock...
//
//   Pixel Clock
//      Period: 29ns, 34.341 MHz
//      Display is in dual-pixel mode, each clock clocks two pixels
//      Sinusoidal
//        Centered around 1.8V Peaking just over 2V (should recheck this)
//
//   Hsync
//      Can run freely... (regardless of DE/Vsync)
//      Low for ~300ns
//         Roughly 10 clocks
//      High for ~20.8us
//          Rouhgly 717 clocks
//
//#define T_Hhigh (718) //(T_HD + T_DE + T_DH)

// T_Hlow measured = ~ 490ns -> 7.35 cyc (at 15MHz)


/*#define Hlow_Delay() \
   asm("nop")//; asm("nop"); asm("nop"); asm("nop"); 
*/


// Appears to have no effect...
// Not true... with T_HD=70 T_DH=80 T_Hlow from 17-200
// Somewhere in these experiments it fixed the vertical offset problem
// NOW: 70 is necessary... 36 won't sync, and 160ish causes vsync problems
// This was giving ~200ns which was less than 8 nops (above)
// 8nops is giving ~700ns (B-Time, must be wrong... but the ratio is right)
// 8nops is more stable
/*
#define T_Hlow 15//70 //136//17//25//136 //(NUMCLKS+1) //(10)
#if (T_Hlow < NUMCLKS)
 #define T_Hlow NUMCLKS
 #warning "T_Hlow bumped to NUMCLKS"
#endif
#define T_Hlow_REAL (T_Hlow/NUMCLKS)
//// Let's just assume that there're 15 cpu cycles to enter the interrupt
//// This value is only used for calculating OCR1A... (so far)
// NO MORE! ^^^
//  since it's in a for loop... (see T_HD)
*/


// This is the number of cpu cycles that DE should be high...
// it should be 1/30MHz * 512 = 17.067us
//  and in CPU cycles that'd be...
//    17.067us / (1/15MHz) = 256 (duh)
// This value is only used for calculating OCR1A... (so far)
//#define T_DE_CYC 255
//#define VISIBLE_DOTS  1024


//#define T_DE 488
// Let's center DE for now...
// this should be 103/NUMCLKS

// T_HD measured = ~< 200ns
/*#define HD_Delay() \
   asm("nop")//; asm("nop"); asm("nop")
*/
// asm("nop")//; asm("nop"); asm("nop")


// Appears to have no effect..
// Not true... With T_DH = 80, we need at least T_HD=70
/*
#define T_HD   10 //220 //70//250 //140//7 //140 //100 //((T_Hhigh - T_DE) /
 2)
#define T_HD_REAL (T_HD/NUMCLKS)
#if (T_HD_REAL < 1)
 #define T_HD_REAL 1
 #warning "T_HD bumped to NUMCLKS"
#endif
// This is the number of CPU cycles between Horiz_H -> DE->H
// T_HD_REAL determines this value, but it's not very accurate 
//  since it's in a for loop...
*/



/*
// T_DH measured = ~ 4.3us
// Values 80-550 seem to have no effect...
#define T_DH   160 //80//149 //70//100//(T_Hhigh-T_HD-T_DE) //T_HD
#if (T_DH < NUMCLKS)
 #define T_DH NUMCLKS
 #warning "T_DH bumped to NUMCLKS"
#endif
*/
// This is the number of CPU cycles between DE->L and Horiz->L
//   This value is really the buffer for OCR1A
//   The time when we're *not* in the interrupt
//     assuming all the other T_*_CYC values are accurate
//     (which they're not)
//     4.3us measured before equates to 150.5 (with a dotclock of 35MHz)
//     64.5 cyc at 15MHz...
// With Loading enabled, we apparently have the same time as the max DH
//  measured here... luck I guess.
// 188 causes flicker, 187 seems perfectly stable (with columns)
// THESE VALUES ARE WRONG; T_Hlow_CYC was mistakenly calced by T_HD
// So the actual values should be larger... T_Hlow_CYC was 66
//   should have been 21
//   so actual values should be larger by 45: 187OK->212
//   or my math is off.. 225 seems to work
//   and the goal (prior to finding this) was to optimize the other
//   values to get more free-time for loading a row
//   as it was slightly unstable...
//   Now: 250 looks stable (with columns)
//        slightly vertically unstable with a picture...
//   row loading seems to exist between 200 (220?) and 230
//   NOW: can't recall what it's at... 180ish
//        apparently a lower value for data-invalid lines (vsync, etc)
//        is acceptable (!?)

//#define T_DH_CYC    20//225 //187 OK//120 OK//65==GOOD (calced above)


//       |
//       v
//      T_DH
//      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
// H   __.  ____________  .___________
//      .|_|  .        .|_|  .
//     _.     .________.     .___________
// DE   |_____| 512clk |_____|
//      ^              ^
//       \___________   \                        (just avoiding \ warning)
//                   \  |     768 Hsyncs
//                    v v
//     _             _ _ _ _ _ _ _ _ _ _ 
// DE   |___________| | | | | | | | | | |______
//       ~720us
//   remeasured: 
// 
//     Vsync
//        Low for 124us (6 Hsyncs)
//        Period: 16.56ms (~60hz)
// one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
// In Hsyncs:
// T_VD measured: 340us (360 in storage mode)
//#define T_VD 4//17//(16)


// T_DV measured: 270us
//#define T_DV 4//14//(29)

// T_Vlow measured: 125us
// At highest 'scope resolution: 
//    Vsync L->H seems simultaneous with Hsync H->L
//#define T_Vlow  2//16//6//(16)


/*
//Rather arbitrary... there happens to be a connector already soldered
//  though maybe I'll switch it up to use the timer outputs...
#define HSYNC_PIN    PD5   //OC1A, unused but maybe in the future
#define DE_PIN       PD6
#define HSYNC_PORT   PORTD
#define DE_PORT      PORTD
#define VSYNC_PIN    PD7   //OC2A, ditto
#define VSYNC_PORT   PORTD
#define DATA_PORT    PORTA
#define DATA_DDR     DDRA
//#define FAKE_PORT     PORTB

#define SCOPING   TRUE

//uint8_t picNum = 0;
extern uint8_t mainData[2][768>>5][IMAGE_WIDTH];
uint8_t settingBuffer[768>>5][FB_WIDTH];
//volatile to make reads identically-lengthed...
volatile uint8_t rowBuffer[FB_WIDTH] = \
   {1,0,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,3};

#if (defined(SCOPING) && SCOPING)
uint8_t scopeBuffer[768];
#endif

// Original idea: OCR1A match causes an interrupt AND sets Hsync low
//   interrupt entry takes a predictable number of instructions
//     After which, pull Hsync High 
//        (way more than the 7.3dot-clocks... maybe see the "other idea")
//     Load first pixel
//     Set DE
//     Load pixels
//     Clear DE
//     Reset Counter and set OCR1A
//Another idea is:
//   Allow OCR1B match to cause an interrupt
//
// Using the timer compare-match to clear the pin makes it impossible
// to set it again.
uint8_t dataEnable = 0;
uint16_t hsyncCount = 0;

static __inline__ \
void loadRow(uint8_t rowNum, uint8_t colorOverride)
      __attribute__((__always_inline__));
//    __attribute__((__optimize__ ("unroll-loops","unroll-all-loops",\
                  "peel-loops","unsafe-loop-optimizations")))
//void loadRow(uint8_t rowNum);


// Has no effect: Nor does unroll-all-loops    
//__attribute__((optimize ("unroll-loops")));

hfm_t modulator;

#define DATA_PORT PORTA






In the interrupt:
   // Here is where loadRow used to be called
   // it has been moved to oldNotes.txt, but it would make more sense
   // to look at LCDdirectLVDS <25 or LCDdirect
   // loadRow used the time between DE inactive and the next Hsync
   // to load a row to a row-buffer (as opposed to a frame-buffer)
   // thus, DE could gain more pixels because there would be fewer
   // calculations to determine the memory location to write from
   // This effect has since been minimized
   // BUT loadRow might be necessary for program-memory-based images...
//#ifndef NOLOAD
// if(dataEnable)
//    loadRow(((hsyncCount-T_VD-T_Vlow)>>3)&31, colorOverride);
//#endif

/* //--v if(dataEnable && (hsyncCount < V_COUNT+(T_VD+T_Vlow)))
   {
      uint8_t i;
      for(i=0; i<FB_WIDTH; i++)
         rowBuffer[i] = settingBuffer[(hsyncCount-T_VD-T_Vlow)>>5][i];
   }
//--^
*/

#ifndef NOLOAD
void loadRow(uint8_t rowNum, uint8_t colorOverride)
{
   if((rowNum >= 24) && (colorOverride == 0xff))
      colorOverride = 6;

   if(colorOverride == 0xff)
   {
// uint8_t i;
// for(i=0; i<FB_WIDTH; i++)
   rowBuffer[0] = settingBuffer[rowNum][0];
   rowBuffer[1] = settingBuffer[rowNum][1];
   rowBuffer[2] = settingBuffer[rowNum][2];
   rowBuffer[3] = settingBuffer[rowNum][3];
   rowBuffer[4] = settingBuffer[rowNum][4];
   rowBuffer[5] = settingBuffer[rowNum][5];
   rowBuffer[6] = settingBuffer[rowNum][6];
   rowBuffer[7] = settingBuffer[rowNum][7];
   rowBuffer[8] = settingBuffer[rowNum][8];
   rowBuffer[9] = settingBuffer[rowNum][9];
   rowBuffer[10] = settingBuffer[rowNum][10];
   rowBuffer[11] = settingBuffer[rowNum][11];
   rowBuffer[12] = settingBuffer[rowNum][12];
   rowBuffer[13] = settingBuffer[rowNum][13];
   rowBuffer[14] = settingBuffer[rowNum][14];
   rowBuffer[15] = settingBuffer[rowNum][15];
   rowBuffer[16] = settingBuffer[rowNum][16];
   rowBuffer[17] = settingBuffer[rowNum][17];
   rowBuffer[18] = settingBuffer[rowNum][18];
   rowBuffer[19] = settingBuffer[rowNum][19];
   rowBuffer[20] = settingBuffer[rowNum][20];
   }
   else
   {
      rowBuffer[0] = colorOverride; //settingBuffer[rowNum][0];
      rowBuffer[1] = colorOverride; //settingBuffer[rowNum][1];
      rowBuffer[2] = colorOverride; //settingBuffer[rowNum][2];
      rowBuffer[3] = colorOverride; //settingBuffer[rowNum][3];
      rowBuffer[4] = colorOverride; //settingBuffer[rowNum][4];
      rowBuffer[5] = colorOverride; //settingBuffer[rowNum][5];
      rowBuffer[6] = colorOverride; //settingBuffer[rowNum][6];
      rowBuffer[7] = colorOverride; //settingBuffer[rowNum][7];
      rowBuffer[8] = colorOverride; //settingBuffer[rowNum][8];
      rowBuffer[9] = colorOverride; //settingBuffer[rowNum][9];
      rowBuffer[10] = colorOverride; //settingBuffer[rowNum][10];
      rowBuffer[11] = colorOverride; //settingBuffer[rowNum][11];
      rowBuffer[12] = colorOverride; //settingBuffer[rowNum][12];
      rowBuffer[13] = colorOverride; //settingBuffer[rowNum][13];
      rowBuffer[14] = colorOverride; //settingBuffer[rowNum][14];
      rowBuffer[15] = colorOverride; //settingBuffer[rowNum][15];
      rowBuffer[16] = colorOverride; //settingBuffer[rowNum][16];
      rowBuffer[17] = colorOverride; //settingBuffer[rowNum][17];
      rowBuffer[18] = colorOverride; //settingBuffer[rowNum][18];
      rowBuffer[19] = colorOverride; //settingBuffer[rowNum][19];
      rowBuffer[20] = colorOverride; //settingBuffer[rowNum][20];
   }
}
#endif








In loadData:
   // The first go, each of these are loaded from memory to registers
   // After that, it reuses the registers rather than 
   // the slower reading from memory...
   // HOWEVER:
   // there are not enough registers for as many pixels as can be
   // written at full-speed (pre-lvds note)
   
   //extern uint8_t rowBuffer[];
// register uint8_t one asm("r8");
// one = settingBuffer[rowNum][1];
// register uint8_t two asm("r9");
// two = settingBuffer[rowNum][2];
// register uint8_t three asm("r10");
// three = settingBuffer[rowNum][2];

// register uint8_t reg[21] asm("r8");
   
   //LimitedMemTest...
   //rowNum = 0;

// reg[0] = settingBuffer[rowNum][0];

// DATA_PORT = settingBuffer[rowNum][0];
// clrpinPORT(HSYNC_PIN, HSYNC_PORT);

..........
In LoadData:
   //Out here so data's ready before DE...
//   DATA_PORT = reg[0];
...
      //if(colorOverride == 0xff)
      //{
      //setpinPORT(DE_PIN, DE_PORT);
//      DEonly_fromNada();
-------




main() LVDS Transition Testing:
These may well be old transitions (before the clock-change)
   //Nada:
   DT1 = (2<<4);
   OCR1A = 3;

   while(1)
   {
      //while(TCNT0L); //This helps to align configuration changes
                  // It's probably no longer relevent
                  // since all(?) transitions are a single change

      OCR1B = 0xff;
      OCR1B = 0x01;

      //Nada -> V
//#define Vsync_fromNada() { DT1=(3<<4); }
         //DT1=(3<<4);
         Vsync_fromNada();
         asm("nop");
         asm("nop");
         asm("nop");
      
      //V -> V+H
//#define VplusH_fromVsync()  { OCR1A=0; }
         //OCR1A = 0;
         VplusH_fromVsync();
         asm("nop");
         asm("nop");
         asm("nop");

      //V+H -> V
//#define Vsync_fromVplusH()  { OCR1A=3; }
         //OCR1A = 3;
         Vsync_fromVplusH();
         asm("nop");
         asm("nop");
         asm("nop");

      //V -> Nada
//#define Nada_fromVsync() { DT1=(2<<4); }
         //DT1 = (2<<4);
         Nada_fromVsync();
         asm("nop");
         asm("nop");
         asm("nop");

      //Nada -> H
//#define Hsync_fromNada() { OCR1A=2; }
         //OCR1A = 2;
         Hsync_fromNada();
         asm("nop");
         asm("nop");
         asm("nop");

      //H -> Nada
//#define Nada_fromHsync() { OCR1A=3; }
         //OCR1A = 3;
         Nada_fromHsync();
         asm("nop");
         asm("nop");
         asm("nop");

      //Nada -> DE
//#define DE_fromNada()    { DT1=(1<<4); }
         //DT1 = (1<<4);
         DE_fromNada();
         asm("nop");
         asm("nop");
         asm("nop");

      //DE -> Nada
//#define Nada_fromDE()    { DT1=(2<<4); }
         //DT1 = (2<<4);
         Nada_fromDE();
         asm("nop");
         asm("nop");
         asm("nop");

   }

   DT1 = 1<<4; //For transition-testing... NothingActive is the only
               // state that pays attention to DT... (rest are setOnComp)
   while(1)
   {
      while(TCNT0L);
      asm("nop");
      asm("nop");
      asm("nop");

      //These are only for transition testing
      OCR1B = 0xff;
      OCR1B = 0x01;
      //lvds_NothingActive();
         // *DT:1//DT:1-5
         // *clrComp
         // *OCR:5
         //DT1 = 1<<4; see pre-while note
         //Determined from next state:
         // (Note: signals shown are INVERSE of OCW1A due to PWM1X)
         // (  thus "clrOnCompare" will appear as /set/ )
         //If OCR setting occurs slightly after counter reset (0)...
         // then it won't take effect until next reset (0)
         //Assuming OCR value is large enough to allow a full CPU cycle...
         //Also considering clrOnCompare will take effect at the
         // compare-match after it's called...
         //That compare-match will be the first with the new OCR value
         // Clr-On-Compare will be enabled, but the signal is already in
         // the cleared-state from the clear-on-0 state previously
         // so no pin-change will occur
         //
         // Example Given: OCR written 2 (was 4)
         //
         //  OCR written    OCR effective
         //     |            |
         //     |            |    OCR match
         //     |            |     |
         //     v            v     v
         // 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6
         // _._,¯.¯.¯.¯.¯._._,¯.¯.¯.¯.¯.¯.¯,_._.¯.¯.¯.¯.¯
         //       \________________/
         //         Time to execute \
         //           COM1x1 write   COM1x1 effective
         //         (clrOnCompare())   ComMatch sets output (already set)
         //
         // Because the pin was already high, from clr-on-zero
         //  and clr-on-compare became effective _on_ the compare
         // it will thus stay high.
         //
         // THIS IS A GREAT EXPLANATION FOR HOW THE /NEXT/ TRANSITION WORKS
         // BUT DOES NOT WORK FOR THIS ONE.
         // BIT 5 needs to be _ZERO_ for DE-disabled....
         // Bit 6 can be Low as well, since the next state is V-only...
         // BUT: BIT 0 cannot be low!
         // so we need:
         //
         //   VwithoutH      ->                      NothingActive
         // setOnCompare                             clrOnCompare 
         // (No DT)                                  DT=1
         // OCR=4                                    OCR=5 ------v
         // /¯¯¯¯¯¯¯¯¯¯¯\                            /¯¯¯¯¯¯¯¯¯¯¯¯\
         // 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6
         // ¯.¯.¯.¯.¯._._,¯. . . . ._.x,¯.x.x.x.x._.x,¯.x.x.x.x._.¯
         // H         D V H          ^             ^
         //                          |             |
         //                          clrOnCompare effective (either)
         //                          (also DT)
         asm("nop");
         TCCR1A = (1<<COM1A1) //setOnCompare (same setting as VwithoutH)
                | (1<<COM1A0) // (no PWM)
                | (0<<COM1B1)
                | (1<<COM1B0)
                | (0<<PWM1A)  //PWM disabled 
                              //(this all should take effect immediately)
                | (1<<PWM1B);
         //The datasheet (P101) appears to be misleading...
         // setOnCompare in normal mode only sets the output
         // there is no clear-on-0
         // likewise for clrOnCompare...
         asm("nop");
         asm("nop");
         asm("nop");
         TCCR1A = (1<<COM1A1) //clrOnCompare 
                              //NOT PWM's clrOnCompareComplementary
                | (0<<COM1A0) // (no PWM)
                | (0<<COM1B1)
                | (1<<COM1B0)
                | (0<<PWM1A)  //PWM disabled 
                              //(this all should take effect immediately)
                | (1<<PWM1B);
         asm("nop");
         asm("nop");
         asm("nop");
         TCCR1A = (0<<COM1A1) //toggleOnCompare 
                              //PWM's clrOnCompareComplementary
                | (1<<COM1A0) // (no PWM)
                | (0<<COM1B1)
                | (1<<COM1B0)
                | (0<<PWM1A)  //PWM disabled 
                              //(this all should take effect immediately)
                | (1<<PWM1B)
                | (1<<FOC1A);
         asm("nop");
         asm("nop");
         asm("nop");


         OCR1A = 5;  //Set first...
         lvds_clrOnCompare(); //Set second...
         //OCR1A = 5;
         asm("nop");
#ifndef _DEPERFECT_
         //Of course, DEPERFECT's affect will change with
         // changes to the number of instructions in this loop...
         asm("nop");
         asm("nop");
#endif


      asm("nop");
//BROKEN WITH EACH CHANGE ABOVE...
      //lvds_VwithoutH();
      // This is a nice transition in testing... 
      // ..._.¯,¯... -> ..._._,¯''' -> '''_._,¯'''
      //    D V H          D V H          D V H
      //            Comp4 effective
      //Comp4 written |
      //    V   Comp5 | DT    Comp4   Fully Configured signal
      //            v v v       v   /¯¯¯¯¯¯¯¯¯¯¯¯\
      // 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 
      // ¯._._._._._.¯.¯._._._._._._.¯.¯.¯.¯.¯._._.¯.'''
      //           D V H         D V H         D V H
      //            \__________/\
      //        Time to execute  COM1x1 effective
      //         COM1x1 write    ComMatch sets OCW (clears output)
      //        Actually: Time   (output already cleared by DT earlier)
      //        at which COM1x1
      //        write must be
      //        completed.
      //        Instruction could be started earlier
      //        as long as Comp4 write is complete AFTER 0
      //
      // BUT IT IS DEPENDENT ON THE PHASE OF THE INSTRUCTION-CALL
      // Removal of two nops above gives:
      // ..._.¯,¯... -> ...¯.¯,_... -> ..._._,¯''' -> '''_._,¯'''
      // Spurious:      DE-^              ^
      //                      Why doesn't OCR1A=4 affect here?
      // Maybe it does...?
      //   COM1x1 changes occur at the next match
      //   so the match goes low (setOnCompare+PWM1X inversion)
      //   (but it was already low)
      //   (but there's a set-delay, so it should go low one bit later)
      // Also Odd: Why isn't it alternating? Seems unlikely
      // we'd have exactly a number of cycles in this loop such that
      //  8 * N + 1 = M * 7 AND
      //  8 * N + 2 = L * 7 AND (just tested)
      //  8 * N     = K * 7 where MLK are all integers...
      // Or, somehow, triggering on the overshoot of the clock signal
      // allowed for regular detection of a particular case...
         //=DT:1//DT: 0-(5-OCR1A) NO DT in setOnComp
         // *setComp()
         //=OCR:5//OCR: 1-5 //SHOULDN'T THIS BE FOUR?! YES.
         // WAIT: it should be one less due to DT=1 previously
         // the *limit* should not be 4, but 5.
         OCR1A = 4;
         lvds_setOnCompare();
         //Switching the order:
         //(setOnCompare disables the dead-timers)
         //The setOnCompare should occur on compare of 5
         // clearing the already low output
         // then clearing OCW at 0
         // setting the output
         // then settingOCW at 5, and updating OCR to 4
         // clearing the output (at 5) 
         //Spurious DE from the other direction... YEP.
         //NO DELAY with setOnCompare...
         //OCR1A = 4;

         asm("nop");
         asm("nop");
         asm("nop");

   }

   while(1)
   {
/*
      dms4day_t thisTime = dmsGetTime();

      heartUpdate();

      if(thisTime - lastTime > 20*DMS_SEC)
      {
         lastTime = thisTime;

//       DT1 = deadTime<<4;

         lvdsState++;
         if(lvdsState >= 7)
         {
//          deadTime++;
            lvdsState = 0;
         
//          if(deadTime >= 7)
//             deadTime = 0;

         // DT1 = deadTime<<4;
         }
//       OCR1A = lvdsState;

         set_heartBlink(lvdsState);

         //This is just for testing...
         switch(lvdsState)
         {
            case 0:
               lvds_NothingActive();
               break;
            case 1:
               lvds_HOnly();
               break;
            case 2:
               lvds_DE();
               break;
            case 3:
               lvds_VwithoutH();
               break;
            case 4:
               lvds_VwithH();
               break;
            default:
               break;
         }

      }
*/






OLD PICTURE-CHANGING STUFF:

//    static uint8_t picNum = 0;
//    static uint16_t frameNum = 0;



/*    static uint8_t fbRow = 0;
      static uint8_t fbCol = 0;

      if(fbCol == FB_WIDTH)
      {
         fbCol = 0;
         fbRow++;
      }
      
      if(fbRow == (768>>5))
      {
         if(picNum == 0)
            picNum = 1;
         else
            picNum = 0;

         fbRow=0;
      }
*/
/*    uint8_t fbRow, fbCol;

      for(fbRow=0; fbRow<(768>>5); fbRow++)
      {
#if (FB_WIDTH >= 21)
 #define COPY_WIDTH IMAGE_WIDTH
#else
 #define COPY_WIDTH FB_WIDTH
#endif
         for(fbCol=0; fbCol<COPY_WIDTH; fbCol++)
         {
//          picNum = !picNum;
            frameBuffer[fbRow][fbCol] = mainData[picNum][fbRow][fbCol];
         }
#if (COPY_WIDTH > 21)
         uint8_t extra;
         for(extra=0; extra<(FB_WIDTH-COPY_WIDTH); extra++)
            frameBuffer[fbRow][fbCol+extra] = 2;
#endif
      }

   // fbCol++;

      //FullFrame(TRUE);
      frameNum++;

      if(frameNum == FB_WIDTH*(768>>5))
      {
         frameNum = 0;
         if(picNum)
            picNum = 0;
         else
            picNum = 1;
      }
   // heartUpdate();
*/
   }













//PORTB is unused, so FAKE_DELAY should match DATA_PORT++ in T_DE...
#define FAKE_DELAY() \
   asm("nop"); asm("nop"); 
//asm("nop"); asm("nop"); asm("nop"); asm("nop");
// if(withDE)
//    FAKE_PORT++
//#define FAKE_DELAY()  {}
// Starts at the Hsync low-to-high edge (DE is already low)
void Hsync_withDE(uint8_t withDE)
{
   uint8_t timer;

   //uint8_t *(data[FB_WIDTH]);;

// if(withDE)
   // data = mainData[rowNum];
      DATA_PORT = rowBuffer[0]; //settingBuffer[rowNum][0];
// else
//    FAKE_PORT = rowBuffer[0]; //settingBuffer[rowNum][0];


   // Hsync H->L
   clrpinPORT(HSYNC_PIN, HSYNC_PORT);
   for(timer=0; timer<T_Hlow/NUMCLKS; timer++)
   {
         FAKE_DELAY();
   }

   // HSYNC L->H
   setpinPORT(HSYNC_PIN, HSYNC_PORT);

   for(timer=0; timer<T_HD/NUMCLKS; timer++)
   {
      FAKE_DELAY();
   }

   // DE L->H
   if(withDE)
      setpinPORT(DE_PIN, DE_PORT);


   loadData();

   // DE H->L
   //if(withDE)
      clrpinPORT(DE_PIN, DE_PORT);

   //DATA_PORT = 0; 

   // DE L -> Hsync L delay
   for(timer=0; timer<T_DH/NUMCLKS; timer++)
   {
      FAKE_DELAY();
   }

   // Hsync H->L
// clrpinPORT(HSYNC_PIN, HSYNC_PORT);

// for(timer=0; timer<T_Hlow/NUMCLKS; timer++)
// {
//    FAKE_DELAY();
// }

// // Hsync H->L
// clrpinPORT(HSYNC_PIN, HSYNC_PORT);
// for(timer=0; timer<T_Hlow/NUMCLKS; timer++)
// {
//      FAKE_DELAY();
// }
// // HSYNC L->H
// setpinPORT(HSYNC_PIN, HSYNC_PORT);
// for(timer=0; timer<T_HD/NUMCLKS; timer++)
// {
//    FAKE_DELAY();
// }
}

/*
// Starts with Hsync L->High edge...
void Hsync_NoDE(void)
{
   uint8_t timer;
   
   setpinPORT(HSYNC_PIN, HSYNC_PORT);

   for(timer=0; timer<T_Hhigh; timer++)
   {}

   clrpinPORT(HSYNC_PIN, HSYNC_PORT);

   for(timer=0; timer<T_Hlow; timer++)
   {}
}
*/



In main():

   // It starts with CLKDIV8 (from 30MHz)
   //   so it will be in range
   /* From the manual:
      To avoid unintentional changes of clock frequency, a special write 
      procedure must be followed to change the CLKPS bits: 
      1. Write the Clock Prescaler Change Enable (CLKPCE) bit to one 
         and all other bits in CLKPR to zero. 
      2. Within four cycles, write the desired value to CLKPS while 
         writing a zero to CLKPCE. 
      Interrupts must be disabled when changing prescaler setting to make 
      sure the write procedure is not interrupted. */

   // Set the prescaler to 2 (30MHz -> 15MHz)
// CLKPR=(1<<CLKPCE);
// CLKPR=(1<<CLKPS0); // Division factor 2
   // CLKPR=0 is Division Factor 1 if I want to try overclocking later...


// setoutPORT(DE_PIN, DE_PORT);
// setoutPORT(HSYNC_PIN, HSYNC_PORT);
// setoutPORT(VSYNC_PIN, VSYNC_PORT);
// clrpinPORT(DE_PIN, DE_PORT);
// setpinPORT(HSYNC_PIN, HSYNC_PORT);

// uint8_t row, col;
// for(row=0; row<(768>>5); row++)
//    for(col=0; col<FB_WIDTH; col++)
//    {
//       mainData[row][col] = row+col;
//    }

// setpinPORT(VSYNC_PIN, VSYNC_PORT);

   //Set the entire PORTA as outputs (3 bits used for color data)
// DATA_DDR = ALLOUTS; //0xff;
   // Doesn't really seem to help...
// for(i=0; i<768; i++)
//    Hsync_NoDE();
//    FullFrame(FALSE);

// hfm_setup(&modulator, 0x7f, 39);
// hfm_setPower(&modulator, 1);

// dataEnable = TRUE;

