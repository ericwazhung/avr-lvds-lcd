GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 1


   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.stabs	"/Users/meh/_avrProjects/LCDdirectLVDS/59-reallyCommon2/",100,0,2,.Ltext0
  10               		.stabs	"main.c",100,0,2,.Ltext0
  11               		.text
  12               	.Ltext0:
  13               		.stabs	"gcc2_compiled.",60,0,0,0
  14               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  15               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  16               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  17               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  18               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  19               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  20               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  21               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  22               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  23               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  24               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  25               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  26               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  29               		.stabs	"projInfo.h",130,0,0,0
  30               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdint.h",130,0,0,0
  32               		.stabs	"int8_t:t(3,1)=(0,10)",128,0,121,0
  33               		.stabs	"uint8_t:t(3,2)=(0,11)",128,0,122,0
  34               		.stabs	"int16_t:t(3,3)=(0,1)",128,0,123,0
  35               		.stabs	"uint16_t:t(3,4)=(0,4)",128,0,124,0
  36               		.stabs	"int32_t:t(3,5)=(0,3)",128,0,125,0
  37               		.stabs	"uint32_t:t(3,6)=(0,5)",128,0,126,0
  38               		.stabs	"int64_t:t(3,7)=(0,6)",128,0,128,0
  39               		.stabs	"uint64_t:t(3,8)=(0,7)",128,0,129,0
  40               		.stabs	"intptr_t:t(3,9)=(3,3)",128,0,142,0
  41               		.stabs	"uintptr_t:t(3,10)=(3,4)",128,0,147,0
  42               		.stabs	"int_least8_t:t(3,11)=(3,1)",128,0,159,0
  43               		.stabs	"uint_least8_t:t(3,12)=(3,2)",128,0,164,0
  44               		.stabs	"int_least16_t:t(3,13)=(3,3)",128,0,169,0
  45               		.stabs	"uint_least16_t:t(3,14)=(3,4)",128,0,174,0
  46               		.stabs	"int_least32_t:t(3,15)=(3,5)",128,0,179,0
  47               		.stabs	"uint_least32_t:t(3,16)=(3,6)",128,0,184,0
  48               		.stabs	"int_least64_t:t(3,17)=(3,7)",128,0,192,0
  49               		.stabs	"uint_least64_t:t(3,18)=(3,8)",128,0,199,0
  50               		.stabs	"int_fast8_t:t(3,19)=(3,1)",128,0,213,0
  51               		.stabs	"uint_fast8_t:t(3,20)=(3,2)",128,0,218,0
  52               		.stabs	"int_fast16_t:t(3,21)=(3,3)",128,0,223,0
  53               		.stabs	"uint_fast16_t:t(3,22)=(3,4)",128,0,228,0
  54               		.stabs	"int_fast32_t:t(3,23)=(3,5)",128,0,233,0
  55               		.stabs	"uint_fast32_t:t(3,24)=(3,6)",128,0,238,0
  56               		.stabs	"int_fast64_t:t(3,25)=(3,7)",128,0,246,0
  57               		.stabs	"uint_fast64_t:t(3,26)=(3,8)",128,0,253,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 2


  58               		.stabs	"intmax_t:t(3,27)=(3,7)",128,0,273,0
  59               		.stabs	"uintmax_t:t(3,28)=(3,8)",128,0,278,0
  60               		.stabn	162,0,0,0
  61               		.stabs	"int_farptr_t:t(2,1)=(3,5)",128,0,77,0
  62               		.stabs	"uint_farptr_t:t(2,2)=(3,6)",128,0,81,0
  63               		.stabn	162,0,0,0
  64               		.stabn	162,0,0,0
  65               		.stabs	"main.h",130,0,0,0
  66               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/io.h",130,0,0,0
  67               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdlib.h",130,0,0,0
  72               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/include/stddef.h",130,0,0,0
  73               		.stabs	"size_t:t(8,1)=(0,4)",128,0,211,0
  74               		.stabs	"wchar_t:t(8,2)=(0,1)",128,0,323,0
  75               		.stabn	162,0,0,0
  76               		.stabs	"div_t:t(7,1)=(7,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,71,0
  77               		.stabs	"ldiv_t:t(7,3)=(7,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,77,0
  78               		.stabs	"__compar_fn_t:t(7,5)=(7,6)=*(7,7)=f(0,1)",128,0,80,0
  79               		.stabn	162,0,0,0
  80               		.stabs	"_commonCode_localized/heartbeat/1.21/heartbeat.h",130,0,0,0
  81               		.stabs	"./_commonCode_localized/hfModulation/0.93/hfModulation.h",130,0,0,0
  82               		.stabs	"hfm_t:t(10,1)=(10,2)=B(10,3)=s6runningSum:(3,4),0,16;desiredSum:(3,4),16,16;maxPower:(3,2)
  83               		.stabn	162,0,0,0
  84               		.stabn	162,0,0,0
  85               		.stabn	162,0,0,0
  86               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  87               		.stabs	"prog_void:t(11,1)=(11,2)=(11,2)",128,0,217,0
  88               		.stabs	"prog_char:t(11,3)=(11,4)=@s8;r(11,4);0;255;",128,0,218,0
  89               		.stabs	"prog_uchar:t(11,5)=(11,6)=@s8;r(11,6);0;255;",128,0,219,0
  90               		.stabs	"prog_int8_t:t(11,7)=(11,8)=(0,10)",128,0,221,0
  91               		.stabs	"prog_uint8_t:t(11,9)=(11,10)=(0,11)",128,0,222,0
  92               		.stabs	"prog_int16_t:t(11,11)=(11,12)=(0,1)",128,0,223,0
  93               		.stabs	"prog_uint16_t:t(11,13)=(11,14)=(0,4)",128,0,224,0
  94               		.stabs	"prog_int32_t:t(11,15)=(11,16)=(0,3)",128,0,225,0
  95               		.stabs	"prog_uint32_t:t(11,17)=(11,18)=(0,5)",128,0,226,0
  96               		.stabs	"prog_int64_t:t(11,19)=(11,20)=(0,6)",128,0,228,0
  97               		.stabs	"prog_uint64_t:t(11,21)=(11,22)=(0,7)",128,0,229,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"_commonCode_localized/sineTable/0.99/sineTable.h",130,0,0,0
 100               		.stabs	"theta_t:t(12,1)=(3,3)",128,0,69,0
 101               		.stabs	"sine_t:t(12,2)=(3,3)",128,0,96,0
 102               		.stabs	"mult_t:t(12,3)=(3,5)",128,0,99,0
 103               		.stabs	"axis_t:t(12,4)=(3,5)",128,0,114,0
 104               		.stabn	162,0,0,0
 105               		.stabs	"rowSegBuffer.c",130,0,0,0
 106               		.stabs	"_NONAME_:T(13,1)=s2red_length:(3,2),0,8;green_blue:(3,2),8,8;;",128,0,0,0
 107               		.stabs	"seg_t:t(13,2)=(13,1)",128,0,103,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"getTetBrick:F(3,2)",36,0,393,getTetBrick
 110               		.stabs	"row:P(3,2)",64,0,393,24
 111               		.stabs	"col:P(3,2)",64,0,393,22
 112               	.global	getTetBrick
 113               		.type	getTetBrick, @function
 114               	getTetBrick:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 3


 115               		.stabd	46,0,0
 116               		.stabs	"tetStuff.c",132,0,0,.Ltext1
 117               	.Ltext1:
   1:tetStuff.c    **** //YEP. In a previous version (long before the row-seg-buffer)
   2:tetStuff.c    **** // Tetris was dang-near completion...
   3:tetStuff.c    **** // each block was a single drawable pixel
   4:tetStuff.c    **** // so it was pretty durn ugly.
   5:tetStuff.c    **** // But the refresh-rate was fast-enough at the time and the pixels were
   6:tetStuff.c    **** //  large-enough to make it playable
   7:tetStuff.c    **** // It was, in fact, my lifelong-goal to write Tetris... Ever since I
   8:tetStuff.c    **** // started "coding" in HyperCard.
   9:tetStuff.c    **** // Maybe something groovy could be done with low-refresh-rates...
  10:tetStuff.c    **** // "PredictaTris"... where hand-eye-coordination is handy, it doesn't
  11:tetStuff.c    **** // require much in the way of memory... Could be the same game, the same
  12:tetStuff.c    **** // speeds... just that the screen updates once a second, so you have to 
  13:tetStuff.c    **** // remember your moves and plan 'em out... crazy.
  14:tetStuff.c    **** 
  15:tetStuff.c    **** 
  16:tetStuff.c    **** #if (TRUE)
  17:tetStuff.c    **** 
  18:tetStuff.c    **** //in main...
  19:tetStuff.c    **** uint8_t fb_to_rb(uint8_t fbColor);
  20:tetStuff.c    **** 
  21:tetStuff.c    **** // Tetris:
  22:tetStuff.c    **** // 10 across
  23:tetStuff.c    **** // 18 up
  24:tetStuff.c    **** // 7 pieces (colors = 3 bits each)
  25:tetStuff.c    **** // Using 4 bits, for easy-access: 90 bytes
  26:tetStuff.c    **** // Using 3 bits: 67.5 bytes
  27:tetStuff.c    **** // How about a happy-medium... use 32-bits for a row...
  28:tetStuff.c    **** #define TET_HEIGHT	18
  29:tetStuff.c    **** #define TET_WIDTH		10
  30:tetStuff.c    **** #define TET_TOP_ROW  (0)
  31:tetStuff.c    **** 
  32:tetStuff.c    **** extern uint16_t pgm_tetPiece[7][4];
  33:tetStuff.c    **** #define bin4x4(b15,b14,b13,b12,\
  34:tetStuff.c    **** 		         b11,b10, b9, b8,\
  35:tetStuff.c    **** 		          b7, b6, b5, b4,\
  36:tetStuff.c    ****                 b3, b2, b1, b0)\
  37:tetStuff.c    ****          ((bin(b15,b14,b13,b12,b11,b10, b9, b8) << 8) | \
  38:tetStuff.c    **** 			          (bin( b7, b6, b5, b4, b3, b2, b1, b0)))
  39:tetStuff.c    **** 
  40:tetStuff.c    **** #define getTetPieceBrick(piece, orientation, row, col) \
  41:tetStuff.c    **** 	   getbit((row*4+col), pgm_getTetPiece(piece,orientation))
  42:tetStuff.c    **** 
  43:tetStuff.c    **** #define pgm_getTetPiece(piece,orientation) \
  44:tetStuff.c    **** 	   ((uint16_t)pgm_read_word(&(pgm_tetPiece[piece][orientation])))
  45:tetStuff.c    **** 
  46:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col);
  47:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val);
  48:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick);
  49:tetStuff.c    **** 	
  50:tetStuff.c    **** //For now, let's just test that it works...
  51:tetStuff.c    **** // (This could be implemented with bitfields?)
  52:tetStuff.c    **** uint32_t tetRow[TET_HEIGHT];
  53:tetStuff.c    **** 
  54:tetStuff.c    **** void tetInit(uint8_t filledRows)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 4


  55:tetStuff.c    **** {
  56:tetStuff.c    **** 	uint8_t row;
  57:tetStuff.c    **** 
  58:tetStuff.c    **** 	//Clear the board...
  59:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
  60:tetStuff.c    **** 		tetRow[row]=0;
  61:tetStuff.c    **** #if (TRUE) //Load random-ish "bricks" for testing...
  62:tetStuff.c    **** 	uint8_t col;
  63:tetStuff.c    **** 	//Now, leaving the first several rows blank for piece-testing...
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
  65:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
  66:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
  67:tetStuff.c    **** 
  68:tetStuff.c    **** #endif
  69:tetStuff.c    **** #if (FALSE) //Just throw some random pieces in for testing... Dun Woik
  70:tetStuff.c    **** 	row = 0;
  71:tetStuff.c    **** 	uint8_t col;
  72:tetStuff.c    **** 	uint8_t piece = 0;
  73:tetStuff.c    **** 	uint8_t pieceRow;
  74:tetStuff.c    **** 
  75:tetStuff.c    **** 	for(col=0; col<TET_WIDTH; col++)
  76:tetStuff.c    **** 	{
  77:tetStuff.c    **** 		piece = col/4;
  78:tetStuff.c    **** 
  79:tetStuff.c    **** 		for(pieceRow=0; pieceRow<4; pieceRow++)
  80:tetStuff.c    **** 			setTetBrick(pieceRow + row, col, (row+col) & 0x07);
  81:tetStuff.c    **** 				  	//(getTetPieceBrick(piece,0,pieceRow,col)) ? piece : 0);
  82:tetStuff.c    **** 
  83:tetStuff.c    **** 		row+=4;
  84:tetStuff.c    **** 
  85:tetStuff.c    **** 	}
  86:tetStuff.c    **** #endif
  87:tetStuff.c    **** }
  88:tetStuff.c    **** 
  89:tetStuff.c    **** 
  90:tetStuff.c    **** //Also determines color (pieceNum+1)...
  91:tetStuff.c    **** uint8_t pieceNum = 0;
  92:tetStuff.c    **** uint8_t pieceOrientation = 0;
  93:tetStuff.c    **** //Upper-Left corner
  94:tetStuff.c    **** uint8_t pieceTopRow = 0;
  95:tetStuff.c    **** uint8_t pieceLeftCol = 0;
  96:tetStuff.c    **** #define PIECE_HEIGHT 4
  97:tetStuff.c    **** #define PIECE_WIDTH	4
  98:tetStuff.c    **** #define NUM_PIECES	7
  99:tetStuff.c    **** #define PIECE_STARTCOL 3
 100:tetStuff.c    **** #define PIECE_STARTROW 0
 101:tetStuff.c    **** 
 102:tetStuff.c    **** 
 103:tetStuff.c    **** static __inline__ \
 104:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[]) \
 105:tetStuff.c    **** 	  __attribute__((__always_inline__));
 106:tetStuff.c    **** //This assumes rowBuffer[] points to the first column we should draw
 107:tetStuff.c    **** // it could be called as, e.g. tet_drawRow(rbRowNum, &RealRowBuffer[5])
 108:tetStuff.c    **** // to shift it right five pixels...
 109:tetStuff.c    **** // rowNum corresponds to the row in drawable pixels
 110:tetStuff.c    **** // (though this may change later... for, e.g. high vertical resolution)
 111:tetStuff.c    **** // (e.g. for brick separators...)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 5


 112:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[])
 113:tetStuff.c    **** {
 114:tetStuff.c    **** 	uint8_t i; 
 115:tetStuff.c    **** 
 116:tetStuff.c    **** 	if( (rowNum >= TET_TOP_ROW) &&
 117:tetStuff.c    **** 		 (rowNum < TET_TOP_ROW+TET_HEIGHT) )
 118:tetStuff.c    **** 	{
 119:tetStuff.c    **** 		//left border:
 120:tetStuff.c    **** 		rowBuffer[0]=fb_to_rb(_W);
 121:tetStuff.c    **** 
 122:tetStuff.c    **** 		//Draw active (and inactive) bricks
 123:tetStuff.c    **** 		for(i=1; i<=TET_WIDTH; i++)
 124:tetStuff.c    **** 		{
 125:tetStuff.c    **** 			rowBuffer[i]=
 126:tetStuff.c    **** 				fb_to_rb(tetBrick_to_fb(
 127:tetStuff.c    **** 							getTetBrick(rowNum-TET_TOP_ROW,i-1)));
 128:tetStuff.c    **** 		}
 129:tetStuff.c    **** 
 130:tetStuff.c    **** 		//right border:
 131:tetStuff.c    **** 		rowBuffer[i]=fb_to_rb(_W);
 132:tetStuff.c    **** 
 133:tetStuff.c    **** 		//SEE NOTE in main.c re: _b and _c -> _W syncing...
 134:tetStuff.c    **** 	}
 135:tetStuff.c    **** 	//bottom border:
 136:tetStuff.c    **** 	else if(rowNum == TET_TOP_ROW+TET_HEIGHT)
 137:tetStuff.c    **** 		for(i=0; i<=TET_WIDTH+1; i++)
 138:tetStuff.c    **** 			rowBuffer[i]=fb_to_rb(_W);
 139:tetStuff.c    **** //	else
 140:tetStuff.c    **** //		return;
 141:tetStuff.c    **** 
 142:tetStuff.c    **** 
 143:tetStuff.c    **** 	//Active (falling) piece:
 144:tetStuff.c    **** 
 145:tetStuff.c    **** 	if((rowNum >= pieceTopRow) &&
 146:tetStuff.c    **** 		(rowNum < pieceTopRow+PIECE_HEIGHT) )
 147:tetStuff.c    **** 	{
 148:tetStuff.c    **** 		uint8_t pieceRowNum = rowNum - pieceTopRow;
 149:tetStuff.c    **** 
 150:tetStuff.c    **** 		for(i=0; i<PIECE_WIDTH; i++)
 151:tetStuff.c    **** 		{
 152:tetStuff.c    **** 			uint8_t pieceBrick = 
 153:tetStuff.c    **** 					getTetPieceBrick(pieceNum, pieceOrientation, 
 154:tetStuff.c    **** 										  pieceRowNum, i);
 155:tetStuff.c    **** 
 156:tetStuff.c    **** 			//Only draw piece pixels (not black/empty pixels)
 157:tetStuff.c    **** 			// (we don't want to overwrite nearby bricks)
 158:tetStuff.c    **** 			if(pieceBrick)
 159:tetStuff.c    **** 			//+1 for the left border...
 160:tetStuff.c    **** 				rowBuffer[i+1+pieceLeftCol] =
 161:tetStuff.c    **** 						fb_to_rb(tetBrick_to_fb(pieceNum+1));
 162:tetStuff.c    **** 		}
 163:tetStuff.c    **** 	}
 164:tetStuff.c    **** 
 165:tetStuff.c    **** 
 166:tetStuff.c    **** 
 167:tetStuff.c    **** 
 168:tetStuff.c    **** 	//Draw "TETRIS" vertically...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 6


 169:tetStuff.c    **** #define CHARACTER_START_COL   14 //FB_WIDTH
 170:tetStuff.c    ****    //i=FB_WIDTH;
 171:tetStuff.c    ****    i=CHARACTER_START_COL;
 172:tetStuff.c    **** 
 173:tetStuff.c    ****    uint8_t charRow;
 174:tetStuff.c    ****    uint8_t color;
 175:tetStuff.c    ****    char character;
 176:tetStuff.c    ****    switch(rowNum/8)
 177:tetStuff.c    ****    {
 178:tetStuff.c    ****          case 0:
 179:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 180:tetStuff.c    ****             character = 'T';
 181:tetStuff.c    ****             color = _R;
 182:tetStuff.c    ****             break;
 183:tetStuff.c    ****          case 1:
 184:tetStuff.c    ****             //charRow = getCharRow('E', rowNum%8);
 185:tetStuff.c    ****             character = 'E';
 186:tetStuff.c    ****             color = _O;
 187:tetStuff.c    ****             break;
 188:tetStuff.c    ****          case 2:
 189:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 190:tetStuff.c    ****             character = 'T';
 191:tetStuff.c    ****             color = _Y;
 192:tetStuff.c    ****             break;
 193:tetStuff.c    ****          case 3:
 194:tetStuff.c    ****             { 
 195:tetStuff.c    ****                uint8_t z, temp;
 196:tetStuff.c    ****                
 197:tetStuff.c    ****                //Reverse the "R" to make it look Russian
 198:tetStuff.c    ****                // And shift it one left...
 199:tetStuff.c    ****                temp = getCharRow('R', rowNum%8);
 200:tetStuff.c    ****                
 201:tetStuff.c    ****                for(z=0; z<8; z++)
 202:tetStuff.c    ****                {
 203:tetStuff.c    ****                   writebit(7-z, charRow, getbit(z,temp));
 204:tetStuff.c    ****                }  
 205:tetStuff.c    ****                //Characters are reversed... bit 0 is far-left
 206:tetStuff.c    ****                //So to shift a character left, I must shift its bits right
 207:tetStuff.c    ****                // (right?)
 208:tetStuff.c    ****                charRow >>= 1;
 209:tetStuff.c    ****                color = _G; 
 210:tetStuff.c    ****             }  
 211:tetStuff.c    ****             break;
 212:tetStuff.c    ****          case 4:
 213:tetStuff.c    ****             //charRow = getCharRow('I', rowNum%8);
 214:tetStuff.c    ****             character = 'I';
 215:tetStuff.c    ****             color = _C; 
 216:tetStuff.c    ****             break;
 217:tetStuff.c    ****          case 5:
 218:tetStuff.c    ****             //charRow = getCharRow('S', rowNum%8);
 219:tetStuff.c    ****             character = 'S';
 220:tetStuff.c    ****             color = _B; 
 221:tetStuff.c    ****             break;
 222:tetStuff.c    ****          default:
 223:tetStuff.c    ****             character = ' ';
 224:tetStuff.c    ****             //charRow = 0;
 225:tetStuff.c    ****             break;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 7


 226:tetStuff.c    ****    }     
 227:tetStuff.c    **** 
 228:tetStuff.c    **** 	//Load charRow for all cases except the backwards "R"
 229:tetStuff.c    **** 	// which is handled above...      
 230:tetStuff.c    ****    if(rowNum/8 != 3)
 231:tetStuff.c    ****          charRow = getCharRow(character, rowNum%8);
 232:tetStuff.c    **** 
 233:tetStuff.c    ****    i++;
 234:tetStuff.c    **** 
 235:tetStuff.c    ****    uint8_t j;
 236:tetStuff.c    ****    for(j=0; j<8; j++)
 237:tetStuff.c    ****          if(getbit(j, charRow))
 238:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x25;
 239:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(color); //0x25);
 240:tetStuff.c    ****          else
 241:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x01;
 242:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(0x00);
 243:tetStuff.c    **** 
 244:tetStuff.c    **** 
 245:tetStuff.c    **** }
 246:tetStuff.c    **** 
 247:tetStuff.c    **** void tetUpdate(void)
 248:tetStuff.c    **** {
 249:tetStuff.c    **** 	//For now, we're just experimenting with the different pieces/
 250:tetStuff.c    **** 	// orientations/positions...	
 251:tetStuff.c    **** 	static uint8_t callCount = 0;
 252:tetStuff.c    **** 	static uint8_t newPieceHitCount=0;
 253:tetStuff.c    **** 
 254:tetStuff.c    **** 	uint8_t new_pieceOrientation;
 255:tetStuff.c    **** 	uint8_t new_pieceTopRow;
 256:tetStuff.c    **** 	uint8_t new_pieceLeftCol;
 257:tetStuff.c    **** //	uint8_t new_pieceNum;
 258:tetStuff.c    **** 
 259:tetStuff.c    **** 	uint8_t pieceRow;
 260:tetStuff.c    **** 	uint8_t pieceCol;
 261:tetStuff.c    **** 
 262:tetStuff.c    **** 	uint8_t noChange = FALSE;
 263:tetStuff.c    **** 	uint8_t settle = FALSE;
 264:tetStuff.c    **** 
 265:tetStuff.c    **** 	if(newPieceHitCount == 5)
 266:tetStuff.c    **** 	{
 267:tetStuff.c    **** 		newPieceHitCount = 0;
 268:tetStuff.c    **** 		tetInit(0);
 269:tetStuff.c    **** 	}
 270:tetStuff.c    **** 
 271:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 272:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 273:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 274:tetStuff.c    **** 
 275:tetStuff.c    **** 	if(callCount%4 == 2)
 276:tetStuff.c    ****    {
 277:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 278:tetStuff.c    ****       if (new_pieceOrientation==4)
 279:tetStuff.c    **** 			new_pieceOrientation=0;
 280:tetStuff.c    **** 	}
 281:tetStuff.c    **** 
 282:tetStuff.c    ****       if(callCount%4==0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 8


 283:tetStuff.c    ****       {  
 284:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 285:tetStuff.c    **** 		}
 286:tetStuff.c    **** 
 287:tetStuff.c    **** 		if(callCount%4==3)
 288:tetStuff.c    **** 		{
 289:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 290:tetStuff.c    ****       }
 291:tetStuff.c    **** 
 292:tetStuff.c    **** 	callCount++;
 293:tetStuff.c    **** 
 294:tetStuff.c    **** 
 295:tetStuff.c    **** 
 296:tetStuff.c    **** 
 297:tetStuff.c    **** 
 298:tetStuff.c    **** 	//Check for collision in the new piece position/orientation...
 299:tetStuff.c    **** 	//Starting from the bottom... (intentional wraparound)
 300:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 301:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 302:tetStuff.c    **** 		{
 303:tetStuff.c    **** 			//This isn't particularly efficient...
 304:tetStuff.c    **** 			// rereading each time...
 305:tetStuff.c    **** 			uint8_t pieceBrick =
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 307:tetStuff.c    **** 											  pieceRow, pieceCol);
 308:tetStuff.c    **** 
 309:tetStuff.c    **** 			uint8_t boardRow = new_pieceTopRow + pieceRow;
 310:tetStuff.c    **** 
 311:tetStuff.c    **** 			uint8_t boardCol = new_pieceLeftCol + pieceCol;
 312:tetStuff.c    **** 
 313:tetStuff.c    **** 			uint8_t boardBrick = getTetBrick(boardRow, boardCol);
 314:tetStuff.c    **** 
 315:tetStuff.c    **** 
 316:tetStuff.c    **** 			if(pieceBrick)
 317:tetStuff.c    **** 			{
 318:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 319:tetStuff.c    **** 				{
 320:tetStuff.c    **** 					noChange = TRUE;
 321:tetStuff.c    **** 					settle = TRUE;
 322:tetStuff.c    **** 					break;
 323:tetStuff.c    **** 				}
 324:tetStuff.c    **** 
 325:tetStuff.c    **** 				//There's some plausibility for some oddities here...
 326:tetStuff.c    **** 				// revisit 41-15.zip
 327:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 328:tetStuff.c    **** 				{
 329:tetStuff.c    **** 				   noChange = TRUE;
 330:tetStuff.c    **** 				   break;
 331:tetStuff.c    **** 				}
 332:tetStuff.c    **** 
 333:tetStuff.c    **** 
 334:tetStuff.c    **** 				if(boardBrick)
 335:tetStuff.c    **** 				{
 336:tetStuff.c    **** 					//Must be a settle...
 337:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 338:tetStuff.c    **** 						(new_pieceLeftCol == pieceLeftCol))
 339:tetStuff.c    **** 						settle = TRUE;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 9


 340:tetStuff.c    **** 
 341:tetStuff.c    **** 					noChange = TRUE;
 342:tetStuff.c    **** 					break;
 343:tetStuff.c    **** 				}
 344:tetStuff.c    **** 			}
 345:tetStuff.c    **** 		}
 346:tetStuff.c    **** 
 347:tetStuff.c    **** 
 348:tetStuff.c    **** 
 349:tetStuff.c    **** 
 350:tetStuff.c    **** 
 351:tetStuff.c    **** 	if(!noChange)
 352:tetStuff.c    **** 	{
 353:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 354:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 355:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 356:tetStuff.c    **** 	}
 357:tetStuff.c    **** 
 358:tetStuff.c    **** 	if(settle)
 359:tetStuff.c    **** 	{
 360:tetStuff.c    **** 		// Check if we've hit on a new piece...
 361:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 362:tetStuff.c    **** 		   (pieceLeftCol == PIECE_STARTCOL) &&
 363:tetStuff.c    **** 		   (pieceOrientation == 0))
 364:tetStuff.c    **** 		   newPieceHitCount++;
 365:tetStuff.c    **** 
 366:tetStuff.c    **** 
 367:tetStuff.c    **** 		//Load the piece into the board...
 368:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 369:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 370:tetStuff.c    **** 			{
 371:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 372:tetStuff.c    **** 										  pieceRow, pieceCol))
 373:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 374:tetStuff.c    **** 								pieceLeftCol+pieceCol,
 375:tetStuff.c    **** 								pieceNum+1);
 376:tetStuff.c    **** 			}
 377:tetStuff.c    **** 
 378:tetStuff.c    **** 
 379:tetStuff.c    **** 		//Load a new piece...
 380:tetStuff.c    **** 		pieceNum++;
 381:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 382:tetStuff.c    **** 			pieceNum = 0;
 383:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 384:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 385:tetStuff.c    **** 		pieceOrientation = 0;
 386:tetStuff.c    **** 	}
 387:tetStuff.c    **** 
 388:tetStuff.c    **** }
 389:tetStuff.c    **** 
 390:tetStuff.c    **** //returns a 3-bit value
 391:tetStuff.c    **** // 0 corresponds to no brick
 392:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 393:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col)
 394:tetStuff.c    **** {
 118               		.stabn	68,0,394,.LM0-.LFBB1
 119               	.LM0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 10


 120               	.LFBB1:
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               		.stabn	68,0,394,.LM1-.LFBB1
 124               	.LM1:
 125 0000 E82F      		mov r30,r24
 126 0002 F0E0      		ldi r31,lo8(0)
 127 0004 EE0F      		lsl r30
 128 0006 FF1F      		rol r31
 129 0008 EE0F      		lsl r30
 130 000a FF1F      		rol r31
 131 000c E050      		subi r30,lo8(-(tetRow))
 132 000e F040      		sbci r31,hi8(-(tetRow))
 133 0010 862F      		mov r24,r22
 134 0012 90E0      		ldi r25,lo8(0)
 135 0014 63E0      		ldi r22,lo8(3)
 136 0016 70E0      		ldi r23,hi8(3)
 137 0018 00D0      		rcall __mulhi3
 138 001a 2081      		ld r18,Z
 139 001c 3181      		ldd r19,Z+1
 140 001e 4281      		ldd r20,Z+2
 141 0020 5381      		ldd r21,Z+3
 142 0022 00C0      		rjmp 2f
 143 0024 5695      	1:	lsr r21
 144 0026 4795      		ror r20
 145 0028 3795      		ror r19
 146 002a 2795      		ror r18
 147 002c 8A95      	2:	dec r24
 148 002e 02F4      		brpl 1b
 395:tetStuff.c    **** 	//uint8_t tetCol = col*3;
 396:tetStuff.c    **** //	uint8_t tetMask = '\007';
 397:tetStuff.c    **** 	
 398:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
 399:tetStuff.c    **** 
 400:tetStuff.c    **** }
 149               		.stabn	68,0,400,.LM2-.LFBB1
 150               	.LM2:
 151 0030 822F      		mov r24,r18
 152 0032 8770      		andi r24,lo8(7)
 153               	/* epilogue start */
 154 0034 0895      		ret
 155               		.size	getTetBrick, .-getTetBrick
 156               	.Lscope1:
 157               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 158               		.stabd	78,0,0
 159               		.stabs	"setTetBrick:F(0,15)",36,0,406,setTetBrick
 160               		.stabs	"row:P(3,2)",64,0,406,24
 161               		.stabs	"col:P(3,2)",64,0,406,22
 162               		.stabs	"val:P(3,2)",64,0,406,20
 163               	.global	setTetBrick
 164               		.type	setTetBrick, @function
 165               	setTetBrick:
 166               		.stabd	46,0,0
 401:tetStuff.c    **** 
 402:tetStuff.c    **** 
 403:tetStuff.c    **** //val should only be 0-7
 404:tetStuff.c    **** // 0 corresponds to no brick
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 11


 405:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 406:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val)
 407:tetStuff.c    **** {
 167               		.stabn	68,0,407,.LM3-.LFBB2
 168               	.LM3:
 169               	.LFBB2:
 170 0036 0F93      		push r16
 171 0038 1F93      		push r17
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 408:tetStuff.c    **** 	//Clear the old value...
 409:tetStuff.c    **** 	tetRow[row] &= ~(((uint32_t)'\007')<<(3*col));
 174               		.stabn	68,0,409,.LM4-.LFBB2
 175               	.LM4:
 176 003a E82F      		mov r30,r24
 177 003c F0E0      		ldi r31,lo8(0)
 178 003e 862F      		mov r24,r22
 179 0040 90E0      		ldi r25,lo8(0)
 180 0042 63E0      		ldi r22,lo8(3)
 181 0044 70E0      		ldi r23,hi8(3)
 182 0046 00D0      		rcall __mulhi3
 183 0048 A82F      		mov r26,r24
 410:tetStuff.c    **** 	//Write the new value...
 411:tetStuff.c    **** 	tetRow[row] |= (((uint32_t)val)<<(3*col));
 184               		.stabn	68,0,411,.LM5-.LFBB2
 185               	.LM5:
 186 004a EE0F      		lsl r30
 187 004c FF1F      		rol r31
 188 004e EE0F      		lsl r30
 189 0050 FF1F      		rol r31
 190 0052 E050      		subi r30,lo8(-(tetRow))
 191 0054 F040      		sbci r31,hi8(-(tetRow))
 192 0056 67E0      		ldi r22,lo8(7)
 193 0058 70E0      		ldi r23,hi8(7)
 194 005a 80E0      		ldi r24,hlo8(7)
 195 005c 90E0      		ldi r25,hhi8(7)
 196 005e 0A2E      		mov r0,r26
 197 0060 00C0      		rjmp 2f
 198 0062 660F      	1:	lsl r22
 199 0064 771F      		rol r23
 200 0066 881F      		rol r24
 201 0068 991F      		rol r25
 202 006a 0A94      	2:	dec r0
 203 006c 02F4      		brpl 1b
 204 006e 6095      		com r22
 205 0070 7095      		com r23
 206 0072 8095      		com r24
 207 0074 9095      		com r25
 208 0076 0081      		ld r16,Z
 209 0078 1181      		ldd r17,Z+1
 210 007a 2281      		ldd r18,Z+2
 211 007c 3381      		ldd r19,Z+3
 212 007e 6023      		and r22,r16
 213 0080 7123      		and r23,r17
 214 0082 8223      		and r24,r18
 215 0084 9323      		and r25,r19
 216 0086 242F      		mov r18,r20
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 12


 217 0088 30E0      		ldi r19,lo8(0)
 218 008a 40E0      		ldi r20,lo8(0)
 219 008c 50E0      		ldi r21,hi8(0)
 220 008e 00C0      		rjmp 2f
 221 0090 220F      	1:	lsl r18
 222 0092 331F      		rol r19
 223 0094 441F      		rol r20
 224 0096 551F      		rol r21
 225 0098 AA95      	2:	dec r26
 226 009a 02F4      		brpl 1b
 227 009c 622B      		or r22,r18
 228 009e 732B      		or r23,r19
 229 00a0 842B      		or r24,r20
 230 00a2 952B      		or r25,r21
 231 00a4 6083      		st Z,r22
 232 00a6 7183      		std Z+1,r23
 233 00a8 8283      		std Z+2,r24
 234 00aa 9383      		std Z+3,r25
 235               	/* epilogue start */
 412:tetStuff.c    **** }
 236               		.stabn	68,0,412,.LM6-.LFBB2
 237               	.LM6:
 238 00ac 1F91      		pop r17
 239 00ae 0F91      		pop r16
 240 00b0 0895      		ret
 241               		.size	setTetBrick, .-setTetBrick
 242               	.Lscope2:
 243               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 244               		.stabd	78,0,0
 245               		.stabs	"tetInit:F(0,15)",36,0,54,tetInit
 246               		.stabs	"filledRows:P(3,2)",64,0,54,24
 247               	.global	tetInit
 248               		.type	tetInit, @function
 249               	tetInit:
 250               		.stabd	46,0,0
  55:tetStuff.c    **** {
 251               		.stabn	68,0,55,.LM7-.LFBB3
 252               	.LM7:
 253               	.LFBB3:
 254 00b2 0F93      		push r16
 255 00b4 1F93      		push r17
 256               	/* prologue: function */
 257               	/* frame size = 0 */
  55:tetStuff.c    **** {
 258               		.stabn	68,0,55,.LM8-.LFBB3
 259               	.LM8:
 260 00b6 E0E0      		ldi r30,lo8(tetRow)
 261 00b8 F0E0      		ldi r31,hi8(tetRow)
 262               	.L6:
  60:tetStuff.c    **** 		tetRow[row]=0;
 263               		.stabn	68,0,60,.LM9-.LFBB3
 264               	.LM9:
 265 00ba 1192      		st Z+,__zero_reg__
 266 00bc 1192      		st Z+,__zero_reg__
 267 00be 1192      		st Z+,__zero_reg__
 268 00c0 1192      		st Z+,__zero_reg__
  59:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 13


 269               		.stabn	68,0,59,.LM10-.LFBB3
 270               	.LM10:
 271 00c2 90E0      		ldi r25,hi8(tetRow+72)
 272 00c4 E030      		cpi r30,lo8(tetRow+72)
 273 00c6 F907      		cpc r31,r25
 274 00c8 01F4      		brne .L6
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 275               		.stabn	68,0,64,.LM11-.LFBB3
 276               	.LM11:
 277 00ca 12E1      		ldi r17,lo8(18)
 278 00cc 181B      		sub r17,r24
 279 00ce 00C0      		rjmp .L7
 280               	.L9:
 281 00d0 00E0      		ldi r16,lo8(0)
 282               	.L8:
  66:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
 283               		.stabn	68,0,66,.LM12-.LFBB3
 284               	.LM12:
 285 00d2 402F      		mov r20,r16
 286 00d4 410F      		add r20,r17
 287 00d6 4770      		andi r20,lo8(7)
 288 00d8 812F      		mov r24,r17
 289 00da 602F      		mov r22,r16
 290 00dc 00D0      		rcall setTetBrick
  65:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
 291               		.stabn	68,0,65,.LM13-.LFBB3
 292               	.LM13:
 293 00de 0F5F      		subi r16,lo8(-(1))
 294 00e0 0A30      		cpi r16,lo8(10)
 295 00e2 01F4      		brne .L8
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 296               		.stabn	68,0,64,.LM14-.LFBB3
 297               	.LM14:
 298 00e4 1F5F      		subi r17,lo8(-(1))
 299               	.L7:
 300 00e6 1231      		cpi r17,lo8(18)
 301 00e8 00F0      		brlo .L9
 302               	/* epilogue start */
  87:tetStuff.c    **** }
 303               		.stabn	68,0,87,.LM15-.LFBB3
 304               	.LM15:
 305 00ea 1F91      		pop r17
 306 00ec 0F91      		pop r16
 307 00ee 0895      		ret
 308               		.size	tetInit, .-tetInit
 309               		.stabs	"row:r(3,2)",64,0,56,17
 310               		.stabs	"col:r(3,2)",64,0,62,16
 311               		.stabn	192,0,0,.LFBB3-.LFBB3
 312               		.stabn	224,0,0,.Lscope3-.LFBB3
 313               	.Lscope3:
 314               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 315               		.stabd	78,0,0
 316               		.stabs	"tetUpdate:F(0,15)",36,0,247,tetUpdate
 317               	.global	tetUpdate
 318               		.type	tetUpdate, @function
 319               	tetUpdate:
 320               		.stabd	46,0,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 14


 248:tetStuff.c    **** {
 321               		.stabn	68,0,248,.LM16-.LFBB4
 322               	.LM16:
 323               	.LFBB4:
 324 00f0 2F92      		push r2
 325 00f2 3F92      		push r3
 326 00f4 4F92      		push r4
 327 00f6 5F92      		push r5
 328 00f8 6F92      		push r6
 329 00fa 7F92      		push r7
 330 00fc 8F92      		push r8
 331 00fe 9F92      		push r9
 332 0100 AF92      		push r10
 333 0102 BF92      		push r11
 334 0104 CF92      		push r12
 335 0106 DF92      		push r13
 336 0108 EF92      		push r14
 337 010a FF92      		push r15
 338 010c 0F93      		push r16
 339 010e 1F93      		push r17
 340 0110 DF93      		push r29
 341 0112 CF93      		push r28
 342 0114 00D0      		rcall .
 343 0116 CDB7      		in r28,__SP_L__
 344 0118 DEB7      		in r29,__SP_H__
 345               	/* prologue: function */
 346               	/* frame size = 2 */
 265:tetStuff.c    **** 	if(newPieceHitCount == 5)
 347               		.stabn	68,0,265,.LM17-.LFBB4
 348               	.LM17:
 349 011a 8091 0000 		lds r24,newPieceHitCount.1827
 350 011e 8530      		cpi r24,lo8(5)
 351 0120 01F4      		brne .L15
 267:tetStuff.c    **** 		newPieceHitCount = 0;
 352               		.stabn	68,0,267,.LM18-.LFBB4
 353               	.LM18:
 354 0122 1092 0000 		sts newPieceHitCount.1827,__zero_reg__
 268:tetStuff.c    **** 		tetInit(0);
 355               		.stabn	68,0,268,.LM19-.LFBB4
 356               	.LM19:
 357 0126 80E0      		ldi r24,lo8(0)
 358 0128 00D0      		rcall tetInit
 359               	.L15:
 271:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 360               		.stabn	68,0,271,.LM20-.LFBB4
 361               	.LM20:
 362 012a 3090 0000 		lds r3,pieceOrientation
 272:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 363               		.stabn	68,0,272,.LM21-.LFBB4
 364               	.LM21:
 365 012e 4091 0000 		lds r20,pieceLeftCol
 273:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 366               		.stabn	68,0,273,.LM22-.LFBB4
 367               	.LM22:
 368 0132 2090 0000 		lds r2,pieceTopRow
 275:tetStuff.c    **** 	if(callCount%4 == 2)
 369               		.stabn	68,0,275,.LM23-.LFBB4
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 15


 370               	.LM23:
 371 0136 5091 0000 		lds r21,callCount.1826
 372 013a 852F      		mov r24,r21
 373 013c 90E0      		ldi r25,lo8(0)
 374 013e 8370      		andi r24,lo8(3)
 375 0140 9070      		andi r25,hi8(3)
 376 0142 8230      		cpi r24,2
 377 0144 9105      		cpc r25,__zero_reg__
 378 0146 01F4      		brne .L16
 277:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 379               		.stabn	68,0,277,.LM24-.LFBB4
 380               	.LM24:
 381 0148 232D      		mov r18,r3
 382 014a 2F5F      		subi r18,lo8(-(1))
 278:tetStuff.c    ****       if (new_pieceOrientation==4)
 383               		.stabn	68,0,278,.LM25-.LFBB4
 384               	.LM25:
 385 014c 2430      		cpi r18,lo8(4)
 386 014e 01F0      		breq .+2
 387 0150 00C0      		rjmp .L18
 388 0152 00C0      		rjmp .L48
 389               	.L16:
 282:tetStuff.c    ****       if(callCount%4==0)
 390               		.stabn	68,0,282,.LM26-.LFBB4
 391               	.LM26:
 392 0154 0097      		sbiw r24,0
 393 0156 01F4      		brne .L19
 284:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 394               		.stabn	68,0,284,.LM27-.LFBB4
 395               	.LM27:
 396 0158 342F      		mov r19,r20
 397 015a 3F5F      		subi r19,lo8(-(1))
 398 015c 00C0      		rjmp .L43
 399               	.L19:
 287:tetStuff.c    **** 		if(callCount%4==3)
 400               		.stabn	68,0,287,.LM28-.LFBB4
 401               	.LM28:
 402 015e 8330      		cpi r24,3
 403 0160 9105      		cpc r25,__zero_reg__
 404 0162 01F4      		brne .L45
 289:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 405               		.stabn	68,0,289,.LM29-.LFBB4
 406               	.LM29:
 407 0164 2394      		inc r2
 408               	.L45:
 409 0166 342F      		mov r19,r20
 410               	.L43:
 411 0168 232D      		mov r18,r3
 412               	.L20:
 292:tetStuff.c    **** 	callCount++;
 413               		.stabn	68,0,292,.LM30-.LFBB4
 414               	.LM30:
 415 016a 5F5F      		subi r21,lo8(-(1))
 416 016c 5093 0000 		sts callCount.1826,r21
 417               	.LBB107:
 418               	.LBB108:
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 16


 419               		.stabn	68,0,306,.LM31-.LFBB4
 420               	.LM31:
 421 0170 8091 0000 		lds r24,pieceNum
 422 0174 90E0      		ldi r25,lo8(0)
 423 0176 880F      		lsl r24
 424 0178 991F      		rol r25
 425 017a 880F      		lsl r24
 426 017c 991F      		rol r25
 427 017e 820F      		add r24,r18
 428 0180 911D      		adc r25,__zero_reg__
 429 0182 880F      		lsl r24
 430 0184 991F      		rol r25
 431 0186 8050      		subi r24,lo8(-(pgm_tetPiece))
 432 0188 9040      		sbci r25,hi8(-(pgm_tetPiece))
 433 018a 122D      		mov r17,r2
 434 018c 1D5F      		subi r17,lo8(-(3))
 435 018e A0E0      		ldi r26,lo8(0)
 436 0190 B3E0      		ldi r27,lo8(3)
 437 0192 FC01      		movw r30,r24
 438               	/* #APP */
 439               	 ;  306 "tetStuff.c" 1
 440 0194 C590      		lpm r12, Z+
 441 0196 D490      		lpm r13, Z
 442               		
 443               	 ;  0 "" 2
 444               	/* #NOAPP */
 445 0198 00C0      		rjmp .L22
 446               	.L26:
 447               	.LBE108:
 316:tetStuff.c    **** 			if(pieceBrick)
 448               		.stabn	68,0,316,.LM32-.LFBB4
 449               	.LM32:
 450 019a CF01      		movw r24,r30
 451 019c 8E0D      		add r24,r14
 452 019e 9F1D      		adc r25,r15
 453 01a0 2601      		movw r4,r12
 454 01a2 00C0      		rjmp 2f
 455 01a4 5694      	1:	lsr r5
 456 01a6 4794      		ror r4
 457 01a8 8A95      	2:	dec r24
 458 01aa 02F4      		brpl 1b
 459 01ac 40FE      		sbrs r4,0
 460 01ae 00C0      		rjmp .L23
 318:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 461               		.stabn	68,0,318,.LM33-.LFBB4
 462               	.LM33:
 463 01b0 1231      		cpi r17,lo8(18)
 464 01b2 00F4      		brsh .L24
 327:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 465               		.stabn	68,0,327,.LM34-.LFBB4
 466               	.LM34:
 467 01b4 0A30      		cpi r16,lo8(10)
 468 01b6 00F4      		brsh .L25
 334:tetStuff.c    **** 				if(boardBrick)
 469               		.stabn	68,0,334,.LM35-.LFBB4
 470               	.LM35:
 471 01b8 802F      		mov r24,r16
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 17


 472 01ba 90E0      		ldi r25,lo8(0)
 473 01bc 63E0      		ldi r22,lo8(3)
 474 01be 70E0      		ldi r23,hi8(3)
 475 01c0 00D0      		rcall __mulhi3
 476 01c2 2401      		movw r4,r8
 477 01c4 3501      		movw r6,r10
 478 01c6 00C0      		rjmp 2f
 479 01c8 7694      	1:	lsr r7
 480 01ca 6794      		ror r6
 481 01cc 5794      		ror r5
 482 01ce 4794      		ror r4
 483 01d0 8A95      	2:	dec r24
 484 01d2 02F4      		brpl 1b
 485 01d4 842D      		mov r24,r4
 486 01d6 8770      		andi r24,lo8(7)
 487 01d8 01F0      		breq .L23
 337:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 488               		.stabn	68,0,337,.LM36-.LFBB4
 489               	.LM36:
 490 01da 2315      		cp r18,r3
 491 01dc 01F4      		brne .L25
 492 01de 3417      		cp r19,r20
 493 01e0 01F4      		brne .L25
 494 01e2 00C0      		rjmp .L24
 495               	.L23:
 496 01e4 3196      		adiw r30,1
 497 01e6 0F5F      		subi r16,lo8(-(1))
 498               	.LBE107:
 301:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 499               		.stabn	68,0,301,.LM37-.LFBB4
 500               	.LM37:
 501 01e8 E430      		cpi r30,4
 502 01ea F105      		cpc r31,__zero_reg__
 503 01ec 01F4      		brne .L26
 504 01ee 80E0      		ldi r24,lo8(0)
 505 01f0 00C0      		rjmp .L27
 506               	.L24:
 507 01f2 81E0      		ldi r24,lo8(1)
 508 01f4 00C0      		rjmp .L44
 509               	.L25:
 510 01f6 80E0      		ldi r24,lo8(0)
 511               	.L44:
 512 01f8 A1E0      		ldi r26,lo8(1)
 513               	.L27:
 300:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 514               		.stabn	68,0,300,.LM38-.LFBB4
 515               	.LM38:
 516 01fa B150      		subi r27,lo8(-(-1))
 517 01fc 1150      		subi r17,lo8(-(-1))
 518 01fe BF3F      		cpi r27,lo8(-1)
 519 0200 01F0      		breq .L28
 520 0202 8823      		tst r24
 521 0204 01F4      		brne .L28
 522               	.L22:
 523 0206 AA23      		tst r26
 524 0208 01F0      		breq .+2
 525 020a 00C0      		rjmp .L37
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 18


 526               	.LBB111:
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 527               		.stabn	68,0,306,.LM39-.LFBB4
 528               	.LM39:
 529 020c EB2E      		mov r14,r27
 530 020e FF24      		clr r15
 531 0210 EE0C      		lsl r14
 532 0212 FF1C      		rol r15
 533 0214 EE0C      		lsl r14
 534 0216 FF1C      		rol r15
 535               	.LBB109:
 536               	.LBB110:
 398:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
 537               		.stabn	68,0,398,.LM40-.LFBB4
 538               	.LM40:
 539 0218 E12F      		mov r30,r17
 540 021a F0E0      		ldi r31,lo8(0)
 541 021c EE0F      		lsl r30
 542 021e FF1F      		rol r31
 543 0220 EE0F      		lsl r30
 544 0222 FF1F      		rol r31
 545 0224 E050      		subi r30,lo8(-(tetRow))
 546 0226 F040      		sbci r31,hi8(-(tetRow))
 547 0228 8080      		ld r8,Z
 548 022a 9180      		ldd r9,Z+1
 549 022c A280      		ldd r10,Z+2
 550 022e B380      		ldd r11,Z+3
 551 0230 032F      		mov r16,r19
 552 0232 E0E0      		ldi r30,lo8(0)
 553 0234 F0E0      		ldi r31,hi8(0)
 554 0236 00C0      		rjmp .L26
 555               	.L28:
 556               	.LBE110:
 557               	.LBE109:
 558               	.LBE111:
 351:tetStuff.c    **** 	if(!noChange)
 559               		.stabn	68,0,351,.LM41-.LFBB4
 560               	.LM41:
 561 0238 AA23      		tst r26
 562 023a 01F4      		brne .L30
 353:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 563               		.stabn	68,0,353,.LM42-.LFBB4
 564               	.LM42:
 565 023c 2093 0000 		sts pieceOrientation,r18
 354:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 566               		.stabn	68,0,354,.LM43-.LFBB4
 567               	.LM43:
 568 0240 3093 0000 		sts pieceLeftCol,r19
 355:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 569               		.stabn	68,0,355,.LM44-.LFBB4
 570               	.LM44:
 571 0244 2092 0000 		sts pieceTopRow,r2
 572               	.L30:
 358:tetStuff.c    **** 	if(settle)
 573               		.stabn	68,0,358,.LM45-.LFBB4
 574               	.LM45:
 575 0248 8823      		tst r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 19


 576 024a 01F4      		brne .+2
 577 024c 00C0      		rjmp .L37
 361:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 578               		.stabn	68,0,361,.LM46-.LFBB4
 579               	.LM46:
 580 024e 8091 0000 		lds r24,pieceTopRow
 581 0252 8823      		tst r24
 582 0254 01F0      		breq .+2
 583 0256 00C0      		rjmp .L31
 584 0258 8091 0000 		lds r24,pieceLeftCol
 585 025c 8330      		cpi r24,lo8(3)
 586 025e 01F0      		breq .+2
 587 0260 00C0      		rjmp .L31
 588 0262 8091 0000 		lds r24,pieceOrientation
 589 0266 8823      		tst r24
 590 0268 01F0      		breq .+2
 591 026a 00C0      		rjmp .L31
 364:tetStuff.c    **** 		   newPieceHitCount++;
 592               		.stabn	68,0,364,.LM47-.LFBB4
 593               	.LM47:
 594 026c 8091 0000 		lds r24,newPieceHitCount.1827
 595 0270 8F5F      		subi r24,lo8(-(1))
 596 0272 8093 0000 		sts newPieceHitCount.1827,r24
 597 0276 00C0      		rjmp .L31
 598               	.L34:
 599               	.LBB112:
 371:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 600               		.stabn	68,0,371,.LM48-.LFBB4
 601               	.LM48:
 602 0278 4091 0000 		lds r20,pieceNum
 603 027c E42F      		mov r30,r20
 604 027e F0E0      		ldi r31,lo8(0)
 605 0280 EE0F      		lsl r30
 606 0282 FF1F      		rol r31
 607 0284 EE0F      		lsl r30
 608 0286 FF1F      		rol r31
 609 0288 8091 0000 		lds r24,pieceOrientation
 610 028c E80F      		add r30,r24
 611 028e F11D      		adc r31,__zero_reg__
 612 0290 EE0F      		lsl r30
 613 0292 FF1F      		rol r31
 614 0294 E050      		subi r30,lo8(-(pgm_tetPiece))
 615 0296 F040      		sbci r31,hi8(-(pgm_tetPiece))
 616               	/* #APP */
 617               	 ;  371 "tetStuff.c" 1
 618 0298 8591      		lpm r24, Z+
 619 029a 9491      		lpm r25, Z
 620               		
 621               	 ;  0 "" 2
 622               	/* #NOAPP */
 623               	.LBE112:
 624 029c B701      		movw r22,r14
 625 029e 620F      		add r22,r18
 626 02a0 731F      		adc r23,r19
 627 02a2 00C0      		rjmp 2f
 628 02a4 9695      	1:	lsr r25
 629 02a6 8795      		ror r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 20


 630 02a8 6A95      	2:	dec r22
 631 02aa 02F4      		brpl 1b
 632 02ac 80FF      		sbrs r24,0
 633 02ae 00C0      		rjmp .L33
 373:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 634               		.stabn	68,0,373,.LM49-.LFBB4
 635               	.LM49:
 636 02b0 8091 0000 		lds r24,pieceTopRow
 637 02b4 6091 0000 		lds r22,pieceLeftCol
 638 02b8 6E0D      		add r22,r14
 639 02ba 4F5F      		subi r20,lo8(-(1))
 640 02bc 810F      		add r24,r17
 641 02be 2983      		std Y+1,r18
 642 02c0 3A83      		std Y+2,r19
 643 02c2 00D0      		rcall setTetBrick
 644 02c4 3A81      		ldd r19,Y+2
 645 02c6 2981      		ldd r18,Y+1
 646               	.L33:
 647 02c8 0894      		sec
 648 02ca E11C      		adc r14,__zero_reg__
 649 02cc F11C      		adc r15,__zero_reg__
 369:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 650               		.stabn	68,0,369,.LM50-.LFBB4
 651               	.LM50:
 652 02ce 64E0      		ldi r22,lo8(4)
 653 02d0 E616      		cp r14,r22
 654 02d2 F104      		cpc r15,__zero_reg__
 655 02d4 01F4      		brne .L34
 368:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 656               		.stabn	68,0,368,.LM51-.LFBB4
 657               	.LM51:
 658 02d6 1F5F      		subi r17,lo8(-(1))
 659 02d8 2C5F      		subi r18,lo8(-(4))
 660 02da 3F4F      		sbci r19,hi8(-(4))
 661 02dc 1430      		cpi r17,lo8(4)
 662 02de 01F4      		brne .L38
 663 02e0 00C0      		rjmp .L49
 664               	.L31:
 665 02e2 20E0      		ldi r18,lo8(0)
 666 02e4 30E0      		ldi r19,hi8(0)
 667 02e6 10E0      		ldi r17,lo8(0)
 668               	.L38:
 669 02e8 EE24      		clr r14
 670 02ea FF24      		clr r15
 671 02ec 00C0      		rjmp .L34
 672               	.L49:
 380:tetStuff.c    **** 		pieceNum++;
 673               		.stabn	68,0,380,.LM52-.LFBB4
 674               	.LM52:
 675 02ee 8091 0000 		lds r24,pieceNum
 676 02f2 8F5F      		subi r24,lo8(-(1))
 677 02f4 8093 0000 		sts pieceNum,r24
 381:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 678               		.stabn	68,0,381,.LM53-.LFBB4
 679               	.LM53:
 680 02f8 8730      		cpi r24,lo8(7)
 681 02fa 01F4      		brne .L36
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 21


 382:tetStuff.c    **** 			pieceNum = 0;
 682               		.stabn	68,0,382,.LM54-.LFBB4
 683               	.LM54:
 684 02fc 1092 0000 		sts pieceNum,__zero_reg__
 685               	.L36:
 383:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 686               		.stabn	68,0,383,.LM55-.LFBB4
 687               	.LM55:
 688 0300 83E0      		ldi r24,lo8(3)
 689 0302 8093 0000 		sts pieceLeftCol,r24
 384:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 690               		.stabn	68,0,384,.LM56-.LFBB4
 691               	.LM56:
 692 0306 1092 0000 		sts pieceTopRow,__zero_reg__
 385:tetStuff.c    **** 		pieceOrientation = 0;
 693               		.stabn	68,0,385,.LM57-.LFBB4
 694               	.LM57:
 695 030a 1092 0000 		sts pieceOrientation,__zero_reg__
 696 030e 00C0      		rjmp .L37
 697               	.L48:
 388:tetStuff.c    **** }
 698               		.stabn	68,0,388,.LM58-.LFBB4
 699               	.LM58:
 700 0310 20E0      		ldi r18,lo8(0)
 701               	.L18:
 702 0312 342F      		mov r19,r20
 703 0314 00C0      		rjmp .L20
 704               	.L37:
 705               	/* epilogue start */
 706 0316 0F90      		pop __tmp_reg__
 707 0318 0F90      		pop __tmp_reg__
 708 031a CF91      		pop r28
 709 031c DF91      		pop r29
 710 031e 1F91      		pop r17
 711 0320 0F91      		pop r16
 712 0322 FF90      		pop r15
 713 0324 EF90      		pop r14
 714 0326 DF90      		pop r13
 715 0328 CF90      		pop r12
 716 032a BF90      		pop r11
 717 032c AF90      		pop r10
 718 032e 9F90      		pop r9
 719 0330 8F90      		pop r8
 720 0332 7F90      		pop r7
 721 0334 6F90      		pop r6
 722 0336 5F90      		pop r5
 723 0338 4F90      		pop r4
 724 033a 3F90      		pop r3
 725 033c 2F90      		pop r2
 726 033e 0895      		ret
 727               		.size	tetUpdate, .-tetUpdate
 728               		.stabs	"callCount:V(3,2)",38,0,251,callCount.1826
 729               		.stabs	"newPieceHitCount:V(3,2)",38,0,252,newPieceHitCount.1827
 730               		.stabs	"new_pieceOrientation:r(3,2)",64,0,254,3
 731               		.stabs	"new_pieceTopRow:r(3,2)",64,0,255,2
 732               		.stabs	"new_pieceLeftCol:r(3,2)",64,0,256,20
 733               		.stabs	"pieceRow:r(3,2)",64,0,259,27
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 22


 734               		.stabs	"pieceCol:r(3,2)",64,0,260,21
 735               		.stabs	"noChange:r(3,2)",64,0,262,26
 736               		.stabs	"settle:r(3,2)",64,0,263,24
 737               		.stabn	192,0,0,.LFBB4-.LFBB4
 738               		.stabs	"__addr16:r(3,4)",64,0,306,24
 739               		.stabn	192,0,0,.LBB108-.LFBB4
 740               		.stabn	224,0,0,.LBE108-.LFBB4
 741               		.stabs	"__addr16:r(3,4)",64,0,371,30
 742               		.stabn	192,0,0,.LBB112-.LFBB4
 743               		.stabn	224,0,0,.LBE112-.LFBB4
 744               		.stabn	224,0,0,.Lscope4-.LFBB4
 745               	.Lscope4:
 746               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 747               		.stabd	78,0,0
 748               		.stabs	"tetBrick_to_fb:F(3,2)",36,0,416,tetBrick_to_fb
 749               		.stabs	"tetBrick:P(3,2)",64,0,416,24
 750               	.global	tetBrick_to_fb
 751               		.type	tetBrick_to_fb, @function
 752               	tetBrick_to_fb:
 753               		.stabd	46,0,0
 413:tetStuff.c    **** 
 414:tetStuff.c    **** uint8_t tetColorScheme = 0;
 415:tetStuff.c    **** 
 416:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick)
 417:tetStuff.c    **** {
 754               		.stabn	68,0,417,.LM59-.LFBB5
 755               	.LM59:
 756               	.LFBB5:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 418:tetStuff.c    **** 	if(!tetBrick)
 759               		.stabn	68,0,418,.LM60-.LFBB5
 760               	.LM60:
 761 0340 8823      		tst r24
 762 0342 01F0      		breq .L52
 419:tetStuff.c    **** 		return 0;
 420:tetStuff.c    **** 
 421:tetStuff.c    **** 	switch(tetColorScheme)
 763               		.stabn	68,0,421,.LM61-.LFBB5
 764               	.LM61:
 765 0344 9091 0000 		lds r25,tetColorScheme
 766 0348 8150      		subi r24,lo8(-(-1))
 767 034a 9230      		cpi r25,lo8(2)
 768 034c 00F4      		brsh .L53
 769               		.stabs	"main.c",132,0,0,.Ltext2
 770               	.Ltext2:
   1:main.c        **** #include "projInfo.h"   //Don't include in main.h 'cause that's included in other .c's?
   2:main.c        **** #include "main.h"
   3:main.c        **** #include <util/delay.h> //For delay_us in pll_enable
   4:main.c        **** #include <avr/pgmspace.h>
   5:main.c        **** #include _TIMERCOMMON_HEADER_
   6:main.c        **** //#include "../../../_commonCode/charBitmap/0.10/charBitmap.h"
   7:main.c        **** #include _CHARBITMAP_HEADER_
   8:main.c        **** #include "fbColors.h"
   9:main.c        **** 
  10:main.c        **** #include _SINETABLE_HEADER_
  11:main.c        **** #include "tetStuff.c"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 23


  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** // Latest Version is v59-10 or so.. in which I'm adding a lot of notes re:
  17:main.c        **** // defines, etc... labelled a/o v59
  18:main.c        **** // These notes, when conflicting with older notes, should be considered
  19:main.c        **** // the most recent.
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** 
  23:main.c        **** //The current state is such that basically ONLY the row-segment-buffer
  24:main.c        **** // display-method has been tested for quite some time. The other code
  25:main.c        **** // remains, but I can't promise it still works.
  26:main.c        **** 
  27:main.c        **** //Only one of the following SEG_whatevers should be TRUE
  28:main.c        **** // (Assuming we're using the Row-Segment-Buffer, as explained above).
  29:main.c        **** // IF NONE ARE TRUE:
  30:main.c        **** //  The default is to convert whatever's in the row-buffer into 
  31:main.c        **** //  the row-segment-buffer...
  32:main.c        **** //  This is where my old-code starts getting iffy, as the row-buffer hasn't
  33:main.c        **** //  been used for quite some time.
  34:main.c        **** // Best to stick with assigning one of these SEG_xxx things true.
  35:main.c        **** 
  36:main.c        **** 
  37:main.c        **** //Draws a diagonal white line on a red background...
  38:main.c        **** // I think it's supposed to repeat three times and not fill the entire
  39:main.c        **** // screen... though it's been a long time since I've used this.
  40:main.c        **** //#define SEG_LINE TRUE
  41:main.c        **** 
  42:main.c        **** //A very nice test-pattern... shows a sine-wave, the under-side of which
  43:main.c        **** // is horizontal color-bars, above it is vertical color-bars. 
  44:main.c        **** // Above that is two lines of text, showing all available characters
  45:main.c        **** // And above that is color-patterns using up the remaining Row-Segments
  46:main.c        **** // This is meant to be rotated 90-degrees
  47:main.c        **** // Like SEG_HFM, it might be handy to adjust NUM_SEGMENTS for experimenting
  48:main.c        **** // Note that color-segments which are too long to be stored in a single
  49:main.c        **** // row-segment are automatically put into the next.
  50:main.c        **** // And that existing segments are automatically stretched if the next-added
  51:main.c        **** // segment is the same color.
  52:main.c        **** // This displays all available colors and shows the resolution capabilities
  53:main.c        **** #define SEG_SINE TRUE
  54:main.c        **** 
  55:main.c        **** //Uses "High-Frequency Modulation" to display an interesting pattern...
  56:main.c        **** // HFM is kinda like PWM. The idea is to have an output ON for
  57:main.c        **** //  a certain percentage of the time...
  58:main.c        **** //  In PWM, that's done by turning it on for a fraction of a cycle 
  59:main.c        **** //  (the "width" of the pulse), then off for the remainder.
  60:main.c        **** //  In HFM, it's accomplished by knowing the fraction of time it should be
  61:main.c        **** //  on... (the "power"). The fractions are automatically reduced 5/10->1/2.
  62:main.c        **** //  e.g. if the on-time should be 1/100th of the time, it will be on
  63:main.c        **** //  during one update-period, and off for 99, then repeat.
  64:main.c        **** //  If the on-time should be 1/2 of the time, it will be on during one
  65:main.c        **** //  update, off during the next, on again, and so-on.
  66:main.c        **** //  If the on-time is some strange fraction, like 3/5, it will distribute
  67:main.c        **** //  the pulses accordingly (e.g. on, off, on, off, on, repeat)
  68:main.c        **** //  Thus, the output toggles as quickly as possible to achieve the desired
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 24


  69:main.c        **** //  power... thus "High-Frequency"
  70:main.c        **** //  (See _commonCode.../hfModulation/...)
  71:main.c        **** //  I've been using HFM in ways never originally intended: e.g. it can be
  72:main.c        **** //  used for smoothing lines between two distant points...
  73:main.c        **** //  It's used this way in "SEG_RACER" in order to use a low-resolution
  74:main.c        **** //  course in memory, and increase the resolution by knowing that there are
  75:main.c        **** //  a certain number of rows in which it has to get from point1 to point2
  76:main.c        **** //  so the "power" of the HFM is set to (p2-p1)/numRows.
  77:main.c        **** //  The nice thing about it, is it doesn't use any actual division (which
  78:main.c        **** //  is quite slow) because it knows that every point inbetween will be 
  79:main.c        **** //  traversed.
  80:main.c        **** // THIS visualizes that, and actually looks pretty cool. Like moire
  81:main.c        **** //  patterns, or magnetic-field-lines.
  82:main.c        **** // Each row increases in power, essentially: rowNum/NUM_SEGMENTS
  83:main.c        **** // (Experimenting with NUM_SEGMENTS is fun, in this case, just don't exceed
  84:main.c        **** //  the available memory, and keep in mind that there's a stack and stuff)
  85:main.c        **** //#define SEG_HFM		TRUE
  86:main.c        **** // You can override NUM_SEGMENTS here, for that purpose...
  87:main.c        **** // OTHERWISE, it should probably be handled in rowSegBuffer.c
  88:main.c        **** #if(defined(SEG_HFM) && SEG_HFM)
  89:main.c        ****  #define NUM_SEGMENTS   127 //128 //95//96//128 //68 //128//68
  90:main.c        **** #endif
  91:main.c        **** 
  92:main.c        **** //Displays a Question-Mark box, ala Mario-Brothers. Press the button and
  93:main.c        **** // receive an award (and occasional goomba)
  94:main.c        **** // Demonstrates usage of program-memory-based images... (16x16 pixels WOO!)
  95:main.c        **** //#define SEG_QUESTION	TRUE
  96:main.c        **** 
  97:main.c        **** //A Game! Ala "Racer" from the ol' TI-82 days...
  98:main.c        **** // Use a potentiometer to try to keep the "car" on the race-track
  99:main.c        **** // It gets harder the longer you stay on course!
 100:main.c        **** // (Ideally: when this isn't true, remove ADC stuff from the makefile
 101:main.c        **** //  to save codespace. I don't think I've ever actually paid attention to
 102:main.c        **** //  this...)
 103:main.c        **** //#define SEG_RACER 	TRUE
 104:main.c        **** 
 105:main.c        **** 
 106:main.c        **** 
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** 
 110:main.c        **** 
 111:main.c        **** 
 112:main.c        **** //#warning "This needs to be moved... and conditional"
 113:main.c        **** //#include "rowSegBuffer.c"
 114:main.c        **** 
 115:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
 116:main.c        **** #define pgm_readImageByte(image, row, col)   \
 117:main.c        **** 	   pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** 
 121:main.c        **** // I hereby declare this FPD-Link simulation technique to forever be called
 122:main.c        **** //  PW-BANGing
 123:main.c        **** 
 124:main.c        **** 
 125:main.c        **** //For testing of slower LVDS pixel-rates
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 25


 126:main.c        **** // (maybe we can increase the resolution)
 127:main.c        **** // value must be 1, 2, 4, or 8
 128:main.c        **** // This is overridden by 8 when SLOW_LVDS_TEST is true...
 129:main.c        **** // If commented-out the default of 1 is used...
 130:main.c        **** // AFAICT, this only increases codesize in HLow_delay...
 131:main.c        **** // CHANGING THIS MIGHT AFFECT DISPLAYABILITY...
 132:main.c        **** // One place to look is the delay_cyc in drawPix
 133:main.c        **** //  Currently 1, 2, and 8 seem to work.
 134:main.c        **** //  8 no longer works, noticed a/o v46
 135:main.c        **** // a/o v59, this has been 8 for quite some time... it works well with
 136:main.c        **** // RowSegBuffer, to increase resolution at the expense of frame-rate
 137:main.c        **** // I have since tried it with 2... interesting effect
 138:main.c        **** //   Surprisingly, it works, despite the fact that in this mode, I think it
 139:main.c        **** //   should be still keeping Data-Enable active for the full image
 140:main.c        **** //   which extends way beyond the edge of the screen.
 141:main.c        **** //   Oddly, it seems to be scaling BOTH horizontally *and* vertically
 142:main.c        **** //   I can't explain this.
 143:main.c        **** //   It offers quite a bit of potential, though. The refresh-rate is
 144:main.c        **** //   increased dramatically, just by changing this value from 8 to 2
 145:main.c        **** //   
 146:main.c        **** #define LVDS_PRESCALER 8//1//2//8//2//1//8//2//4//8//2//8//2
 147:main.c        **** //8//2//1//2//2//2//2//2//2//2//2//2//2//2//8//4 //1 //2//4//8//2//4
 148:main.c        **** 
 149:main.c        **** 
 150:main.c        **** //#define LIFE TRUE
 151:main.c        **** #if (defined(LIFE) && LIFE)
 152:main.c        ****  #include "lifeStuff.c"
 153:main.c        **** #endif
 154:main.c        **** 
 155:main.c        **** // a/o v59
 156:main.c        **** //This should probably always be TRUE now... It's been a LONG time since I
 157:main.c        **** // experimented with it otherwise.
 158:main.c        **** #define ROW_SEG_BUFFER	TRUE
 159:main.c        **** //now, SEG_STRETCH >= 3 causes weirdness... (repeated rows)
 160:main.c        **** // previously 3 was OK
 161:main.c        **** // This is fixed a/o newSeg, etc.
 162:main.c        **** //a/o v59 I believe this is only used in the case when no SEG_(mode) is set
 163:main.c        **** // to stretch a low-resolution row-buffer across the screen
 164:main.c        **** // And that case (No SEG_mode set) doesn't really do anything anymore
 165:main.c        **** #define SEG_STRETCH 5//4//3//2//3//4//6//3//4//6	//Stretch pixels using longer segments
 166:main.c        **** 
 167:main.c        **** #if (defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
 168:main.c        ****  #warning "ROW_SEG_BUFFER requires ROW_BUFFER, but this is a hack"
 169:main.c        ****  #if (!defined(LVDS_PRESCALER) || (LVDS_PRESCALER < 2))
 170:main.c        ****   #error "ROW_SEG_BUFFER uses 20cyc/pixel, which isn't compatible with ROW_BUFFER -> width=64, sinc
 171:main.c        ****  #endif
 172:main.c        ****  #define ROW_BUFFER TRUE
 173:main.c        ****  #include "rowSegBuffer.c"
 174:main.c        **** #endif
 175:main.c        **** 
 176:main.c        **** //a/o v59:
 177:main.c        **** //If this is not true, then it uses the frameBuffer... which is no longer
 178:main.c        **** // tested/implemented...
 179:main.c        **** #define ROW_BUFFER TRUE
 180:main.c        **** #if (defined(ROW_BUFFER) && ROW_BUFFER)
 181:main.c        ****  #include "rowBuffer.c"
 182:main.c        **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 26


 183:main.c        **** 
 184:main.c        **** //Only valid with ROW_BUFFER=TRUE above:
 185:main.c        **** //#define HORIZONTAL_COLOR_BARS TRUE
 186:main.c        **** 
 187:main.c        **** 
 188:main.c        **** 
 189:main.c        **** 
 190:main.c        **** 
 191:main.c        **** 
 192:main.c        **** 
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** // a/o v59:
 196:main.c        **** //See its old definition elsewhere
 197:main.c        **** // for an explanation of the math... and a bunch of remaining questions.
 198:main.c        **** #define NUM_PSEGS (1024/3+16)
 199:main.c        **** 
 200:main.c        **** 
 201:main.c        **** 
 202:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
 203:main.c        **** 	#include _ADC_HEADER_
 204:main.c        **** //	#include <stdio.h>
 205:main.c        **** 
 206:main.c        **** //Returns 0-9 or -1 if we've reached 0...
 207:main.c        **** int8_t grabDecimal_u32(uint32_t value, uint8_t newVal)
 208:main.c        **** {
 209:main.c        ****    static uint32_t divisor = 1000000000;
 210:main.c        **** 
 211:main.c        ****    static uint32_t thisVal;
 212:main.c        **** 
 213:main.c        ****    if(newVal)
 214:main.c        ****    {
 215:main.c        ****       divisor = 1000000000;
 216:main.c        ****       thisVal = value;
 217:main.c        ****    }
 218:main.c        **** 
 219:main.c        ****    uint8_t decimal = 0;
 220:main.c        **** 
 221:main.c        **** 
 222:main.c        **** 
 223:main.c        ****    if(divisor == 0)
 224:main.c        ****       return -1;
 225:main.c        **** 
 226:main.c        ****    while(thisVal >= divisor)
 227:main.c        ****    {
 228:main.c        ****       decimal++;
 229:main.c        ****       thisVal -= divisor;
 230:main.c        **** 
 231:main.c        ****    }
 232:main.c        **** 
 233:main.c        **** 
 234:main.c        **** 
 235:main.c        **** 
 236:main.c        ****    divisor /= 10;
 237:main.c        **** 
 238:main.c        ****    return decimal;
 239:main.c        **** }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 27


 240:main.c        **** 
 241:main.c        **** 
 242:main.c        **** //Including raceWidth, and maybe some buffer...
 243:main.c        **** #define RACE_WIDTH_PSEGS	272
 244:main.c        **** 
 245:main.c        **** 
 246:main.c        **** void showScore(uint16_t rowNum, uint32_t score, uint8_t color)
 247:main.c        **** {
 248:main.c        **** 
 249:main.c        **** 	//The first few rows aren't displaying?
 250:main.c        **** //		rowNum-=6;
 251:main.c        **** 		int8_t decimal;
 252:main.c        **** 		uint8_t scoreFound = FALSE;
 253:main.c        **** 
 254:main.c        **** 		static uint32_t thisScore;
 255:main.c        **** 
 256:main.c        **** 		if(rowNum == 0)
 257:main.c        **** 			thisScore = score; // goodCount;
 258:main.c        **** 
 259:main.c        **** 		decimal = grabDecimal_u32(thisScore, 1);
 260:main.c        **** 
 261:main.c        **** 		uint8_t col;
 262:main.c        **** 
 263:main.c        **** 		uint8_t charRow = 0;
 264:main.c        **** 
 265:main.c        **** 		for(col=0; col<NUM_PSEGS-3-RACE_WIDTH_PSEGS; col++)
 266:main.c        **** 		{
 267:main.c        **** //			uint8_t charRow = 0;
 268:main.c        **** 			
 269:main.c        **** 			if(col%8==0)
 270:main.c        **** 			{
 271:main.c        **** 				if((decimal != 0) && (decimal != -1))
 272:main.c        **** 					scoreFound = TRUE;
 273:main.c        **** 
 274:main.c        **** 				if((decimal == -1) || (!scoreFound))
 275:main.c        **** 					charRow = 0;
 276:main.c        **** 				else
 277:main.c        **** 					charRow = getCharRow(decimal+'0', rowNum/2);
 278:main.c        **** 				decimal = grabDecimal_u32(thisScore, 0);
 279:main.c        **** 			}
 280:main.c        **** 
 281:main.c        **** 			if(getbit(col%8, charRow))
 282:main.c        **** 				addSegfb(1,color);
 283:main.c        **** 			else
 284:main.c        **** 				addSegfb(1,_B);
 285:main.c        **** 		}
 286:main.c        **** }	
 287:main.c        **** 
 288:main.c        **** #endif
 289:main.c        **** 
 290:main.c        **** 
 291:main.c        **** 
 292:main.c        **** 
 293:main.c        **** 
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 28


 297:main.c        **** //Options LTN, IDT, or TESTVALS
 298:main.c        **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
 299:main.c        **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 300:main.c        **** 
 301:main.c        **** //For Red and Green (NOT Blue) This enables four shades, instead of three
 302:main.c        **** // (including black)
 303:main.c        **** // Doing so increases pixel-processing time, thus the pixel-widths
 304:main.c        **** // (thus decreasing resolution)
 305:main.c        **** // each color takes 9 cycles to process in three-shade mode
 306:main.c        **** // or 12 cycles for red and green, plus 9 for blue in four-shade mode
 307:main.c        **** // a/o v59: I don't think this does anything in ROW_SEG_BUFFER
 308:main.c        **** #define FOUR_SHADES TRUE
 309:main.c        **** 
 310:main.c        **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 311:main.c        **** //  it seems the speed (at least for the LTN) isn't so important after all
 312:main.c        **** //  This could be used to my advantage...
 313:main.c        **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
 314:main.c        **** //  Thus, pixels could be skinnier, thus higher-resolution.
 315:main.c        **** //   Or more instructions could be used for the same resolution
 316:main.c        **** //   allowing, e.g. sprites from program-memory, without necessitating a
 317:main.c        **** //   large (or any?) frame-buffer...
 318:main.c        **** 
 319:main.c        **** 
 320:main.c        **** //This used to be handled by TOOFAST_TEST, but now can be configured here
 321:main.c        **** // 0xff sets the processor to run as fast as possible 
 322:main.c        **** //  (~16MHz? ~128MHz bit-rate)
 323:main.c        **** // 0x00 sets it as slow as possible (~4MHz, ~32MHz bit-rate)
 324:main.c        **** //  good for testing whether odd colors
 325:main.c        **** //  or bad syncing is due to bits being shifted, etc. 
 326:main.c        **** //  Maybe due to slow "LVDS" conversion chips, or whatnot.
 327:main.c        **** //   This seems to be the case right now... 0xff: black is appearing green
 328:main.c        **** //   There should be *some* green in it, but not this much.
 329:main.c        **** //   Likely due to different propagation delays between my under-driven
 330:main.c        **** //    74LS86's (running red and green), from 3.3V!
 331:main.c        **** //    and the happier and newer 74AHC XOR and OR currently driving the
 332:main.c        **** //    clock and DVH/Blue signals
 333:main.c        **** //  Highly dependent on the screen itself, some may not run at all with
 334:main.c        **** //  such slow bitrates... heck, some may not run at all even at the fastest
 335:main.c        **** // If SLOW_EVERYTHING_TEST is true, this value is overridden
 336:main.c        **** // LTN last used 0x20
 337:main.c        **** // a/o v59:
 338:main.c        **** // 0xD8 is the lowest value that syncs reliably, a few glitches from time
 339:main.c        **** // to time.
 340:main.c        **** // The effect of lower values isn't *quite* what I was expecting, but
 341:main.c        **** // definitely suggests that using ROW_SEG_BUFFER at this bit/refresh-rate
 342:main.c        **** // is dang-near right at the minimum required for this display.
 343:main.c        **** // This might be why the other (same model) display didn't work, but its
 344:main.c        **** // flakeyness at 0xff appeared different than this one's at lower OSCCALs
 345:main.c        **** #define OSCCAL_VAL	0xff//0xDB//0xDC//0xE0//0//0xff//0x20//0xff //0x00
 346:main.c        **** 
 347:main.c        **** //This would normally be 0 for the highest-speed frame-refresh possible
 348:main.c        **** // However, increasing this value can slow the frame-refresh rate
 349:main.c        **** //   if desired
 350:main.c        **** // e.g. 50000 causes it to refresh ~ every few seconds
 351:main.c        **** //   (durn-near the limit for how long the LCD will retain an image)
 352:main.c        **** // The benefit being that it doesn't flicker at annoying rates for
 353:main.c        **** //  stationary images
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 29


 354:main.c        **** //  worth exploring...
 355:main.c        **** // This may be highly dependent on the screen capabilities...
 356:main.c        **** //   of course, this sorta thing is undocumented
 357:main.c        **** //   it just has to be experimented with
 358:main.c        **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 359:main.c        **** //   likely be driven DC... not sure what the long term effects are.
 360:main.c        **** // This could be a hell of a lot more sophisticated...
 361:main.c        **** // e.g. refresh after a frameBuffer change
 362:main.c        **** //      refresh based on a seconds-timer
 363:main.c        **** //      ...
 364:main.c        **** // AS-IS: Does refreshes completely independent of the frame-buffer
 365:main.c        **** //      if it's too slow, some images may be missed completely.
 366:main.c        **** //      This is not true for FRAME_SYNC TRUE (below)
 367:main.c        **** //      (and it's not really useful anymore with FRAME_SYNC)
 368:main.c        **** // a/0 v59: This is no longer used (!?) I coulda sworn it was still
 369:main.c        **** //          responsible for modifying the timer's interrupt frequency
 370:main.c        **** //          This was also used in an attempt to make the Horizontal Back
 371:main.c        **** //          Porch constant regardless of row calculation-time
 372:main.c        **** //          So, either, the HBP is long enough for the current math, or
 373:main.c        **** //          the display is not sensitive to varying HBPs between rows
 374:main.c        **** //          (see also lcdStuff.c)
 375:main.c        **** //#define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 376:main.c        **** 
 377:main.c        **** //SHOULD PROBABLY BE REVISITED
 378:main.c        **** // It probably doesn't work with all cases...
 379:main.c        **** // Definitely with drawPix/Images...
 380:main.c        **** //This causes main o update the image *after* FRAME_UPDATE_DELAY
 381:main.c        **** // a/o v59: I don't think this is used anymore...
 382:main.c        **** #define FRAME_SYNC TRUE
 383:main.c        **** 
 384:main.c        **** //New Idea:
 385:main.c        **** // Disable the Hsync timer interrupt after the frame completes
 386:main.c        **** //  and reenable elsewhere...
 387:main.c        **** //  (It seems pixels changing from one shade to another take an
 388:main.c        **** //   intermediate step halfway between)
 389:main.c        **** //  (Thus, two updates then a pause might clear that up)
 390:main.c        **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 391:main.c        **** //   is the same...)
 392:main.c        **** //  (but it is an interesting effect)
 393:main.c        **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 394:main.c        **** //  Reworded: Having several frame refreshes before a pause helps to
 395:main.c        **** //  "solidify" the color changes... especially the sharp changes 
 396:main.c        **** //  (e.g. yellow<->black)
 397:main.c        **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
 398:main.c        **** //   in LCDdirect that was only connected such that R, G, and B were each
 399:main.c        **** //   either full-off or full-on, i.e. all Red bits were connected to a
 400:main.c        **** //   single output pin (full on when 1, full off when 0).
 401:main.c        **** //   I hadn't attributed it to improper refresh synchronization
 402:main.c        **** //   as the refresh rate was too fast to see... That's a handy way to get
 403:main.c        **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 404:main.c        **** //  connected with each color 
 405:main.c        **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 406:main.c        **** //  If you WANT this effect (for intermediate shades?) 
 407:main.c        **** //   set FRAME_COUNT_TO_DELAY to 1
 408:main.c        **** //  Then, each change of color will (apparently) result in a value halfway
 409:main.c        **** //   between the old color and the new color
 410:main.c        **** //  Not sure whether it's an electrical problem, but these half-shades 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 30


 411:main.c        **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 412:main.c        **** //   depends on the goal...
 413:main.c        **** // a/o v59: I believe this doesn't work with ROW_SEG_BUFFER...
 414:main.c        **** #define FRAME_COUNT_TO_DELAY 8//2//7//1//5//2//3
 415:main.c        **** 
 416:main.c        **** 
 417:main.c        **** //These two are mutually-exclusive (BLUE_VERT_BAR overrides DE_BLUE)
 418:main.c        **** // (BLUE_DIAG_BAR overrides both...)
 419:main.c        **** 
 420:main.c        **** 
 421:main.c        **** // Default is drawPix, from program memory...
 422:main.c        **** 
 423:main.c        **** //These are only used in drawPix...
 424:main.c        **** //This probably has no purpose outside of COLOR_BAR_SCROLL below
 425:main.c        **** // Actually, it's kinda funny watcching the top of the smiley's
 426:main.c        **** // head scroll... like he's getting a brain transplant
 427:main.c        **** //#define PIXEL_SCROLL TRUE
 428:main.c        **** 
 429:main.c        **** //This is only valid in drawPix with an image...
 430:main.c        **** #define IMAGE_CHANGE TRUE
 431:main.c        **** 
 432:main.c        **** 
 433:main.c        **** //#define COLOR_BAR_SCROLL TRUE
 434:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
 435:main.c        **** 
 436:main.c        **** //#warning "COLOR_BAR_SCROLL is broken a/o v29, possibly earlier"
 437:main.c        **** // Probably just a timing issue...
 438:main.c        **** 
 439:main.c        **** //Optional, but only useful here...
 440:main.c        ****  #define PIXEL_SCROLL TRUE
 441:main.c        **** 
 442:main.c        ****  //Handles all the displayable colors in a single row for scrolling...
 443:main.c        ****  #define FB_WIDTH 64 //28
 444:main.c        ****  //Two different arrangements of colors...
 445:main.c        ****  #define FB_HEIGHT 2
 446:main.c        **** 
 447:main.c        **** #else //drawPix from program memory
 448:main.c        ****  #define FB_WIDTH	16
 449:main.c        ****  #define FB_HEIGHT 16
 450:main.c        **** #endif
 451:main.c        **** 
 452:main.c        **** 
 453:main.c        **** 
 454:main.c        **** //DC_DE is only used in drawPix...
 455:main.c        **** //#define DC_DE_DISABLE TRUE
 456:main.c        **** //This should remove DC from Vsync, etc...
 457:main.c        **** // Currently only implemented with FULL_INIT_TESTS below...
 458:main.c        **** //#define REMOVE_DC TRUE
 459:main.c        **** 
 460:main.c        **** //#define FULL_INIT_TESTS TRUE
 461:main.c        **** 
 462:main.c        **** 
 463:main.c        **** //#define BLUE_DIAG_BAR TRUE
 464:main.c        **** 
 465:main.c        **** //A single black bar, followed by a single blue bar... ~1/3 and 2/3's width
 466:main.c        **** //#define BLUE_VERT_BAR TRUE
 467:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 31


 468:main.c        **** //#define DE_BLUE TRUE
 469:main.c        **** // NONE SELECTED DOESN'T SYNC!!! DE not detected???
 470:main.c        **** 
 471:main.c        **** 
 472:main.c        **** //#define DE_ONLY_DISPLAY	TRUE
 473:main.c        **** 
 474:main.c        **** 
 475:main.c        **** //a/0 v24, this allows the clock signal to be affected by DT
 476:main.c        **** // if it works, we'll be able to use Green on /OC1B
 477:main.c        **** // Sort of works... Blues with DT=0 are good, timing's not screwed
 478:main.c        **** // but blues with DT!=0 are damn-near black except for a light pixel
 479:main.c        **** // before-hand
 480:main.c        **** //a/0 v26, this is now required for Green IN MODES OTHER THAN DRAWPIX
 481:main.c        **** // Not sure where that note makes sense...
 482:main.c        **** // a/o 56-36-3ish it's been removed completely.
 483:main.c        **** //DO NOT define CLOCK_INSENSITIVITY_TESTING TRUE
 484:main.c        **** 
 485:main.c        **** // Rather than *possibly* mess with timing (on other displays?)
 486:main.c        **** // Also for testing...
 487:main.c        **** //#define DT0_BLUES_ONLY	TRUE
 488:main.c        **** 
 489:main.c        **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 490:main.c        **** // LTN appears to be content with my pseudo-LVDS scheme.
 491:main.c        **** // IAXG has never unblanked
 492:main.c        **** //      Even though suitable timings were found with SwitchResX
 493:main.c        **** //      Maybe due to psuedo-LVDS
 494:main.c        **** //            slight timing issues // It probably doesn't work with all cases...
 495:main.c        **** // Definitely with drawPix/Images...(RC oscillator variances?)
 496:main.c        **** //            glitches when switching LVDS states 
 497:main.c        **** //                 (thought I had that figured out, originally)
 498:main.c        **** //      The fact the LTN appears to recognize the signalling suggests the
 499:main.c        **** //      IAXG would be worth further exploration...
 500:main.c        **** //         Unfortunately, the CCFT blew out my inverter
 501:main.c        **** //                        And I must have put it back together incorrectly
 502:main.c        **** //                        (backlight filters out of order or flipped?)
 503:main.c        **** //                        (which actually makes for some very interesting
 504:main.c        **** //                         visuals, but hard to develop with)
 505:main.c        **** //      IAXG: uses DE, V, and H
 506:main.c        **** //             At low pixel-clock DE is active for fewer pixels...
 507:main.c        **** //              Last Tested: 680 was full-screen
 508:main.c        **** //             Nice because it increases the frame-rate!
 509:main.c        **** //      LTN:  uses DE only
 510:main.c        **** 
 511:main.c        **** 
 512:main.c        **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
 513:main.c        **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 514:main.c        **** //  (Though I am currently running with OSCAL set to the highest frequency
 515:main.c        **** //   and the PLL seems to be syncing at about 128MHz)
 516:main.c        **** 
 517:main.c        **** 
 518:main.c        **** // Wiring:
 519:main.c        **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 520:main.c        **** //   simplest of all:
 521:main.c        **** //
 522:main.c        **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 523:main.c        **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 524:main.c        **** //   It's spec'd to run from 4.5-5.5V, and its propagatio delays and slew
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 32


 525:main.c        **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 526:main.c        **** //     yet it's working...
 527:main.c        **** //   Further, the output voltages are right in the LVDS range,
 528:main.c        **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
 529:main.c        **** //      (Don't forget the LCD has a 100ohm resistor between
 530:main.c        **** //         RXinN/clk+ and RXinN/clk-)
 531:main.c        **** //   Most signals are connected as shown (RXin0, RXin2, RXclk)
 532:main.c        **** //   Green is the only one which has RXin1- and RXin1+ swapped
 533:main.c        **** //     since it is on the /OC1B (inverted) output
 534:main.c        **** //   Green may benefit from a pull-up resistor on /OC1B
 535:main.c        **** //     there was some weird noise appearing like a floating-input
 536:main.c        **** //     when the full frame was not filled with pixels
 537:main.c        **** //     (but it should've waited to disable /OC1B until *after* the delays,
 538:main.c        **** //      etc. So I'm not sure what it was)
 539:main.c        **** //
 540:main.c        **** //   It's probably best to use two XORs from the same chip for a single
 541:main.c        **** //    LVDS channel, since different chips may have slightly different
 542:main.c        **** //    characteristics. 
 543:main.c        **** //
 544:main.c        **** //   The entire circuit, thus, requires TWO 74LS86's 
 545:main.c        **** //    (four XORs apiece, two per LVDS channel, 8-total)
 546:main.c        **** //
 547:main.c        **** //
 548:main.c        **** //              VCC3V3   VCC3V3
 549:main.c        **** //                |        |
 550:main.c        **** //                +---\ \-_
 551:main.c        **** //                     | |    -
 552:main.c        **** //                     | | XOR   >------> RXinN/clk-
 553:main.c        **** //   AVR               | |    _-
 554:main.c        **** //   OC1x >----+------/ /___-
 555:main.c        **** //   output    |
 556:main.c        **** //             |   
 557:main.c        **** //             |      
 558:main.c        **** //             `------\ \-_
 559:main.c        **** //                     | |    -
 560:main.c        **** //                     | | XOR   >------> RXinN/clk+
 561:main.c        **** //                     | |    _-
 562:main.c        **** //                +---/ /___-
 563:main.c        **** //                |        |
 564:main.c        **** //               GND      GND
 565:main.c        **** //
 566:main.c        **** //  
 567:main.c        **** //  Also used: The TTL 74AHC series...
 568:main.c        **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 569:main.c        **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
 570:main.c        **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 571:main.c        **** //     (with a 100ohm load in the LCD)
 572:main.c        **** //
 573:main.c        **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 574:main.c        **** //     channels, I had to implement Red and Green with the LS 
 575:main.c        **** //     before switching all channels to the LS... Using different chips
 576:main.c        **** //     (specifically, different TYPES of chips) for different channels
 577:main.c        **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 578:main.c        **** //     signals are synchronized, but the red and green signals were shifted
 579:main.c        **** //     a bit or two (resulting in "Black" appearing green, of course
 580:main.c        **** //     true black isn't really possible with my timing scheme... see below)
 581:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 33


 582:main.c        **** //  For other circuits attempted, see oldNotes.txt
 583:main.c        **** //     (and boy there were many, involving voltage dividers, AC coupling,
 584:main.c        **** //      reference voltages, BJT differential amplifiers... I doubt I 
 585:main.c        **** //      documented them all, or even most. Whoda thunk the simplest, 
 586:main.c        **** //      especially under- AND over-spec'd--timing, supply voltage, and
 587:main.c        **** //      output voltage--would be the one...?)
 588:main.c        **** //
 589:main.c        **** // LVDS/FPD-Link timing:
 590:main.c        **** 
 591:main.c        **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 592:main.c        **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
 593:main.c        **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 594:main.c        **** //            |____.____.____.____               |____.____.____.____
 595:main.c        **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 596:main.c        **** //            |         |            |         |
 597:main.c        **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 598:main.c        **** //            |                                  |
 599:main.c        **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 600:main.c        **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 601:main.c        **** //            | ^  ^ | 
 602:main.c        **** //            |         |<--Not Blue-->|         |
 603:main.c        **** //            |                                  |
 604:main.c        **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 605:main.c        **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 606:main.c        **** //            | ^ ^  |  
 607:main.c        **** //            |         |<------->|-Not Green    |
 608:main.c        **** //
 609:main.c        **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 610:main.c        **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 611:main.c        **** //            | ^^     
 612:main.c        **** //            |         |<-->|-Not Red
 613:main.c        **** //
 614:main.c        **** //   Of course: The Not Green/Red bits above are low-bits and
 615:main.c        **** //              basically have little/no visible effect
 616:main.c        **** //
 617:main.c        **** //
 618:main.c        **** // Ponderings on using /OC1x's and OC1D for other colors...
 619:main.c        **** //    /OC1D could easily be used for another color, unaffected by others
 620:main.c        **** //          since DT1(L) and OCR1D are unused
 621:main.c        **** //
 622:main.c        **** // DE:   Blue Values
 623:main.c        **** //       -----------
 624:main.c        **** //       OCR1A=4,5,6   (OCR1A=6, Full-Blue would force /OC1A low,
 625:main.c        **** //       DT1(H)=0,1,2                      e.g. Green=Full-Green or Off)
 626:main.c        **** //                      Also: OCR1A=4,5 would affect Green
 627:main.c        **** //                            (DT1(L) is from this edge...)
 628:main.c        **** //                            DT1(H) also affects complementary OC1D
 629:main.c        **** //
 630:main.c        **** // CLK:  OCR1B=3       CLOCK can NOT be complementary-output mode
 631:main.c        **** //                                   (/OC1B unusuable)
 632:main.c        **** //                                   otherwise, DT1 would affect clock
 633:main.c        **** //
 634:main.c        **** //
 635:main.c        **** // CLOCK_INSENSITIVITY_TESTING:
 636:main.c        **** //   (a/o 56-36-3ish, no longer testable)
 637:main.c        **** //    Testing of DE/Blue's DeadTime values on Clocking...
 638:main.c        **** //    	Image-shift (not sure why, more calculations? Not *that* many!)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 34


 639:main.c        **** //       Blue now has only two shades besides black
 640:main.c        **** //         ~66% and 100%
 641:main.c        **** //       Now each blue pixel (the ones appearing black)
 642:main.c        **** //         is bordered by a blue line...
 643:main.c        **** //    All doable. Would have preferred 3 shades besides black,
 644:main.c        **** //       but two isn't bad.
 645:main.c        **** //
 646:main.c        **** //  New Idea: Since CLOCK can be used with DT1H (during DE)
 647:main.c        **** //    DE/Blue DT values are 0, 1, or 2 (D0, D1, D2)
 648:main.c        **** //     Dn corresponds to the low-to-high dead-timer value
 649:main.c        **** //                   (aka counter-reset delay, on OCR1x)
 650:main.c        **** //     dn corresponds to the high-to-low dead-timer value
 651:main.c        **** //                   (aka OCR match delay, on /OCR1x)
 652:main.c        **** //     Cn corresponds to OCR1x=n
 653:main.c        **** //
 654:main.c        **** // This was easier to comprehend in v<26... now it's more informative
 655:main.c        **** //   but harder to view...
 656:main.c        **** //                          OCR1B = 3
 657:main.c        **** //  TCNT:     |  0   1    2    3  | 4    5    6
 658:main.c        **** //
 659:main.c        **** //  CLKideal: /\______________/
 660:main.c        **** //
 661:main.c        **** //            |____ ____ ____.____v              |
 662:main.c        **** //  CLK:   D0>/ D1>/ D2>/         \    .    .    /
 663:main.c        **** //  OC1B      |           |  |
 664:main.c        **** //            |                   |
 665:main.c        **** //            | G2   G1   B1   B0 | G5   G4   G3
 666:main.c        **** //  Green:    |                   |____ ____ ____
 667:main.c        **** //  /OC1B     \    .    .    . d0>/ d1>/ d2>/ d3?\  //
 668:main.c        **** //            |      
 669:main.c        **** //            |
 670:main.c        **** //            | R1   R0   G0   R5   R4   R3   R2
 671:main.c        **** //  Red:      |____ ____ ____ ____ ____ ____ ____
 672:main.c        **** //  OC1D   D0>/ D1>/ D2>/ C2>\ C3>\ C4>\ C5>\ C6...
 673:main.c        **** //                       
 674:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 675:main.c        **** //  /OC1D     \ ^OCR1D>=6^ L>/  M>/  N>/  O>/ P?>...
 676:main.c        **** //                   
 677:main.c        **** //
 678:main.c        **** //              B3   B2   DE   /V   /H   B5   B4
 679:main.c        **** // "Blue/DVH" |____ ____ ____.____.____ ____ ____
 680:main.c        **** //  OC1A:  D0>/ D1>/ D2>/           C4>\ C5>\ C6...
 681:main.c        **** //            |                  
 682:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 683:main.c        **** //  /OC1A:    \  ^^^--OCR1A>=6--^^^  X>/  Y>/ Z?>\  //
 684:main.c        **** //  (usable?)        
 685:main.c        **** //                 X: OCR1A=4, DTL=0
 686:main.c        **** //                 Y: OCR1A=4, DTL=1; OCR1A=5, DTL=0
 687:main.c        **** //                 Z: OCR1A=4, DTL=2; OCR1A=5, DTL=1; OCR1A>=6
 688:main.c        **** 
 689:main.c        **** //I've looked it over extensively, albiet exhaustedly, and it seems
 690:main.c        **** // there's only one way to do this. Unfortunately, DTH=1,2 *does* affect
 691:main.c        **** // the clocking. Everything displays properly, but the lighter shades of 
 692:main.c        **** // blue enabled by DTH=1,2 don't display at all (or dang-near black)
 693:main.c        **** // So there's really no benefit to using DTH=1,2 during DE for blues...
 694:main.c        **** // That gives two (similar) shades of bright blue 63/63 and 47/63
 695:main.c        **** // *'d are arbitrarily chosen for implementation
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 35


 696:main.c        **** // F'd are selected when FOUR_SHADES is TRUE
 697:main.c        **** //   (experimentation might show other choices are better)
 698:main.c        **** //
 699:main.c        **** // Red is connected to OC1D, Complementary output is not necessary
 700:main.c        **** //  OCR1D determines its brightness:
 701:main.c        **** //   (+OC1D => RX0+)
 702:main.c        **** //   *Off (0/63): OCR1D = 0  \      //
 703:main.c        **** //    3/63:			OCR1D = 1   > These three appear identical in glColorTest
 704:main.c        **** //    3/63:			OCR1D = 2  /  (G0 Active, from here down)
 705:main.c        **** //   *35/63:		OCR1D = 3
 706:main.c        **** //   F51/63:		OCR1D = 4
 707:main.c        **** //    59/63:		OCR1D = 5  \  These two appear identical in glColorTest
 708:main.c        **** //   *63/63:		OCR1D >= 6 /
 709:main.c        **** //    (+OC1D => RX0-)
 710:main.c        **** //    Not really worth pursuing, next step from 60/63 is 28/63 then 12
 711:main.c        **** //
 712:main.c        **** // Green is connected to /OC1B (the complementary channel to CLK)
 713:main.c        **** //  Its polarity is reversed (but that's easy since we have a single-ended
 714:main.c        **** //  to differential converter, and its outputs can just be swapped)
 715:main.c        **** //  DTL1 determines its brightness (G0 affected by Red):
 716:main.c        **** //   (/OC1B => RX1+)
 717:main.c        **** //    Off (0/63):	DTL1 = 3 (is this possible?)
 718:main.c        **** //    8-9/63:			DTL1 = 2
 719:main.c        **** //    24-25/63:		DTL1 = 1
 720:main.c        **** //    56-57/63:		DTL1 = 0
 721:main.c        **** //   (/OC1B => RX1-)				(B1,0 Active, as well as G2,1)
 722:main.c        **** //	  *Off (6/63):	DTL1 = 0
 723:main.c        **** //   *38-39/63:		DTL1 = 1
 724:main.c        **** //   F54-55/63:		DTL1 = 2
 725:main.c        **** //   *62-63/63:		DTL1 = 3
 726:main.c        **** //
 727:main.c        **** // Blue, as in previous versions, is connected to OC1A, DTH=0 during DE 
 728:main.c        **** //  so as not to interfere with the clock
 729:main.c        **** //  OCR1A determines the brightness (B1,0 active, per Green->RX1-):
 730:main.c        **** //    (+OC1A => RX2+)			      (B3,2 Active from here down)
 731:main.c        **** //    *Off (15/63):	OCR1A=4
 732:main.c        **** //    *47/63:		 	OCR1A=5
 733:main.c        **** //		*63/63:			OCR1A=6
 734:main.c        **** //
 735:main.c        **** // The clock is single-ended (complementary-mode disabled) during NON-DE
 736:main.c        **** //  because the DE/V/H signals (except in DE mode) require DT1H to vary.
 737:main.c        **** //  When DE is active the clock channel (OC1B) is switched to 
 738:main.c        **** //  complementary-output-mode to enable the Green PWM output
 739:main.c        **** //
 740:main.c        **** // For easier viewing:
 741:main.c        **** //   Red: (+OC1D => RX0+)
 742:main.c        **** //    Off (0/63): OCR1D = 0
 743:main.c        **** //    35/63:      OCR1D = 3
 744:main.c        **** //    51/63:      OCR1D = 4	(FOUR_SHADES only)
 745:main.c        **** //    63/63:      OCR1D >= 6
 746:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 747:main.c        **** //    Off (6/63): DTL1 = 0
 748:main.c        **** //    38-39/63:      DTL1 = 1
 749:main.c        **** //    54-55/63:		DTL1 = 2	(FOUR_SHADES only)
 750:main.c        **** //    62-63/63:      DTL1 = 3
 751:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 752:main.c        **** //    Off (15/63):  OCR1A=4
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 36


 753:main.c        **** //    47/63:        OCR1A=5
 754:main.c        **** //    63/63:        OCR1A=6
 755:main.c        **** //
 756:main.c        **** 
 757:main.c        **** // Toward creating a GIMP palette... v54.5
 758:main.c        **** // Probably absurd, but this was brown/orange on GIMP and it's yellow here
 759:main.c        **** //
 760:main.c        **** //   Red: (+OC1D => RX0+)
 761:main.c        **** //    Off (0/63): OCR1D = 0	r=0
 762:main.c        **** //    35/63:      OCR1D = 3	r=142
 763:main.c        **** //    51/63:      OCR1D = 4	r=206
 764:main.c        **** //    63/63:      OCR1D >= 6	r=255
 765:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 766:main.c        **** //    Off (6/63): DTL1 = 0		g=24
 767:main.c        **** //    38-39/63:      DTL1 = 1 g=154
 768:main.c        **** //    54-55/63:		DTL1 = 2	g=218
 769:main.c        **** //    62-63/63:      DTL1 = 3 g=251
 770:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 771:main.c        **** //    Off (15/63):  OCR1A=4	b=61
 772:main.c        **** //    47/63:        OCR1A=5	b=190
 773:main.c        **** //    63/63:        OCR1A=6	b=255
 774:main.c        **** //
 775:main.c        **** //  These numbers don't look entirely accurate...
 776:main.c        **** //    they vary depending on the other colors... and why is blue so high
 777:main.c        **** //    even when it's off?
 778:main.c        **** //  Maybe I'm looking at old notes...?
 779:main.c        **** //   SEE lvdsColorExperiments.c Now Here.
 780:main.c        **** 
 781:main.c        **** 
 782:main.c        **** //  Implementations/prospects:
 783:main.c        **** //  * rowBuffer.c (more like row-settings-buffer)
 784:main.c        **** //     calculate a row's worth of pixels before drawing that row
 785:main.c        **** //     (uses packed color settings in a single byte per drawable pixel)
 786:main.c        **** //     64 drawable pixels across, regardless of LVDS speed
 787:main.c        **** //  * For faster pixels: these settings values could be stored 
 788:main.c        **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 789:main.c        **** //     (not implemented)
 790:main.c        **** //  * rowSegBuffer.c
 791:main.c        **** //     also calculates an entire row before drawing it
 792:main.c        **** //     instead of storing pixels, store "segments"
 793:main.c        **** //     i.e. each segment is defined by a color value and a length
 794:main.c        **** //      the color-value is stored as DT/OCR values (not RGB values)
 795:main.c        **** //     Number of segments is limited only by memory...
 796:main.c        **** //      e.g. 64 segments per row (max) is 64*3Bytes
 797:main.c        **** //       Three bytes for color, and *really simple* packing for seg-length
 798:main.c        **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 799:main.c        **** //       as high as one LCD pixel.
 800:main.c        **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 801:main.c        **** //      (with packing)
 802:main.c        **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 803:main.c        **** //      only adds two clock cycles to each "pixel", so probably worth it
 804:main.c        **** 
 805:main.c        **** //   In Any Case: There's not enough RAM for a full frame
 806:main.c        **** //          64 pixels across * 64 pixels down is 4096 bytes
 807:main.c        **** //          So whatever method, we need to precalculate each row before
 808:main.c        **** //          displaying it
 809:main.c        **** //          Could be as simple as loading direct from program memory
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 37


 810:main.c        **** //
 811:main.c        **** 
 812:main.c        **** // Since low-bits are barely visible, their effect is neglected.
 813:main.c        **** //   Thus: Green is affected only by the Compare-Match deadTimer (DT1L)
 814:main.c        **** //         Red is affected only by OCR1D, and could be single-ended
 815:main.c        **** //   OTOH:
 816:main.c        **** //         The Visible blue values (with DT affecting clock)
 817:main.c        **** //         are only the high-two values, which are affected only by OCR1A
 818:main.c        **** //         So counter-reset dead-time (DT1H) needn't be varied
 819:main.c        **** //         And, then, the clock won't be affected at all
 820:main.c        **** //         (assuming we set it to single-ended during DE disabled, for V/H)
 821:main.c        **** //
 822:main.c        **** // NEW CONSIDERATION: "The dead timer delays the waveform by a minimum of
 823:main.c        **** //    "of one count, when DT=0..."
 824:main.c        **** // So changing the clock from single-ended to complementary
 825:main.c        **** //   might actually cause the clock output to be shifted!
 826:main.c        **** 
 827:main.c        **** 
 828:main.c        **** // DE/V/H Timing (LCDdirectLVDS):
 829:main.c        **** //  
 830:main.c        **** //
 831:main.c        **** //            |  0   1    2    3    4    5    6       All: set @ 0
 832:main.c        **** //            |____.____.____.____                         OCR1C = 6 
 833:main.c        **** //  Clock:    /                   \    .    .    /         Complementary-
 834:main.c        **** //                                             Output Mode
 835:main.c        **** //                                                          required for DT
 836:main.c        **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 837:main.c        **** //             ____ ____ ____ ____ ____ ____ ____|____    
 838:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 839:main.c        **** //   state2                      |    
 840:main.c        **** //   DE_BLUE: >|    DT=X, OCR=0
 841:main.c        **** //                         Watch the transition!! -------^
 842:main.c        **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 843:main.c        **** //   DC_DISABLED:
 844:main.c        **** //   maxBlue: >\____|		DT=0, OCR=5
 845:main.c        **** //             See below for more blue settings...
 846:main.c        **** //
 847:main.c        **** //             ____ ____      ____      ____ ____|____ 
 848:main.c        **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 849:main.c        **** //   state1              | 
 850:main.c        **** //            >______________/\______________|    DT=3, OCR=3
 851:main.c        **** //  DC_DISABLED:
 852:main.c        **** //   Not much can be done...
 853:main.c        **** //
 854:main.c        **** //             ____ ____           ____ ____ ____|____ 
 855:main.c        **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 856:main.c        **** //   state3              |
 857:main.c        **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 858:main.c        **** // DC_DISABLED:
 859:main.c        **** //            >___________________/\____|		DT=4, OCR=5
 860:main.c        **** 
 861:main.c        **** //             ____ ____                ____ ____|____ 
 862:main.c        **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 863:main.c        **** //   state4          | 
 864:main.c        **** //            >__________________________________|    DT=X, OCR=0
 865:main.c        **** //                             TransitionWatch!!! -------^
 866:main.c        **** //                             Shouldn't matter... DT from no-edge
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 38


 867:main.c        **** // DC_DISABLED:
 868:main.c        **** //            >\________________________|		DT=0, OCR=1
 869:main.c        **** 
 870:main.c        **** //             ____ ____      ____ ____ ____ ____|____ 
 871:main.c        **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 872:main.c        **** //   state0                  |     
 873:main.c        **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 874:main.c        **** // DC_DISABLED:
 875:main.c        **** //            >______________/\____|		DT=3, OCR=5
 876:main.c        **** 
 877:main.c        **** // Transitions: OLD!!!!! WRONG!!!!
 878:main.c        **** //   (are they? There're several additional transitions, now, for one.)
 879:main.c        **** //  The idea is to reduce the number of instructions between each
 880:main.c        **** //  LVDS "state."
 881:main.c        **** //  These are implemented below in the case:
 882:main.c        **** //    "#else //NOT FULL_INIT_TESTS"
 883:main.c        **** //  Since each instruction takes *longer than* a single pixel
 884:main.c        **** //    two instructions would *at best* occur on two consecutive pixels
 885:main.c        **** //    Thus, there's likely to be a transition-glitch
 886:main.c        **** //    (e.g. old OCR value with new DT value)
 887:main.c        **** //  Note that the new DT values are implemented at the next corresponding
 888:main.c        **** //    edge after the DT-write instruction completes
 889:main.c        **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 890:main.c        **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 891:main.c        **** //    New OCR values are delayed until the next TCNT reset to 0
 892:main.c        **** //
 893:main.c        **** //  Initial:
 894:main.c        **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 895:main.c        **** 
 896:main.c        **** //  Nada	->	H			OCR=2
 897:main.c        **** //  H		->	Nada		OCR=NADA_OCR
 898:main.c        **** //  
 899:main.c        **** //  Nada	->	V			DT=3
 900:main.c        **** //  V		->	V+H		OCR=0
 901:main.c        **** //  V+H	->	V			OCR=NADA_OCR
 902:main.c        **** //  V		->	Nada		DT=2
 903:main.c        **** //
 904:main.c        **** //  Nada	->	DE			DT=1
 905:main.c        **** //  DE	->	Nada		DT=2
 906:main.c        **** 
 907:main.c        **** 
 908:main.c        **** #if (defined(REMOVE_DC) && REMOVE_DC)
 909:main.c        **** #error "REMOVE_DC hasn't been tested since lcdStuff, or long prior"
 910:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 911:main.c        **** 
 912:main.c        ****  //Unused, normally...
 913:main.c        ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 914:main.c        ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
 915:main.c        ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 916:main.c        ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
 917:main.c        ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 918:main.c        **** 
 919:main.c        **** #else //!REMOVE_DC
 920:main.c        **** //Nada init
 921:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 922:main.c        **** 
 923:main.c        **** //Unused, normally...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 39


 924:main.c        ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 925:main.c        ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 926:main.c        ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 927:main.c        **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 928:main.c        ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
 929:main.c        ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 930:main.c        **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 931:main.c        ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 932:main.c        **** #endif //REMOVE_DC
 933:main.c        **** 
 934:main.c        **** 
 935:main.c        **** //#define FULL_INIT_TESTS TRUE
 936:main.c        **** 
 937:main.c        **** //Display is DE-Only (doesn't use H/Vsync)
 938:main.c        **** // Shouldn't be necessary to select this if it is,
 939:main.c        **** // since DE timing is the same either way
 940:main.c        **** // but I want to test whether a single-bit is being detected
 941:main.c        **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 942:main.c        **** //  single bit, which might explain why the other display didn't work)
 943:main.c        **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
 944:main.c        **** #define Vsync_fromNada()      Nada_init()
 945:main.c        **** #define VplusH_fromVsync()    Nada_init()
 946:main.c        **** #define Vsync_fromVplusH()    Nada_init()
 947:main.c        **** #define Nada_fromVsync()      Nada_init()
 948:main.c        **** #define Hsync_fromNada()      Nada_init()
 949:main.c        **** #define Nada_fromHsync()      Nada_init()
 950:main.c        **** #define DEonly_fromNada()     DE_init()
 951:main.c        **** #define DEblue_fromDEonly()	DE_init()
 952:main.c        **** #define Nada_fromDEblue()		Nada_init()
 953:main.c        ****  #if(DE_BLUE)
 954:main.c        ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 955:main.c        ****   #warning "...The display should be blank"
 956:main.c        ****  #endif
 957:main.c        **** //Use full initialization of each LVDS state
 958:main.c        **** // (might not be good during transitions, but should guarantee
 959:main.c        **** //  steady-state, in case my transitions aren't correct...)
 960:main.c        **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 961:main.c        **** #define Vsync_fromNada()		Vsync_init()
 962:main.c        **** #define VplusH_fromVsync()		VplusH_init()
 963:main.c        **** #define Vsync_fromVplusH()		Vsync_init()
 964:main.c        **** #define Nada_fromVsync()		Nada_init()
 965:main.c        **** #define Hsync_fromNada()		Hsync_init()
 966:main.c        **** #define Nada_fromHsync()		Nada_init()
 967:main.c        **** #define DEonly_fromNada()		DEonly_init()
 968:main.c        **** #define DEblue_fromDEonly()	DEblue_init()
 969:main.c        **** #define Nada_fromDEonly()		Nada_init()
 970:main.c        **** #define Nada_fromDEblue()		Nada_init()
 971:main.c        **** 
 972:main.c        **** 
 973:main.c        **** #else	//NOT FULL_INIT_TESTS
 974:main.c        **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 975:main.c        **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 976:main.c        **** 																	 //for easy-scoping
 977:main.c        **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 978:main.c        **** #define VplusH_fromVsync() { OCR1A=0; }
 979:main.c        **** //#define Vsync_fromVplusH() { OCR1A=4; }
 980:main.c        **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 40


 981:main.c        **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 982:main.c        **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 983:main.c        **** #define Hsync_fromNada()   { OCR1A=3; }
 984:main.c        **** #define Nada_fromHsync()   { OCR1A=4; }
 985:main.c        **** 
 986:main.c        **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 987:main.c        **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 988:main.c        **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 989:main.c        **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 990:main.c        **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 991:main.c        **** 
 992:main.c        **** /*
 993:main.c        **** #if (!defined(DE_BLUE) || !DE_BLUE)
 994:main.c        ****  //Nada -> DE
 995:main.c        ****  //#define DE_fromNada()      { DT1=(1<<4); }	//DT1 = (1<<4);
 996:main.c        ****  #define DE_fromNada()      { DT1=(2<<4); }
 997:main.c        ****  //DE -> Nada
 998:main.c        ****  //#define Nada_fromDE()      { DT1=(2<<4); }	//DT1 = (2<<4);
 999:main.c        ****  #define Nada_fromDE()      { DT1=(3<<4); }
1000:main.c        **** #else
1001:main.c        ****  //Nada -> DE
1002:main.c        ****  //#define DE_fromNada()      { OCR1A=0xff; }   //DT1 = (1<<4);
1003:main.c        ****  #define DE_fromNada()      { OCR1A=0xff; }
1004:main.c        ****  //DE -> Nada
1005:main.c        ****  //#define Nada_fromDE()      { OCR1A=3; }   //DT1 = (2<<4);
1006:main.c        ****  #define Nada_fromDE()      { OCR1A=4; }
1007:main.c        **** #endif
1008:main.c        **** */
1009:main.c        **** #endif //End Of FULL_INIT_TESTS
1010:main.c        **** 
1011:main.c        **** 
1012:main.c        **** 
1013:main.c        **** // NOTES:
1014:main.c        **** //    DeadTimer requires
1015:main.c        **** //        COM1x1:0 = 01 ("Complementary Compare Output Mode" ?)
1016:main.c        **** //      Complementary Compare Output Mode:
1017:main.c        **** //        OCW1A: cleared on match, set at BOTTOM
1018:main.c        **** //    If PWM1X (pwm inversion) is used, OC1A = !OCW1A
1019:main.c        **** //        (Does not affect DT)
1020:main.c        **** //
1021:main.c        **** // CLOCK:
1022:main.c        **** //    Can NOT use differential mode with:
1023:main.c        **** //		 OC1B pin is -differential input (through a resistor)
1024:main.c        **** //    /OC1B pin is +differential input (through a resistor)
1025:main.c        **** //    BECAUSE: DeadTimer affects ALL PWM channels
1026:main.c        **** //
1027:main.c        **** 
1028:main.c        **** //
1029:main.c        **** //
1030:main.c        **** // ISSUES:
1031:main.c        **** //    Using Dead-Timer does not allow for use of complementary outputs
1032:main.c        **** //      as complementary LVDS inputs... 
1033:main.c        **** //      DeadTimer affects ALL PWM channels in complementary mode
1034:main.c        **** //    (e.g. RXclkin+ on OC1B and RXclkin- on /OC1B is not an option)
1035:main.c        **** //
1036:main.c        **** 
1037:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 41


1038:main.c        **** // The typical patterns look like this (not at all to scale):
1039:main.c        **** //   ----______------------------------------------------___----- V
1040:main.c        **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
1041:main.c        **** //      __________-__-__-__-__-__-__-__-__-__-  DE
1042:main.c        **** //                 
1043:main.c        **** //             ^^^^\														//blah
1044:main.c        **** //             1234 5?
1045:main.c        **** // Pixels are sent during DE High (basically all the CPU will be used here)
1046:main.c        **** //Ideally, 
1047:main.c        **** //  there won't be any glitches when changing from one state to another
1048:main.c        **** //
1049:main.c        **** //  NOTES: PWM1X inversion affects all PWM channels!
1050:main.c        **** //
1051:main.c        **** //  Unchangeables:
1052:main.c        **** //    FastPWM
1053:main.c        **** //		inverted with PWM1X
1054:main.c        **** //
1055:main.c        **** //  Init (pre 1):
1056:main.c        **** //    DeadTimerRising=1
1057:main.c        **** //
1058:main.c        **** //  The states are:
1059:main.c        **** //   (Not necessarily accurate, just looking into necessary changes)
1060:main.c        **** //   (from Vsync L->H)
1061:main.c        **** //
1062:main.c        **** //   1  NothingActive (long, No DE, VporchFrontTimes)
1063:main.c        **** //      *  1<=DeadTimerRising<=5
1064:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1065:main.c        **** //      *  OCR1A == 6
1066:main.c        **** //
1067:main.c        **** //   2  Hsync
1068:main.c        **** //      *  DeadTimer _OFF_ -> Horiz
1069:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1070:main.c        **** //        (OCR1A == 6
1071:main.c        **** //   3  NothingActive (short)
1072:main.c        **** //      *  1<=DeadTimerRising<=5
1073:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1074:main.c        **** //        (OCR1A == 6
1075:main.c        **** //   4  DE
1076:main.c        **** //        (1<=DeadTimerRising<(=?)5 (>1 for blue pixels?) 
1077:main.c        **** //            (==5 cancelled by OCR1A match?)
1078:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1079:main.c        **** //      *  OCR1A = 5 (or 1<=OCR1A<5 for blue pixels?)
1080:main.c        **** //   5  NothingActive(?)
1081:main.c        **** //        (1<=DeadTimerRising<=5
1082:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1083:main.c        **** //      *  OCR1A == 6
1084:main.c        **** //
1085:main.c        **** //   7  Repeat 2-5 for each row
1086:main.c        **** //
1087:main.c        **** //   8  NothingActive (long, No DE, VporchBackTimes)
1088:main.c        **** //      ?  1<=DeadTimerRising<=5
1089:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1090:main.c        **** //        (OCR1A == 6
1091:main.c        **** //
1092:main.c        **** //   9  V w/o H
1093:main.c        **** //      ?  OFF <= DeadTimer <= (5 - OCR1A)
1094:main.c        **** //     **  OCW1A: cleared at BOTTOM, set at OCR1A
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 42


1095:main.c        **** //            ??? What is the effect of changing this while running?
1096:main.c        **** //      *  1 <= OCR1A <= 5
1097:main.c        **** //   10 V w/  H
1098:main.c        **** //      ?   DeadTimer OFF (H -> Low)
1099:main.c        **** //      *   OCW1A: set @ BOTTOM, cleared @ OCR1A
1100:main.c        **** //      *   OCR1A > (=?) OCR1C
1101:main.c        **** //
1102:main.c        **** //   11 Repeat 9-10 for Vsync time...
1103:main.c        **** //
1104:main.c        **** 
1105:main.c        **** // Here's how it worked pre-lvds:
1106:main.c        **** // HSYNC, VSYNC, and DE refer to the actual pins
1107:main.c        **** // In the LVDS setup, there're modes corresponding to each pin-combination
1108:main.c        **** //
1109:main.c        **** // Timer Interrupt:
1110:main.c        **** //  loadData:
1111:main.c        **** //   HSYNC active
1112:main.c        **** //   HSYNC Low delay
1113:main.c        **** //   HSYNC inactive
1114:main.c        **** //   if(dataEnable)
1115:main.c        **** //    DE active
1116:main.c        **** //     Send row data
1117:main.c        **** //    DE inactive
1118:main.c        **** //  //Prep for next interrupt
1119:main.c        **** //  switch(hsyncCount++)
1120:main.c        **** //    //Vsync H->L (active)
1121:main.c        **** //    1:
1122:main.c        **** //          dataEnable=FALSE
1123:main.c        **** //          VSYNC active
1124:main.c        **** //    //Vsync L->H (inactive)
1125:main.c        **** //    T_Vlow:
1126:main.c        **** //          VSYNC inactive
1127:main.c        **** //    //Start of frame
1128:main.c        **** //    T_VD +(T_Vlow):
1129:main.c        **** //          dataEnable=TRUE
1130:main.c        **** //    //All rows have been displayed
1131:main.c        **** //    V_COUNT +(T_VD+T_Vlow):
1132:main.c        **** //          dataEnable=FALSE
1133:main.c        **** //    //Frame Complete
1134:main.c        **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
1135:main.c        **** //          hsyncCount=0
1136:main.c        **** //  if(dataEnable)
1137:main.c        **** //    Use the remaining time to load the next row to memory
1138:main.c        **** 
1139:main.c        **** //  So:
1140:main.c        **** //Interrupt0       End
1141:main.c        **** //    |             |  Interrupt1
1142:main.c        **** //    v             v  v
1143:main.c        **** //  H |_||_||_|
1144:main.c        **** // DE ___________________________________________________ ...
1145:main.c        **** //  V |_____________________________________ ...
1146:main.c        **** //       |        ||
1147:main.c        **** // DETIME^--------^|
1148:main.c        **** //                 |
1149:main.c        **** //                 VSYNC active
1150:main.c        **** //                 dataEnable=FALSE (not necessary?)
1151:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 43


1152:main.c        **** //InterruptT_Vlow   End
1153:main.c        **** //    |             |
1154:main.c        **** //    v             v
1155:main.c        **** //  H |_||_||_|
1156:main.c        **** // DE ___________________________________________________ ...
1157:main.c        **** //  V _____________| ...
1158:main.c        **** //       |        ||
1159:main.c        **** // DETIME^--------^|
1160:main.c        **** //                 |
1161:main.c        **** //                 VSYNC inactive
1162:main.c        **** //
1163:main.c        **** //
1164:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1165:main.c        **** //    |             |  |            End
1166:main.c        **** //    v             v  v            v
1167:main.c        **** //  H |_||_||_|
1168:main.c        **** // DE ____________________||_______||____ ...
1169:main.c        **** //  V 
1170:main.c        **** //       |        ||      |        |
1171:main.c        **** // DETIME^--------^|      ^--------^
1172:main.c        **** //                 |
1173:main.c        **** //                 dataEnable=TRUE
1174:main.c        **** //
1175:main.c        **** //InterruptV_COUNT  End
1176:main.c        **** //    |             |
1177:main.c        **** //    v             v
1178:main.c        **** //  H |_||_||_|
1179:main.c        **** // DE ___||______________________________________ ...
1180:main.c        **** //  V 
1181:main.c        **** //       |        ||      |        |
1182:main.c        **** // DETIME^--------^|      ^--------^
1183:main.c        **** //                 |
1184:main.c        **** //                 dataEnable=FALSE
1185:main.c        **** //
1186:main.c        **** //
1187:main.c        **** // This isn't really a state, it's basically just:
1188:main.c        **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
1189:main.c        **** //    hsyncCount = 0;
1190:main.c        **** //                    .....................................
1191:main.c        **** //                    .                                   .
1192:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1193:main.c        **** //    |             | .|                                  .
1194:main.c        **** //    v             v .v                                  .
1195:main.c        **** //  H |_||_||_|
1196:main.c        **** // DE ___________________________________________________ .
1197:main.c        **** //  V |____________________ .
1198:main.c        **** //       |        ||  .   |        |                      .
1199:main.c        **** // DETIME^--------^|  .   ^--------^                      .
1200:main.c        **** //                 |  .                                   .
1201:main.c        **** //                 hsyncCount=0 (repeat from Interrupt0)  .
1202:main.c        **** //                    .                                   .
1203:main.c        **** //                    .....................................
1204:main.c        **** //
1205:main.c        **** 
1206:main.c        **** 
1207:main.c        **** // NOW to compare with LVDS states:
1208:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 44


1209:main.c        **** //Interrupt0       End
1210:main.c        **** //    |             |  Interrupt1
1211:main.c        **** //    v             v  v
1212:main.c        **** //  H |_||_||_|
1213:main.c        **** // DE ___________________________________________________ ...
1214:main.c        **** //  V |_____________________________________ ...
1215:main.c        **** //    ^ ^          ^   ^ ^
1216:main.c        **** //    | |          |   | |
1217:main.c        **** //    | |          |   | +--- V w/o H  \ These two toggle until
1218:main.c        **** //    | |          |   +----- V w/ H   / next LCD state...
1219:main.c        **** //    | |          |
1220:main.c        **** //    | |          +--------- V w/o H > Intermediate change of state
1221:main.c        **** //    | |
1222:main.c        **** //    | +----- NothingActive  \ From Previous State (?)
1223:main.c        **** //    +------- H_Only         /
1224:main.c        **** 
1225:main.c        **** 
1226:main.c        **** //InterruptT_Vlow   End
1227:main.c        **** //    |             |
1228:main.c        **** //    v             v
1229:main.c        **** //  H |_||_||_|
1230:main.c        **** // DE ___________________________________________________ ...
1231:main.c        **** //  V _____________| ...
1232:main.c        **** //    ^ ^          ^   ^ ^
1233:main.c        **** //    | |          |   | |
1234:main.c        **** //    | |          |   | +--- NothingActive  \ These two toggle until
1235:main.c        **** //    | |          |   +----- H_Only         / next LCD state...
1236:main.c        **** //    | |          |
1237:main.c        **** //    | |          +--------- NothingActive > Intermediate change of state
1238:main.c        **** //    | |
1239:main.c        **** //    | +----- V w/o H   \ From previous state
1240:main.c        **** //    +------- V w/ H    /
1241:main.c        **** 
1242:main.c        **** 
1243:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1244:main.c        **** //    |             |  |            End
1245:main.c        **** //    v             v  v            v
1246:main.c        **** //  H |_||_||_|
1247:main.c        **** // DE ____________________||_______||____ ...
1248:main.c        **** //  V 
1249:main.c        **** //    ^ ^              ^ ^^        ^ 
1250:main.c        **** //    | |              | ||        |
1251:main.c        **** //    | |              | ||        +--- NothingActive  \  These four
1252:main.c        **** //    | |              | |+------------ DE              | cycle until
1253:main.c        **** //    | |              | +------------- NothingActive   | next LCD state...
1254:main.c        **** //    | |              +--------------- H_Only  ^      /
1255:main.c        **** //    | |                                       |
1256:main.c        **** //    | +----- NothingActive  \ From previous   |
1257:main.c        **** //    +------- H_Only         / state           +-This intermediate state
1258:main.c        **** //                                                may not be necessary
1259:main.c        **** //                                                (IAXG01 shows 160 dots!)
1260:main.c        **** 
1261:main.c        **** 
1262:main.c        **** 
1263:main.c        **** //InterruptV_COUNT  End
1264:main.c        **** //    |             |
1265:main.c        **** //    v             v
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 45


1266:main.c        **** //  H |_||_||_|
1267:main.c        **** // DE ___||______________________________________ ...
1268:main.c        **** //  V 
1269:main.c        **** //    ^ ^^        ^    ^ ^
1270:main.c        **** //    | ||        |    | |
1271:main.c        **** //    | ||        |    | +--- NothingActive \  These two toggle
1272:main.c        **** //    | ||        |    +----- H_Only        /  until next LCD state
1273:main.c        **** //    | ||        |
1274:main.c        **** //    | ||        +---- NothingActive \ 								//blah
1275:main.c        **** //    | |+------------- DE             |  From previous state
1276:main.c        **** //    | +-------------- NothingActive  |
1277:main.c        **** //    +---------------- H_Only        /
1278:main.c        **** 
1279:main.c        **** // This isn't really a state, it's essentially just:
1280:main.c        **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
1281:main.c        **** //    hsyncCount = 0;
1282:main.c        **** //                    .....................................
1283:main.c        **** //                    .                                   .
1284:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1285:main.c        **** //    |             | .|                                  .
1286:main.c        **** //    v             v .v                                  .
1287:main.c        **** //  H |_||_||_|
1288:main.c        **** // DE ___________________________________________________ .
1289:main.c        **** //  V |____________________ .
1290:main.c        **** //    ^ ^             .                                   .
1291:main.c        **** //    | |             .....................................
1292:main.c        **** //    | +--- NothingActive \											//blah
1293:main.c        **** //    +----- H_Only        / From previous state...
1294:main.c        **** 
1295:main.c        **** 
1296:main.c        **** 
1297:main.c        **** //  LVDS State transitions:
1298:main.c        **** //   1 H_Only
1299:main.c        **** //   2 NothingActive
1300:main.c        **** //
1301:main.c        **** //   3 V w/o H
1302:main.c        **** //   4 V w/ H
1303:main.c        **** //    
1304:main.c        **** //   (repeat 3,4)
1305:main.c        **** //
1306:main.c        **** //   5 V w/o H
1307:main.c        **** //
1308:main.c        **** //   6 NothingActive
1309:main.c        **** //   7 H_Only
1310:main.c        **** //
1311:main.c        **** //   (repeat 6,7)
1312:main.c        **** //
1313:main.c        **** //   8 NothingActive
1314:main.c        **** //
1315:main.c        **** //   9 H_Only
1316:main.c        **** //  10 NothingActive
1317:main.c        **** //  11 DE
1318:main.c        **** //  12 NothingActive
1319:main.c        **** //
1320:main.c        **** //  (repeat 9-12)
1321:main.c        **** //
1322:main.c        **** //  13 H_Only
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 46


1323:main.c        **** //  14 NothingActive
1324:main.c        **** //
1325:main.c        **** //  (repeat 13-14)
1326:main.c        **** //
1327:main.c        **** //   These should be reviewed to determine which changes are necessary
1328:main.c        **** //   between each state...
1329:main.c        **** //   (the fewer changes, the less likely we'll glitch...?)
1330:main.c        **** 
1331:main.c        **** 
1332:main.c        **** // This'll probably be better rearranged...
1333:main.c        **** //  For now, though, OC1A is in all the notes above, for the D/V/H signal
1334:main.c        **** //  so OC1B is for the clock...
1335:main.c        **** // CHANGING THESE does NOT change channel association.
1336:main.c        **** #define DVH_OCR	OCR1A
1337:main.c        **** #define CLOCK_OCR	OCR1B
1338:main.c        **** 
1339:main.c        **** 
1340:main.c        **** void pll_enable(void)
1341:main.c        **** {
1342:main.c        **** 	//Stolen from threePinIDer109t:
1343:main.c        **** 
1344:main.c        ****    //Set Timer1 to use the "asynchronous clock source" (PLL at 64MHz)
1345:main.c        ****    // With phase-correct PWM (256 steps up, then back down) and CLKDIV1
1346:main.c        ****    // this is 64MHz/512=125kHz
1347:main.c        ****    // The benefit of such high PWM frequency is the low RC values necessary
1348:main.c        ****    //  for filtering to DC.
1349:main.c        ****    // "To change Timer/Counter1 to the async mode follow this procedure"
1350:main.c        ****    // 1: Enable the PLL
1351:main.c        ****    setbit(PLLE, PLLCSR);
1352:main.c        ****    // 2: Wait 100us for the PLL to stabilize
1353:main.c        ****    // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
1354:main.c        ****    _delay_us(100);
1355:main.c        **** //   dmsWait(1);
1356:main.c        ****    // 3: Poll PLOCK until it is set...
1357:main.c        ****    while(!getbit(PLOCK, PLLCSR))
1358:main.c        ****    {
1359:main.c        ****       asm("nop");
1360:main.c        ****    }
1361:main.c        ****    // 4: Set the PCKE bit to enable async mode
1362:main.c        ****    setbit(PCKE, PLLCSR);
1363:main.c        **** 
1364:main.c        **** }
1365:main.c        **** 
1366:main.c        **** void lvds_timerInit(void)
1367:main.c        **** {
1368:main.c        ****    //Timer1 is used for LVDS (in PLL clocking mode)
1369:main.c        ****   
1370:main.c        ****   	//pll_enable();	
1371:main.c        ****    
1372:main.c        ****    //We want it to count 7 bits, 0-6 and reset at 7
1373:main.c        ****    OCR1C = 6;
1374:main.c        **** 
1375:main.c        **** 	//We want the clock to go low at TCNT=0 and high at TCNT=4
1376:main.c        **** 	CLOCK_OCR = 3; //2; //3;
1377:main.c        ****    
1378:main.c        **** 
1379:main.c        **** // My 'scope is only 20MHz, and I'd rather be able to use the digital mode
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 47


1380:main.c        **** // which is even slower...
1381:main.c        **** 
1382:main.c        **** 
1383:main.c        **** //Overridden when SLOW_EVERYTHING_TEST is true...
1384:main.c        **** //#define TOOFAST_TEST TRUE
1385:main.c        **** #warning "HERE AND BELOW, doesn't OSCCAL have special write requirements?"
1386:main.c        **** //OSCCAL = 0x00;
1387:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1388:main.c        **** //FOR TESTING. This should slow the clock...
1389:main.c        **** 	// Gives roughly 4MHz...
1390:main.c        **** 	OSCCAL = 0x00; //0x80; 
1391:main.c        **** 
1392:main.c        **** 	// This should divide the system clock by 256
1393:main.c        **** 	// does this affect the PLL? NO.
1394:main.c        **** 	// The PLL is clocked only by the RC Oscillator
1395:main.c        **** 	//   OSCCAL does affect it.
1396:main.c        **** 	// OPTIONS FOR SIMULATING FULL FUNCTIONALITY AT LOW SPEED:
1397:main.c        **** 	// Run PLL as normal
1398:main.c        **** 	//  Prescale Timer1 and DeadTimer equally
1399:main.c        **** 	//  Prescale System clock equally
1400:main.c        **** 	CLKPR = (1<<CLKPCE);
1401:main.c        **** 	CLKPR = (1<<CLKPS1) | (1<<CLKPS0);	//CLKDIV8
1402:main.c        **** 	//4MHz / 8 = .5Mhz...
1403:main.c        **** 	//PLL is 4MHz*8 = 32MHz
1404:main.c        **** 	// then TimerClockDivisor=8 gives 4MHz
1405:main.c        **** 	pll_enable();
1406:main.c        **** 	#define SLOW_LVDS_TEST TRUE
1407:main.c        **** #elif (defined(OSCCAL_VAL))
1408:main.c        ****    OSCCAL = OSCCAL_VAL;
1409:main.c        **** #endif
1410:main.c        **** 
1411:main.c        **** 
1412:main.c        **** 
1413:main.c        **** #if (defined(SLOW_LVDS_TEST) && SLOW_LVDS_TEST)
1414:main.c        **** 	//This case doesn't really make sense without SLOW_EVERYTHING...
1415:main.c        **** 	//8x prescaler for Timer1
1416:main.c        **** 	#define CSBITS (1<<CS12)
1417:main.c        **** 	//8x prescaler for the dead-timer
1418:main.c        **** 	#define DTPSBITS ((1<<DTPS11) | (1<<DTPS10))
1419:main.c        **** #elif (defined(LVDS_PRESCALER))
1420:main.c        **** 	//Timer1 on the Tiny861 uses a strange CLKDIV scheme...
1421:main.c        **** 	// (but it's nicer!)
1422:main.c        **** 	// The divisor is (1<<(csbits-1))
1423:main.c        **** 	// so a divisor of 1 = (1<<0) = (1<<(1-1)), (csbits = 0x1)
1424:main.c        **** 	// 256 = (1<<8) = (1<<(9-1)), (csbits = 0x9)
1425:main.c        **** 	// 512 = (1<<9) = (1<<(10-1)), (csbits = 0xA)
1426:main.c        **** 	// ...
1427:main.c        **** 	// (0x0 stops the timer)
1428:main.c        **** 	/*
1429:main.c        **** 		uint16_t divisor;
1430:main.c        **** 		uint8_t csbits = 0;
1431:main.c        **** 		for(divisor=CLKDIV; divisor != 0; divisor>>=1)
1432:main.c        **** 		   csbits++;
1433:main.c        **** 			writeMasked(csbits, 0x0f, TCCR1B);
1434:main.c        **** 	*/
1435:main.c        **** 
1436:main.c        **** //#if ((LVDS_PRESCALER != 64) && (LVDS_PRESCALER != 32) && \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 48


1437:main.c        **** //	  (LVDS_PRESCALER != 16) && 
1438:main.c        **** #if ((LVDS_PRESCALER != 8) && \
1439:main.c        **** 	  (LVDS_PRESCALER != 4)  && (LVDS_PRESCALER != 2) && \
1440:main.c        **** 	  (LVDS_PRESCALER != 1))
1441:main.c        **** #error "LVDS_PRESCALER must be a power of 2, from 1 to 8"
1442:main.c        **** #endif
1443:main.c        **** 
1444:main.c        **** 	//Figured this out in cTools/dePower.c...
1445:main.c        **** 	//64 is overkill here, since the deadTimer prescaler only goes to 8...
1446:main.c        **** #define divToCS(div) \
1447:main.c        **** 	( (div == 64) ? 7 : (div == 32) ? 6 : (div == 16) ? 5 : (div == 8) ? 4 \
1448:main.c        **** 	  : (div == 4) ? 3 : (div == 2) ? 2 : (div == 1) ? 1 : 0)
1449:main.c        **** 
1450:main.c        **** 
1451:main.c        **** 	//CSBITS (through PLL/8) (CS10 is bit 0)
1452:main.c        **** 	//CS12:10	CS12	CS11	CS10		PLL division
1453:main.c        **** 	//1			0		0		1			1
1454:main.c        **** 	//2			0		1		0			2
1455:main.c        **** 	//3			0		1		1			4
1456:main.c        **** 	//4			1		0		0			8
1457:main.c        **** 	#define CSBITS divToCS(LVDS_PRESCALER) //<<CS10 should be redundant
1458:main.c        **** 	//DTPSBITS (DTPS10 is bit 4)
1459:main.c        **** 	//DTPS11:10	DTPS11 DTPS10	PLL division
1460:main.c        **** 	//0			0		0			1
1461:main.c        **** 	//1			0		1			2
1462:main.c        **** 	//2			1		0			4
1463:main.c        **** 	//3			1		1			8
1464:main.c        **** 	#define DTPSBITS ((CSBITS-1)<<DTPS10)
1465:main.c        **** 
1466:main.c        **** 	//Whoops! Forgot this (a/o 42-som'n WTF1pix)
1467:main.c        **** 	// so, it's promising to get single-pixel control...
1468:main.c        **** 	//  the result was kinda ugly, though... scroll was quite slow
1469:main.c        **** 	// Further, it was only drawing a certain number of pixels...
1470:main.c        **** 	//  (horizontally... pre LVDS_PRESCALER affecting DOTS_TO_CYC)
1471:main.c        **** 	//  so accessing *all* pixels in a row would make it even slower...
1472:main.c        **** 	// Further, it didn't seem to be paying attention to the fact that
1473:main.c        **** 	// the same pixels are drawn on multiple rows...
1474:main.c        **** 	// WTF? (the image was scaled, proportionately! 1pix x 1pix)
1475:main.c        **** 	pll_enable();
1476:main.c        **** 
1477:main.c        **** #else
1478:main.c        **** 	//No clock divisor
1479:main.c        **** 	#define CSBITS (1<<CS10)
1480:main.c        **** 	//No dead-timer divisor
1481:main.c        **** 	#define DTPSBITS 0
1482:main.c        **** 	pll_enable();
1483:main.c        **** 	//#warning "The PLL configuration code is not in here yet!"
1484:main.c        **** #endif
1485:main.c        **** 
1486:main.c        **** 	//Set the Timer1 clock prescaler...
1487:main.c        **** 	writeMasked(CSBITS, 
1488:main.c        **** 					((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)),
1489:main.c        **** 					TCCR1B);
1490:main.c        **** 
1491:main.c        **** 	//Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
1492:main.c        **** 	// Allegedly this is prescaled from the PCK (or CK)
1493:main.c        **** 	// 	NOT from the Timer1 prescaler...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 49


1494:main.c        **** 	writeMasked(DTPSBITS,
1495:main.c        **** 					((1<<DTPS11) | (1<<DTPS10)),
1496:main.c        **** 					TCCR1B);
1497:main.c        **** 
1498:main.c        **** 
1499:main.c        **** 
1500:main.c        ****    //All LVDS modes (and signals) use FastPWM.. 
1501:main.c        ****  
1502:main.c        ****    //FastPWM
1503:main.c        **** //Now Handled in lvds_xxxOnCompare():
1504:main.c        **** 
1505:main.c        **** 	//These are also written below (excluding PWM1D)
1506:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
1507:main.c        ****                            //Need to do the same for other channels
1508:main.c        ****   
1509:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
1510:main.c        **** 
1511:main.c        **** 	setbit(PWM1D, TCCR1C);
1512:main.c        **** 
1513:main.c        **** 	//PWM1D is not in TCCR1A...
1514:main.c        **** 
1515:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
1516:main.c        **** //	setoutPORT(PB0, PORTB);	//-OC1A 	MOSI unused
1517:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
1518:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
1519:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
1520:main.c        **** 
1521:main.c        **** 
1522:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
1523:main.c        ****                ((1<<WGM11) | (1<<WGM10)), // (affects all PWM channels)
1524:main.c        ****                TCCR1D);
1525:main.c        **** 
1526:main.c        **** 	//OC1A is used, but /OC1A isn't
1527:main.c        **** // Not Valid (deadTime only functions if in complementary-mode):
1528:main.c        **** 	// OTOH: dead-time is not necessary in the only case we need to switch
1529:main.c        **** 	// Most lvds states use clear on compare-match, set at 0
1530:main.c        **** 	// But there is one that uses the opposite
1531:main.c        **** 	// This can be toggled by a single bit-change
1532:main.c        **** 	//  COM1A1 = 1
1533:main.c        **** 	//  COM1A0 value indicates what happens on Compare-Match
1534:main.c        **** 	//					  or ! at BOTTOM
1535:main.c        **** //#define lvds_clrOnCompare() clrbit(COM1A0, TCCR1A)
1536:main.c        **** //#define lvds_setOnCompare() setbit(COM1A0, TCCR1A)
1537:main.c        **** 	//HOWEVER: the alternative is possible:
1538:main.c        **** 	// Use complementary (clear-on-compare)
1539:main.c        **** 	// and single-ended with set-on-compare
1540:main.c        **** 	// COM1A0 = 1
1541:main.c        **** 	// COM1A1 value indicates what happens on Compare-Match
1542:main.c        **** 
1543:main.c        **** /* These are three instructions apiece!
1544:main.c        **** #define lvds_ComplementaryClrOnCompare() clrbit(COM1A1, TCCR1A)
1545:main.c        **** 
1546:main.c        **** #define lvds_setOnCompare() setbit(COM1A1, TCCR1A)
1547:main.c        **** #define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1548:main.c        **** */
1549:main.c        **** 
1550:main.c        **** //Page 99:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 50


1551:main.c        **** // "In Fast PWM Mode ... when the COM1x1:0 bits are set to 01 ...
1552:main.c        **** //  an user programmable Dead Time delay is inserted for 
1553:main.c        **** //  these complementary output pairs (OC1x and OC1x)."
1554:main.c        **** 
1555:main.c        **** //Page 98:
1556:main.c        **** // "The counter is loaded with a 4-bit DT1H or DT1L value from DT1 
1557:main.c        **** //  I/O register, depending on the edge of the Waveform 
1558:main.c        **** //  Output (OCW1x) when the dead time insertion is started."
1559:main.c        **** // In other words, (as it appears from the diagram)
1560:main.c        **** //  the dead-time value is loaded into the counter when the corresponding
1561:main.c        **** //  edge in OCW1x is detected
1562:main.c        **** //  So changing the value of DT1 affects the *next* corresponding edge 
1563:main.c        **** //   (NOT if the dead timer is already running)
1564:main.c        **** 
1565:main.c        **** //Page 96:
1566:main.c        **** // "The OCR1x Registers are double buffered when using any of the 
1567:main.c        **** // Pulse Width Modulation (PWM) modes."
1568:main.c        **** // "The double buffering synchronizes the update of the OCR1x 
1569:main.c        **** // Compare Registers to either top or bottom of the counting sequence.
1570:main.c        **** // The synchronization prevents the occurrence of odd-length, non-sym- 
1571:main.c        **** // metrical PWM pulses, thereby making the output glitch-free."
1572:main.c        **** 
1573:main.c        **** //Page 100:
1574:main.c        **** //"A change of the COM1x1:0 bits state will have effect 
1575:main.c        **** // at the first Compare Match after the bits are written."
1576:main.c        **** //Page 97: HAH!
1577:main.c        **** //"Be aware that the COM1x1:0 bits are not double buffered 
1578:main.c        **** // together with the compare value. 
1579:main.c        **** // Changing the COM1x1:0 bits will take effect immediately."
1580:main.c        **** 
1581:main.c        **** 
1582:main.c        **** //#define lvds_setOnCompare()	
1583:main.c        **** //	TCCR1A = ( (1<<COM1A1) | (1<<COM1A0) 
1584:main.c        **** //			   | (0<<COM1B1) | (1<<COM1B0) 
1585:main.c        **** //			   | (1<<PWM1A) | (1<<PWM1B) )
1586:main.c        **** //#define lvds_ComplementaryClrOnCompare() \ //
1587:main.c        **** 	//Do TCCR1C first, because it contains shadow-bits of TCCR1A that I
1588:main.c        **** 	// don't want to have to rewrite...
1589:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
1590:main.c        **** 				| (1<<PWM1D) );
1591:main.c        **** 
1592:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
1593:main.c        ****             | (1<<COM1B1) | (0<<COM1B0) //Don't use complementary for CLK
1594:main.c        ****             | (1<<PWM1A) | (1<<PWM1B) );
1595:main.c        **** 
1596:main.c        **** //#define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1597:main.c        **** 
1598:main.c        **** 	// Enable Complementary-Mode (and thus the dead-timer)
1599:main.c        **** 	// This'll be changed as needed, but we need COM1A0 set prior to that
1600:main.c        **** 
1601:main.c        **** 	//	lvds_clrOnCompare();
1602:main.c        **** //	writeMasked(((0<<COM1A1) | (1<<COM1A0)), 
1603:main.c        **** //					((1<<COM1A1) | (1<<COM1A0)), 
1604:main.c        **** //					TCCR1A);
1605:main.c        **** 
1606:main.c        **** 
1607:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 51


1608:main.c        **** 	//THIS IS NOT THOROUGHLY THOUGHT-OUT...
1609:main.c        **** 	// as I recall, we need to use /OC1B for the clock output
1610:main.c        **** 	//  because it won't be affected by the deadtime...
1611:main.c        **** //Now Handled in lvds_xxxOnCompare():
1612:main.c        **** //	writeMasked(((0<<COM1B1) | (1<<COM1B0)),
1613:main.c        **** //					((1<<COM1B1) | (1<<COM1B0)),
1614:main.c        **** //					TCCR1A);
1615:main.c        **** 
1616:main.c        ****    //Since PWM inversion affects all channels, great-pains were taken
1617:main.c        ****    // to assure that it needn't be changed in any lvds state...
1618:main.c        ****    // PWM inversion must be enabled:
1619:main.c        **** 
1620:main.c        **** 	//inverted with PWM1X
1621:main.c        **** //   setbit(PWM1X, TCCR1B);
1622:main.c        ****  
1623:main.c        ****  	Nada_init();
1624:main.c        **** }
1625:main.c        **** 
1626:main.c        **** 
1627:main.c        **** //PWM Timing:
1628:main.c        **** // (ATTiny861, Timer1, FastPWM, PWM1X;
1629:main.c        **** //  a/o LCDdirectLVDS1_5_PWMtimingTests):
1630:main.c        **** //
1631:main.c        **** //  PWM output on OC1A
1632:main.c        **** //    if OCR1A = 0, OC1A remains constant High
1633:main.c        **** //       OCR1A = 1, OC1A is low for 2 counts
1634:main.c        **** //       OCR1A = 2, OC1A is low for 3 counts
1635:main.c        **** //       OCR1A = 3, OC1A is low for 4 counts
1636:main.c        **** //       OCR1A = OCR1C, OC1A remains constant Low
1637:main.c        **** //
1638:main.c        **** //    THUS:
1639:main.c        **** //       compare-match occurs when TCNT changes AWAY from match
1640:main.c        **** //         (assuming TCNT starts at 0 for one pulse, 1 for one pulse...)
1641:main.c        **** //       TOP (OCR1C) is included in the count...
1642:main.c        **** //       There is no single-count pulse-width
1643:main.c        **** //         (Though, it seems dead-time could simulate it...)
1644:main.c        **** //         (set a deadtime of 1 on the BOTTOM edge and OCR1A)
1645:main.c        **** //         (but then there's no high for only one clock)
1646:main.c        **** 
1647:main.c        **** 
1648:main.c        **** 
1649:main.c        **** 
1650:main.c        **** //This isn't valid, who knows how many instructions the for loop takes
1651:main.c        **** static __inline__ \
1652:main.c        **** void delay_cyc(int32_t numCyc) \
1653:main.c        **** 	  __attribute__((__always_inline__));
1654:main.c        **** 
1655:main.c        **** //This'll optimze-out in some cases.
1656:main.c        **** // The timings and instructions used are probably specific to the
1657:main.c        **** // instruction-set in the MCU, the GCC version, optimization-level, etc.
1658:main.c        **** // a/o LCDdirectLVDS11 HLow_delay() this is how it's compiling...
1659:main.c        **** 
1660:main.c        **** // The actual number of cycs will probably be a few higher...
1661:main.c        **** // (or who knows, if things optimze-out, e.g. small ~0-8 numCycs)
1662:main.c        **** // Due to init, and division...
1663:main.c        **** // Using rounding-up as well...
1664:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 52


1665:main.c        **** // the argument is int32_t to allow for negative value testing
1666:main.c        **** // BUT: numCyc is only tested against a uint16_t...
1667:main.c        **** //  the greatest value (?) is (UINT16_MAX - 7)
1668:main.c        **** // (maybe it'd make more sense to do the math outside the delay_cyc call
1669:main.c        **** // and allow the preprocessor to change it to 0, instead of doing it here.
1670:main.c        **** 
1671:main.c        **** //This should probably be reimplemented using _delay_loop_1/2() from 
1672:main.c        **** // util/delay_basic.h
1673:main.c        **** //  1 uses three cycles per count, counts from 1-256, 
1674:main.c        **** //		256 counts: _delay_loop_1(0)
1675:main.c        **** //  2 uses four, counts from 1-65536, 65536 is passed as 0
1676:main.c        **** 
1677:main.c        **** #define DELAY_CYC_DELAY_LOOP TRUE//FALSE
1678:main.c        **** 
1679:main.c        **** #if(defined(DELAY_CYC_DELAY_LOOP) && DELAY_CYC_DELAY_LOOP)
1680:main.c        **** #warning "This has only been tested with v54+... rowSegBuffer, etc."
1681:main.c        **** void delay_cyc(int32_t numCyc)
1682:main.c        **** {
1683:main.c        **** 	if(numCyc <= 0)
1684:main.c        **** 		return;
1685:main.c        **** 
1686:main.c        **** 	uint16_t numLoops = (numCyc+3)/4;
1687:main.c        **** 
1688:main.c        **** 	_delay_loop_2(numLoops);
1689:main.c        **** 
1690:main.c        **** /*	uint32_t delayLoops = (numCyc+3)/4;
1691:main.c        **** 
1692:main.c        **** 	do
1693:main.c        **** 	{
1694:main.c        **** 		delayLoops--;
1695:main.c        **** //		_delay_loop_2(delayLoops&0xffff);
1696:main.c        **** 
1697:main.c        **** //		delayLoops -= (delayLoops&0xffff);
1698:main.c        **** 	} while(delayLoops);
1699:main.c        **** */
1700:main.c        **** /*
1701:main.c        **** 	//Since this is inline, AND it's only called with values computed
1702:main.c        **** 	// at compile time, only one of these should be compiled in...
1703:main.c        **** 	// as necessary...
1704:main.c        **** 	// If called without precomputed value (i.e. a variable)????
1705:main.c        **** 	// Maybe I should only use delay_loop_2...
1706:main.c        **** 	if(numCyc < 256*3)
1707:main.c        **** 		_delay_loop_1(numCyc/&0xff);
1708:main.c        **** 
1709:main.c        **** 	else
1710:main.c        **** */
1711:main.c        **** }
1712:main.c        **** 
1713:main.c        **** #else
1714:main.c        **** void delay_cyc(int32_t numCyc)
1715:main.c        **** {
1716:main.c        **** 
1717:main.c        **** 	//This shouldn't happen often, but some delay_cyc() calls use math
1718:main.c        **** 	// to calculate the number of cycles, and it could be negative
1719:main.c        **** 	if(numCyc < 0)
1720:main.c        **** 		return;
1721:main.c        **** 											//#Clocks
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 53


1722:main.c        **** 	//Two instructions:
1723:main.c        **** 	// ldi r24, 0						//1 			i=0
1724:main.c        **** 	// ldi r25, 0						//1
1725:main.c        **** 	uint16_t i;
1726:main.c        **** 
1727:main.c        **** 
1728:main.c        **** 	//Loop instructions:
1729:main.c        **** 	//nop									//1
1730:main.c        **** 	//adiw  r24, 0x01   ; 1			//2 			i++
1731:main.c        **** 	//cpi   r24, 0x77   ; 119		//1 			i<numCyc (119 in this case)
1732:main.c        **** 	//cpc   r25, r1					//1 			Apparently it's also testing
1733:main.c        **** 											//  			the high byte is 0
1734:main.c        **** 	//brne  .-10        ;			//"1/2"		return to nop
1735:main.c        **** 											//				if I understand, this is two
1736:main.c        **** 											//				cyc when branching
1737:main.c        **** 											//				or one if not (when complete)
1738:main.c        **** 
1739:main.c        **** 	//READ THIS:
1740:main.c        **** 	// Current Compilation Settings: A/O v18:
1741:main.c        **** 	//    THIS LOOP WILL BE UNROLLED if numLoops <= 5!!!
1742:main.c        **** 	//    Which then turns into numLoops*2 cycles (instead of numLoops*8)
1743:main.c        **** 	// 
1744:main.c        **** 	// Here's an attempted hack...
1745:main.c        **** 	//  it *should* optimize the test out in either case, so it's like a 
1746:main.c        **** 	//  preprocessing directive...
1747:main.c        **** 	uint16_t numLoops = (((uint16_t)(numCyc)+7)>>3);
1748:main.c        **** 
1749:main.c        **** 
1750:main.c        **** 	// HACK ATTEMPT 2: THATS A LOT OF CODE.
1751:main.c        **** 		switch(numLoops)
1752:main.c        **** 		{
1753:main.c        **** 			case 5:
1754:main.c        **** 				asm("nop");
1755:main.c        **** 				asm("nop");
1756:main.c        **** 				asm("nop");
1757:main.c        **** 				asm("nop");
1758:main.c        **** 				asm("nop");
1759:main.c        **** 				asm("nop");
1760:main.c        **** 				asm("nop");
1761:main.c        **** 				asm("nop");
1762:main.c        **** 			case 4:
1763:main.c        **** 				asm("nop");
1764:main.c        **** 				asm("nop");
1765:main.c        **** 				asm("nop");
1766:main.c        **** 				asm("nop");
1767:main.c        **** 				asm("nop");
1768:main.c        **** 				asm("nop");
1769:main.c        **** 				asm("nop");
1770:main.c        **** 				asm("nop");
1771:main.c        **** 			case 3:
1772:main.c        **** 				asm("nop");
1773:main.c        **** 				asm("nop");
1774:main.c        **** 				asm("nop");
1775:main.c        **** 				asm("nop");
1776:main.c        **** 				asm("nop");
1777:main.c        **** 				asm("nop");
1778:main.c        **** 				asm("nop");
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 54


1779:main.c        **** 				asm("nop");
1780:main.c        **** 			case 2:
1781:main.c        **** 				asm("nop");
1782:main.c        **** 				asm("nop");
1783:main.c        **** 				asm("nop");
1784:main.c        **** 				asm("nop");
1785:main.c        **** 				asm("nop");
1786:main.c        **** 				asm("nop");
1787:main.c        **** 				asm("nop");
1788:main.c        **** 				asm("nop");
1789:main.c        **** 			case 1:
1790:main.c        **** 				asm("nop");
1791:main.c        **** 				asm("nop");
1792:main.c        **** 				asm("nop");
1793:main.c        **** 				asm("nop");
1794:main.c        **** 				asm("nop");
1795:main.c        **** 				asm("nop");
1796:main.c        **** 				asm("nop");
1797:main.c        **** 				asm("nop");
1798:main.c        **** 				return;
1799:main.c        **** 				break;
1800:main.c        **** 			default:
1801:main.c        **** 				break;
1802:main.c        **** 		}
1803:main.c        **** 	// THUS:
1804:main.c        **** 	// Each loop is 7 cycles, make it 8 by adding an extra nop and we can
1805:main.c        **** 	// use >> instead of / for calculations...
1806:main.c        **** 	// +7 assures rounding-up...
1807:main.c        **** #warning "This loop seems to be optimizing out!"
1808:main.c        **** 	//for(i=0; i<((numCyc+7)>>3); i++)
1809:main.c        **** 	for(i=0; i<numLoops; i++)
1810:main.c        **** 	{
1811:main.c        **** 		//THIS IS A HACK DUE TO OPTIMIZATION, see above
1812:main.c        **** 		// It will NOT likely be happy with different versions of gcc...
1813:main.c        **** 	/*	// NOGO: Apparently it won't expand the loop if this is part of it
1814:main.c        **** 		// so then we have 5 loops AND 8 instructions /within/ the loop
1815:main.c        **** 		// AND the comparison overhead!`
1816:main.c        **** 		if(numLoops <= 5)
1817:main.c        **** 		{
1818:main.c        **** 		   asm("nop");
1819:main.c        **** 			asm("nop");
1820:main.c        **** 		//	asm("nop");
1821:main.c        **** 		//	asm("nop");
1822:main.c        **** 		//	asm("nop");
1823:main.c        **** 		//	asm("nop");
1824:main.c        **** 		}
1825:main.c        **** 		else
1826:main.c        **** 		{
1827:main.c        **** 			asm("nop");
1828:main.c        **** 			asm("nop");
1829:main.c        **** 		}
1830:main.c        **** 	*/
1831:main.c        **** 		//Apparently this loop will optimize-out without this:
1832:main.c        **** 		// Obviously, one instruction each...
1833:main.c        **** 		asm("nop");
1834:main.c        **** 		asm("nop");
1835:main.c        **** 	}
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 55


1836:main.c        **** }
1837:main.c        **** #endif
1838:main.c        **** 
1839:main.c        **** //One dot-clock is 7/8ths of a CPU cycle... (prescaler = 1)
1840:main.c        **** //                 14/8ths with prescaler = 2 ...
1841:main.c        **** //
1842:main.c        **** //    1 dot = 7/8 cyc
1843:main.c        **** //    n dots = n * 7/8 cyc
1844:main.c        **** //
1845:main.c        **** //    1 = 1 dot / (7/8) cyc
1846:main.c        **** //    1 = 8 dots / 7 cyc
1847:main.c        **** //
1848:main.c        **** //  With prescaling = 2:
1849:main.c        **** //
1850:main.c        **** //    1 dot = 7/8 * 2 cyc = 14/8 cyc
1851:main.c        **** //   
1852:main.c        **** //    8/14 dots = 1 cyc
1853:main.c        **** //    n dots = n*14/8 cyc
1854:main.c        **** //   
1855:main.c        **** //    I coulda sworn the prescaler was on the divide-side...
1856:main.c        **** //   Also, is there any benefit to adding +7*LVDS_PRESCALER-1 for rounding?
1857:main.c        **** #define DOTS_TO_CYC(dots) ((((dots)*(7l)*(LVDS_PRESCALER))/8))
1858:main.c        **** 
1859:main.c        **** #define delay_Dots(numDots) delay_cyc(DOTS_TO_CYC(numDots))
1860:main.c        **** 
1861:main.c        **** 
1862:main.c        **** //THESE NOTES ARE OLD:
1863:main.c        **** //This has to be changed every time the DE code is changed...
1864:main.c        **** // Actually, I think it should just match IMAGE_WIDTH
1865:main.c        **** //#define FB_WIDTH 28 //21//19
1866:main.c        **** //#define IMAGE_WIDTH 21
1867:main.c        **** 
1868:main.c        **** 
1869:main.c        **** #define TESTVALS	0
1870:main.c        **** #define LTN 1
1871:main.c        **** #define IDT 2
1872:main.c        **** 
1873:main.c        **** 
1874:main.c        **** //TIMING:
1875:main.c        **** //  Measurements below (in microseconds) are referring to preLVDS
1876:main.c        **** //  There may be other such old-notes...
1877:main.c        **** 
1878:main.c        **** 
1879:main.c        **** //        |<--T_Hhigh-->| |<-T_Hlow
1880:main.c        **** //    __   _____________   ____________  3.6V
1881:main.c        **** // H    |_|             |_|           _  0V
1882:main.c        **** //
1883:main.c        **** //    Data Enable
1884:main.c        **** //       Only active when there's valid pixel data
1885:main.c        **** //       (for 512 of the 717 clocks in HSYNC-active)
1886:main.c        **** //       Low during Vsync... (~720us)
1887:main.c        **** //
1888:main.c        **** 
1889:main.c        **** //IDTech display: 136 dots
1890:main.c        **** //2-136+
1891:main.c        **** //IDTech, last used: 40
1892:main.c        **** //LTN Last used 8
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 56


1893:main.c        **** // LTN: 1072-1344-1500 clocks per line, 1024DE... Hsync unused
1894:main.c        **** // SEE Hlow_Delay() notes if this value is large!
1895:main.c        **** 
1896:main.c        **** #if (DISPLAY == LTN)
1897:main.c        **** #define H_LOW_DOTS	8
1898:main.c        **** #elif (DISPLAY == IDT)
1899:main.c        **** #define H_LOW_DOTS   40//8//1//40 //30 //2//136
1900:main.c        **** #elif (DISPLAY == TESTVALS)
1901:main.c        **** #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
1902:main.c        **** 							  // And having a value here increases codesize
1903:main.c        **** #endif
1904:main.c        **** 
1905:main.c        **** 
1906:main.c        **** //H is set low immediately upon entry of the timer interrupt
1907:main.c        **** // its low-time is controlled via nops
1908:main.c        **** // (so if HLow is long for a particular display, this might need revising)
1909:main.c        **** #define Hlow_Delay() \
1910:main.c        **** 	delay_Dots(H_LOW_DOTS)
1911:main.c        **** 
1912:main.c        **** 
1913:main.c        **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1914:main.c        **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
1915:main.c        **** 
1916:main.c        **** 
1917:main.c        **** 
1918:main.c        **** //This was found expermentally with SwitchResX
1919:main.c        **** //IDTech Last Used: 680
1920:main.c        **** //LTN last used 1024
1921:main.c        **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
1922:main.c        **** //        it does, however, affect the vertical(!)
1923:main.c        **** // If I recall Correctly, this is used only for setting the timer interrupt
1924:main.c        **** //  rate...
1925:main.c        **** #if (DISPLAY == LTN)
1926:main.c        **** #define DE_ACTIVE_DOTS	1024
1927:main.c        **** #elif (DISPLAY == IDT)
1928:main.c        **** #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
1929:main.c        **** #elif (DISPLAY == TESTVALS)
1930:main.c        **** #define DE_ACTIVE_DOTS	1024
1931:main.c        **** #endif
1932:main.c        **** 
1933:main.c        **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
1934:main.c        **** 
1935:main.c        **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
1936:main.c        **** //  90-320+
1937:main.c        **** //Horizontal Total Time: 1206-1344-2047
1938:main.c        **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
1939:main.c        **** // Excess waits should be thrown in DH (since that's between interrupts)
1940:main.c        **** //T_HD is the time from H inactivated to DE activated
1941:main.c        **** //aka H back-porch: 1-160+
1942:main.c        **** //IDTech Last Used: 50
1943:main.c        **** //LTN last used 5
1944:main.c        **** 
1945:main.c        **** #if (DISPLAY == LTN)
1946:main.c        **** #define HD_DOTS 5
1947:main.c        **** #elif (DISPLAY == IDT)
1948:main.c        **** #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
1949:main.c        **** #elif (DISPLAY == TESTVALS)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 57


1950:main.c        **** #define HD_DOTS 50//5
1951:main.c        **** #endif
1952:main.c        **** 
1953:main.c        **** #define HD_Delay()	delay_Dots(HD_DOTS)
1954:main.c        **** 
1955:main.c        **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1956:main.c        **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1957:main.c        **** 
1958:main.c        **** // This is the number of CPU cycles between DE->L and Horiz->L
1959:main.c        **** // This is just used in calculating the OCR value...
1960:main.c        **** // aka H Front Porch: 0-24+
1961:main.c        **** // IDTech Last Used: 24
1962:main.c        **** // LTN last used 46
1963:main.c        **** // 1072-1024-1-1 = 46
1964:main.c        **** #if (DISPLAY == LTN)
1965:main.c        **** #define DH_DOTS	46
1966:main.c        **** #elif (DISPLAY == IDT)
1967:main.c        **** #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
1968:main.c        **** #elif (DISPLAY == TESTVALS)
1969:main.c        **** #define DH_DOTS	0//1000//100//46
1970:main.c        **** #endif
1971:main.c        **** 
1972:main.c        **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1973:main.c        **** 
1974:main.c        **** //       |
1975:main.c        **** //       v
1976:main.c        **** //      T_DH
1977:main.c        **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
1978:main.c        **** // H   __.  ____________  .___________
1979:main.c        **** //      .|_|  .        .|_|  .
1980:main.c        **** //     _.     .________.     .___________
1981:main.c        **** // DE   |_____| 512clk |_____|
1982:main.c        **** //      ^              ^
1983:main.c        **** //       \___________   \                        (just avoiding \ warning)
1984:main.c        **** //                   \  |     768 Hsyncs
1985:main.c        **** //                    v v
1986:main.c        **** //     _             _ _ _ _ _ _ _ _ _ _ 
1987:main.c        **** // DE   |___________| | | | | | | | | | |______
1988:main.c        **** //
1989:main.c        **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1990:main.c        **** 
1991:main.c        **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1992:main.c        **** // IDTech Last Used: 29
1993:main.c        **** // LTN last used 3
1994:main.c        **** //LTN Frame: 772-806-1000 lines...
1995:main.c        **** #if (DISPLAY == LTN)
1996:main.c        **** #define T_VD 3
1997:main.c        **** #elif (DISPLAY == IDT)
1998:main.c        **** #define  T_VD 29 //3//29 //7 //29
1999:main.c        **** #elif (DISPLAY == TESTVALS)
2000:main.c        **** #define T_VD 3
2001:main.c        **** #endif
2002:main.c        **** 
2003:main.c        **** //aka V-sync front porch: 1-3+
2004:main.c        **** // IDTech Last Used: 3
2005:main.c        **** // LTN last used 3
2006:main.c        **** #if (DISPLAY == LTN)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 58


2007:main.c        **** #define T_DV 3
2008:main.c        **** #elif (DISPLAY == IDT)
2009:main.c        **** #define T_DV 3//3 //1 //3
2010:main.c        **** #elif (DISPLAY == TESTVALS)
2011:main.c        **** #define T_DV 3
2012:main.c        **** #endif
2013:main.c        **** 
2014:main.c        **** //1-6+ (1 is used by the first switch-case...)
2015:main.c        **** // IDTech Last Used: 6
2016:main.c        **** // LTN Last used 16
2017:main.c        **** // 772 - 768 - 1 - 1 = 2
2018:main.c        **** #if (DISPLAY == LTN)
2019:main.c        **** #define T_Vlow 16
2020:main.c        **** #elif (DISPLAY == IDT)
2021:main.c        **** #define T_Vlow	6 //16//6 //2 //6
2022:main.c        **** #elif (DISPLAY == TESTVALS)
2023:main.c        **** #define T_Vlow 32
2024:main.c        **** #endif
2025:main.c        **** 
2026:main.c        **** // IDTech Last Used: 768
2027:main.c        **** #if (DISPLAY == LTN)
2028:main.c        **** #define V_COUNT	768
2029:main.c        **** #elif (DISPLAY == IDT)
2030:main.c        **** #define V_COUNT	768
2031:main.c        **** #elif (DISPLAY == TESTVALS)
2032:main.c        ****  #if (LVDS_PRESCALER == 8)
2033:main.c        ****   #define V_COUNT 768
2034:main.c        ****  #else
2035:main.c        ****   #define V_COUNT	(768*2/3)
2036:main.c        ****  #endif
2037:main.c        **** #endif
2038:main.c        **** 
2039:main.c        **** //                       
2040:main.c        **** //                      |           
2041:main.c        **** //                      V           
2042:main.c        **** //              |<-T_DV>|           |<-T_VD-->|
2043:main.c        **** //              .       .           .         .
2044:main.c        **** //     _____________||__.   124us   .____||___________________
2045:main.c        **** //  V           .   ||  |___________|    ||   .
2046:main.c        **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
2047:main.c        **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
2048:main.c        **** //              .   ||                   ||   .
2049:main.c        **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
2050:main.c        **** // DE   | | | | |___||___________________||___| | | | | | | | |
2051:main.c        **** //                  ||                   ||
2052:main.c        **** //
2053:main.c        **** //                        1
2054:main.c        **** //                        |
2055:main.c        **** //                        v               
2056:main.c        **** //     _________________   ___________________   _____________
2057:main.c        **** //  V                   |_|                   |_|
2058:main.c        **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
2059:main.c        **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
2060:main.c        **** //                          ^
2061:main.c        **** //                          |
2062:main.c        **** //                          2
2063:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 59


2064:main.c        **** 
2065:main.c        **** 
2066:main.c        **** 
2067:main.c        **** static __inline__ \
2068:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
2069:main.c        **** 	  __attribute__((__always_inline__));
2070:main.c        **** 
2071:main.c        **** //volatile uint8_t rowBuffer[FB_WIDTH] =
2072:main.c        **** //There's not enough memory for a full frame-buffer...
2073:main.c        **** // but this is how LCDdirect worked, and changing it would be a pain.
2074:main.c        **** //uint8_t settingBuffer[FB_HEIGHT][FB_WIDTH]; 
2075:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
2076:main.c        **** uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH];
2077:main.c        **** #else
2078:main.c        **** uint8_t *pimage;
2079:main.c        **** #endif
2080:main.c        **** 
2081:main.c        **** /* in LCDStuff
2082:main.c        **** uint8_t dataEnable = 0;
2083:main.c        **** uint8_t vSync = 0;
2084:main.c        **** uint16_t hsyncCount = 0;
2085:main.c        **** */
2086:main.c        **** 
2087:main.c        **** /* in LCDStuff, along with the if, woot
2088:main.c        **** //frameCount=0 can be used in main to detect whether we've completed a 
2089:main.c        **** //  a frame AND its FRAME_UPDATE_DELAY
2090:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
2091:main.c        **** uint8_t frameCount = 0;
2092:main.c        **** #endif
2093:main.c        **** */
2094:main.c        **** 
2095:main.c        **** static __inline__ \
2096:main.c        **** void loadRow(uint16_t rowNum) \
2097:main.c        **** 	__attribute__((__always_inline__));
2098:main.c        **** 
2099:main.c        **** 
2100:main.c        **** #include _LCDSTUFF_CFILE_
2101:main.c        **** //#include "../../../_commonCode/lcdStuff/0.50ncf/lcdStuff.c"
2102:main.c        **** //#include "lcdUpdate.c"
2103:main.c        **** 
2104:main.c        **** //SIGNAL(TIMER1_COMPA_vect)
2105:main.c        **** SIGNAL(TIMER0_COMPA_vect)
2106:main.c        **** {
2107:main.c        **** 	static uint8_t frameCount = 0;
2108:main.c        **** 
2109:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
2110:main.c        **** 	while(TCNT0L != 7){};
2111:main.c        **** 	//This won't work... who knows how many cycles interrupt-entry will be
2112:main.c        **** 	//Above should fix that...
2113:main.c        **** 	//I believe this was only so I'd have something for the 'scope to
2114:main.c        **** 	// trigger on... 
2115:main.c        **** #error "These shouldn't be used anymore, since PB2 is GREEN"
2116:main.c        **** 	setpinPORT(PB2, PORTB);
2117:main.c        **** 	clrpinPORT(PB2, PORTB);
2118:main.c        **** #endif
2119:main.c        **** 
2120:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 60


2121:main.c        **** 	if(updateLCD())
2122:main.c        **** 	{
2123:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
2124:main.c        **** 			//static uint8_t frameCount = 0;
2125:main.c        **** 			frameCount++;
2126:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
2127:main.c        **** 			{
2128:main.c        **** 				frameCount = 0;
2129:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
2130:main.c        **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
2131:main.c        **** 			}
2132:main.c        **** #endif
2133:main.c        **** 	}
2134:main.c        **** 
2135:main.c        **** #if(defined(LOADROW) && LOADROW)
2136:main.c        **** 	//Load the next row into the row(seg)buffer
2137:main.c        **** 	//data is enabled after T_VD+T_Vlow...
2138:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
2139:main.c        **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
2140:main.c        **** #endif
2141:main.c        **** 	// Here is where loadRow used to be called
2142:main.c        **** 	// it has been moved to oldNotes.txt, but it would make more sense
2143:main.c        **** 	// to look at LCDdirectLVDS <25 or LCDdirect
2144:main.c        **** 	// loadRow used the time between DE inactive and the next Hsync
2145:main.c        **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
2146:main.c        **** 	// thus, DE could gain more pixels because there would be fewer
2147:main.c        **** 	// calculations to determine the memory location to write from
2148:main.c        **** 	// This effect has since been minimized
2149:main.c        **** 	// BUT loadRow might be necessary for program-memory-based images...
2150:main.c        **** }
2151:main.c        **** 
2152:main.c        **** 
2153:main.c        **** #define nibbletochar(val)	\
2154:main.c        **** 	(((val)<=9) ? ((val) + '0') : ((val) + ('A' - 10)))
2155:main.c        **** 
2156:main.c        **** 
2157:main.c        **** #if 0
2158:main.c        **** uint8_t hexColor = 0;
2159:main.c        **** 
2160:main.c        **** static __inline__ \
2161:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[]) \
2162:main.c        **** 	  __attribute__((__always_inline__));
2163:main.c        **** 
2164:main.c        **** //Takes a nibble and makes it a hex character...
2165:main.c        **** 
2166:main.c        **** #define HEXCOLOR_TOPROW 32
2167:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[])
2168:main.c        **** {
2169:main.c        **** //	static uint8_t color = 0;
2170:main.c        **** 
2171:main.c        **** 	if( (rbRowNum >= HEXCOLOR_TOPROW) &&
2172:main.c        **** 		 (rbRowNum < HEXCOLOR_TOPROW+8) )
2173:main.c        **** 	{
2174:main.c        **** 		uint8_t charRow1, charRow2;
2175:main.c        **** 		//uint8_t color;
2176:main.c        **** 
2177:main.c        **** 		charRow1 = 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 61


2178:main.c        **** 			getCharRow(nibbletochar((hexColor)>>4), rbRowNum-HEXCOLOR_TOPROW);
2179:main.c        **** 		charRow2 = 
2180:main.c        **** 			getCharRow(nibbletochar(hexColor&0x0f), rbRowNum-HEXCOLOR_TOPROW);
2181:main.c        **** 
2182:main.c        **** 		uint8_t col;
2183:main.c        **** 		for(col=0; col<8; col++)
2184:main.c        **** 		{
2185:main.c        **** 			if(getbit(col, charRow1))
2186:main.c        **** 				rowBuffer[col+1] = fb_to_rb(hexColor);
2187:main.c        **** 			//else
2188:main.c        **** 			//	rowBuffer[col] = fb_to_rb(0x00);
2189:main.c        **** 
2190:main.c        **** 			if(getbit(col, charRow2))
2191:main.c        **** 				rowBuffer[col+8+1] = fb_to_rb(hexColor);
2192:main.c        **** 		}
2193:main.c        **** 	}
2194:main.c        **** }
2195:main.c        **** #endif //0
2196:main.c        **** 
2197:main.c        **** 
2198:main.c        **** #if(defined(LOADROW) && LOADROW)
2199:main.c        **** #warning "loadRow is currently in an intermediate phase..."
2200:main.c        **** void loadRow(uint16_t rowNum)
2201:main.c        **** {
2202:main.c        **** 
2203:main.c        **** #if 0
2204:main.c        **** 	uint8_t i=0;
2205:main.c        **** 
2206:main.c        **** //	if((rowNum < 0) || (rowNum >= V_COUNT))
2207:main.c        **** //		return;
2208:main.c        **** 
2209:main.c        **** 	//THIS DOES NOT MAKE AN OUNCE OF SENSE TO ME:
2210:main.c        **** 	// why do I need *2 here?! Without it, the image is stretched and cut
2211:main.c        **** 	// in half vertically!
2212:main.c        **** 	// Apparently has to do with delayed Hsyncs due to calculations...?
2213:main.c        **** 	// LIFE with delay = 10 causes 2/3 frame at *2
2214:main.c        **** 	// The screen itself appears to be repeating rows...
2215:main.c        **** #if(!defined(HORIZONTAL_COLOR_BARS) || !HORIZONTAL_COLOR_BARS)
2216:main.c        ****  #if(LVDS_PRESCALER == 8)
2217:main.c        ****   #define ROW_SCALE 1
2218:main.c        ****  #else
2219:main.c        ****   #define ROW_SCALE 2
2220:main.c        ****  #endif
2221:main.c        **** 	uint8_t rbRowNum = ((uint32_t)rowNum)*RB_HEIGHT*ROW_SCALE/V_COUNT;
2222:main.c        **** 
2223:main.c        **** 	//Old note pre tet_drawRow... (code deleted a/o v45)	
2224:main.c        **** 	//WITHOUT THIS: syncing seems OK
2225:main.c        **** 	// But this is necessary for the right-border...
2226:main.c        **** 	// Adding it causes syncing problems at _b and _c -> _W
2227:main.c        **** 	// TODO: Look into sync-problems above!!!
2228:main.c        **** 	//  (revisit 41-1)
2229:main.c        **** 	//i++;
2230:main.c        **** 
2231:main.c        **** 	//Clear the rowBuffer, it will be reloaded, where appropriate, after
2232:main.c        **** 	// This isn't particularly speed-efficient, since most pixels will 
2233:main.c        **** 	// be written twice... but it should make things more plug-n-play...
2234:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 62


2235:main.c        **** 		rowBuffer[i]=fb_to_rb(0);
2236:main.c        **** 
2237:main.c        **** 
2238:main.c        **** 	tet_drawRow(rbRowNum, rowBuffer);
2239:main.c        **** 
2240:main.c        **** 
2241:main.c        **** 	hexColor_drawRow(rbRowNum, rowBuffer);
2242:main.c        **** 
2243:main.c        **** 	
2244:main.c        **** 	i=63-40;
2245:main.c        **** 
2246:main.c        **** 	static uint16_t colorShift = 0;
2247:main.c        **** 
2248:main.c        **** 	//!!! This *should* only increment once per frame (RIGHT?)
2249:main.c        **** 	// BUT, set colorShift>>5 to colorShift>>3 or even >>0
2250:main.c        **** 	// and it seems this is not true... WTF, again?
2251:main.c        **** 	if(rbRowNum == 0)
2252:main.c        **** 		colorShift++;
2253:main.c        **** 
2254:main.c        **** 	//Just fill up the remaining pixels with color...
2255:main.c        **** 	// i-- to overwrite the blank column in the characters
2256:main.c        **** 	// Leaving one column of black to check into syncing problems
2257:main.c        **** 	// with LVDS_PRESCALER=8...
2258:main.c        **** 	// apparently, the garbage-lines are related to the last color drawn(?!)
2259:main.c        **** 	for( ;i<RB_WIDTH;i++)
2260:main.c        **** 	{
2261:main.c        **** 			uint8_t colorVal = (i + rbRowNum + (colorShift>>5)) & 0x3f;
2262:main.c        **** 
2263:main.c        **** 			//We don't want Black, since it's used for LIFE...
2264:main.c        **** 			if(colorVal==0)
2265:main.c        **** 				colorVal = 0x15;
2266:main.c        **** 
2267:main.c        **** 			//Only draw colors where there isn't already data
2268:main.c        **** 			// (e.g. LIFE or the SMILEY)
2269:main.c        **** 			// Actually, this can't work, since Black is a possibility...
2270:main.c        **** 			//if(!rowBuffer[i])
2271:main.c        **** 				rowBuffer[i] = fb_to_rb(colorVal);
2272:main.c        **** 	}
2273:main.c        **** 
2274:main.c        **** /* This is now handled in the rowSegBuffer loading...
2275:main.c        **** 	I guess that doesn't fix it for the old non-row-seg case...
2276:main.c        **** 
2277:main.c        **** 	//Apparently *black* causes issues... as well as some dark colors
2278:main.c        **** 	// (certain shades of blue?)
2279:main.c        **** 	// White, as the last pixel, causes syncing to work fine, ish
2280:main.c        **** 	//And adding a black column doesn't do anything?!
2281:main.c        **** 	// either way, thsi should be redundant due to rowBuffer clearing
2282:main.c        **** 	// and RB_WIDTH-2 in the color-filling
2283:main.c        **** 	// WTF?
2284:main.c        **** 	//rowBuffer[RB_WIDTH-2] = fb_to_rb(_K);
2285:main.c        **** 	rowBuffer[RB_WIDTH-1] = fb_to_rb(_W);
2286:main.c        **** */
2287:main.c        **** 
2288:main.c        **** 	//Draw the smiley on top of the color pixels
2289:main.c        **** #define SMILE_TOP_ROW (20)
2290:main.c        **** #define SMILE_HEIGHT FB_HEIGHT
2291:main.c        **** #define SMILE_SHIFT	(24+(40-FB_WIDTH)/2)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 63


2292:main.c        **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
2293:main.c        **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
2294:main.c        **** 	{
2295:main.c        **** 			for(i=0; i<FB_WIDTH; i++)
2296:main.c        **** 			{
2297:main.c        **** 				uint8_t temp;
2298:main.c        **** 			#if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
2299:main.c        ****          	temp=frameBuffer[rbRowNum-SMILE_TOP_ROW][i];
2300:main.c        **** 			#else
2301:main.c        ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
2302:main.c        **** 			#endif
2303:main.c        **** 
2304:main.c        **** 				if(!(temp & 0xC0))
2305:main.c        **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
2306:main.c        **** 			}
2307:main.c        **** 	}
2308:main.c        **** 
2309:main.c        **** 
2310:main.c        **** 	#if(defined(LIFE) && LIFE)
2311:main.c        **** 	//This has to be called *after* the colored background is drawn...
2312:main.c        **** 	// (that could be changed... with _Tr?)
2313:main.c        **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
2314:main.c        **** 	#endif //LIFE
2315:main.c        **** 
2316:main.c        **** 
2317:main.c        **** #else //HORIZONTAL_COLOR_BARS
2318:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2319:main.c        **** 		rowBuffer[i] = fb_to_rb(rowNum);
2320:main.c        **** #endif
2321:main.c        **** 
2322:main.c        **** 
2323:main.c        **** #endif //0
2324:main.c        **** 
2325:main.c        **** 	
2326:main.c        **** 
2327:main.c        **** //#define SEG_QUESTION TRUE
2328:main.c        **** 	//Isn't BLAH = 1 necessary so we don't get a row with no data?
2329:main.c        **** 	// *looks* like it's working, but I dunno...
2330:main.c        **** #define BLAH 0
2331:main.c        **** 
2332:main.c        **** 
2333:main.c        **** #if(defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
2334:main.c        **** // Wasn't sure where 357 came from... and now I'm wondering where the
2335:main.c        **** // notes I wrote regarding it disappeared to...
2336:main.c        **** // Anyhow, from line 72, if ROW_SEG_BUFFER && !LVDS_PRESCALER
2337:main.c        **** // "ROW_SEG_BUFFER uses 20cyc/pixel" (doesn't match the math I've 
2338:main.c        **** // elsewhere) 1024/20*7 = 358.4... so maybe that's something to do with it
2339:main.c        **** // TODO: If it was 21cyc/pixel, wouldn't we have perfect alignment with
2340:main.c        **** //       color-transitions and segment widths?
2341:main.c        **** //#define NUM_PSEGS	(1024/3+16) //357
2342:main.c        ****  #if (defined(SEG_RACER) && SEG_RACER)
2343:main.c        ****   #include <stdlib.h>	//rand()
2344:main.c        ****   #define NEXT_COLOR	_R
2345:main.c        ****   #define THIS_COLOR	_G
2346:main.c        ****   #define OVERLAP_COLOR	_Y
2347:main.c        ****   #define BG_COLOR	_C
2348:main.c        ****   #define BG_BAD_COLOR	_M
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 64


2349:main.c        **** 
2350:main.c        **** 
2351:main.c        **** 
2352:main.c        **** 	int16_t racerPseg = NUM_PSEGS/2 - 2;
2353:main.c        **** 
2354:main.c        **** 	adc_startConversion();
2355:main.c        **** 	while(adc_isBusy())
2356:main.c        **** 		asm("nop;");
2357:main.c        **** 	racerPseg = (adc_getValue()>>2)+5;
2358:main.c        **** 	if(racerPseg > NUM_PSEGS-2)
2359:main.c        **** 		racerPseg = NUM_PSEGS-2;
2360:main.c        **** 
2361:main.c        **** 	segClear();
2362:main.c        **** 	addSegfb(1, _W);
2363:main.c        **** 	static uint16_t raceWidth = 16;
2364:main.c        **** 	static uint8_t trackPosition = 0;
2365:main.c        ****   #define TRACK_LENGTH	24	//24*32 = 768
2366:main.c        ****   #define TRACK_ROWS	(V_COUNT/TRACK_LENGTH)
2367:main.c        **** 	static uint16_t raceTrack[TRACK_LENGTH*2];
2368:main.c        **** 
2369:main.c        **** 	uint8_t bgColor = BG_COLOR;
2370:main.c        **** 
2371:main.c        **** 	//racePseg += ((rand()&0xff0)>>4)*2/0xff - 1;
2372:main.c        **** 
2373:main.c        **** 	uint8_t thisTrackRow = rowNum/TRACK_ROWS; //(V_COUNT/TRACK_LENGTH);
2374:main.c        **** 	uint8_t thisPosition = thisTrackRow + (trackPosition? TRACK_LENGTH : 0);
2375:main.c        **** 	uint8_t nextPosition = thisTrackRow + (trackPosition? 0 : TRACK_LENGTH);
2376:main.c        **** 
2377:main.c        **** 	static hfm_t thisSmoothingHFM, nextSmoothingHFM;
2378:main.c        **** 	static uint8_t thisTrackGrowing, nextTrackGrowing;
2379:main.c        **** 
2380:main.c        **** /*
2381:main.c        **** 	static theta_t racerTheta = 0;
2382:main.c        **** 	if(racerTheta >= SINE_2PI)
2383:main.c        **** 		racerTheta -= SINE_2PI;
2384:main.c        **** 
2385:main.c        **** 	racerPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2386:main.c        **** 	racerTheta++;
2387:main.c        **** */
2388:main.c        **** 
2389:main.c        **** 	uint8_t outOfTrack = FALSE;
2390:main.c        **** 	typedef struct _IST_BLAH_
2391:main.c        **** 	{
2392:main.c        **** 		uint16_t length;
2393:main.c        **** 		uint8_t color;
2394:main.c        **** 	}	intermediateSeg_t;
2395:main.c        **** 
2396:main.c        **** #define ISEGS_PER_WHATEVER	3
2397:main.c        **** #define IS_SEGS (5*ISEGS_PER_WHATEVER)
2398:main.c        **** 	intermediateSeg_t is[IS_SEGS] = 
2399:main.c        **** 	{ {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2400:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2401:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W} };
2402:main.c        **** 
2403:main.c        **** 	uint8_t isPos = 0;
2404:main.c        **** 
2405:main.c        **** #define addSegIS(len, c) \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 65


2406:main.c        **** ({\
2407:main.c        ****  	is[isPos].length = (len); \
2408:main.c        ****  	is[isPos].color = (c); \
2409:main.c        ****  	isPos+=ISEGS_PER_WHATEVER; \
2410:main.c        ****  	{}; \
2411:main.c        **** })
2412:main.c        **** 
2413:main.c        **** 
2414:main.c        **** 
2415:main.c        **** 	int8_t prevNextPosition;
2416:main.c        **** 	int8_t prevThisPosition;
2417:main.c        **** 
2418:main.c        **** 	static uint16_t thisIS, nextIS;
2419:main.c        **** 
2420:main.c        **** 	static uint8_t level = 1;
2421:main.c        **** 
2422:main.c        **** 
2423:main.c        **** 	if(rowNum%TRACK_ROWS == 0) //(V_COUNT/TRACK_LENGTH) == 0)
2424:main.c        **** 	{
2425:main.c        **** 		prevNextPosition = nextPosition - 1;
2426:main.c        **** 		if(prevNextPosition < 0)
2427:main.c        **** 			prevNextPosition = TRACK_LENGTH*2 - 1; //+prevNextPosition;
2428:main.c        **** 
2429:main.c        **** 		prevThisPosition = thisPosition - 1;
2430:main.c        **** 		if(prevThisPosition < 0)
2431:main.c        **** 			prevThisPosition = TRACK_LENGTH*2 - 1; //+prevThisPosition;
2432:main.c        **** 		
2433:main.c        **** 		static theta_t racerTheta=0;
2434:main.c        **** 
2435:main.c        **** 		int16_t nextTrackPseg;
2436:main.c        **** 
2437:main.c        **** 		nextTrackPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2438:main.c        **** 		racerTheta+=level;
2439:main.c        **** 		if(racerTheta >= SINE_2PI)
2440:main.c        **** 			racerTheta-=SINE_2PI;
2441:main.c        **** /*
2442:main.c        **** 	int8_t randomVal = rand()&0x03;
2443:main.c        **** 	switch(randomVal)
2444:main.c        **** 	{
2445:main.c        **** 		case 1:
2446:main.c        **** 			if(nextTrackPseg < NUM_PSEGS-2-raceWidth)
2447:main.c        **** 				nextTrackPseg += 1;
2448:main.c        **** 			break;
2449:main.c        **** 		case 2:
2450:main.c        **** 			if(nextTrackPseg > 1)
2451:main.c        **** 				nextTrackPseg -= 1;
2452:main.c        **** 			break;
2453:main.c        **** 		default:
2454:main.c        **** 			break;
2455:main.c        **** 	}
2456:main.c        **** */
2457:main.c        **** 
2458:main.c        **** 
2459:main.c        **** 		raceTrack[nextPosition] = nextTrackPseg;
2460:main.c        **** 
2461:main.c        **** 		thisIS = raceTrack[prevThisPosition];
2462:main.c        **** 		nextIS = raceTrack[prevNextPosition];
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 66


2463:main.c        **** 		uint8_t nextHFMdist, thisHFMdist;
2464:main.c        **** 
2465:main.c        **** 		if(raceTrack[nextPosition] > nextIS)
2466:main.c        **** 		{
2467:main.c        **** 			nextTrackGrowing = TRUE;
2468:main.c        **** 			nextHFMdist = raceTrack[nextPosition] - nextIS;
2469:main.c        **** 		}
2470:main.c        **** 		else
2471:main.c        **** 		{
2472:main.c        **** 			nextTrackGrowing = FALSE;
2473:main.c        **** 			nextHFMdist = nextIS - raceTrack[nextPosition];
2474:main.c        **** 		}
2475:main.c        **** 		
2476:main.c        **** 		if(raceTrack[thisPosition] > thisIS)
2477:main.c        **** 		{
2478:main.c        **** 			thisTrackGrowing = TRUE;
2479:main.c        **** 			thisHFMdist = raceTrack[thisPosition] - thisIS;
2480:main.c        **** 		}
2481:main.c        **** 		else
2482:main.c        **** 		{
2483:main.c        **** 			thisTrackGrowing = FALSE;
2484:main.c        **** 			thisHFMdist = thisIS - raceTrack[thisPosition];
2485:main.c        **** 		}
2486:main.c        **** 
2487:main.c        **** 		hfm_setup(&nextSmoothingHFM, nextHFMdist, TRACK_ROWS);
2488:main.c        **** 
2489:main.c        **** 		hfm_setup(&thisSmoothingHFM, thisHFMdist, TRACK_ROWS);
2490:main.c        **** 	}
2491:main.c        **** 
2492:main.c        **** 
2493:main.c        **** 	if(thisTrackGrowing)//raceTrack[thisPosition] > raceTrack[prevThisPosition])
2494:main.c        **** 		thisIS += hfm_nextOutput(&thisSmoothingHFM);
2495:main.c        **** 	else
2496:main.c        **** 		thisIS -= hfm_nextOutput(&thisSmoothingHFM);
2497:main.c        **** 
2498:main.c        **** 	if(nextTrackGrowing)//raceTrack[nextPosition] > raceTrack[prevNextPosition])
2499:main.c        **** 		nextIS += hfm_nextOutput(&nextSmoothingHFM);
2500:main.c        **** 	else
2501:main.c        **** 		nextIS -= hfm_nextOutput(&nextSmoothingHFM);
2502:main.c        **** 
2503:main.c        **** 	if(thisIS < nextIS)
2504:main.c        **** 	{
2505:main.c        **** 		addSegIS(thisIS, bgColor);
2506:main.c        **** 
2507:main.c        **** 		//Tracks overlap
2508:main.c        **** 		if(nextIS < thisIS + raceWidth)
2509:main.c        **** 		{
2510:main.c        **** 			addSegIS(nextIS - thisIS, THIS_COLOR);
2511:main.c        **** 			addSegIS(thisIS + raceWidth - nextIS, OVERLAP_COLOR);
2512:main.c        **** 			addSegIS(nextIS - thisIS, NEXT_COLOR);
2513:main.c        **** 			//outOfTrack=TRUE;
2514:main.c        **** 		}
2515:main.c        **** 		else
2516:main.c        **** 		{
2517:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2518:main.c        **** 			addSegIS(nextIS - thisIS - raceWidth, bgColor);
2519:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 67


2520:main.c        **** 		}
2521:main.c        **** 
2522:main.c        **** 		//addSegIS(NUM_PSEGS-2-nextIS-raceWidth, bgColor);
2523:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-nextIS-raceWidth, bgColor);
2524:main.c        **** 
2525:main.c        **** 	}
2526:main.c        **** 	else if(thisIS > nextIS)
2527:main.c        **** 	{
2528:main.c        **** 		addSegIS(nextIS, bgColor);
2529:main.c        **** 
2530:main.c        **** 		//Tracks overlap
2531:main.c        **** 		if(thisIS < nextIS + raceWidth)
2532:main.c        **** 		{
2533:main.c        **** 			addSegIS(thisIS - nextIS, NEXT_COLOR);
2534:main.c        **** 			addSegIS(nextIS + raceWidth - thisIS, OVERLAP_COLOR);
2535:main.c        **** 			addSegIS(thisIS - nextIS, THIS_COLOR);
2536:main.c        **** 			//outOfTrack=TRUE;
2537:main.c        **** 		}
2538:main.c        **** 		else
2539:main.c        **** 		{
2540:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
2541:main.c        **** 			addSegIS(thisIS - nextIS - raceWidth, bgColor);
2542:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2543:main.c        **** 		}
2544:main.c        **** 	
2545:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2546:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2547:main.c        **** 	}
2548:main.c        **** 	else //Positions equal
2549:main.c        **** 	{
2550:main.c        **** 		//outOfTrack=TRUE;
2551:main.c        **** 		addSegIS(thisIS, bgColor);
2552:main.c        **** 
2553:main.c        **** 		addSegIS(raceWidth, OVERLAP_COLOR);
2554:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2555:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2556:main.c        **** 	}
2557:main.c        **** /*
2558:main.c        **** addSegfb(raceWidth, _W);
2559:main.c        **** 	addSegfb(NUM_PSEGS-racePseg-raceWidth-2, _R);
2560:main.c        **** */
2561:main.c        **** 	uint8_t isSeg;
2562:main.c        **** 	uint16_t isSegTrackPos = 0;
2563:main.c        **** 	uint16_t oldTrackPos = 0;
2564:main.c        **** 	//uint8_t racerFound = FALSE;
2565:main.c        **** 
2566:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2567:main.c        **** 	{
2568:main.c        **** 		isSegTrackPos += is[isSeg].length;
2569:main.c        **** 
2570:main.c        **** 		//if(!racerFound && 
2571:main.c        **** 		if((isSegTrackPos >= (uint16_t)racerPseg))
2572:main.c        **** 		{
2573:main.c        **** 			//racerFound = TRUE;
2574:main.c        **** 			uint16_t oldLength = is[isSeg].length;
2575:main.c        **** 			is[isSeg].length = racerPseg - oldTrackPos;
2576:main.c        **** 			is[isSeg+1].length = 1;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 68


2577:main.c        **** 			is[isSeg+1].color = _K;
2578:main.c        **** 			//Not sure why this shouldn't be -1...
2579:main.c        **** 			is[isSeg+2].length = oldLength - is[isSeg].length; //- 1;
2580:main.c        **** 			is[isSeg+2].color = is[isSeg].color;
2581:main.c        **** 			if((is[isSeg].color != THIS_COLOR) && (is[isSeg].color != OVERLAP_COLOR))
2582:main.c        **** 				outOfTrack = TRUE;
2583:main.c        **** 			isSeg++;
2584:main.c        **** 			break;
2585:main.c        **** 		}
2586:main.c        **** 		oldTrackPos = isSegTrackPos;
2587:main.c        **** 	}
2588:main.c        **** 
2589:main.c        **** 	
2590:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2591:main.c        ****   	{
2592:main.c        **** 		if(is[isSeg].length == 0)
2593:main.c        **** 			continue;
2594:main.c        **** 		if(outOfTrack && (is[isSeg].color==BG_COLOR))
2595:main.c        **** 			addSegfb(is[isSeg].length, BG_BAD_COLOR);
2596:main.c        **** 		else
2597:main.c        **** 			addSegfb(is[isSeg].length, is[isSeg].color);
2598:main.c        **** 	}
2599:main.c        **** 
2600:main.c        **** 	static uint32_t badCount=0;
2601:main.c        **** 	static uint32_t goodCount=0;
2602:main.c        **** 
2603:main.c        **** 	if(outOfTrack)
2604:main.c        **** 		badCount++;
2605:main.c        **** 	else
2606:main.c        **** 		goodCount++;
2607:main.c        **** 
2608:main.c        **** 	
2609:main.c        **** 	addSegfb(1, _B);
2610:main.c        **** 
2611:main.c        **** 
2612:main.c        **** 	uint8_t percentage = goodCount*100/(badCount+goodCount);
2613:main.c        **** 	static uint32_t lastLevelUpdate = 0;
2614:main.c        **** 
2615:main.c        **** 	if((percentage > 50) && (goodCount - lastLevelUpdate > V_COUNT*3))
2616:main.c        **** 	{
2617:main.c        **** 		lastLevelUpdate = goodCount;
2618:main.c        **** 		level++;
2619:main.c        **** 	}
2620:main.c        **** 
2621:main.c        **** 	if((rowNum>=6) && (rowNum < 22))
2622:main.c        **** 		showScore(rowNum-6, level, _C);
2623:main.c        **** 
2624:main.c        **** 	else if((rowNum>=24) && (rowNum <40))
2625:main.c        **** 		showScore(rowNum-24, goodCount, _G);
2626:main.c        **** 	else if((rowNum >= 42) && rowNum < 58)
2627:main.c        **** 		showScore(rowNum-42, badCount, _R);
2628:main.c        **** 	else if((rowNum >= 60) && (rowNum < 76))
2629:main.c        **** 		showScore(rowNum-60, percentage, _Y);
2630:main.c        **** 
2631:main.c        **** 
2632:main.c        **** 	addSegfb(NUM_PSEGS-2-RACE_WIDTH_PSEGS, _B);
2633:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 69


2634:main.c        **** 	addSegfb(1, _W);
2635:main.c        **** 	segTerminate();
2636:main.c        **** 
2637:main.c        **** 	if(rowNum >= V_COUNT-1)
2638:main.c        **** 		trackPosition = !trackPosition;
2639:main.c        **** 
2640:main.c        ****  #elif (defined(SEG_HFM) && SEG_HFM)
2641:main.c        **** 	segClear();
2642:main.c        **** 	//Just some experimenting... 1024/3+16 seems to be the width...
2643:main.c        **** 	// == 357 segments (Where does this come from?)
2644:main.c        **** //Pixel Segments...
2645:main.c        **** #define BORDER_PSEGS	1
2646:main.c        **** #define SEGS_AVAILABLE (NUM_SEGMENTS-2)
2647:main.c        **** #define PSEGS_AVAILABLE	(NUM_PSEGS-BORDER_PSEGS*2)
2648:main.c        **** #define HFM_PSEGS	(PSEGS_AVAILABLE/SEGS_AVAILABLE)
2649:main.c        **** #define HFM_PSEGS_REMAINDER	(PSEGS_AVAILABLE%SEGS_AVAILABLE)
2650:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2651:main.c        **** 
2652:main.c        **** 	hfm_t hfmThing;
2653:main.c        **** 	hfm_setup(&hfmThing, (uint8_t)((uint32_t)rowNum*(uint32_t)SEGS_AVAILABLE/V_COUNT), SEGS_AVAILABLE)
2654:main.c        **** 
2655:main.c        **** 	hfm_t hfmColStretcher;
2656:main.c        **** 	hfm_setup(&hfmColStretcher, HFM_PSEGS_REMAINDER, SEGS_AVAILABLE);
2657:main.c        **** 
2658:main.c        **** 	uint16_t pseg;
2659:main.c        **** 	for(pseg=0; pseg<SEGS_AVAILABLE; pseg++)
2660:main.c        **** 	{
2661:main.c        **** 		if(hfm_nextOutput(&hfmThing))
2662:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_R);
2663:main.c        **** 		else
2664:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_C);
2665:main.c        **** 	}
2666:main.c        **** 
2667:main.c        **** 	//addSegfb(NUM_PSEGS-BORDER_PSEGS*2-SEGS_AVAILABLE*HFM_PSEGS, _M);
2668:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2669:main.c        **** 	segTerminate();
2670:main.c        **** 
2671:main.c        ****  #elif (defined(SEG_QUESTION) && SEG_QUESTION)
2672:main.c        **** 
2673:main.c        **** //Actually, this probably won't work right...
2674:main.c        **** // because the rgb values aren't exact like that, right?
2675:main.c        **** // e.g. black = 0,0,0 but it shows as 0,0,60 ish...
2676:main.c        **** // then again, going in reverse like this might work fine...
2677:main.c        **** // due to rounding (seems OK with this color-scheme)
2678:main.c        **** // The idea wasn't so much to be able to input an 8-bit RGB value to get
2679:main.c        **** // a close match (would probably want rounding up for that, not that it'd
2680:main.c        **** // be even close)
2681:main.c        **** // but to be able to read color-values from GIMP when using the 
2682:main.c        **** //  LCDdirectLVDS color-palette... which isn't especially necessary since
2683:main.c        **** //  now the colors are named with 3-based colors.
2684:main.c        **** #define rgb8(r,g,b) \
2685:main.c        **** 		rgb((((r)*3)/255), (((g)*3)/255), (((b)*3)/255))
2686:main.c        **** 
2687:main.c        **** 
2688:main.c        **** 
2689:main.c        **** //THESE DON'T BELONG HERE
2690:main.c        **** // AND they shouldn't be "Q" specific, at all.
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 70


2691:main.c        **** #define Q_WIDTH	16
2692:main.c        **** #define Q_HEIGHT	16
2693:main.c        **** 		//This should be an init-thing, I guess... it's only a 2-cycle
2694:main.c        **** 		// instruction, so it doesn't hurt too much to have it in the loop
2695:main.c        **** 		// BUT it does have to occur a while before the first getpinPORT
2696:main.c        **** 		// to allow time for the pull-ups to do their job
2697:main.c        **** 		setinpuPORT(PB0, PORTB);
2698:main.c        **** 
2699:main.c        **** 	static uint8_t qCount = 0;
2700:main.c        **** 
2701:main.c        **** 	segClear();
2702:main.c        **** 	//Not sure why this is stretched without /2...
2703:main.c        **** 	// I think I ran into this elsewhere as well.
2704:main.c        **** 	//!!! INSTEAD: filled the rest of the row properly...
2705:main.c        **** 	// (wasn't filling up the entire row, due to rounding...
2706:main.c        **** 	//   result was the rows were carrying-over into the next)
2707:main.c        **** 	uint8_t qRow;// = (rowNum*Q_HEIGHT/(V_COUNT)); ///2));
2708:main.c        **** 	uint8_t qCol;
2709:main.c        **** 	
2710:main.c        **** 	//Guess white helps with sync...?
2711:main.c        **** 	// can't hurt.
2712:main.c        **** 	//addSegfb(3, _W);
2713:main.c        **** 	// Looks like some white is already being inserted (or syncing on end-
2714:main.c        **** 	// white?) about 3pixels wide.
2715:main.c        **** 
2716:main.c        **** 	// 1024/3/32 = 10.67... so for every 3 segments, add 2
2717:main.c        **** #define Q_STRETCHTOP	1//0//28//2
2718:main.c        **** #define Q_STRETCHDIV 5//30//3
2719:main.c        **** 	hfm_t colincrementer_hfm;
2720:main.c        **** 	hfm_setup(&colincrementer_hfm, Q_STRETCHTOP, Q_STRETCHDIV);
2721:main.c        **** 
2722:main.c        **** 	for(qCol=0; qCol<Q_WIDTH; qCol++)
2723:main.c        **** 	{
2724:main.c        **** 		//Not sure where this is defined, if it is...
2725:main.c        **** 		// each "segment length" appears to be 3 physical pixels
2726:main.c        **** 		//+1 is a result of random experiments with stretch
2727:main.c        **** 		// resulting in a stretch larger than 1
2728:main.c        **** 		#define Q_SEGLENGTH	(1024/3/Q_WIDTH+1)
2729:main.c        **** 
2730:main.c        **** 	//These are not included in NUM_ICONS
2731:main.c        **** 	#include "icons/Question.h"
2732:main.c        **** 	#include "icons/Solid.h"
2733:main.c        **** 	#include "icons/GoombaDead.h"
2734:main.c        **** 
2735:main.c        **** 	//These are included in NUM_ICONS
2736:main.c        **** 	#include "icons/1up.h"
2737:main.c        **** 	#include "icons/Biggie.h"
2738:main.c        **** 	#include "icons/StarV.h"
2739:main.c        **** 	#include "icons/FlowerPowerV.h"
2740:main.c        **** 	#include "icons/Goomba.h"
2741:main.c        **** 	#include "icons/Coin.h"
2742:main.c        **** 
2743:main.c        **** 	//Excluding Solid and Question, etc...
2744:main.c        **** 	#define NUM_ICONS 6
2745:main.c        **** 		/*
2746:main.c        **** 		static uint8_t iconSelection = 0;
2747:main.c        **** 		static uint8_t * icon[NUM_ICONS] = { pgm_imageUP, pgm_imageCOIN};
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 71


2748:main.c        **** 		static uint8_t iconFrames[NUM_ICONS] = {NUM_UPS, NUM_COINS};
2749:main.c        **** 
2750:main.c        **** 		static uint8_t * p_image = pgm_imageUP; // = icon[0]; //(pgm_imageFLOWER);
2751:main.c        **** 		static uint8_t NumFramesInImage = NUM_UPS; // = NUM_FLOWERS;
2752:main.c        **** 		*/
2753:main.c        **** 		//For changing images...
2754:main.c        **** 		static sprite_t *p_selectedSprite = &spriteQ;
2755:main.c        **** 		static uint16_t buttonPressed = FALSE;
2756:main.c        **** 
2757:main.c        **** #define DEBUGGING_PRESSIMMEDIATE TRUE
2758:main.c        **** 
2759:main.c        **** #if(!defined(DEBUGGING_PRESSIMMEDIATE) || !DEBUGGING_PRESSIMMEDIATE)
2760:main.c        **** 		if((p_selectedSprite == &spriteQ) 
2761:main.c        **** 				|| (p_selectedSprite == &spriteGOOMBA))
2762:main.c        **** #else
2763:main.c        **** 	#warning "Debugging mode... players can change their result!"
2764:main.c        **** #endif
2765:main.c        **** 		if(!getpinPORT(PB0, PORTB))
2766:main.c        **** 		{
2767:main.c        **** 			if(!buttonPressed)
2768:main.c        **** 			{
2769:main.c        **** 				buttonPressed = rowNum;
2770:main.c        **** 				if(buttonPressed == 0)
2771:main.c        **** 					buttonPressed = 1;
2772:main.c        **** 			}
2773:main.c        **** 			else if((rowNum-buttonPressed) >= 64)
2774:main.c        **** 				buttonPressed += 0x4000;
2775:main.c        **** 		}
2776:main.c        **** 
2777:main.c        **** 
2778:main.c        **** #define REALLY_IMMEDIATE	TRUE
2779:main.c        **** #if (defined(REALLY_IMMEDIATE) && REALLY_IMMEDIATE)
2780:main.c        **** 		if((rowNum == 0) || (buttonPressed&0x8000))
2781:main.c        **** #else
2782:main.c        **** 		if(rowNum==0)
2783:main.c        **** #endif
2784:main.c        **** 		{
2785:main.c        **** 			if(!(buttonPressed&0x8000) && !((p_selectedSprite == &spriteQ) ||
2786:main.c        **** 												(p_selectedSprite == &spriteGOOMBA)))
2787:main.c        **** 				buttonPressed = FALSE;
2788:main.c        **** 
2789:main.c        **** 			if(buttonPressed)
2790:main.c        **** 			{
2791:main.c        **** 				if(p_selectedSprite == &spriteGOOMBA)
2792:main.c        **** 				{
2793:main.c        **** 					if(qCount == 1)
2794:main.c        **** 						p_selectedSprite = &spriteDEADGOOMBA;
2795:main.c        **** 
2796:main.c        **** 				}
2797:main.c        **** 				else
2798:main.c        **** 				{
2799:main.c        **** 					//Duh...
2800:main.c        **** 					// But still, 255 % 3 should give a value from 0 to 2
2801:main.c        **** 					//buttonPressed=FALSE;
2802:main.c        **** 					qCount = 0;
2803:main.c        **** 					//static uint8_t iconSelection;
2804:main.c        **** 					//iconSelection++;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 72


2805:main.c        **** 					//iconSelection%=NUM_ICONS;
2806:main.c        **** 					//NumFramesInImage = iconFrames[iconSelection];
2807:main.c        **** //#define RANDOMSPRITE_OVERRIDE 0
2808:main.c        **** #if(defined(RANDOMSPRITE_OVERRIDE))
2809:main.c        **** 					switch(RANDOMSPRITE_OVERRIDE)
2810:main.c        **** #else
2811:main.c        **** 					switch ((buttonPressed-1)%(NUM_ICONS*2))
2812:main.c        **** #endif
2813:main.c        **** 					{
2814:main.c        **** 						case 0:
2815:main.c        **** 							p_selectedSprite = &spriteFLOWER;
2816:main.c        **** 							break;
2817:main.c        **** 						case 1:
2818:main.c        **** 							p_selectedSprite = &sprite1UP;
2819:main.c        **** 							break;
2820:main.c        **** 						case 2:
2821:main.c        **** 							p_selectedSprite = &spriteBIG;
2822:main.c        **** 							break;
2823:main.c        **** 						case 3:
2824:main.c        **** 							p_selectedSprite = &spriteSTAR;
2825:main.c        **** 							break;
2826:main.c        **** 						case 4:
2827:main.c        **** 							p_selectedSprite = &spriteGOOMBA;
2828:main.c        **** 							break;
2829:main.c        **** 						default:
2830:main.c        **** 							p_selectedSprite = &spriteCOIN;
2831:main.c        **** 							break;
2832:main.c        **** 					}
2833:main.c        **** 				}
2834:main.c        **** 
2835:main.c        **** 				//buttonPressed=FALSE;
2836:main.c        **** 			}
2837:main.c        **** 			if(p_selectedSprite == &spriteCOIN)
2838:main.c        **** 			{
2839:main.c        **** 				if(qCount >= 2)
2840:main.c        **** 					p_selectedSprite = &spriteSOLID;
2841:main.c        **** 			}
2842:main.c        **** 			else if(p_selectedSprite != &spriteQ)
2843:main.c        **** 			{
2844:main.c        **** 				if(qCount >= 4)
2845:main.c        **** 				{
2846:main.c        **** 					qCount = 0;
2847:main.c        **** 					if(p_selectedSprite != &spriteSOLID)
2848:main.c        **** 						p_selectedSprite = &spriteSOLID;
2849:main.c        **** 					else
2850:main.c        **** 						p_selectedSprite = &spriteQ;
2851:main.c        **** 				}
2852:main.c        **** 			}
2853:main.c        **** 
2854:main.c        **** 			buttonPressed = FALSE;
2855:main.c        **** 		}
2856:main.c        **** 
2857:main.c        **** 		qRow = (rowNum*ICON_HEIGHT/(V_COUNT)); ///2));
2858:main.c        **** 		
2859:main.c        **** 
2860:main.c        **** 
2861:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 73


2862:main.c        **** //		p_image = (icon[iconSelection] + 
2863:main.c        **** //						(qCount%NumFramesInImage)*ICON_HEIGHT*ICON_WIDTH);
2864:main.c        **** 
2865:main.c        **** 		// Should use readImageByte... but it's specific to FB_WIDTH
2866:main.c        **** 		//uint8_t data=
2867:main.c        **** 		//  pgm_read_byte((uint8_t *)(&((p_image)[(qRow)*Q_WIDTH+(qCol)])));
2868:main.c        **** 		uint8_t data;
2869:main.c        **** 	  
2870:main.c        **** 		if(p_selectedSprite == &spriteFLOWER)
2871:main.c        **** 		{
2872:main.c        **** 			if(qRow<FLOWER_PALETTE1_ROW)
2873:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,
2874:main.c        **** 							qCount%(spriteFLOWER.numPalettes-1) + 1, qRow, qCol);
2875:main.c        **** 			else
2876:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,0,qRow, qCol);
2877:main.c        **** 		}
2878:main.c        **** 		else if(p_selectedSprite == &spriteGOOMBA)
2879:main.c        **** 		{
2880:main.c        **** 			uint8_t gCol = qCol;
2881:main.c        **** 			//Goomba moves by flipping horizontally...
2882:main.c        **** 			if(qCount & 0x01)
2883:main.c        **** 				gCol = 15-qCol;
2884:main.c        **** 
2885:main.c        **** 			data = getGimpColorVal(&spriteGOOMBA, 0, qRow, gCol);
2886:main.c        **** 		}
2887:main.c        **** 		else
2888:main.c        **** 		{
2889:main.c        **** 			data = getGimpColorVal(p_selectedSprite, 
2890:main.c        **** 							qCount%p_selectedSprite->numPalettes, qRow, qCol);
2891:main.c        **** 		}
2892:main.c        **** 		data = gimpPixelValToLColor(data);
2893:main.c        **** 
2894:main.c        **** 		addSegfb(Q_SEGLENGTH + hfm_nextOutput(&colincrementer_hfm), data);
2895:main.c        **** 	}
2896:main.c        **** 
2897:main.c        **** 
2898:main.c        **** 	//Wow, is it really so smart as to recognize that rowNum is never >=
2899:main.c        **** 	// V_COUNT?! was 7684 when if(rowNum==0), then 7668 after this bug...
2900:main.c        **** 	//if(rowNum >= V_COUNT)
2901:main.c        **** 	if(rowNum >= V_COUNT-1)
2902:main.c        **** 	{
2903:main.c        **** 		qCount++;
2904:main.c        **** 	}
2905:main.c        **** 
2906:main.c        **** 
2907:main.c        **** 	//Wait, what?! We can't fit 1024 segments! But this sorta works
2908:main.c        **** 	// We're gtting syncing, a tiny bit of white-space on the right
2909:main.c        **** 	// which seems reasonable based on shotty math, 
2910:main.c        **** 	//                10     *  32   +  10   *    2       /   3 = 326
2911:main.c        **** 	// but 1024/3 is 341 (where's my math error?)
2912:main.c        **** 	//addSegfb(1024-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2913:main.c        **** 	// But, nope, 341-... doesn't sync (vertical stretching again)
2914:main.c        **** 	// But, 342 does. Sweet. 1024/3=341.33333, actually.
2915:main.c        **** 	//addSegfb(342-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2916:main.c        **** 	// Because it's not 10*2/3, it's 32*2/3=21.3...
2917:main.c        **** 	// which is exactly right
2918:main.c        **** 	// which then doesn't explain why it has whitespace and doesn't sync
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 74


2919:main.c        **** 	// without 342 above...
2920:main.c        **** 	// something to do with white being necessary?
2921:main.c        **** 	// Can't recall where 1024/3 was determined, maybe it varies
2922:main.c        **** 	// since the LVDS clock is 7 cycles...?
2923:main.c        **** 	//OK, so maybe we just need a white pixel at the end...
2924:main.c        **** 	// I mean, this works.
2925:main.c        **** 	addSegfb(1,_W);
2926:main.c        **** 
2927:main.c        **** 
2928:main.c        **** 	segTerminate();
2929:main.c        **** 
2930:main.c        ****  #elif (defined(SEG_LINE) && SEG_LINE)
2931:main.c        **** 
2932:main.c        **** 	//syncing issues due to recursion overflowing the stack???
2933:main.c        **** 	// Apparently was
2934:main.c        **** 	segClear();
2935:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
2936:main.c        **** 	newSeg((rowNum&0xff) | BLAH, 0x06, (4<<4) | 0);				//R
2937:main.c        **** 	newSeg(1,0x06, (6<<4) | 3);									//W
2938:main.c        **** 	newSeg((255-(rowNum&0xff)) | BLAH, 0x06, (4<<4) | 0 );	//R
2939:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
2940:main.c        **** 	segTerminate();
2941:main.c        **** 
2942:main.c        ****  #elif (defined(SEG_SINE) && SEG_SINE)
2943:main.c        **** 	static uint16_t lastThetaOffset = 0;
2944:main.c        **** 	static uint8_t frameCount = 0;
2945:main.c        **** 
2946:main.c        **** 	if(rowNum == 0)
2947:main.c        **** 	{
2948:main.c        **** 		lastThetaOffset+=16;
2949:main.c        **** 		frameCount++;
2950:main.c        **** 	}
2951:main.c        **** 	//pgm_read_sine(sineTable[theta])
2952:main.c        **** 
2953:main.c        **** 	segClear();
2954:main.c        **** 	//addSegfb(3,0x06, (6<<4) | 3);
2955:main.c        **** 	addSegfb(3, _W);
2956:main.c        **** 
2957:main.c        **** 	uint8_t sineVal = (uint8_t)((int8_t)128 + 
2958:main.c        **** 			sineRaw8(rowNum+lastThetaOffset));
2959:main.c        **** 
2960:main.c        **** 	uint8_t nextSineVal = (uint8_t)((int8_t)128 +
2961:main.c        **** 			sineRaw8(rowNum+1+lastThetaOffset));
2962:main.c        **** 
2963:main.c        **** 	uint8_t length; 
2964:main.c        **** 
2965:main.c        **** 	//If the step-size is greater than one pixel, we'll see hashing
2966:main.c        **** 	// this should fix that.
2967:main.c        **** 	if(nextSineVal < sineVal)
2968:main.c        **** 	{
2969:main.c        **** 		length = (sineVal - nextSineVal);
2970:main.c        **** 		//This assures that the additional length of the white-segment
2971:main.c        **** 		// goes in the proper direction...
2972:main.c        **** 		sineVal-=length;//*4;
2973:main.c        **** 	}
2974:main.c        **** 	else if(nextSineVal > sineVal)
2975:main.c        **** 		length = (nextSineVal - sineVal);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 75


2976:main.c        **** 		
2977:main.c        **** 	//But we don't want zero-length white segments (where the sine values
2978:main.c        **** 	// are horizontal)
2979:main.c        **** 	if(length == 0)
2980:main.c        **** 		length = 1;
2981:main.c        **** 
2982:main.c        **** 	uint8_t rgbVal=0;
2983:main.c        **** 	uint8_t J=0;
2984:main.c        **** 	uint8_t j = frameCount;
2985:main.c        **** 
2986:main.c        **** #define WIDTH 5//3//4
2987:main.c        **** 	while(1)
2988:main.c        **** 	{
2989:main.c        **** 		J++;
2990:main.c        **** 		j++; // = J+frameCount;
2991:main.c        **** 		
2992:main.c        **** 		rgbVal = rgbGradient(j);
2993:main.c        **** 
2994:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
2995:main.c        **** 			break;
2996:main.c        **** 
2997:main.c        **** 		addSegfb(WIDTH, rgbVal);
2998:main.c        **** 	}
2999:main.c        **** 
3000:main.c        **** 	J--;
3001:main.c        **** 
3002:main.c        **** 	addSegfb(sineVal-(uint16_t)J*(uint16_t)WIDTH, rgbVal); 
3003:main.c        **** 
3004:main.c        **** 	addSegfb(length, _W); 
3005:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
3006:main.c        **** 
3007:main.c        **** 	addSegfb(3, _W);
3008:main.c        **** 
3009:main.c        **** 	//Draw a sideways character...
3010:main.c        **** 	{
3011:main.c        **** 		addSegfb(3, _R);
3012:main.c        **** 
3013:main.c        **** 		uint8_t i;
3014:main.c        **** 
3015:main.c        **** 		//Without + ' ' we get the same alphabet but shifted
3016:main.c        **** 		// starting with the lower-case letters which are shifted down a row
3017:main.c        **** 	   // and some garbage in the top row...
3018:main.c        **** 		// now I get that I'm reading weird memory locations, but this
3019:main.c        **** 		// doesn't seem right. I should be accessing outside the array 
3020:main.c        **** 		// altogether, no? 	
3021:main.c        **** 		char thisChar = (rowNum/8)%('~'-' '+1) + ' '; //pgm_read_byte(&(string[rowNum/8])); 
3022:main.c        **** 		//'A'; //string[rowNum/8];
3023:main.c        **** 
3024:main.c        **** 		//Ironically, there are exactly the number of characters to be
3025:main.c        **** 		// displayed in 768 lines (plus one on the right, to center)
3026:main.c        **** 		for(i=8; i>0; i--)
3027:main.c        **** 		{
3028:main.c        **** 			if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
3029:main.c        **** 				addSegfb(1, _Y); //0x06, (4<<4) | 3);
3030:main.c        **** 			else
3031:main.c        **** 				addSegfb(1, _R); //0x06, (4<<4) | 0);
3032:main.c        **** 		}
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 76


3033:main.c        **** 
3034:main.c        **** 		addSegfb(3, _R); //0x06, (4<<4) | 0);
3035:main.c        **** 
3036:main.c        **** 		addSegfb(1, _W); //0x04, (6<<4) | 3);
3037:main.c        **** 
3038:main.c        **** 		//PGM_P charPtr = strchrnul_P(
3039:main.c        **** 		PGM_P tqbf = PSTR(" The Quick Brown Fox Jumped Over The Lazy Dog! \177"); 
3040:main.c        **** 		//, rowNum/8);
3041:main.c        **** 
3042:main.c        **** 		strncpy_P(&thisChar, tqbf+(rowNum/8), 1);
3043:main.c        **** 
3044:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0, (6<<4) | 0);
3045:main.c        **** 
3046:main.c        **** 		if(rowNum/8 < strlen_P(tqbf))
3047:main.c        **** 		{
3048:main.c        **** 			for(i=8; i>0; i--)
3049:main.c        **** 			{
3050:main.c        **** 				if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
3051:main.c        **** 					addSegfb(1, rgb(3,0,1));//_C); //0, (6<<4) | 3);
3052:main.c        **** 				else
3053:main.c        **** 					addSegfb(1, rgb(0,0,1));//_B); //0, (6<<4) | 0);
3054:main.c        **** 			}
3055:main.c        **** 		}
3056:main.c        **** 		else
3057:main.c        **** 			addSegfb(8, rgb(0,0,1));//_B); //0,(6<<4) | 0);
3058:main.c        **** 
3059:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0,(6<<4)|0);
3060:main.c        **** 
3061:main.c        **** 	}
3062:main.c        **** 
3063:main.c        **** 	//newSeg(3,0x06,(4<<4) | 0);
3064:main.c        **** 
3065:main.c        **** 	uint8_t i;
3066:main.c        **** 	for(i=0; i<64; i++)
3067:main.c        **** 		addSegfb(1, (i+rowNum/4)&0x3f);
3068:main.c        **** 
3069:main.c        **** 	addSegfb(3, _W); //0x06, (6<<4) | 3);
3070:main.c        **** 
3071:main.c        **** 	segTerminate();
3072:main.c        **** 
3073:main.c        ****  #else //NOT SEG_LINE NOR SEG_SINE NOR ANY OTHERS...
3074:main.c        ****   #if(!defined(SEG_STRETCH))
3075:main.c        **** 	#define SEG_STRETCH 1
3076:main.c        ****   #endif
3077:main.c        **** 
3078:main.c        **** 	segClear();
3079:main.c        **** 
3080:main.c        **** 	//Good for syncing to have white on both borders...
3081:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
3082:main.c        **** 	
3083:main.c        **** 	uint16_t i;
3084:main.c        **** 	//i+1 because we don't want to overwrite the white border...
3085:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
3086:main.c        **** 		rbpix_to_seg(rowBuffer[i], i+1, SEG_STRETCH);
3087:main.c        **** 	
3088:main.c        **** 	//white...
3089:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 77


3090:main.c        **** 	segTerminate();
3091:main.c        ****  #endif //SEG_LINE
3092:main.c        **** #endif //ROW_SEG_BUFFER
3093:main.c        **** }
3094:main.c        **** #endif //LOAD_ROW
3095:main.c        **** 
3096:main.c        **** void init_timer0Hsync(void)
3097:main.c        **** {
3098:main.c        **** 	//T_HD + T_DH + T_low + T_DE
3099:main.c        **** 	// For the original system, 19.865us = 695 dot-clocks
3100:main.c        **** 	// We'd need to take advantage of the 16-bit timer
3101:main.c        **** 	//  OCR1A may not be written properly (with a temporary high-byte)
3102:main.c        **** 	//  ... not sure.
3103:main.c        **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
3104:main.c        **** 
3105:main.c        **** // This is a hack, for testing syncability with long row-calculations
3106:main.c        **** // before actually drawing it... e.g. loading from program memory
3107:main.c        **** // This value needs to be larger than the calculation time
3108:main.c        **** // otherwise, it seems, syncing isn't stable
3109:main.c        **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
3110:main.c        **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
3111:main.c        **** 
3112:main.c        **** #define DISPLAY_CYC_COUNT \
3113:main.c        **** 	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
3114:main.c        **** 
3115:main.c        **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
3116:main.c        **** // apparently an effect of the display, definitely not a code-thing
3117:main.c        **** // in which case the vertical resolution decreases
3118:main.c        **** // though, this could be used to advantage... 
3119:main.c        **** // (e.g. more processing time outside the drawing interrupts?)
3120:main.c        **** // NOTE that if the value is too small and calculations take longer in some
3121:main.c        **** // lines than others (?), those lines may repeat, or syncing could be off
3122:main.c        **** #if (LVDS_PRESCALER == 8)
3123:main.c        ****  //#define ROW_CALCULATION_DELAY 1//20
3124:main.c        ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
3125:main.c        **** #else
3126:main.c        ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
3127:main.c        ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
3128:main.c        **** #endif
3129:main.c        **** 
3130:main.c        **** #define TOTAL_CYC_COUNT \
3131:main.c        **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
3132:main.c        **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
3133:main.c        **** //#define TOTAL_CYC_COUNT 2000
3134:main.c        **** #if (TOTAL_CYC_COUNT > 255)
3135:main.c        ****  //Adding +7 causes it to round up (hopefully)
3136:main.c        ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
3137:main.c        ****  #define TIMER0_CLKDIV	CLKDIV8
3138:main.c        ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
3139:main.c        ****  #if (TIMER0_TCNTS > 255)
3140:main.c        ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
3141:main.c        ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
3142:main.c        ****   #define TIMER0_CLKDIV CLKDIV64
3143:main.c        ****   #if (TIMER0_TCNTS > 255)
3144:main.c        **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
3145:main.c        **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
3146:main.c        **** 	 #define TIMER0_CLKDIV CLKDIV256
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 78


3147:main.c        **** 	 #if (TIMER0_TCNTS > 255)
3148:main.c        **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
3149:main.c        **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
3150:main.c        **** 		#define TIMER0_CLKDIV	CLKDIV1024
3151:main.c        **** 	 #endif
3152:main.c        ****   #endif
3153:main.c        ****  #endif
3154:main.c        ****  #if (TIMER0_TCNTS == 0)
3155:main.c        ****   #error "TIMER0_OCRVAL == 0"
3156:main.c        ****  #endif
3157:main.c        **** #else
3158:main.c        ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
3159:main.c        ****  #define TIMER0_CLKDIV CLKDIV1
3160:main.c        **** #endif
3161:main.c        **** 
3162:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
3163:main.c        ****  //For testing, I want to see the pulses with the 'scope
3164:main.c        ****  // Unless the timer is divisible by 7 the pulses will not align with the
3165:main.c        ****  // timer overflow...
3166:main.c        ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
3167:main.c        ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
3168:main.c        ****  // and we'll only start visualizing *after* the extra TCNTs...
3169:main.c        ****  //Since the timer counts from 0 to (and including) OCR1A
3170:main.c        ****  // Add one to this test...
3171:main.c        ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
3172:main.c        ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
3173:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
3174:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
3175:main.c        **** 
3176:main.c        ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
3177:main.c        ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
3178:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
3179:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
3180:main.c        **** 
3181:main.c        ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
3182:main.c        ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
3183:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
3184:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
3185:main.c        **** 
3186:main.c        ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
3187:main.c        ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
3188:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
3189:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
3190:main.c        **** 
3191:main.c        ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
3192:main.c        ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
3193:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
3194:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
3195:main.c        **** 
3196:main.c        ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
3197:main.c        ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
3198:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
3199:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
3200:main.c        **** 
3201:main.c        ****  #elif (((TIMER0_TCNTS) % 7) == 0)
3202:main.c        ****   #warning "(TIMER0_TCNTS) % 7 == 0"
3203:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 79


3204:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
3205:main.c        **** 
3206:main.c        ****  #else
3207:main.c        ****   #error "WTF?"
3208:main.c        ****  #endif
3209:main.c        **** #else
3210:main.c        ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
3211:main.c        **** #endif
3212:main.c        **** 
3213:main.c        **** #if (TIMER0_OCRVAL > 255)
3214:main.c        ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
3215:main.c        **** #endif
3216:main.c        **** 
3217:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
3218:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
3219:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
3220:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
3221:main.c        **** }
3222:main.c        **** 
3223:main.c        **** //For a first go...
3224:main.c        **** // B5 = OCR=5
3225:main.c        **** // B4 = OCR=6+
3226:main.c        **** // B3 = DT=0
3227:main.c        **** // B2 = DT=1
3228:main.c        **** // Possible combinations:
3229:main.c        **** // B3, B2, B5, B4		OCR>6 (DT=0)
3230:main.c        **** // B3, B2, B5			OCR=5, DT=0
3231:main.c        **** // B3, B2				OCR=4, DT=0
3232:main.c        **** //     B2, B5, B4		OCR=6, DT=1 (is OCR=6 possible?)
3233:main.c        **** //     B2, B5			OCR=5, DT=1
3234:main.c        **** //     B2				OCR=4, DT=1
3235:main.c        **** //         B5, B4		OCR=6, DT=2 (is OCR=6 possible?)
3236:main.c        **** //         B5			OCR=5, DT=2
3237:main.c        **** // OCR=6 is full-on...
3238:main.c        **** 
3239:main.c        **** //            |  0   1    2    3    4    5    6    
3240:main.c        **** //            |____ ____ ____ ____ ____ ____ ____
3241:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X
3242:main.c        **** //            |                  
3243:main.c        **** 
3244:main.c        **** // Active Bits     | Brightness   |
3245:main.c        **** //                 | (0-63)       |    Configuration
3246:main.c        **** // ----------------+--------------+-------------------------
3247:main.c        **** // B5  B4  B3  B2  |     60		 |		OCR>6 (DT=0)  //DC
3248:main.c        **** // B5      B3  B2  |     44 		 |		OCR=5, DT=0
3249:main.c        **** // B5          B2  |     36 		 |		OCR=5, DT=1
3250:main.c        **** // B5              |     32 		 |		OCR=5, DT=2  
3251:main.c        **** //         B3  B2  |     12 		 |		OCR=4, DT=0  //Damn-near black...
3252:main.c        **** //             B2  |     4  		 |		OCR=4, DT=1  //Even closer
3253:main.c        **** // None = Black    |     0        |    OCR=4, DT=2
3254:main.c        **** //
3255:main.c        **** // The colors 60, 44, 36, and 32 are all discernable
3256:main.c        **** // (though 36 and 32 mightn't be if not side-by-side)
3257:main.c        **** // 12, 4, and 0 are damn-near identical and may not be worth the overhead
3258:main.c        **** // There is a SIGNIFICANT jump between 32 and 12
3259:main.c        **** //   32 is I'd say half-bright, maybe more
3260:main.c        **** //   12 is damn-near black
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 80


3261:main.c        **** 
3262:main.c        **** #define fullBlue()	DEblue_init()
3263:main.c        **** 
3264:main.c        **** /*
3265:main.c        **** static __inline__ \
3266:main.c        **** void writeBlue(uint8_t settingVal) \
3267:main.c        **** 	  __attribute__((__always_inline__));
3268:main.c        **** */
3269:main.c        **** 
3270:main.c        **** #if FALSE
3271:main.c        **** #define GREEN_PIN_MASK	0x03
3272:main.c        **** #define GREEN_PORT		PORTA
3273:main.c        **** #define GREEN_ON			0x01
3274:main.c        **** #define GREEN_ON_STRING	"0x01"
3275:main.c        **** #define GREEN_OFF			0x02
3276:main.c        **** #define GREEN_OFF_STRING "0x02"
3277:main.c        **** // in settingVal: bit 3 is unused by blue (4<=OCR<=6), so use it for green
3278:main.c        **** #define GREEN_SETTING_BIT	3
3279:main.c        **** #define GREEN_SETTING_BIT_STRING	"3"
3280:main.c        **** // for setBlue:
3281:main.c        **** #define GREEN_BLUEVAL_BIT	0
3282:main.c        **** 
3283:main.c        **** #define RED_PIN_MASK		0x0C
3284:main.c        **** #define RED_PORT			PORTA
3285:main.c        **** #define RED_ON				0x04
3286:main.c        **** #define RED_ON_STRING	"0x04"
3287:main.c        **** #define RED_OFF			0x08
3288:main.c        **** #define RED_OFF_STRING	"0x08"
3289:main.c        **** #define RED_SETTING_BIT	7
3290:main.c        **** #define RED_SETTING_BIT_STRING "7"
3291:main.c        **** #define RED_BLUEVAL_BIT	1
3292:main.c        **** 
3293:main.c        **** #define REDGREEN_PORT 	RED_PORT
3294:main.c        **** 
3295:main.c        **** 
3296:main.c        **** void writeBlue(uint8_t settingVal)
3297:main.c        **** {
3298:main.c        **** 	//Best to do these calculations first and write the registers later
3299:main.c        **** 	// it's a noticeable change (green is offset a bit, but much less)
3300:main.c        **** 	uint8_t dt = settingVal & 0x70;
3301:main.c        **** 	uint8_t ocr = settingVal & 0x07;
3302:main.c        **** 
3303:main.c        **** 	//The red and green PORT value will be temporarily calculated here...
3304:main.c        **** 	uint8_t redGreen; 
3305:main.c        **** 
3306:main.c        **** 
3307:main.c        **** 	//ASM Notes:
3308:main.c        ****    // avr-libc-user-manual-1.7.0/inline__asm.html
3309:main.c        **** 
3310:main.c        **** 	//This is timing-critical... the amount of time taken in writeBlue
3311:main.c        **** 	// determines the width of each pixel.
3312:main.c        **** 	// Most importantly: if standard C-style if/else statements are used
3313:main.c        **** 	//  it compiles differently each time (based on optimization, etc.)
3314:main.c        **** 	//  Often, though not always, it would compile such that different
3315:main.c        **** 	//  color values would use more instructions than others (branching)...
3316:main.c        **** 	//  It was too unpredictable (and believe me I tried) to code it in C
3317:main.c        **** 	//  and make it consistent. e.g. adding a nop in an else-case caused
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 81


3318:main.c        **** 	//  it to compile using brne, but not adding the nop caused breq
3319:main.c        **** 
3320:main.c        **** 	//Simply: if(getbit(greenBit, settingVal)) 	redGreen=GREEN_ON;
3321:main.c        **** 	//        else											redGreen=GREEN_OFF;
3322:main.c        **** __asm__ __volatile__
3323:main.c        **** 		  //SBRC takes 1 cycle if not skipping, 2 (or 3) if skipping
3324:main.c        **** 	     ( "sbrc %1, " GREEN_SETTING_BIT_STRING "; \n\t"				//0,1
3325:main.c        **** 							//Skip the jump if !getbit(GREEN, settingVal)
3326:main.c        **** 			 "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)	//1-
3327:main.c        **** 			 "ldi  %0, " GREEN_OFF_STRING "; \n\t"							//0-
3328:main.c        **** 			 "rjmp .+4; \n\t"  // skip setting GREEN_ON					//0-
3329:main.c        **** 			 "nop; \n\t"
3330:main.c        **** 			 "ldi  %0, " GREEN_ON_STRING "; \n\t"							//1-
3331:main.c        **** 			: "=r" (redGreen)		//redGreen is assigned to %0
3332:main.c        **** 			: "r"  (settingVal)	//settingVal is assigned to %1
3333:main.c        **** 			);
3334:main.c        **** 	//Simply: if(getbit(redBit, settingVal))		redGreen|=RED_ON;
3335:main.c        **** 	//			 else											redGreen|=RED_OFF;
3336:main.c        **** __asm__ __volatile__
3337:main.c        **** 	     ( "sbrc %1, " RED_SETTING_BIT_STRING "; \n\t"
3338:main.c        ****                      //Skip the jump if !getbit(GREEN, settingVal)
3339:main.c        ****           "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)
3340:main.c        ****           "ori  %2, " RED_OFF_STRING "; \n\t"
3341:main.c        ****           "rjmp .+4; \n\t"  // skip setting GREEN_ON
3342:main.c        ****           "nop; \n\t"
3343:main.c        **** 			 "ori  %2, " RED_ON_STRING "; \n\t"
3344:main.c        ****          : "=r" (redGreen)    //redGreen is assigned to %0
3345:main.c        ****          : "r"  (settingVal),  //settingVal is assigned to %1
3346:main.c        **** 			  "d0"  (redGreen) //d is necessary for ori
3347:main.c        ****          );                 // 0 means 2 is shared with 0 for r/w... 
3348:main.c        **** 									 //(its value is also an input)
3349:main.c        **** 	//See notes in [the new] setBlue()
3350:main.c        **** 
3351:main.c        **** 	//Since instructions are longer than pixels, it's damn-near impossible
3352:main.c        **** 	// to have perfectly sharp edges... this order seems best,
3353:main.c        **** 	// but I haven't experimented much
3354:main.c        **** 	// May be that the reverse order is best when switching from lighter
3355:main.c        **** 	// to darker, which would require more overhead to detect
3356:main.c        **** 	// making pixels even longer. Best to have a single-LCD-pixel of ugly
3357:main.c        **** 	// than to make displayable pixels wider, reducing resolution...
3358:main.c        **** 	OCR1A = ocr;
3359:main.c        **** 	DT1 = dt;
3360:main.c        **** 	REDGREEN_PORT = redGreen;
3361:main.c        **** 
3362:main.c        **** 	//This is just to try to mimic 17's timing...
3363:main.c        **** 	// (right now, there's some timing issues, 
3364:main.c        **** 	//   line seems to start somewhat randomly, near the right edge
3365:main.c        **** 	//   some PIXEL_SCROLLs give static...)
3366:main.c        **** 	// <= 46 optimizes out, somehow, even though the code-size is larger
3367:main.c        **** 	// Should be fixed now... (see delay_cyc hacks)
3368:main.c        **** //	delay_Dots(15);
3369:main.c        **** 
3370:main.c        **** }
3371:main.c        **** #endif //FALSE
3372:main.c        **** 
3373:main.c        **** static __inline__ \
3374:main.c        **** void writeColor(uint8_t colorVal) \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 82


3375:main.c        **** 	  __attribute__((__always_inline__));
3376:main.c        **** 
3377:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3378:main.c        **** //THIS IS JUST AN ESTIMATE
3379:main.c        ****  #define WRITE_COLOR_CYCS	(13)
3380:main.c        **** #elif(defined(FOUR_SHADES) && FOUR_SHADES)
3381:main.c        ****  // Roughly...
3382:main.c        ****  #define WRITE_COLOR_CYCS	(12*2+9+3)
3383:main.c        **** #else
3384:main.c        ****  // Roughly...
3385:main.c        ****  #define WRITE_COLOR_CYCS	(9*3+3)
3386:main.c        **** #endif
3387:main.c        **** 
3388:main.c        **** void writeColor(uint8_t colorVal)
3389:main.c        **** {
3390:main.c        **** //#warning "I'm absolutely certain this'll need to be revised, probably asm"
3391:main.c        **** 	//   Red: (+OC1D => RX0+)
3392:main.c        **** 	//    Off (0/63): OCR1D = 0
3393:main.c        **** 	//    35/63:      OCR1D = 3
3394:main.c        **** 	//    63/63:      OCR1D >= 6
3395:main.c        **** 
3396:main.c        **** /* No Shit: This compiles to a 16-bit test!
3397:main.c        **** 	switch((uint8_t)(colorVal & (uint8_t)0x03))
3398:main.c        **** 	{
3399:main.c        **** 		case (uint8_t)0:
3400:main.c        **** 			OCR1D = 0;
3401:main.c        **** 			break;
3402:main.c        **** 		case (uint8_t)1:
3403:main.c        **** 			OCR1D = 3;
3404:main.c        **** 			break;
3405:main.c        **** 		case (uint8_t)2:
3406:main.c        **** 		default:
3407:main.c        **** 			OCR1D = 6;
3408:main.c        **** 			break;
3409:main.c        **** 	}
3410:main.c        **** */
3411:main.c        **** 
3412:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3413:main.c        **** 	// In this case, colorVal is actually settingVal...
3414:main.c        **** 	// Between LDI, these instructions, and OCR/DT register writes
3415:main.c        **** 	// this is 14 cycles... or 16 pixels...
3416:main.c        **** 
3417:main.c        **** 	//										//ldi (colorVal) (2 cyc)
3418:main.c        **** 	//Red: (temp)
3419:main.c        **** 	uint8_t ocrd = colorVal >> 2;	//mov, shl, shl
3420:main.c        **** 	//Green:
3421:main.c        **** 	uint8_t dt = colorVal & 0x03; //andi
3422:main.c        **** 	//Blue:
3423:main.c        **** 	uint8_t ocra = ocrd >> 3;		//mov, shl, shl, shl
3424:main.c        **** 	//And red...
3425:main.c        **** 	ocrd &= 0x07;						//andi
3426:main.c        **** 											//out OCRD, out DT, out OCRA
3427:main.c        **** 
3428:main.c        **** #else //NOT ROW_BUFFER (FRAMEBUFFER)
3429:main.c        **** 
3430:main.c        **** //	uint8_t redVal; // = colorVal & 0x03;
3431:main.c        **** 	uint8_t ocrd;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 83


3432:main.c        **** 
3433:main.c        **** /*
3434:main.c        **** 	if(redVal == 0x00)
3435:main.c        **** 		ocrd = 0;
3436:main.c        **** 	else if(redVal == 0x01)
3437:main.c        **** 		ocrd = 3;
3438:main.c        **** 	else //2, 3
3439:main.c        **** 		ocrd = 6;
3440:main.c        **** */
3441:main.c        **** #if(defined(FOUR_SHADES) && FOUR_SHADES)
3442:main.c        ****  // "nop; nop; nop;" compiles to just a single nop! 
3443:main.c        ****  //"\n\t" or maybe the space is necessary
3444:main.c        ****  #define FOUR_SHADES_NOPS "nop ; \n\t nop ; \n\t nop ; \n\t"
3445:main.c        **** #else
3446:main.c        ****  #define FOUR_SHADES_NOPS "\n\t"
3447:main.c        **** #endif
3448:main.c        **** 	//Each branch is 9 cycles... (12 with FOUR_SHADES)
3449:main.c        **** __asm__ __volatile__
3450:main.c        **** 	( "mov 	%0, %1 	; \n\t"	// ocrd (redVal) = colorVal			  //1
3451:main.c        **** 	  "andi	%0, 0x03	; \n\t"	// ocrd = ocrd & 0x03					  //1
3452:main.c        **** 	  "brne	red1tst_%=; \n\t"	// if(ocrd != 0x00) jump to red1test  //1`2
3453:main.c        **** 	  "ldi   %0, 0x00	; \n\t"	// (ocrd==0x00) add some delays		  //1 .
3454:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
3455:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
3456:main.c        **** 	  "nop				; \n\t"  //                                    //1 .
3457:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //N .
3458:main.c        **** 	  "rjmp  end_%=	; \n\t"	//   jump to the end						  //2 .
3459:main.c        **** 	  									// (ocrd_reg = redVal_reg = 0)            .
3460:main.c        **** 	"red1tst_%=:"					//"%=" is a unique identifier for this asm.
3461:main.c        **** 										//  invocation, so the label won't be     .
3462:main.c        **** 										//  mistaken from another invocation      .
3463:main.c        **** 	  "cpi	%0, 0x01	; \n\t"	// if(ocrd-0x01 != 0)					  //  1
3464:main.c        **** 	  "brne	red23_%=	; \n\t"	//   jump to red=2,3						  //  1`2
3465:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //  N .
3466:main.c        **** 	  "ldi	%0, 0x03	; \n\t"	// else ocrd = 0x03                   //  1 .
3467:main.c        **** 	  "rjmp	end_%=	; \n\t"	//      jump to the end               //  2 .
3468:main.c        **** 	"red23_%=:"                                                      //    .
3469:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3470:main.c        **** 	  "cpi	%0, 0x02 ; \n\t"	// if(ocrd-0x02 !=0)                  //( . 1
3471:main.c        **** 	  "brne  red3_%=	; \n\t"	//		jump to red=3                   //( . 1`2
3472:main.c        **** 	  "ldi   %0, 0x04 ; \n\t"	// else ocrd=4                        //( . 1 .
3473:main.c        **** 	  "rjmp  end_%=	; \n\t"	//      jump to the end               //( . 2 .
3474:main.c        **** 	"red3_%=:"                                                       //( .   /
3475:main.c        **** #endif                                                              //(  \ /
3476:main.c        ****      "ldi	%0, 0x06	; \n\t"	// ocrd = 0x06                        //    1
3477:main.c        **** 	  "nop				; \n\t"  // one delay...							  //    1
3478:main.c        ****   "end_%=:"
3479:main.c        **** 
3480:main.c        **** 	  : "=r" (ocrd)      //Output only "%0"
3481:main.c        **** 	  : "r"  (colorVal)  //colorVal is "%1"
3482:main.c        **** 	  //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3483:main.c        **** 	);
3484:main.c        **** 
3485:main.c        **** 
3486:main.c        **** //	OCR1D = ocrd;
3487:main.c        **** 
3488:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 84


3489:main.c        **** 	//   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
3490:main.c        **** 	//    Off (6/63): DTL1 = 0
3491:main.c        **** 	//    38-39/63:      DTL1 = 1
3492:main.c        **** 	//    62-63/63:      DTL1 = 3
3493:main.c        **** /*	switch(colorVal & 0x0C)
3494:main.c        **** 	{
3495:main.c        **** 		case 0x00:
3496:main.c        **** 			DT1 = 0;
3497:main.c        **** 			break;
3498:main.c        **** 		case 0x04:
3499:main.c        **** 			DT1 = 1;
3500:main.c        **** 			break;
3501:main.c        **** 		case 0x08:
3502:main.c        **** 		default:
3503:main.c        **** 			DT1 = 3;
3504:main.c        **** 			break;
3505:main.c        **** 	}
3506:main.c        **** */
3507:main.c        **** //	uint8_t greenVal = colorVal & 0x0C;
3508:main.c        **** 	uint8_t dt;
3509:main.c        **** /*	if(greenVal == 0x00)
3510:main.c        **** 		dt=0;
3511:main.c        **** 	else if(greenVal == 0x04)
3512:main.c        **** 		dt=1;
3513:main.c        **** 	else //0x06, 0x0C
3514:main.c        **** 		dt=3;
3515:main.c        **** */
3516:main.c        ****    //Each branch is 9 cycles... (12 with FOUR_SHADES)
3517:main.c        **** __asm__ __volatile__
3518:main.c        ****    ( "mov   %0, %1   ; \n\t"  // dt (greenVal) = colorVal           //1
3519:main.c        ****      "andi  %0, 0x0C ; \n\t"  // dt = dt & 0x0C                     //1
3520:main.c        ****      "brne  grn4tst_%=; \n\t" // if(dt != 0x00) jump to grn4test    //1`2
3521:main.c        ****      "ldi   %0, 0x00 ; \n\t"  // (dt==0x00) add some delays         //1 .
3522:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3523:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3524:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3525:main.c        ****      FOUR_SHADES_NOPS         //                                    //N .
3526:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3527:main.c        ****    "grn4tst_%=:"              //"%=" is a unique identifier for this asm.
3528:main.c        ****                               //  invocation, so the label won't be     .
3529:main.c        ****                               //  mistaken from another invocation      .
3530:main.c        ****      "cpi   %0, 0x04 ; \n\t"  // if(dt-0x04 != 0)                   //  1
3531:main.c        ****      "brne  grn8C_%= ; \n\t"  //   jump to green=8,C                //  1`2
3532:main.c        ****      "ldi   %0, 0x01 ; \n\t"  // else dt = 0x01                     //  1 .
3533:main.c        ****      FOUR_SHADES_NOPS         //                                    //  N .
3534:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3535:main.c        ****    "grn8C_%=:"                                                      //    .
3536:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3537:main.c        ****      "cpi   %0, 0x08 ; \n\t"  // if(dt-0x08 !=0)                    //( . 1
3538:main.c        ****      "brne  grn3_%=  ; \n\t"  //    jump to green=3                 //( . 1`2
3539:main.c        ****      "ldi   %0, 0x02 ; \n\t"  // else dt=2                          //( . 1 .
3540:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //( . 2 .
3541:main.c        ****    "grn3_%=:"                                                       //( .   /
3542:main.c        **** #endif                                                              //(  \ /
3543:main.c        ****      "ldi   %0, 0x03 ; \n\t"  // dt = 0x03                          //    1
3544:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3545:main.c        ****    "end_%=:"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 85


3546:main.c        **** 
3547:main.c        ****      : "=r" (dt)      //Output only "%0"
3548:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3549:main.c        ****      //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3550:main.c        ****    );
3551:main.c        **** 
3552:main.c        **** 
3553:main.c        **** 
3554:main.c        **** //	DT1 = dt;
3555:main.c        **** 	//   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
3556:main.c        **** 	//    Off (15/63):  OCR1A=4
3557:main.c        **** 	//    47/63:        OCR1A=5
3558:main.c        **** 	//    63/63:        OCR1A=6
3559:main.c        **** /*	switch(colorVal & 0x30)
3560:main.c        **** 	{
3561:main.c        **** 		case 0x00:
3562:main.c        **** 			OCR1A = 4;
3563:main.c        **** 			break;
3564:main.c        **** 		case 0x10:
3565:main.c        **** 			OCR1A = 5;
3566:main.c        **** 			break;
3567:main.c        **** 		case 0x20:
3568:main.c        **** 		default:
3569:main.c        **** 			OCR1A = 6;
3570:main.c        **** 			break;
3571:main.c        **** 	}
3572:main.c        **** */
3573:main.c        **** //	uint8_t blueVal = colorVal & 0x30;
3574:main.c        **** 	uint8_t ocra;
3575:main.c        **** /*	if(blueVal == 0x00)
3576:main.c        **** 		ocra=4;
3577:main.c        **** 	else if(blueVal == 0x10)
3578:main.c        **** 		ocra=5;
3579:main.c        **** 	else //0x20, 0x30
3580:main.c        **** 		ocra=6;
3581:main.c        **** */
3582:main.c        **** 
3583:main.c        ****    //Each branch is 9 cycles...
3584:main.c        **** __asm__ __volatile__
3585:main.c        ****    ( "mov   %0, %1   ; \n\t"  // ocra (blueVal) = colorVal          //1
3586:main.c        ****      "andi  %0, 0x30 ; \n\t"  // ocra = ocra & 0x30                 //1
3587:main.c        ****      "brne  blu1tst_%=; \n\t" // if(ocra != 0x00) jump to red1test  //1`2
3588:main.c        ****      "ldi   %0, 0x04 ; \n\t"  // (ocra==0x00) add some delays       //1 .
3589:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3590:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3591:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3592:main.c        ****      "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3593:main.c        ****                               // (ocra_reg = blueVal_reg = 0)            .
3594:main.c        ****    "blu1tst_%=:"              //"%=" is a unique identifier for this asm.
3595:main.c        ****                               //  invocation, so the label won't be     .
3596:main.c        ****                               //  mistaken from another invocation      .
3597:main.c        ****      "cpi   %0, 0x10 ; \n\t"  // if(ocra-0x10 != 0)                 //  1
3598:main.c        ****      "brne  blu23_%= ; \n\t"  //   jump to red=2,3                  //  1`2
3599:main.c        ****      "ldi   %0, 0x05 ; \n\t"  // else ocra = 0x05                   //  1 .
3600:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3601:main.c        ****    "blu23_%=:"                                                      //    .
3602:main.c        ****      "ldi   %0, 0x06 ; \n\t"  // ocra = 0x06                        //    1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 86


3603:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3604:main.c        ****    "end_%=:"
3605:main.c        **** 
3606:main.c        ****      : "=r" (ocra)      //Output only "%0"
3607:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3608:main.c        ****      //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
3609:main.c        ****    );
3610:main.c        **** 
3611:main.c        **** #endif //SETTING vs. FRAMEBUFFER
3612:main.c        **** 
3613:main.c        **** 	DT1 = dt;
3614:main.c        **** 	OCR1D = ocrd;
3615:main.c        **** 	OCR1A=ocra;
3616:main.c        **** }
3617:main.c        **** 
3618:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
3619:main.c        **** void setColor(uint8_t red, uint8_t green, uint8_t blue, 
3620:main.c        **** 					uint8_t row, uint8_t col)
3621:main.c        **** {
3622:main.c        **** 	red = (red > 3) ? 3 : red;
3623:main.c        **** 	green = (green > 3) ? 3 : green;
3624:main.c        **** 	blue = (blue > 3) ? 3 : blue;
3625:main.c        **** 
3626:main.c        **** 	frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
3627:main.c        **** }
3628:main.c        **** #endif
3629:main.c        **** 
3630:main.c        **** /*
3631:main.c        **** void setBlue(uint8_t val, uint8_t r, uint8_t c)
3632:main.c        **** {
3633:main.c        **** 	//Each If statement consists of (rougly):
3634:main.c        **** 	//  comparison (cpi)
3635:main.c        **** 	//  jump if false to next (brcs)
3636:main.c        **** 	//    load immediate -> register
3637:main.c        **** 	//    out OCR1a <- register
3638:main.c        **** 	//    load immediate -> register
3639:main.c        **** 	//    out DT1 <- register
3640:main.c        **** 	//    jump to end of If's...
3641:main.c        **** 
3642:main.c        **** 	//THUS: the brighter the color, the fewer cycles are executed
3643:main.c        **** 	// (fewer comparisons, fewer jumps)
3644:main.c        **** 	
3645:main.c        **** 	// One option: insert NOPs...
3646:main.c        **** 	// Another option (and probably better all 'round):
3647:main.c        **** 	//   Store the OCR1A and DT1 values in the settingBuffer
3648:main.c        **** 	//   instead of storing the color value
3649:main.c        **** 	//   (IOW: do this test when writing the "settingBuffer"
3650:main.c        **** 	//    instead of when reading)
3651:main.c        **** 	//   Then, here, just write OCR1A and DT1
3652:main.c        **** 	//   If a single-byte is used for both, DT1 could be written directly
3653:main.c        **** 	//     e.g. blueSetting=(DTVal<<4) | OCR1AVal
3654:main.c        **** 	//     DT1 = blueSetting; //OK since /OCR1n outputs are unused
3655:main.c        **** 	//     OCR1A = (blueSetting & 0x0f);
3656:main.c        **** 
3657:main.c        **** 
3658:main.c        **** 
3659:main.c        ****    // | (val & GREEN_SETTING_BIT)  is a hack a/o v20, for GREEN
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 87


3660:main.c        ****    uint8_t green =
3661:main.c        ****       getbit(GREEN_BLUEVAL_BIT, val) ? (1<<GREEN_SETTING_BIT) : 0 ;
3662:main.c        ****    uint8_t red =
3663:main.c        ****       getbit(RED_BLUEVAL_BIT, val) ? (1<<RED_SETTING_BIT) : 0 ;
3664:main.c        **** 
3665:main.c        ****    uint8_t redGreen = green | red;
3666:main.c        **** 
3667:main.c        **** 
3668:main.c        **** 
3669:main.c        **** #if(defined(DC_DE_DISABLE) && DC_DE_DISABLE)
3670:main.c        **** // #define NUM_BLUES 5		//Currently Unused... (not including black)
3671:main.c        **** #else
3672:main.c        **** // #define NUM_BLUES 6		//Currently Unused... (not including black)
3673:main.c        **** 
3674:main.c        **** 	if(val>=(60<<2)) 
3675:main.c        **** 	{
3676:main.c        **** 		//OCR1A = 0xff;
3677:main.c        **** 		settingBuffer[r][c] = (0<<4) | 6 | redGreen;
3678:main.c        **** 	}
3679:main.c        **** 	else
3680:main.c        **** #endif
3681:main.c        **** 	if(val >= (44<<2))
3682:main.c        **** 	{
3683:main.c        **** 		//OCR1A = 5;
3684:main.c        **** 		//DT1 = (0<<4);
3685:main.c        **** 		settingBuffer[r][c] = (0<<4) | 5 | redGreen;
3686:main.c        **** 	}
3687:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3688:main.c        **** 	else if(val >= (36<<2)) //OK
3689:main.c        **** 	{
3690:main.c        **** 		//OCR1A = 5;
3691:main.c        **** 		//DT1 = (1<<4);
3692:main.c        **** 		settingBuffer[r][c] = (1<<4) | 5 | redGreen;
3693:main.c        **** 	}
3694:main.c        **** 	else if(val >= (32<<2)) //OK
3695:main.c        **** 	{
3696:main.c        **** 		//DT1=(2<<4);
3697:main.c        **** 		//OCR1A = 5;
3698:main.c        **** 		settingBuffer[r][c] = (2<<4) | 5 | redGreen;
3699:main.c        **** 	}
3700:main.c        **** 	else if(val >= (12<<2)) //DIM
3701:main.c        **** #else //DT0_BLUES_ONLY
3702:main.c        **** 	else //Closest to black we can get with DT=0
3703:main.c        **** #endif
3704:main.c        **** 	{
3705:main.c        **** 		//DT1=(0<<4);
3706:main.c        **** 		//OCR1A = 4;
3707:main.c        **** 		settingBuffer[r][c] = (0<<4) | 4 | redGreen;
3708:main.c        **** 	}
3709:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3710:main.c        **** 	else if(val >= (4<<2)) //DIM
3711:main.c        **** 	{
3712:main.c        **** 		//DT1=(1<<4);
3713:main.c        **** 		//OCR1A = 4;
3714:main.c        **** 		settingBuffer[r][c] = (1<<4) | 4 | redGreen;
3715:main.c        **** 	}
3716:main.c        **** 	else	//Black
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 88


3717:main.c        **** 	{
3718:main.c        **** 		//DT1=(2<<4);
3719:main.c        **** 		//OCR1A = 4;
3720:main.c        **** 		settingBuffer[r][c] = (2<<4) | 4 | redGreen;
3721:main.c        **** 	}
3722:main.c        **** #endif
3723:main.c        **** }
3724:main.c        **** */
3725:main.c        **** 
3726:main.c        **** /*
3727:main.c        **** static __inline__ \
3728:main.c        **** void drawPix(uint8_t rowNum) \
3729:main.c        **** 	  __attribute__((__always_inline__));
3730:main.c        **** */
3731:main.c        **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
3732:main.c        **** void drawPix(uint8_t rowNum)
3733:main.c        **** {
3734:main.c        **** 	//uint8_t *setting = &(settingBuffer[rowNum][0]);
3735:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3736:main.c        **** 	uint8_t *color = &(rowBuffer[0]);
3737:main.c        **** #else
3738:main.c        **** 	uint8_t *color = &(frameBuffer[rowNum][0]);
3739:main.c        **** #endif
3740:main.c        **** 	/*
3741:main.c        ****       DEonly_fromNada();
3742:main.c        ****       //Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
3743:main.c        ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3744:main.c        ****                | (0<<COM1B1) | (1<<COM1B0)
3745:main.c        ****                | (1<<PWM1A) | (1<<PWM1B) );
3746:main.c        **** 	*/
3747:main.c        **** 		//The Greenish-bar on the left is due to the time it takes to execute
3748:main.c        **** 		// the first writeColor (since its value is only written at the END)
3749:main.c        **** 		// Thus the greenish-bar is about one write-color wide...
3750:main.c        **** 
3751:main.c        **** 	//Judging by some weird experiences re v21/22,
3752:main.c        **** 	// it's not entirely likely this will be predictable
3753:main.c        **** 	// it may try to recalculate the Z register between writeBlues...
3754:main.c        **** 	// hopefully not, for now. I should probably assemblify this
3755:main.c        **** 		writeColor(*(color+0));
3756:main.c        **** 
3757:main.c        **** 		//Moving this here not only removes (most of) the green bar
3758:main.c        **** 		// but also seems to make the pixel edges significantly sharper
3759:main.c        **** 		// (v29 has ~1/8in of noise, v30 has ~1pixel noise at the right edge)
3760:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3761:main.c        **** 		         | (0<<COM1B1) | (1<<COM1B0)
3762:main.c        **** 		         | (1<<PWM1A) | (1<<PWM1B) );
3763:main.c        **** 
3764:main.c        **** 		writeColor(*(color+1));	 
3765:main.c        **** 		writeColor(*(color+2));	 
3766:main.c        **** 		writeColor(*(color+3)); 
3767:main.c        **** 		writeColor(*(color+4));	 
3768:main.c        **** 		writeColor(*(color+5));					 
3769:main.c        **** 		writeColor(*(color+6));  
3770:main.c        **** 		writeColor(*(color+7));                         
3771:main.c        **** 		writeColor(*(color+8));                         
3772:main.c        **** 		writeColor(*(color+9));                         
3773:main.c        **** 		writeColor(*(color+10));                         
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 89


3774:main.c        **** 		writeColor(*(color+11));                         
3775:main.c        **** 		writeColor(*(color+12));                         
3776:main.c        **** 		writeColor(*(color+13));                         
3777:main.c        **** 		writeColor(*(color+14));                         
3778:main.c        **** 		writeColor(*(color+15));   
3779:main.c        **** #define COLORS_WRITTEN	16		
3780:main.c        **** #if ( (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL) \
3781:main.c        **** 	|| (defined(ROW_BUFFER) && (ROW_BUFFER)) )
3782:main.c        **** 		writeColor(*(color+16));
3783:main.c        **** 		writeColor(*(color+17));
3784:main.c        **** 		writeColor(*(color+18));
3785:main.c        **** 		writeColor(*(color+19));
3786:main.c        **** writeColor(*(color+20));
3787:main.c        **** writeColor(*(color+21));
3788:main.c        **** writeColor(*(color+22));
3789:main.c        **** writeColor(*(color+23));
3790:main.c        **** writeColor(*(color+24));
3791:main.c        **** writeColor(*(color+25));
3792:main.c        **** writeColor(*(color+26));
3793:main.c        **** writeColor(*(color+27));
3794:main.c        **** #define COLORS_WRITTEN	28
3795:main.c        **** #if (defined(ROW_BUFFER) && (ROW_BUFFER))
3796:main.c        **** writeColor(*(color+28));
3797:main.c        **** writeColor(*(color+29));
3798:main.c        **** writeColor(*(color+30));
3799:main.c        **** writeColor(*(color+31));
3800:main.c        **** //Some sort of syncing problem after 32... (?)
3801:main.c        **** 
3802:main.c        **** writeColor(*(color+32));
3803:main.c        **** writeColor(*(color+33));
3804:main.c        **** writeColor(*(color+34));
3805:main.c        **** writeColor(*(color+35));
3806:main.c        **** writeColor(*(color+36));
3807:main.c        **** writeColor(*(color+37));
3808:main.c        **** writeColor(*(color+38));
3809:main.c        **** writeColor(*(color+39));
3810:main.c        **** writeColor(*(color+40));
3811:main.c        **** writeColor(*(color+41));
3812:main.c        **** writeColor(*(color+42));
3813:main.c        **** writeColor(*(color+43));
3814:main.c        **** writeColor(*(color+44));
3815:main.c        **** writeColor(*(color+45));
3816:main.c        **** writeColor(*(color+46));
3817:main.c        **** writeColor(*(color+47));
3818:main.c        **** writeColor(*(color+48));
3819:main.c        **** writeColor(*(color+49));
3820:main.c        **** writeColor(*(color+50));
3821:main.c        **** writeColor(*(color+51));
3822:main.c        **** writeColor(*(color+52));
3823:main.c        **** writeColor(*(color+53));
3824:main.c        **** writeColor(*(color+54));
3825:main.c        **** writeColor(*(color+55));
3826:main.c        **** writeColor(*(color+56));
3827:main.c        **** writeColor(*(color+57));
3828:main.c        **** writeColor(*(color+58));
3829:main.c        **** writeColor(*(color+59));
3830:main.c        **** writeColor(*(color+60));
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 90


3831:main.c        **** writeColor(*(color+61));
3832:main.c        **** writeColor(*(color+62));
3833:main.c        **** writeColor(*(color+63));
3834:main.c        **** // WriteColor writes the pixel *after* the calculations...
3835:main.c        **** // thus the pixel appears basically after writeColor completes
3836:main.c        **** // These nops assure the 64th pixel is fully-displayed before exitting
3837:main.c        **** // (Not sure how the other following instructions apply to this)
3838:main.c        **** // The number of nops was found experimentally...
3839:main.c        **** asm("nop");
3840:main.c        **** asm("nop");
3841:main.c        **** asm("nop");
3842:main.c        **** asm("nop");
3843:main.c        **** asm("nop");
3844:main.c        **** asm("nop");
3845:main.c        **** asm("nop");
3846:main.c        **** asm("nop");
3847:main.c        **** //count "0" below, as well..
3848:main.c        **** #define COLORS_WRITTEN 65
3849:main.c        **** #endif //ROW_BUFFER
3850:main.c        **** #else
3851:main.c        **** //	writeColor(0);
3852:main.c        **** #endif //COLOR_BARS || ROW_BUFFER
3853:main.c        **** 
3854:main.c        **** /*		reg[17] = colorBuffer[rowNum][17];                         
3855:main.c        **** 		writeColor(reg[17]);                         
3856:main.c        **** 		...
3857:main.c        **** 		reg[20] = colorBuffer[rowNum][20];                         
3858:main.c        **** 		writeColor(reg[20]);  
3859:main.c        **** 		
3860:main.c        **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
3861:main.c        **** 		reg[0] = colorBuffer[rowNum][0];
3862:main.c        **** 		writeColor(reg[0]);
3863:main.c        **** 		...
3864:main.c        **** 		reg[10] = colorBuffer[rowNum][10];
3865:main.c        **** 		writeColor(reg[10]);
3866:main.c        **** */
3867:main.c        **** 		//Display the rest as black...
3868:main.c        **** 		writeColor(0);
3869:main.c        **** 		//writeColor(0xff);
3870:main.c        **** 	  	//delay_Dots(500);//142); //Don't want to disable DE too early...	
3871:main.c        **** 		//900 leaves a buffer for various calculations while also showing
3872:main.c        **** 		// a blue bar at the right-side...
3873:main.c        **** 		//LTN Last Used 900
3874:main.c        **** 		// -68 is from 900's intent, IIRC
3875:main.c        **** 		//  seems arbitrary, but its value (especially if too small)
3876:main.c        **** 		// causes blank lines... (?!)
3877:main.c        **** 		// -60 makes more sense for a delay (was the original post-900)
3878:main.c        **** 		//  (outside DOTS_TO_CYC because it's for cycles used for calcs...
3879:main.c        **** 		// -68 worked for LVDS_PRE=2
3880:main.c        **** 		// -60 for 1
3881:main.c        **** 		// 4 doesn't work... blue-lines
3882:main.c        **** 
3883:main.c        **** #else		//ROW_SEG_BUFFER
3884:main.c        **** void drawPix(uint8_t rowNum)
3885:main.c        **** {
3886:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3887:main.c        **** 	         | (0<<COM1B1) | (1<<COM1B0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 91


3888:main.c        **** 	         | (1<<PWM1A) | (1<<PWM1B) );
3889:main.c        **** 
3890:main.c        **** 		drawSegs();
3891:main.c        **** 
3892:main.c        **** #if (defined(GB_COMBINED) && GB_COMBINED)
3893:main.c        ****  #define WRITE_COLOR_CYCS 20
3894:main.c        **** #else
3895:main.c        ****  #define WRITE_COLOR_CYCS 16
3896:main.c        **** #endif
3897:main.c        **** #define COLORS_WRITTEN	64
3898:main.c        **** 
3899:main.c        **** #endif
3900:main.c        **** 
3901:main.c        **** 
3902:main.c        **** 
3903:main.c        **** #define ROW_COMPLETION_DELAY \
3904:main.c        **** 		(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60  \
3905:main.c        **** 		 - WRITE_COLOR_CYCS * COLORS_WRITTEN)
3906:main.c        **** /*
3907:main.c        **** 
3908:main.c        **** #error "should add SEG_STRETCH here..."
3909:main.c        **** #if (ROW_COMPLETION_DELAY > 0)
3910:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60 // - 68)// - 60
3911:main.c        **** 				- WRITE_COLOR_CYCS*COLORS_WRITTEN);
3912:main.c        **** #else
3913:main.c        **** #warning "ROW_COMPLETION_DELAY <= 0"
3914:main.c        **** #endif
3915:main.c        **** */		//DE->Nada transition expects fullBlue...
3916:main.c        **** 		//Also helps to show the edge of the DE timing...
3917:main.c        **** 
3918:main.c        **** 		//!!! Not sure what the state is at this point...
3919:main.c        **** 		// could be any DE+Blue level, or could be NADA...
3920:main.c        **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
3921:main.c        ****          
3922:main.c        **** 		//Among the things that don't make sense...
3923:main.c        **** 		// This appears to go into affect BEFORE delay_cyc (?)
3924:main.c        **** 		// as, without a pull-up resistor on the /OC1B output, 
3925:main.c        **** 		// green seems to be floating between the last pixel and the
3926:main.c        **** 		// delay_cyc (!)
3927:main.c        **** 		//Disable complementary-output for Green 
3928:main.c        **** 		//  (on /OC1B, where CLK is OC1B)
3929:main.c        **** 		// Since Nada, V, and H DT's might be bad for clocking.
3930:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3931:main.c        ****          | (1<<COM1B1) | (0<<COM1B0)
3932:main.c        ****          | (1<<PWM1A) | (1<<PWM1B) );
3933:main.c        **** 
3934:main.c        **** 		fullBlue();
3935:main.c        **** 		Nada_fromDEonly();
3936:main.c        **** }
3937:main.c        **** 
3938:main.c        **** #if 0   //in LCDStuff...
3939:main.c        **** // SCOPING has been removed in LVDS, revisit LCDdirect50
3940:main.c        **** //#else //NOT SCOPING
3941:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable)
3942:main.c        **** {
3943:main.c        **** 	//H Active pulse...
3944:main.c        ****    if(vSync)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 92


3945:main.c        ****    {
3946:main.c        **** 		//Vsync_fromNada() is called at the end of the last interupt
3947:main.c        ****       VplusH_fromVsync();
3948:main.c        ****       Hlow_Delay();
3949:main.c        ****       Vsync_fromVplusH();
3950:main.c        ****       HD_Delay();
3951:main.c        ****    }
3952:main.c        ****    else
3953:main.c        ****    {
3954:main.c        ****       Hsync_fromNada();
3955:main.c        ****       Hlow_Delay();
3956:main.c        ****       Nada_fromHsync();
3957:main.c        ****       HD_Delay();
3958:main.c        ****    }
3959:main.c        **** 
3960:main.c        ****    if(dataEnable)
3961:main.c        ****    {
3962:main.c        **** 
3963:main.c        **** /* WTF, how did this work?! Am I not using drawPix?!
3964:main.c        **** 	Yes, but drawPix calls drawSegs, which doesn't have an argument
3965:main.c        **** 	because loadRow takes the row argument elsewhere, drawSegs just
3966:main.c        **** 	draws 'em
3967:main.c        **** 		//#warning "see 'shouldBe' here..."
3968:main.c        **** 		//Should be:
3969:main.c        **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
3970:main.c        **** 		//rowNum = rowNum / (768/FB_HEIGHT);
3971:main.c        **** */
3972:main.c        **** 
3973:main.c        **** 		//DEonly_fromNada();
3974:main.c        ****       drawPix(rowNum);
3975:main.c        **** 		//Nada_init();
3976:main.c        **** //#warning "THIS ISN'T SAFE"
3977:main.c        **** //		Nada_fromDEonly();
3978:main.c        **** //#endif
3979:main.c        **** 
3980:main.c        **** 	}
3981:main.c        **** }
3982:main.c        **** #endif
3983:main.c        **** /* These are old tests from above, under if(dataEnable)
3984:main.c        **** 	They should all be implemented in lcdStuff.c, but have not been
3985:main.c        **** 	retested since...
3986:main.c        **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
3987:main.c        **** 		uint16_t blueCyc = DOTS_TO_CYC(rowNum);
3988:main.c        **** 		uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
3989:main.c        **** 		
3990:main.c        **** 		DEonly_fromNada();
3991:main.c        **** 		delay_cyc(notBlueCyc);
3992:main.c        **** 		DEblue_fromDEonly();
3993:main.c        **** 		delay_cyc(blueCyc);
3994:main.c        **** 
3995:main.c        **** 		Nada_fromDEblue();
3996:main.c        **** #elif(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
3997:main.c        **** 		DEonly_fromNada();
3998:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
3999:main.c        **** 		DEblue_fromDEonly();
4000:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
4001:main.c        **** 		Nada_fromDEblue();
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 93


4002:main.c        **** #elif(defined(DE_BLUE) && DE_BLUE)
4003:main.c        **** 		DEblue_fromNada();
4004:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
4005:main.c        **** 		Nada_fromDEblue();
4006:main.c        **** #else  //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
4007:main.c        ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
4008:main.c        **** 		if(rowNum <= 256)
4009:main.c        **** 			rowNum=0;
4010:main.c        **** 		else
4011:main.c        **** 			rowNum=1;
4012:main.c        ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
4013:main.c        **** */
4014:main.c        **** 
4015:main.c        **** //Moved Above
4016:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
4017:main.c        **** //#define pgm_readImageByte(image, row, col)	\
4018:main.c        **** //	pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
4019:main.c        **** 
4020:main.c        **** #if( !defined(COLOR_BAR_SCROLL) || !COLOR_BAR_SCROLL)
4021:main.c        **** #if ( (FB_WIDTH != 16) || (FB_HEIGHT != 16) )
4022:main.c        ****  #error "image1 dimensions don't match FB_HEIGHT/WIDTH"
4023:main.c        ****  #error "It's likely I just need to create a specific DRAWIMAGE definition and tests"
4024:main.c        **** #endif
4025:main.c        **** 
4026:main.c        **** #define RED_IMAGEVAL_BIT 0
4027:main.c        **** #define GREEN_IMAGEVAL_BIT 1
4028:main.c        **** #define BLUE_IMAGEVAL_BIT 2
4029:main.c        **** 
4030:main.c        **** /*
4031:main.c        **** #define _R	0x03
4032:main.c        **** #define _O	0x07
4033:main.c        **** #define _G 0x0C
4034:main.c        **** #define _B 0x30
4035:main.c        **** #define _V 0x13
4036:main.c        **** #define _Y	0x0F
4037:main.c        **** #define _C 0x3C
4038:main.c        **** #define _M	0x33
4039:main.c        **** #define _K	0x00
4040:main.c        **** #define _W 0x3F
4041:main.c        **** #define _r 0x01
4042:main.c        **** #define _g 0x04
4043:main.c        **** #define _b 0x10
4044:main.c        **** #define _c 0x14
4045:main.c        **** #define _m 0x11
4046:main.c        **** #define _y 0x05
4047:main.c        **** #define _k 0x15
4048:main.c        **** #define Tr 0xC0	//Transparet
4049:main.c        **** */
4050:main.c        **** #if (TRUE || (!defined(LIFE) || !LIFE))
4051:main.c        **** uint8_t pgm_image1[256] PROGMEM =
4052:main.c        **** {
4053:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
4054:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4055:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4056:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4057:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_K,Tr,
4058:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_K,_K,_Y,_Y,_Y,_K,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 94


4059:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,
4060:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4061:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4062:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
4063:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4064:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
4065:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4066:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4067:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4068:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
4069:main.c        **** };
4070:main.c        **** #else
4071:main.c        **** /*uint8_t pgm_image1[256] PROGMEM =
4072:main.c        **** {  
4073:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4074:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4075:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4076:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4077:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4078:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4079:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4080:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4081:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4082:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4083:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4084:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4085:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4086:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4087:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4088:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4089:main.c        **** };
4090:main.c        **** */
4091:main.c        **** /*
4092:main.c        **** {  
4093:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4094:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4095:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4096:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
4097:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4098:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4099:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
4100:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
4101:main.c        ****    _K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4102:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
4103:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_R,_K,_K,
4104:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,_K,
4105:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,
4106:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4107:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4108:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K
4109:main.c        **** };
4110:main.c        **** */
4111:main.c        **** 
4112:main.c        **** 
4113:main.c        **** 
4114:main.c        **** #endif
4115:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 95


4116:main.c        **** 
4117:main.c        **** uint8_t pgm_image2[256] PROGMEM =
4118:main.c        **** {
4119:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
4120:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4121:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4122:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4123:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,Tr,
4124:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_K,
4125:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4126:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4127:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4128:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
4129:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4130:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
4131:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_K,_R,_K,_R,_K,_Y,_Y,_K,_K,Tr,
4132:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_K,_R,_R,_R,_K,_Y,_K,_K,Tr,Tr,
4133:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_K,_K,_K,_Y,_K,_K,Tr,Tr,Tr,
4134:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
4135:main.c        **** };
4136:main.c        **** #endif //COLOR_BAR_SCROLL
4137:main.c        **** 
4138:main.c        **** /*
4139:main.c        **** #if (IMAGE_WIDTH == 21)
4140:main.c        **** uint8_t mainData[2][768>>5][IMAGE_WIDTH] =
4141:main.c        **** {
4142:main.c        **** 	{
4143:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4144:main.c        **** 	{5,4,3,2,1,6,0,0,0,0,0,0,0,0,0,2,1,6,5,4,3},
4145:main.c        **** 	{4,3,2,1,0,0,0,3,3,3,3,3,3,3,0,0,0,5,4,3,4},
4146:main.c        **** 	{3,2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4147:main.c        **** 	{2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,1,6},
4148:main.c        **** 	{1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,5},
4149:main.c        **** 	{6,0,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,0,4},
4150:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,0,0},
4151:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,3,0},
4152:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,3,0},
4153:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4154:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4155:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4156:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4157:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4158:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4159:main.c        **** 	{6,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,4},
4160:main.c        **** 	{5,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3},
4161:main.c        **** 	{4,3,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2},
4162:main.c        **** 	{3,2,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4163:main.c        **** 	{2,1,5,5,0,0,0,3,3,3,3,3,3,3,0,0,0,3,2,1,6},
4164:main.c        **** 	{1,6,3,4,3,2,0,0,0,0,0,0,0,0,0,4,3,2,1,6,5},
4165:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4166:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3}
4167:main.c        **** 	},
4168:main.c        **** 	{	
4169:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4170:main.c        **** 	{4,3,2,1,6,5,0,0,0,0,0,0,0,0,0,1,6,5,4,3,2},
4171:main.c        **** 	{3,2,1,6,0,0,0,3,3,3,3,3,3,3,0,0,0,4,3,2,1},
4172:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,2,1,6},
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 96


4173:main.c        **** 	{1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,6,5},
4174:main.c        **** 	{6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4},
4175:main.c        **** 	{5,0,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,0,3},
4176:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,3,3,3,3,3,3,3,0,0},
4177:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,3,0,0,0,3,3,3,3,3,0},
4178:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,0},
4179:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4180:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4181:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4182:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4183:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4184:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4185:main.c        **** 	{5,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,3},
4186:main.c        **** 	{4,0,0,3,3,3,3,3,3,0,1,0,1,0,3,3,3,3,0,0,2},
4187:main.c        **** 	{3,2,0,0,3,3,3,3,3,0,1,1,1,0,3,3,3,0,0,2,1},
4188:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,0,0,0,3,3,3,0,0,2,1,6},
4189:main.c        **** 	{1,6,5,4,0,0,0,3,3,3,3,3,3,3,0,0,0,2,1,6,5},
4190:main.c        **** 	{6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,3,2,1,6,5,4},
4191:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4192:main.c        ****    {4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2}
4193:main.c        **** 	}
4194:main.c        **** };
4195:main.c        **** #else
4196:main.c        **** 	#error
4197:main.c        **** #endif
4198:main.c        **** */
4199:main.c        **** 
4200:main.c        **** 
4201:main.c        **** int main(void)
4202:main.c        **** {
4203:main.c        **** 
4204:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
4205:main.c        **** 	adc_takeInput(6);
4206:main.c        **** 	adc_init();
4207:main.c        **** 	adc_select(6);
4208:main.c        **** #endif
4209:main.c        **** 
4210:main.c        **** 	tetInit(7);
4211:main.c        **** 
4212:main.c        **** 	init_timer0Hsync();
4213:main.c        **** 
4214:main.c        **** 	//This starts pretty late... watch out for WDT
4215:main.c        **** 	init_heartBeat();
4216:main.c        **** 
4217:main.c        **** 	setHeartRate(0);
4218:main.c        **** 
4219:main.c        **** 	lvds_timerInit();
4220:main.c        **** 
4221:main.c        **** 	//For synchronizing timer1 settings (to avoid glitches)
4222:main.c        **** 	// count the number of CPU cycles...
4223:main.c        **** 	// depending on how many cycles it takes to start this and whatnot, 
4224:main.c        **** 	// there may be an offset. But the jist is we know every 7 cycles
4225:main.c        **** 	// the timer1 reset is synchronized with the CPU instructions...
4226:main.c        **** //	OCR0A = 6;
4227:main.c        **** //	timer_setWGM(0, WGM_CLR_ON_COMPARE);
4228:main.c        **** //	timer_selectDivisor(0, CLKDIV1);
4229:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 97


4230:main.c        **** /*
4231:main.c        **** 	segPosition=0;
4232:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4233:main.c        **** 	newSeg(16, 0x00, (4<<4) | 0);
4234:main.c        **** 	newSeg(8, 0x06, (4<<4) | 0);
4235:main.c        **** 	newSeg(32, 0x00, (4<<4) | 3);
4236:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4237:main.c        **** 	segTerminate();
4238:main.c        **** */
4239:main.c        **** 
4240:main.c        **** /* I Think these were LONG AGO when Green and Red weren't implemented
4241:main.c        **** 	//For Green...
4242:main.c        **** 	// Possibly later to be reimplemented on PWM, but deadTime might inhibit
4243:main.c        **** 	setoutPORT(PA0, PORTA);
4244:main.c        **** 	setoutPORT(PA1, PORTA);
4245:main.c        **** 	//Red:
4246:main.c        **** 	setoutPORT(PA2, PORTA);
4247:main.c        **** 	setoutPORT(PA3, PORTA);
4248:main.c        **** */
4249:main.c        **** 
4250:main.c        **** 
4251:main.c        **** 	// MUCH Of this is outside the screen...
4252:main.c        **** 
4253:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
4254:main.c        **** /*	uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH] = 
4255:main.c        **** 	{ {
4256:main.c        **** 		(0<<2), 
4257:main.c        **** 			(0<<2) | (1<<RED_BLUEVAL_BIT), (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4258:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4259:main.c        **** 		(4<<2), 
4260:main.c        **** 			(4<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4261:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4262:main.c        **** 	   (12<<2), 
4263:main.c        **** 			(12<<2) | (1<<RED_BLUEVAL_BIT), (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4264:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4265:main.c        **** 		(32<<2), 
4266:main.c        **** 			(32<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4267:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4268:main.c        **** 		(36<<2), 
4269:main.c        **** 			(36<<2) | (1<<RED_BLUEVAL_BIT), (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4270:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4271:main.c        **** 		(44<<2), 
4272:main.c        **** 			(44<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4273:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4274:main.c        **** 		(60<<2),
4275:main.c        **** 	  		(60<<2) | (1<<RED_BLUEVAL_BIT), (60<<2) | (1<<GREEN_BLUEVAL_BIT),
4276:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (60<<2) | (1<<GREEN_BLUEVAL_BIT)
4277:main.c        **** 	  },
4278:main.c        **** 	  {
4279:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<RED_BLUEVAL_BIT),
4280:main.c        **** 	  	(12<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<RED_BLUEVAL_BIT),
4281:main.c        **** 	  	(36<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<RED_BLUEVAL_BIT),
4282:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT),
4283:main.c        **** 		
4284:main.c        **** 		(0<<2) | (1<<GREEN_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT), 
4285:main.c        **** 		(12<<2) | (1<<GREEN_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT), 
4286:main.c        **** 		(36<<2)| (1<<GREEN_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 98


4287:main.c        **** 		(60<<2) | (1<<GREEN_BLUEVAL_BIT), 
4288:main.c        **** 		
4289:main.c        **** 		(0<<2), (4<<2), (12<<2),(32<<2), (36<<2), (44<<2), (60<<2),
4290:main.c        **** 
4291:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4292:main.c        **** 	  	(4<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4293:main.c        **** 		(12<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4294:main.c        **** 	  	(32<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4295:main.c        **** 		(36<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4296:main.c        **** 	  	(44<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4297:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT)
4298:main.c        **** 
4299:main.c        ****   	  }
4300:main.c        **** 	};
4301:main.c        **** */
4302:main.c        **** 
4303:main.c        **** 
4304:main.c        **** 	//Init:
4305:main.c        **** 	uint8_t i;
4306:main.c        **** 	for(i=0; i<FB_WIDTH; i++)
4307:main.c        **** 	{
4308:main.c        **** 		uint8_t j=FB_WIDTH-1-i;
4309:main.c        **** 		setColor((i&0x03), (i&0x0C)>>2, (i&0x30)>>4, 0, i);
4310:main.c        **** 		setColor((i&0x30)>>4, (i&0x0C)>>2, (i&0x03), 1, i);
4311:main.c        **** //		setBlue(frameBuffer[0][i], 0, i);
4312:main.c        **** //		setBlue(frameBuffer[1][i], 1, i);
4313:main.c        **** 	}
4314:main.c        **** #else	//NOT COLOR_BAR_SCROLL
4315:main.c        **** 	//uint8_t frameBuffer[16][16];
4316:main.c        **** 
4317:main.c        **** 	uint8_t row,col;
4318:main.c        **** /*	for(r=0; r<FB_HEIGHT; r++)
4319:main.c        **** 	{
4320:main.c        **** 		for(c=0; c<FB_WIDTH; c++)
4321:main.c        **** 		{
4322:main.c        **** 			uint8_t imagePixel=pgm_readImageByte(pgm_image1, r, c);
4323:main.c        **** 
4324:main.c        **** 			setColor(
4325:main.c        **** 				(getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4326:main.c        **** 				(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4327:main.c        **** 				(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
4328:main.c        **** 				r, c);
4329:main.c        **** //			setBlue(
4330:main.c        **** //					(
4331:main.c        **** //	(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? (60<<2) : 0) |
4332:main.c        **** //	(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? (1<<GREEN_BLUEVAL_BIT) : 0) |
4333:main.c        **** //	(getbit(RED_IMAGEVAL_BIT, imagePixel) ? (1<<RED_BLUEVAL_BIT) : 0)
4334:main.c        **** //					), r, c);
4335:main.c        **** 		}
4336:main.c        **** 	}
4337:main.c        **** */
4338:main.c        ****  #if (defined(IMAGE_CHANGE) && IMAGE_CHANGE)
4339:main.c        **** 	uint32_t counter=0;
4340:main.c        **** 	uint8_t imageNum = 0;
4341:main.c        **** 	uint8_t colorShift = 0;
4342:main.c        **** 	while(1)
4343:main.c        **** 	{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 99


4344:main.c        ****  #if (defined(FRAME_SYNC) && FRAME_SYNC)
4345:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
4346:main.c        ****  #else
4347:main.c        **** 		if(counter==0)
4348:main.c        ****  #endif
4349:main.c        **** 		{
4350:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4351:main.c        **** 			uint8_t *pimage;
4352:main.c        ****  #endif
4353:main.c        **** 
4354:main.c        **** 	#if 0
4355:main.c        **** 			tetUpdate();
4356:main.c        **** 
4357:main.c        **** 			if(imageNum == 0)
4358:main.c        **** 			{
4359:main.c        **** 				imageNum = 1;
4360:main.c        **** 				pimage = pgm_image1;
4361:main.c        **** 				tetColorScheme = 1;
4362:main.c        **** 			}
4363:main.c        **** 			else
4364:main.c        **** 			{
4365:main.c        **** 				hexColor++;
4366:main.c        **** 				hexColor&=0x3f;
4367:main.c        **** 				imageNum = 0;
4368:main.c        **** 				pimage = pgm_image2;
4369:main.c        **** 				tetColorScheme = 0;
4370:main.c        **** 			}
4371:main.c        **** 	#endif //0
4372:main.c        **** 
4373:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4374:main.c        **** 			for(row=0; row<FB_HEIGHT; row++)
4375:main.c        **** 	      for(col=0; col<FB_WIDTH; col++)
4376:main.c        **** 	      {
4377:main.c        **** 	         uint8_t imagePixel=pgm_readImageByte(pimage, row, col);
4378:main.c        **** 
4379:main.c        **** 
4380:main.c        **** 				if(imagePixel == Tr)
4381:main.c        **** 					frameBuffer[row][col] = colorShift+row+col;
4382:main.c        **** 				else
4383:main.c        **** 					frameBuffer[row][col] = imagePixel;	
4384:main.c        **** 			/*
4385:main.c        **** 	         setColor(
4386:main.c        **** 		         (getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4387:main.c        **** 	            (getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4388:main.c        **** 	            (getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
4389:main.c        **** 	            r, c);
4390:main.c        **** 			*/
4391:main.c        **** 			}
4392:main.c        **** 			colorShift++;
4393:main.c        ****  #endif
4394:main.c        ****  #if (defined(LIFE) && LIFE)
4395:main.c        **** 			lifeRound();
4396:main.c        ****  #endif //LIFE
4397:main.c        ****  
4398:main.c        ****  #if (FRAME_COUNT_TO_DELAY != 0)
4399:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
4400:main.c        ****  #endif //FRAME_COUNT_TO_DELAY
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 100


4401:main.c        **** 		}
4402:main.c        ****  #if (!defined(FRAME_SYNC) && !FRAME_SYNC)
4403:main.c        **** 		counter+=16384;
4404:main.c        ****  #else
4405:main.c        **** 		//for LIFE testing...
4406:main.c        **** 		counter++;
4407:main.c        **** #endif
4408:main.c        **** 		heartUpdate();
4409:main.c        **** 	}
4410:main.c        ****  #else
4411:main.c        ****   #error "IMAGE_CHANGE is now required for drawPix with image..."
4412:main.c        ****  #endif
4413:main.c        **** #endif
4414:main.c        **** 
4415:main.c        **** #if (defined(PIXEL_SCROLL) && PIXEL_SCROLL)
4416:main.c        **** 	uint32_t counter=0;
4417:main.c        **** 
4418:main.c        **** 	while(1)
4419:main.c        **** 	{
4420:main.c        **** 		if(counter==0)
4421:main.c        **** 		{
4422:main.c        **** 			uint8_t firstCol[2];
4423:main.c        **** 			firstCol[0] = frameBuffer[0][0];
4424:main.c        **** 			firstCol[1] = frameBuffer[1][0];
4425:main.c        **** 
4426:main.c        **** 			uint8_t i;
4427:main.c        **** 			for(i=0; i<FB_WIDTH-1; i++)
4428:main.c        **** 			{
4429:main.c        **** 				frameBuffer[0][i] = frameBuffer[0][i+1];
4430:main.c        **** 				frameBuffer[1][i] = frameBuffer[1][i+1];
4431:main.c        **** //				setBlue(frameBuffer[0][i], 0, i);
4432:main.c        **** //				setBlue(frameBuffer[1][i], 1, i);
4433:main.c        **** 			}
4434:main.c        **** 
4435:main.c        **** 			frameBuffer[0][i] = firstCol[0];
4436:main.c        **** 			frameBuffer[1][i] = firstCol[1];
4437:main.c        **** //			setBlue(frameBuffer[0][i], 0, i);
4438:main.c        **** //			setBlue(frameBuffer[1][i], 1, i);
4439:main.c        **** 		}
4440:main.c        **** 		counter+=16384;
4441:main.c        **** 		heartUpdate();
4442:main.c        **** 	}
4443:main.c        **** #else
4444:main.c        **** 	while(1)
4445:main.c        **** 	{
4446:main.c        **** 		heartUpdate();
4447:main.c        **** 	}
4448:main.c        **** #endif
4449:main.c        **** 
4450:main.c        **** }
 771               		.stabn	68,0,4450,.LM62-.LFBB5
 772               	.LM62:
 773 034e 8730      		cpi r24,lo8(7)
 774 0350 00F4      		brsh .L55
 775 0352 E82F      		mov r30,r24
 776 0354 F0E0      		ldi r31,lo8(0)
 777 0356 E050      		subi r30,lo8(-(CSWTCH.58))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 101


 778 0358 F040      		sbci r31,hi8(-(CSWTCH.58))
 779 035a 00C0      		rjmp .L57
 780               	.L53:
 781 035c 8730      		cpi r24,lo8(7)
 782 035e 00F4      		brsh .L55
 783 0360 E82F      		mov r30,r24
 784 0362 F0E0      		ldi r31,lo8(0)
 785 0364 E050      		subi r30,lo8(-(CSWTCH.61))
 786 0366 F040      		sbci r31,hi8(-(CSWTCH.61))
 787               	.L57:
 788 0368 8081      		ld r24,Z
 789 036a 0895      		ret
 790               	.L55:
 791 036c 8FE3      		ldi r24,lo8(63)
 792               	.L52:
 793               		.stabs	"tetStuff.c",132,0,0,.Ltext3
 794               	.Ltext3:
 422:tetStuff.c    **** 	{
 423:tetStuff.c    **** 		case 0:
 424:tetStuff.c    **** 		case 1:
 425:tetStuff.c    **** 			switch(tetBrick)
 426:tetStuff.c    **** 			{
 427:tetStuff.c    **** 				case 1:
 428:tetStuff.c    **** 					return _R;
 429:tetStuff.c    **** 				case 2:
 430:tetStuff.c    **** 					return _O;
 431:tetStuff.c    **** 				case 3:
 432:tetStuff.c    **** 					return _Y;
 433:tetStuff.c    **** 				case 4:
 434:tetStuff.c    **** 					return _G;
 435:tetStuff.c    **** 				case 5:
 436:tetStuff.c    **** 					return _C;
 437:tetStuff.c    **** 				case 6:
 438:tetStuff.c    **** 					return _B;
 439:tetStuff.c    **** 				case 7:
 440:tetStuff.c    **** 					return _M;
 441:tetStuff.c    **** 				default:	//WTF???
 442:tetStuff.c    **** 					return _W;
 443:tetStuff.c    **** 			}
 444:tetStuff.c    **** 			break;
 445:tetStuff.c    **** 		default: //Shouldn't happen...
 446:tetStuff.c    **** 			// was case1 but these colors are ugly
 447:tetStuff.c    **** 			// and cause syncing problems...
 448:tetStuff.c    **** 			switch(tetBrick)
 449:tetStuff.c    **** 			{
 450:tetStuff.c    **** 				case 1:
 451:tetStuff.c    **** 					return _r;
 452:tetStuff.c    **** 				case 2:
 453:tetStuff.c    **** 					return _g;
 454:tetStuff.c    **** 				case 3:
 455:tetStuff.c    **** 					return _b;
 456:tetStuff.c    **** 				case 4:
 457:tetStuff.c    **** 					return _c;
 458:tetStuff.c    **** 				case 5:
 459:tetStuff.c    **** 					return _m;
 460:tetStuff.c    **** 				case 6:
 461:tetStuff.c    **** 					return _y;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 102


 462:tetStuff.c    **** 				case 7:
 463:tetStuff.c    **** 					return _k;
 464:tetStuff.c    **** 				default:	//WTF
 465:tetStuff.c    **** 					return _W;
 466:tetStuff.c    **** 			}
 467:tetStuff.c    **** //		default:
 468:tetStuff.c    **** //			return 0;
 469:tetStuff.c    **** 	}
 470:tetStuff.c    **** 
 471:tetStuff.c    **** }
 795               		.stabn	68,0,471,.LM63-.LFBB5
 796               	.LM63:
 797 036e 0895      		ret
 798               		.size	tetBrick_to_fb, .-tetBrick_to_fb
 799               	.Lscope5:
 800               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 801               		.stabd	78,0,0
 802               		.stabs	"segClear:F(0,15)",36,0,159,segClear
 803               	.global	segClear
 804               		.type	segClear, @function
 805               	segClear:
 806               		.stabd	46,0,0
 807               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext4
 808               	.Ltext4:
   1:rowSegBuffer.c **** 
   2:rowSegBuffer.c **** 
   3:rowSegBuffer.c **** #ifndef NUM_SEGMENTS
   4:rowSegBuffer.c ****  #define NUM_SEGMENTS	68//128 //68 //128//68
   5:rowSegBuffer.c **** #endif
   6:rowSegBuffer.c **** 
   7:rowSegBuffer.c **** //Green and blue are in the same byte...
   8:rowSegBuffer.c **** // I don't think the code will compile anymore without this.
   9:rowSegBuffer.c **** // It increases the pixel calculation from 18 cycles to 20 cycles
  10:rowSegBuffer.c **** #define GB_COMBINED TRUE
  11:rowSegBuffer.c **** 
  12:rowSegBuffer.c **** // SQUARE_SEGMENTS inserts nops in the counter-loop
  13:rowSegBuffer.c **** // such that each loop takes the equivalent time as the first load/write
  14:rowSegBuffer.c **** //  of the values...
  15:rowSegBuffer.c **** // Then, each incremet of length is equivalent to one drawable-pixel
  16:rowSegBuffer.c **** // (Later, maybe, setting this FALSE would allow for LCD pixel-resolution
  17:rowSegBuffer.c **** //  down to a single pixel, with LVDS_PRESCALER, etc. BUT, the minimum 
  18:rowSegBuffer.c **** //  width of a segment would be longer, due to higher calculation time
  19:rowSegBuffer.c **** //  at the beginning)
  20:rowSegBuffer.c **** // Another benefit of SQUARE_SEGMENTS is that more distance can be
  21:rowSegBuffer.c **** //  covered in the same count... (fewer segments necessary in memory for a
  22:rowSegBuffer.c **** //  long color-segment)
  23:rowSegBuffer.c **** // Another "benefit" is that all count values can be used,
  24:rowSegBuffer.c **** //  (less testing is necessary to make sure a pixel can be added)
  25:rowSegBuffer.c **** //  (meh...)
  26:rowSegBuffer.c **** #define SQUARE_SEGMENTS TRUE
  27:rowSegBuffer.c **** 
  28:rowSegBuffer.c **** //Segments have four values:
  29:rowSegBuffer.c **** // segment length
  30:rowSegBuffer.c **** // red	(OCR)
  31:rowSegBuffer.c **** // green	(DT)
  32:rowSegBuffer.c **** // blue	(OCR)
  33:rowSegBuffer.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 103


  34:rowSegBuffer.c **** // To save space, and no additional instruction cycles are needed,
  35:rowSegBuffer.c **** //  combine red and length
  36:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  37:rowSegBuffer.c **** //                   \__ __/ \__ __/
  38:rowSegBuffer.c **** //								V       V
  39:rowSegBuffer.c **** //                      |       Red OCR value
  40:rowSegBuffer.c **** //                      segLength
  41:rowSegBuffer.c **** 
  42:rowSegBuffer.c **** // NOW:
  43:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  44:rowSegBuffer.c **** //                   \___ ___/ \_ _/
  45:rowSegBuffer.c **** //                       V       V
  46:rowSegBuffer.c **** //                       |       Red OCR value
  47:rowSegBuffer.c **** //                       segLength
  48:rowSegBuffer.c **** // RISK:
  49:rowSegBuffer.c **** //  At one point I was considering doubling OCR/DT values
  50:rowSegBuffer.c **** //   in able to get higher resolution...
  51:rowSegBuffer.c **** //   (more CPU cycles per pixel clock)
  52:rowSegBuffer.c **** //  That would require a significant overhaul
  53:rowSegBuffer.c **** //   and LVDS_PRESCALER has already helped...
  54:rowSegBuffer.c **** #define SEG_LENGTH_BITS 5
  55:rowSegBuffer.c **** 
  56:rowSegBuffer.c **** //#if (defined(SEG_LENGTH_BITS))
  57:rowSegBuffer.c ****  #define SEG_LENGTH_MASK 	((UPPER_BIT_MASK8(SEG_LENGTH_BITS)))
  58:rowSegBuffer.c **** //&0xff is necessary for an assembly operand to be 8-bits
  59:rowSegBuffer.c ****  #define RED_MASK 			(((~(SEG_LENGTH_MASK))&0xff))
  60:rowSegBuffer.c ****  #define SEG_COUNT_1			((UPPER_BIT_MASK8__COUNT_1(SEG_LENGTH_BITS)))
  61:rowSegBuffer.c ****  #define SEG_LENGTH_SHIFT	((8-(SEG_LENGTH_BITS)))
  62:rowSegBuffer.c **** //#else
  63:rowSegBuffer.c **** // #define SEG_LENGTH_MASK (0xf0)
  64:rowSegBuffer.c **** // #define RED_MASK (~(SEG_LENGTH_MASK))
  65:rowSegBuffer.c **** //#endif
  66:rowSegBuffer.c **** 
  67:rowSegBuffer.c **** 
  68:rowSegBuffer.c **** //This seems backwards, but it's not. See SQUARE_SEGMENTS notes, above
  69:rowSegBuffer.c **** #if (defined(SQUARE_SEGMENTS) && SQUARE_SEGMENTS)
  70:rowSegBuffer.c ****  #define COUNT_INCREMENT SEG_COUNT_1 //0x10
  71:rowSegBuffer.c ****  //This is the actual length, not as shifted for storage
  72:rowSegBuffer.c ****  #define SEG_MAXLENGTH	(SEG_LENGTH_MASK >> SEG_LENGTH_SHIFT)
  73:rowSegBuffer.c **** #else
  74:rowSegBuffer.c **** #error "This probably isn't implemented anymore..."
  75:rowSegBuffer.c ****  #if (defined(GB_COMBINED) && GB_COMBINED)
  76:rowSegBuffer.c ****   #define COUNT_INCREMENT (5*SEG_COUNT_1) //0x50
  77:rowSegBuffer.c ****  #else
  78:rowSegBuffer.c ****   #define COUNT_INCREMENT (4*SEG_COUNT_1) //0x40
  79:rowSegBuffer.c ****  #endif
  80:rowSegBuffer.c **** #endif
  81:rowSegBuffer.c **** 
  82:rowSegBuffer.c **** 
  83:rowSegBuffer.c **** // Similar *might* be possible with green and blue
  84:rowSegBuffer.c **** // IF we can switch DE/Blue to /OC1A
  85:rowSegBuffer.c **** //           switch Green to OC1B
  86:rowSegBuffer.c **** //           use DTH for green -> mov, andi, andi
  87:rowSegBuffer.c **** // Not sure if this is possible
  88:rowSegBuffer.c **** // Otherwise, sharing a byte for green/blue introduces
  89:rowSegBuffer.c **** //            mov, andi, and four lsrs
  90:rowSegBuffer.c **** //            mov, andi, swap, andi... maybe not so bad...?
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 104


  91:rowSegBuffer.c **** //                       only two additional cycles (since ld is two)
  92:rowSegBuffer.c **** // the benefit with red_length is killing two birds with one stone
  93:rowSegBuffer.c **** //   andi both &='s AND tests for 0...
  94:rowSegBuffer.c **** typedef struct _NONAME_
  95:rowSegBuffer.c **** {
  96:rowSegBuffer.c **** 	uint8_t red_length;	// segLength<<3 | OCR1D
  97:rowSegBuffer.c **** #if (defined(GB_COMBINED) && GB_COMBINED)
  98:rowSegBuffer.c **** 	uint8_t green_blue;	// blue<<4 | green
  99:rowSegBuffer.c **** #else
 100:rowSegBuffer.c **** 	uint8_t green;			//DT1(Low nibble)
 101:rowSegBuffer.c **** 	uint8_t blue;			//OCR1A
 102:rowSegBuffer.c **** #endif
 103:rowSegBuffer.c **** } seg_t;
 104:rowSegBuffer.c **** 
 105:rowSegBuffer.c **** 
 106:rowSegBuffer.c **** // Was thinking about loading the last segment as black, but that doesn't
 107:rowSegBuffer.c **** // work if the last segment isn't read, due to length=0...
 108:rowSegBuffer.c **** seg_t rowSegBuffer[NUM_SEGMENTS+1];/*=
 109:rowSegBuffer.c **** {
 110:rowSegBuffer.c **** 	{(4<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3},  //White
 111:rowSegBuffer.c ****    {(8<<SEG_LENGTH_SHIFT) | 0x00, (4<<4) | 0},  //Black
 112:rowSegBuffer.c **** 	{(16<<SEG_LENGTH_SHIFT)| 0x06, (4<<4) | 0},  //Red
 113:rowSegBuffer.c **** 	{(32<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3}, //White
 114:rowSegBuffer.c **** 	{0,(4<<4)}                                   //Terminate
 115:rowSegBuffer.c **** };
 116:rowSegBuffer.c **** */
 117:rowSegBuffer.c **** /*=
 118:rowSegBuffer.c **** {
 119:rowSegBuffer.c **** 	{0x10,4,6},
 120:rowSegBuffer.c **** 	{0x32,4,8},
 121:rowSegBuffer.c **** 	{0x03,5,2},
 122:rowSegBuffer.c **** 	{0x00,0,0}
 123:rowSegBuffer.c **** };
 124:rowSegBuffer.c **** */
 125:rowSegBuffer.c **** 
 126:rowSegBuffer.c **** 
 127:rowSegBuffer.c **** 
 128:rowSegBuffer.c **** //See rowBuffer.c for an explanation...
 129:rowSegBuffer.c **** // The first three will probably seldom be used
 130:rowSegBuffer.c **** // The last....
 131:rowSegBuffer.c **** #define fbBlue_to_seg(fbColor) \
 132:rowSegBuffer.c **** 		((((fbColor & 0x30) | 0x40)))
 133:rowSegBuffer.c **** 		//((((fbColor & 0x30) >> 4) | 0x04)<<4) //fixed
 134:rowSegBuffer.c **** //	   (((fbColor & 0x30) << 1) | 0x40)
 135:rowSegBuffer.c **** 
 136:rowSegBuffer.c **** #define fbGreen_to_seg(fbColor) \
 137:rowSegBuffer.c **** 	   ((fbColor & 0x0C) >> 2)
 138:rowSegBuffer.c **** 
 139:rowSegBuffer.c **** #define fbRed_to_seg(fbColor) \
 140:rowSegBuffer.c **** 	   (((fbColor & 0x03) << 1) | (fbColor & 0x01))
 141:rowSegBuffer.c **** 
 142:rowSegBuffer.c **** //This gives 'red, green_blue' pairs for arguments to newSeg, etc.
 143:rowSegBuffer.c **** // It's kinda hokey to call a three-argument function with *apparently*
 144:rowSegBuffer.c **** // only two arguments, but this'll be used probably more often than
 145:rowSegBuffer.c **** // the actual function-call...
 146:rowSegBuffer.c **** // use newSegfb(length, fbColor) 
 147:rowSegBuffer.c **** //    instead of newSeg(length, fb_to_seg(fbColor))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 105


 148:rowSegBuffer.c **** // it's just a macro, but it makes more sense
 149:rowSegBuffer.c **** #define fb_to_seg(fbColor) \
 150:rowSegBuffer.c ****   fbRed_to_seg(fbColor), (fbBlue_to_seg(fbColor) | fbGreen_to_seg(fbColor))
 151:rowSegBuffer.c **** 
 152:rowSegBuffer.c **** //Outside of rbpix_to_seg, this corresponds with the last-written segment
 153:rowSegBuffer.c **** uint8_t segPosition = 0;
 154:rowSegBuffer.c **** 
 155:rowSegBuffer.c **** 
 156:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue);
 157:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength);
 158:rowSegBuffer.c **** 
 159:rowSegBuffer.c **** void segClear(void)
 160:rowSegBuffer.c **** {
 809               		.stabn	68,0,160,.LM64-.LFBB6
 810               	.LM64:
 811               	.LFBB6:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 161:rowSegBuffer.c **** 	segPosition = 0;
 814               		.stabn	68,0,161,.LM65-.LFBB6
 815               	.LM65:
 816 0370 1092 0000 		sts segPosition,__zero_reg__
 162:rowSegBuffer.c **** 	//The important part is the null-length
 163:rowSegBuffer.c **** 	// but let's load white just in case
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 817               		.stabn	68,0,164,.LM66-.LFBB6
 818               	.LM66:
 819 0374 86E0      		ldi r24,lo8(6)
 820 0376 8093 0000 		sts rowSegBuffer,r24
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 821               		.stabn	68,0,165,.LM67-.LFBB6
 822               	.LM67:
 823 037a 83E6      		ldi r24,lo8(99)
 824 037c 8093 0000 		sts rowSegBuffer+1,r24
 825               	/* epilogue start */
 166:rowSegBuffer.c **** }
 826               		.stabn	68,0,166,.LM68-.LFBB6
 827               	.LM68:
 828 0380 0895      		ret
 829               		.size	segClear, .-segClear
 830               	.Lscope6:
 831               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 832               		.stabd	78,0,0
 833               		.stabs	"segTerminate:F(0,15)",36,0,170,segTerminate
 834               	.global	segTerminate
 835               		.type	segTerminate, @function
 836               	segTerminate:
 837               		.stabd	46,0,0
 167:rowSegBuffer.c **** 
 168:rowSegBuffer.c **** #define rbpix_to_segTerminate segTerminate
 169:rowSegBuffer.c **** 
 170:rowSegBuffer.c **** void segTerminate(void)
 171:rowSegBuffer.c **** {
 838               		.stabn	68,0,171,.LM69-.LFBB7
 839               	.LM69:
 840               	.LFBB7:
 841               	/* prologue: function */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 106


 842               	/* frame size = 0 */
 172:rowSegBuffer.c **** 
 173:rowSegBuffer.c **** 	//Add a new NULL-SEGMENT
 174:rowSegBuffer.c **** 	//This might appear as a stretched last pixel/segment...
 175:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 843               		.stabn	68,0,175,.LM70-.LFBB7
 844               	.LM70:
 845 0382 8091 0000 		lds r24,segPosition
 846 0386 8334      		cpi r24,lo8(67)
 847 0388 00F4      		brsh .L61
 848 038a E82F      		mov r30,r24
 849 038c F0E0      		ldi r31,lo8(0)
 850 038e EE0F      		lsl r30
 851 0390 FF1F      		rol r31
 852 0392 E050      		subi r30,lo8(-(rowSegBuffer))
 853 0394 F040      		sbci r31,hi8(-(rowSegBuffer))
 854 0396 9081      		ld r25,Z
 855 0398 987F      		andi r25,lo8(-8)
 856 039a 01F0      		breq .L63
 176:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK))
 177:rowSegBuffer.c **** 	{
 178:rowSegBuffer.c **** 		segPosition++;
 857               		.stabn	68,0,178,.LM71-.LFBB7
 858               	.LM71:
 859 039c 8F5F      		subi r24,lo8(-(1))
 860 039e 8093 0000 		sts segPosition,r24
 179:rowSegBuffer.c **** 
 180:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 181:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].red_length & RED_MASK;
 861               		.stabn	68,0,181,.LM72-.LFBB7
 862               	.LM72:
 863 03a2 A82F      		mov r26,r24
 864 03a4 B0E0      		ldi r27,lo8(0)
 180:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 865               		.stabn	68,0,180,.LM73-.LFBB7
 866               	.LM73:
 867 03a6 FD01      		movw r30,r26
 868 03a8 EE0F      		lsl r30
 869 03aa FF1F      		rol r31
 870 03ac E050      		subi r30,lo8(-(rowSegBuffer))
 871 03ae F040      		sbci r31,hi8(-(rowSegBuffer))
 872 03b0 AA0F      		lsl r26
 873 03b2 BB1F      		rol r27
 874 03b4 A050      		subi r26,lo8(-(rowSegBuffer-2))
 875 03b6 B040      		sbci r27,hi8(-(rowSegBuffer-2))
 876 03b8 8C91      		ld r24,X
 877 03ba 8770      		andi r24,lo8(7)
 878 03bc 8083      		st Z,r24
 182:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue
 879               		.stabn	68,0,182,.LM74-.LFBB7
 880               	.LM74:
 881 03be 1196      		adiw r26,1
 882 03c0 8C91      		ld r24,X
 883 03c2 1197      		sbiw r26,1
 884 03c4 8183      		std Z+1,r24
 175:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 885               		.stabn	68,0,175,.LM75-.LFBB7
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 107


 886               	.LM75:
 887 03c6 0895      		ret
 888               	.L61:
 183:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].green_blue;
 184:rowSegBuffer.c **** 	}
 185:rowSegBuffer.c **** 	//We're already at the last segment, so we have to nullify it
 186:rowSegBuffer.c **** 	//This might terminate the last pixel early, but is necessary.
 187:rowSegBuffer.c **** 	else if(segPosition == NUM_SEGMENTS-1)
 889               		.stabn	68,0,187,.LM76-.LFBB7
 890               	.LM76:
 891 03c8 8334      		cpi r24,lo8(67)
 892 03ca 01F4      		brne .L63
 188:rowSegBuffer.c **** 	{
 189:rowSegBuffer.c **** 		//Apparently white doesn't cause sync problems... so load it white
 190:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = fbRed_to_seg(_W);
 893               		.stabn	68,0,190,.LM77-.LFBB7
 894               	.LM77:
 895 03cc 87E0      		ldi r24,lo8(7)
 896 03ce 8093 0000 		sts rowSegBuffer+134,r24
 191:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = 
 897               		.stabn	68,0,191,.LM78-.LFBB7
 898               	.LM78:
 899 03d2 83E7      		ldi r24,lo8(115)
 900 03d4 8093 0000 		sts rowSegBuffer+135,r24
 901               	.L63:
 902 03d8 0895      		ret
 903               		.size	segTerminate, .-segTerminate
 904               	.Lscope7:
 905               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 906               		.stabd	78,0,0
 907               		.stabs	"newSeg:F(3,2)",36,0,334,newSeg
 908               		.stabs	"length:P(3,4)",64,0,334,24
 909               		.stabs	"red:P(3,2)",64,0,334,22
 910               		.stabs	"green_blue:P(3,2)",64,0,334,20
 911               	.global	newSeg
 912               		.type	newSeg, @function
 913               	newSeg:
 914               		.stabd	46,0,0
 192:rowSegBuffer.c **** 										fbBlue_to_seg(_W) | fbGreen_to_seg(_W);
 193:rowSegBuffer.c **** 	}
 194:rowSegBuffer.c **** 
 195:rowSegBuffer.c **** 	//If we got here, it's already been terminated...
 196:rowSegBuffer.c **** 	//else...
 197:rowSegBuffer.c **** }
 198:rowSegBuffer.c **** 
 199:rowSegBuffer.c **** 
 200:rowSegBuffer.c **** #define newSegfb(length, fbColor) newSeg((length), fb_to_seg(fbColor))
 201:rowSegBuffer.c **** #define addSegfb(length, fbColor) addSeg((length), fb_to_seg(fbColor))
 202:rowSegBuffer.c **** 
 203:rowSegBuffer.c **** //This is just an intermediate test, for now...
 204:rowSegBuffer.c **** // for reloading the rowbuffer to a seg-buffer.
 205:rowSegBuffer.c **** //This could easily be revised (and generalized) to be...
 206:rowSegBuffer.c **** // addSegment or addPixel
 207:rowSegBuffer.c **** void rbpix_to_seg(uint8_t rbValue, uint8_t col, uint8_t length)
 208:rowSegBuffer.c **** {
 209:rowSegBuffer.c **** 	static uint8_t last_rbValue = 0;
 210:rowSegBuffer.c **** 	//uint8_t length = 1;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 108


 211:rowSegBuffer.c **** 
 212:rowSegBuffer.c **** 	if(col == 0)
 213:rowSegBuffer.c **** 	{
 214:rowSegBuffer.c **** 		last_rbValue = 0;
 215:rowSegBuffer.c **** 		segClear();
 216:rowSegBuffer.c **** 	}
 217:rowSegBuffer.c **** 	//Same color as last pixel...
 218:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 219:rowSegBuffer.c **** 	{
 220:rowSegBuffer.c **** 		stretchSeg(length);
 221:rowSegBuffer.c **** 		return;
 222:rowSegBuffer.c **** 	}
 223:rowSegBuffer.c **** 
 224:rowSegBuffer.c **** 	uint8_t green = rbValue & 0x03;
 225:rowSegBuffer.c **** 	uint8_t red = (rbValue & 0x1C) >> 2;
 226:rowSegBuffer.c **** 	uint8_t blue = rbValue >> 5;
 227:rowSegBuffer.c **** 
 228:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 229:rowSegBuffer.c **** 
 230:rowSegBuffer.c **** 	last_rbValue = rbValue;
 231:rowSegBuffer.c **** }
 232:rowSegBuffer.c **** 
 233:rowSegBuffer.c **** //Call this when we already know the color in the last segment is the same
 234:rowSegBuffer.c **** // so we wish to stretch the segment by additionalLength
 235:rowSegBuffer.c **** // these values are real-lengths, not as shifted for storage...
 236:rowSegBuffer.c **** // Return TRUE if the stretch was truncated...
 237:rowSegBuffer.c **** // THIS DOES NOT TEST DISPLAY_WIDTH!
 238:rowSegBuffer.c **** // DON'T FORGET to make additionalLength square before the call
 239:rowSegBuffer.c **** // if necesary....
 240:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength)
 241:rowSegBuffer.c **** {
 242:rowSegBuffer.c **** 		uint8_t oldLength=
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 244:rowSegBuffer.c **** 
 245:rowSegBuffer.c **** 		if(!additionalLength)
 246:rowSegBuffer.c **** 			return FALSE;
 247:rowSegBuffer.c **** 
 248:rowSegBuffer.c **** 		//We can stretch the current segment
 249:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 250:rowSegBuffer.c **** 		{
 251:rowSegBuffer.c **** 			uint8_t maxStretch = SEG_MAXLENGTH - oldLength;
 252:rowSegBuffer.c **** 
 253:rowSegBuffer.c **** 			// Will the entire addition fit in the previous segment?
 254:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 255:rowSegBuffer.c **** 			{
 256:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 257:rowSegBuffer.c **** 					(additionalLength << SEG_LENGTH_SHIFT);
 258:rowSegBuffer.c **** 
 259:rowSegBuffer.c **** 				//Then we're done.
 260:rowSegBuffer.c **** 			//	additionalLength = 0;
 261:rowSegBuffer.c **** 			//	break;
 262:rowSegBuffer.c **** 				return FALSE;
 263:rowSegBuffer.c **** 			}
 264:rowSegBuffer.c **** 			// Nope... stretch it all the way, then later we'll make another
 265:rowSegBuffer.c **** 			else
 266:rowSegBuffer.c **** 			{
 267:rowSegBuffer.c **** 				uint8_t red = 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 109


 268:rowSegBuffer.c **** 					rowSegBuffer[segPosition].red_length & RED_MASK;
 269:rowSegBuffer.c **** 
 270:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 271:rowSegBuffer.c **** 					red | (SEG_MAXLENGTH << SEG_LENGTH_SHIFT);
 272:rowSegBuffer.c **** 
 273:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 274:rowSegBuffer.c **** 			}
 275:rowSegBuffer.c **** 		}
 276:rowSegBuffer.c **** 
 277:rowSegBuffer.c **** 		//The current segment has been stretched and there's more remaining
 278:rowSegBuffer.c **** 		// or it was already maxed-out...
 279:rowSegBuffer.c **** 
 280:rowSegBuffer.c **** 		// We shouldn't ever get here if additionalLength = 0...
 281:rowSegBuffer.c **** 
 282:rowSegBuffer.c **** 		//But we should test to make sure there's still lenth after
 283:rowSegBuffer.c **** 		// the stretch...
 284:rowSegBuffer.c **** 		if(additionalLength)
 285:rowSegBuffer.c **** 		{
 286:rowSegBuffer.c **** 			uint8_t red =
 287:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length & RED_MASK;
 288:rowSegBuffer.c **** 
 289:rowSegBuffer.c **** 			uint8_t green_blue =
 290:rowSegBuffer.c **** 				rowSegBuffer[segPosition].green_blue;
 291:rowSegBuffer.c **** 
 292:rowSegBuffer.c **** 			uint8_t retVal;
 293:rowSegBuffer.c **** 
 294:rowSegBuffer.c **** 			//Create new segment(s) with the remaining length
 295:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 296:rowSegBuffer.c **** 
 297:rowSegBuffer.c **** 			//Then we're done...
 298:rowSegBuffer.c **** 			//additionalLength = 0;
 299:rowSegBuffer.c **** 			//break;
 300:rowSegBuffer.c **** 
 301:rowSegBuffer.c **** 			return retVal;
 302:rowSegBuffer.c **** 		}	
 303:rowSegBuffer.c **** 
 304:rowSegBuffer.c **** 		//We shouldn't ever get here...
 305:rowSegBuffer.c **** 		// Well, maybe... if additionalLength == maxStretch...?
 306:rowSegBuffer.c **** 		return FALSE;
 307:rowSegBuffer.c **** }
 308:rowSegBuffer.c **** 
 309:rowSegBuffer.c **** //This should be like newSeg, but also checks whether it can stretch
 310:rowSegBuffer.c **** // the last segment...
 311:rowSegBuffer.c **** uint8_t addSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 312:rowSegBuffer.c **** {
 313:rowSegBuffer.c **** 
 314:rowSegBuffer.c **** 	//Currently not smart enough to stretch the first segment...
 315:rowSegBuffer.c **** 	if(segPosition == 0)
 316:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 317:rowSegBuffer.c **** 
 318:rowSegBuffer.c **** 	//Can we stretch?
 319:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 320:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].green_blue == green_blue))
 321:rowSegBuffer.c **** 			return stretchSeg(length);
 322:rowSegBuffer.c **** 	else
 323:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 324:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 110


 325:rowSegBuffer.c **** }
 326:rowSegBuffer.c **** 
 327:rowSegBuffer.c **** //This assumes you intend to create a new segment
 328:rowSegBuffer.c **** // it does *not* check whether the previous segment could be stretched
 329:rowSegBuffer.c **** // (it in fact, is called by stretchSeg as necessary)
 330:rowSegBuffer.c **** // Returns TRUE if it had to be truncated
 331:rowSegBuffer.c **** //  (out of segment memory, past the display edge...)
 332:rowSegBuffer.c **** // length is the real length, not shifted for storage...
 333:rowSegBuffer.c **** // THIS DOES NOT squarify, so adjust length as necessary before calling
 334:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 335:rowSegBuffer.c **** {
 915               		.stabn	68,0,335,.LM79-.LFBB8
 916               	.LM79:
 917               	.LFBB8:
 918               	/* prologue: function */
 919               	/* frame size = 0 */
 920               		.stabn	68,0,335,.LM80-.LFBB8
 921               	.LM80:
 922 03da 2091 0000 		lds r18,segPosition
 336:rowSegBuffer.c **** 
 337:rowSegBuffer.c **** 	//Recursion would be simpler, but we've got a limited stack.
 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 339:rowSegBuffer.c **** 	{
 340:rowSegBuffer.c **** 		// No more segments available...	
 341:rowSegBuffer.c **** 		// The last segment must have a length of 0
 342:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 343:rowSegBuffer.c **** 		{
 344:rowSegBuffer.c **** 			segTerminate();
 345:rowSegBuffer.c **** 			return TRUE;
 346:rowSegBuffer.c **** 		}
 347:rowSegBuffer.c **** 
 348:rowSegBuffer.c **** 		// Not yet sure how to handle display-width...
 349:rowSegBuffer.c **** 		//if(segTotal > DISPLAY_WIDTH)
 350:rowSegBuffer.c **** 		//  at least draw as much of the segment as possible...
 351:rowSegBuffer.c **** 		//  then segTerminate();
 352:rowSegBuffer.c **** 		//  and return TRUE
 353:rowSegBuffer.c **** 
 354:rowSegBuffer.c **** 		// If we've gotten this far, then we can add the segment
 355:rowSegBuffer.c **** 	
 356:rowSegBuffer.c **** 		//Check if the segment buffer is cleared...
 357:rowSegBuffer.c **** 		// then DON'T increment segPosition...
 358:rowSegBuffer.c **** 		//if(!((segPosition == 0) && 
 359:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 360:rowSegBuffer.c **** 		if(segPosition || 
 361:rowSegBuffer.c **** 			((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
 362:rowSegBuffer.c **** 				segPosition++;
 363:rowSegBuffer.c **** 
 364:rowSegBuffer.c **** 
 365:rowSegBuffer.c **** 		//Create a maxlength segment
 366:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length =
 923               		.stabn	68,0,366,.LM81-.LFBB8
 924               	.LM81:
 925 03de 562F      		mov r21,r22
 926 03e0 586F      		ori r21,lo8(-8)
 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 927               		.stabn	68,0,338,.LM82-.LFBB8
 928               	.LM82:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 111


 929 03e2 00C0      		rjmp .L65
 930               	.L70:
 342:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 931               		.stabn	68,0,342,.LM83-.LFBB8
 932               	.LM83:
 933 03e4 2334      		cpi r18,lo8(67)
 934 03e6 01F4      		brne .L66
 935 03e8 2093 0000 		sts segPosition,r18
 936 03ec 00C0      		rjmp .L76
 937               	.L66:
 360:rowSegBuffer.c **** 		if(segPosition || 
 938               		.stabn	68,0,360,.LM84-.LFBB8
 939               	.LM84:
 940 03ee 2223      		tst r18
 941 03f0 01F4      		brne .L68
 942 03f2 3091 0000 		lds r19,rowSegBuffer
 943 03f6 387F      		andi r19,lo8(-8)
 944 03f8 01F0      		breq .L69
 945               	.L68:
 362:rowSegBuffer.c **** 				segPosition++;
 946               		.stabn	68,0,362,.LM85-.LFBB8
 947               	.LM85:
 948 03fa 2F5F      		subi r18,lo8(-(1))
 949               	.L69:
 950               		.stabn	68,0,366,.LM86-.LFBB8
 951               	.LM86:
 952 03fc E22F      		mov r30,r18
 953 03fe F0E0      		ldi r31,lo8(0)
 954 0400 EE0F      		lsl r30
 955 0402 FF1F      		rol r31
 956 0404 E050      		subi r30,lo8(-(rowSegBuffer))
 957 0406 F040      		sbci r31,hi8(-(rowSegBuffer))
 958 0408 5083      		st Z,r21
 367:rowSegBuffer.c **** 			red | (SEG_MAXLENGTH<<SEG_LENGTH_SHIFT);
 368:rowSegBuffer.c **** 
 369:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 959               		.stabn	68,0,369,.LM87-.LFBB8
 960               	.LM87:
 961 040a 4183      		std Z+1,r20
 370:rowSegBuffer.c **** 
 371:rowSegBuffer.c **** 		length -= SEG_MAXLENGTH;
 962               		.stabn	68,0,371,.LM88-.LFBB8
 963               	.LM88:
 964 040c 4F97      		sbiw r24,31
 965               	.L65:
 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 966               		.stabn	68,0,338,.LM89-.LFBB8
 967               	.LM89:
 968 040e 8F31      		cpi r24,31
 969 0410 9105      		cpc r25,__zero_reg__
 970 0412 00F4      		brsh .L70
 971 0414 2093 0000 		sts segPosition,r18
 372:rowSegBuffer.c **** 
 373:rowSegBuffer.c **** 	}
 374:rowSegBuffer.c **** 
 375:rowSegBuffer.c **** 	//We can fit whatever's left (or the whole thing) into a single segment
 376:rowSegBuffer.c **** 	// Unless, of course, there's nothing left...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 112


 377:rowSegBuffer.c **** 	if(length > 0) //< SEG_MAXLENGTH)//Guaranteed now...
 972               		.stabn	68,0,377,.LM90-.LFBB8
 973               	.LM90:
 974 0418 0097      		sbiw r24,0
 975 041a 01F4      		brne .L71
 976 041c 80E0      		ldi r24,lo8(0)
 977 041e 0895      		ret
 978               	.L71:
 378:rowSegBuffer.c **** 	{
 379:rowSegBuffer.c **** 		//Make sure there's another segment to write to!
 380:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 979               		.stabn	68,0,380,.LM91-.LFBB8
 980               	.LM91:
 981 0420 2334      		cpi r18,lo8(67)
 982 0422 01F4      		brne .L72
 983               	.L76:
 381:rowSegBuffer.c **** 		{
 382:rowSegBuffer.c **** 			segTerminate();
 984               		.stabn	68,0,382,.LM92-.LFBB8
 985               	.LM92:
 986 0424 00D0      		rcall segTerminate
 987 0426 81E0      		ldi r24,lo8(1)
 383:rowSegBuffer.c **** 			return TRUE;
 988               		.stabn	68,0,383,.LM93-.LFBB8
 989               	.LM93:
 990 0428 0895      		ret
 991               	.L72:
 384:rowSegBuffer.c **** 		}
 385:rowSegBuffer.c **** 
 386:rowSegBuffer.c **** 		//if(!((segPosition == 0) &&
 387:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 388:rowSegBuffer.c **** 		if(segPosition || 
 992               		.stabn	68,0,388,.LM94-.LFBB8
 993               	.LM94:
 994 042a 2223      		tst r18
 995 042c 01F4      		brne .L73
 996 042e 3091 0000 		lds r19,rowSegBuffer
 997 0432 387F      		andi r19,lo8(-8)
 998 0434 01F0      		breq .L74
 999               	.L73:
 389:rowSegBuffer.c **** 	     ((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
 390:rowSegBuffer.c ****   				segPosition++;
 1000               		.stabn	68,0,390,.LM95-.LFBB8
 1001               	.LM95:
 1002 0436 2F5F      		subi r18,lo8(-(1))
 1003 0438 2093 0000 		sts segPosition,r18
 1004               	.L74:
 391:rowSegBuffer.c **** 
 392:rowSegBuffer.c **** 
 393:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = 
 1005               		.stabn	68,0,393,.LM96-.LFBB8
 1006               	.LM96:
 1007 043c E091 0000 		lds r30,segPosition
 1008 0440 F0E0      		ldi r31,lo8(0)
 1009 0442 EE0F      		lsl r30
 1010 0444 FF1F      		rol r31
 1011 0446 E050      		subi r30,lo8(-(rowSegBuffer))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 113


 1012 0448 F040      		sbci r31,hi8(-(rowSegBuffer))
 1013 044a 880F      		lsl r24
 1014 044c 880F      		lsl r24
 1015 044e 880F      		lsl r24
 1016 0450 862B      		or r24,r22
 1017 0452 8083      		st Z,r24
 394:rowSegBuffer.c **** 			red | (length<<SEG_LENGTH_SHIFT);
 395:rowSegBuffer.c **** 
 396:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 1018               		.stabn	68,0,396,.LM97-.LFBB8
 1019               	.LM97:
 1020 0454 4183      		std Z+1,r20
 1021 0456 80E0      		ldi r24,lo8(0)
 397:rowSegBuffer.c **** 	}
 398:rowSegBuffer.c **** 
 399:rowSegBuffer.c **** 	return FALSE;
 400:rowSegBuffer.c **** 
 401:rowSegBuffer.c **** }
 1022               		.stabn	68,0,401,.LM98-.LFBB8
 1023               	.LM98:
 1024 0458 0895      		ret
 1025               		.size	newSeg, .-newSeg
 1026               	.Lscope8:
 1027               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 1028               		.stabd	78,0,0
 1029               		.stabs	"stretchSeg:F(3,2)",36,0,240,stretchSeg
 1030               		.stabs	"additionalLength:P(3,4)",64,0,240,24
 1031               	.global	stretchSeg
 1032               		.type	stretchSeg, @function
 1033               	stretchSeg:
 1034               		.stabd	46,0,0
 241:rowSegBuffer.c **** {
 1035               		.stabn	68,0,241,.LM99-.LFBB9
 1036               	.LM99:
 1037               	.LFBB9:
 1038               	/* prologue: function */
 1039               	/* frame size = 0 */
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1040               		.stabn	68,0,243,.LM100-.LFBB9
 1041               	.LM100:
 1042 045a E091 0000 		lds r30,segPosition
 1043 045e F0E0      		ldi r31,lo8(0)
 1044 0460 DF01      		movw r26,r30
 1045 0462 AA0F      		lsl r26
 1046 0464 BB1F      		rol r27
 1047 0466 A050      		subi r26,lo8(-(rowSegBuffer))
 1048 0468 B040      		sbci r27,hi8(-(rowSegBuffer))
 1049 046a 2C91      		ld r18,X
 245:rowSegBuffer.c **** 		if(!additionalLength)
 1050               		.stabn	68,0,245,.LM101-.LFBB9
 1051               	.LM101:
 1052 046c 0097      		sbiw r24,0
 1053 046e 01F0      		breq .L78
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1054               		.stabn	68,0,243,.LM102-.LFBB9
 1055               	.LM102:
 1056 0470 422F      		mov r20,r18
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 114


 1057 0472 4695      		lsr r20
 1058 0474 4695      		lsr r20
 1059 0476 4695      		lsr r20
 249:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 1060               		.stabn	68,0,249,.LM103-.LFBB9
 1061               	.LM103:
 1062 0478 4F31      		cpi r20,lo8(31)
 1063 047a 00F4      		brsh .L79
 1064               	.LBB113:
 254:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 1065               		.stabn	68,0,254,.LM104-.LFBB9
 1066               	.LM104:
 1067 047c 3FE1      		ldi r19,lo8(31)
 1068 047e 341B      		sub r19,r20
 1069 0480 432F      		mov r20,r19
 1070 0482 50E0      		ldi r21,lo8(0)
 1071 0484 4817      		cp r20,r24
 1072 0486 5907      		cpc r21,r25
 1073 0488 00F0      		brlo .L80
 256:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 1074               		.stabn	68,0,256,.LM105-.LFBB9
 1075               	.LM105:
 1076 048a 880F      		lsl r24
 1077 048c 880F      		lsl r24
 1078 048e 880F      		lsl r24
 1079 0490 820F      		add r24,r18
 1080 0492 8C93      		st X,r24
 1081 0494 80E0      		ldi r24,lo8(0)
 262:rowSegBuffer.c **** 				return FALSE;
 1082               		.stabn	68,0,262,.LM106-.LFBB9
 1083               	.LM106:
 1084 0496 0895      		ret
 1085               	.L80:
 1086               	.LBB114:
 270:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 1087               		.stabn	68,0,270,.LM107-.LFBB9
 1088               	.LM107:
 1089 0498 286F      		ori r18,lo8(-8)
 1090 049a 2C93      		st X,r18
 273:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 1091               		.stabn	68,0,273,.LM108-.LFBB9
 1092               	.LM108:
 1093 049c 841B      		sub r24,r20
 1094 049e 950B      		sbc r25,r21
 1095               	.LBE114:
 1096               	.LBE113:
 284:rowSegBuffer.c **** 		if(additionalLength)
 1097               		.stabn	68,0,284,.LM109-.LFBB9
 1098               	.LM109:
 1099 04a0 01F0      		breq .L78
 1100               	.L79:
 1101               	.LBB115:
 295:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 1102               		.stabn	68,0,295,.LM110-.LFBB9
 1103               	.LM110:
 1104 04a2 EE0F      		lsl r30
 1105 04a4 FF1F      		rol r31
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 115


 1106 04a6 E050      		subi r30,lo8(-(rowSegBuffer))
 1107 04a8 F040      		sbci r31,hi8(-(rowSegBuffer))
 1108 04aa 6081      		ld r22,Z
 1109 04ac 6770      		andi r22,lo8(7)
 1110 04ae 4181      		ldd r20,Z+1
 1111 04b0 00D0      		rcall newSeg
 301:rowSegBuffer.c **** 			return retVal;
 1112               		.stabn	68,0,301,.LM111-.LFBB9
 1113               	.LM111:
 1114 04b2 0895      		ret
 1115               	.L78:
 1116 04b4 80E0      		ldi r24,lo8(0)
 1117               	.LBE115:
 307:rowSegBuffer.c **** }
 1118               		.stabn	68,0,307,.LM112-.LFBB9
 1119               	.LM112:
 1120 04b6 0895      		ret
 1121               		.size	stretchSeg, .-stretchSeg
 1122               		.stabs	"oldLength:r(3,2)",64,0,242,20
 1123               		.stabn	192,0,0,.LFBB9-.LFBB9
 1124               		.stabs	"retVal:r(3,2)",64,0,292,24
 1125               		.stabn	192,0,0,.LBB115-.LFBB9
 1126               		.stabn	224,0,0,.LBE115-.LFBB9
 1127               		.stabn	224,0,0,.Lscope9-.LFBB9
 1128               	.Lscope9:
 1129               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 1130               		.stabd	78,0,0
 1131               		.stabs	"addSeg:F(3,2)",36,0,311,addSeg
 1132               		.stabs	"length:P(3,4)",64,0,311,24
 1133               		.stabs	"red:P(3,2)",64,0,311,22
 1134               		.stabs	"green_blue:P(3,2)",64,0,311,20
 1135               	.global	addSeg
 1136               		.type	addSeg, @function
 1137               	addSeg:
 1138               		.stabd	46,0,0
 312:rowSegBuffer.c **** {
 1139               		.stabn	68,0,312,.LM113-.LFBB10
 1140               	.LM113:
 1141               	.LFBB10:
 1142               	/* prologue: function */
 1143               	/* frame size = 0 */
 315:rowSegBuffer.c **** 	if(segPosition == 0)
 1144               		.stabn	68,0,315,.LM114-.LFBB10
 1145               	.LM114:
 1146 04b8 E091 0000 		lds r30,segPosition
 1147 04bc EE23      		tst r30
 1148 04be 01F4      		brne .L84
 316:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1149               		.stabn	68,0,316,.LM115-.LFBB10
 1150               	.LM115:
 1151 04c0 00D0      		rcall newSeg
 1152 04c2 0895      		ret
 1153               	.L84:
 319:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 1154               		.stabn	68,0,319,.LM116-.LFBB10
 1155               	.LM116:
 1156 04c4 F0E0      		ldi r31,lo8(0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 116


 1157 04c6 EE0F      		lsl r30
 1158 04c8 FF1F      		rol r31
 1159 04ca E050      		subi r30,lo8(-(rowSegBuffer))
 1160 04cc F040      		sbci r31,hi8(-(rowSegBuffer))
 1161 04ce 2081      		ld r18,Z
 1162 04d0 30E0      		ldi r19,lo8(0)
 1163 04d2 2770      		andi r18,lo8(7)
 1164 04d4 3070      		andi r19,hi8(7)
 1165 04d6 A62F      		mov r26,r22
 1166 04d8 B0E0      		ldi r27,lo8(0)
 1167 04da 2A17      		cp r18,r26
 1168 04dc 3B07      		cpc r19,r27
 1169 04de 01F4      		brne .L86
 1170 04e0 2181      		ldd r18,Z+1
 1171 04e2 2417      		cp r18,r20
 1172 04e4 01F4      		brne .L86
 321:rowSegBuffer.c **** 			return stretchSeg(length);
 1173               		.stabn	68,0,321,.LM117-.LFBB10
 1174               	.LM117:
 1175 04e6 00D0      		rcall stretchSeg
 1176 04e8 0895      		ret
 1177               	.L86:
 323:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1178               		.stabn	68,0,323,.LM118-.LFBB10
 1179               	.LM118:
 1180 04ea 00D0      		rcall newSeg
 325:rowSegBuffer.c **** }
 1181               		.stabn	68,0,325,.LM119-.LFBB10
 1182               	.LM119:
 1183 04ec 0895      		ret
 1184               		.size	addSeg, .-addSeg
 1185               	.Lscope10:
 1186               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 1187               		.stabd	78,0,0
 1188               		.stabs	"rbpix_to_seg:F(0,15)",36,0,207,rbpix_to_seg
 1189               		.stabs	"rbValue:P(3,2)",64,0,207,17
 1190               		.stabs	"col:P(3,2)",64,0,207,22
 1191               		.stabs	"length:P(3,2)",64,0,207,24
 1192               	.global	rbpix_to_seg
 1193               		.type	rbpix_to_seg, @function
 1194               	rbpix_to_seg:
 1195               		.stabd	46,0,0
 208:rowSegBuffer.c **** {
 1196               		.stabn	68,0,208,.LM120-.LFBB11
 1197               	.LM120:
 1198               	.LFBB11:
 1199 04ee 1F93      		push r17
 1200               	/* prologue: function */
 1201               	/* frame size = 0 */
 1202 04f0 182F      		mov r17,r24
 1203 04f2 842F      		mov r24,r20
 212:rowSegBuffer.c **** 	if(col == 0)
 1204               		.stabn	68,0,212,.LM121-.LFBB11
 1205               	.LM121:
 1206 04f4 6623      		tst r22
 1207 04f6 01F4      		brne .L89
 214:rowSegBuffer.c **** 		last_rbValue = 0;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 117


 1208               		.stabn	68,0,214,.LM122-.LFBB11
 1209               	.LM122:
 1210 04f8 1092 0000 		sts last_rbValue.2029,__zero_reg__
 1211               	.LBB116:
 1212               	.LBB117:
 161:rowSegBuffer.c **** 	segPosition = 0;
 1213               		.stabn	68,0,161,.LM123-.LFBB11
 1214               	.LM123:
 1215 04fc 1092 0000 		sts segPosition,__zero_reg__
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 1216               		.stabn	68,0,164,.LM124-.LFBB11
 1217               	.LM124:
 1218 0500 96E0      		ldi r25,lo8(6)
 1219 0502 9093 0000 		sts rowSegBuffer,r25
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 1220               		.stabn	68,0,165,.LM125-.LFBB11
 1221               	.LM125:
 1222 0506 93E6      		ldi r25,lo8(99)
 1223 0508 9093 0000 		sts rowSegBuffer+1,r25
 1224 050c 00C0      		rjmp .L90
 1225               	.L89:
 1226               	.LBE117:
 1227               	.LBE116:
 218:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 1228               		.stabn	68,0,218,.LM126-.LFBB11
 1229               	.LM126:
 1230 050e 9091 0000 		lds r25,segPosition
 1231 0512 9923      		tst r25
 1232 0514 01F0      		breq .L90
 1233 0516 9091 0000 		lds r25,last_rbValue.2029
 1234 051a 1917      		cp r17,r25
 1235 051c 01F4      		brne .L90
 220:rowSegBuffer.c **** 		stretchSeg(length);
 1236               		.stabn	68,0,220,.LM127-.LFBB11
 1237               	.LM127:
 1238 051e 90E0      		ldi r25,lo8(0)
 1239 0520 00D0      		rcall stretchSeg
 221:rowSegBuffer.c **** 		return;
 1240               		.stabn	68,0,221,.LM128-.LFBB11
 1241               	.LM128:
 1242 0522 00C0      		rjmp .L92
 1243               	.L90:
 228:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 1244               		.stabn	68,0,228,.LM129-.LFBB11
 1245               	.LM129:
 1246 0524 612F      		mov r22,r17
 1247 0526 70E0      		ldi r23,lo8(0)
 1248 0528 6C71      		andi r22,lo8(28)
 1249 052a 7070      		andi r23,hi8(28)
 1250 052c 7595      		asr r23
 1251 052e 6795      		ror r22
 1252 0530 7595      		asr r23
 1253 0532 6795      		ror r22
 1254 0534 212F      		mov r18,r17
 1255 0536 2295      		swap r18
 1256 0538 2695      		lsr r18
 1257 053a 2770      		andi r18,lo8(7)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 118


 1258 053c 2295      		swap r18
 1259 053e 207F      		andi r18,lo8(-16)
 1260 0540 912F      		mov r25,r17
 1261 0542 9370      		andi r25,lo8(3)
 1262 0544 292B      		or r18,r25
 1263 0546 90E0      		ldi r25,lo8(0)
 1264 0548 422F      		mov r20,r18
 1265 054a 00D0      		rcall newSeg
 230:rowSegBuffer.c **** 	last_rbValue = rbValue;
 1266               		.stabn	68,0,230,.LM130-.LFBB11
 1267               	.LM130:
 1268 054c 1093 0000 		sts last_rbValue.2029,r17
 1269               	.L92:
 1270               	/* epilogue start */
 231:rowSegBuffer.c **** }
 1271               		.stabn	68,0,231,.LM131-.LFBB11
 1272               	.LM131:
 1273 0550 1F91      		pop r17
 1274 0552 0895      		ret
 1275               		.size	rbpix_to_seg, .-rbpix_to_seg
 1276               		.stabs	"last_rbValue:V(3,2)",38,0,209,last_rbValue.2029
 1277               		.stabn	192,0,0,.LFBB11-.LFBB11
 1278               		.stabn	224,0,0,.Lscope11-.LFBB11
 1279               	.Lscope11:
 1280               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 1281               		.stabd	78,0,0
 1282               		.stabs	"fb_to_rb:F(3,2)",36,0,85,fb_to_rb
 1283               		.stabs	"fbColor:P(3,2)",64,0,85,24
 1284               	.global	fb_to_rb
 1285               		.type	fb_to_rb, @function
 1286               	fb_to_rb:
 1287               		.stabd	46,0,0
 1288               		.stabs	"rowBuffer.c",132,0,0,.Ltext5
 1289               	.Ltext5:
   1:rowBuffer.c   **** // RowBuffer
   2:rowBuffer.c   **** //    An entire row is calculated and stored in the rowbuffer
   3:rowBuffer.c   **** //    before each line is displayed.
   4:rowBuffer.c   **** //    (There is not nearly enough memory for an entire frameBuffer)
   5:rowBuffer.c   **** //
   6:rowBuffer.c   **** //    A single byte is used for each drawable pixel in the row
   7:rowBuffer.c   **** //    this byte is actually a bit-mask of the OCR/DT values
   8:rowBuffer.c   **** //    so it's more of a settings-buffer
   9:rowBuffer.c   **** //    
  10:rowBuffer.c   **** //    Processing each byte and writing registers takes 14 clock cycles
  11:rowBuffer.c   **** //     so at full-speed LVDS (1 pixel per 7/8ths clock cycle)
  12:rowBuffer.c   **** //     then each drawable pixel is 16 LCD pixels wide
  13:rowBuffer.c   **** //     for a maximum resolution of 64 drawable pixels across
  14:rowBuffer.c   **** //     (thus, the row-settings-buffer is 64Bytes)
  15:rowBuffer.c   **** //    (Were the bytes not packed, and we used three bytes per drawable
  16:rowBuffer.c   **** //     pixel, each readFromSRAM*3+loadToRegister*3 pixel would be 
  17:rowBuffer.c   **** //     9 cycles... for ~100 pixels and ~300Bytes. Would it really be worth
  18:rowBuffer.c   **** //     3 times the memory for 1/3 more pixels? Probably not...
  19:rowBuffer.c   **** //     See RowSegmentBuffer for higher resolution...)
  20:rowBuffer.c   **** //
  21:rowBuffer.c   **** //   Red: (+OC1D => RX0+)
  22:rowBuffer.c   **** //    Off (0/63): OCR1D = 0
  23:rowBuffer.c   **** //    35/63:      OCR1D = 3
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 119


  24:rowBuffer.c   **** //    51/63:      OCR1D = 4   (FOUR_SHADES only)
  25:rowBuffer.c   **** //    63/63:      OCR1D >= 6
  26:rowBuffer.c   **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
  27:rowBuffer.c   **** //    Off (6/63): DTL1 = 0
  28:rowBuffer.c   **** //    38-39/63:      DTL1 = 1
  29:rowBuffer.c   **** //    54-55/63:      DTL1 = 2 (FOUR_SHADES only)
  30:rowBuffer.c   **** //    62-63/63:      DTL1 = 3
  31:rowBuffer.c   **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
  32:rowBuffer.c   **** //    Off (15/63):  OCR1A=4
  33:rowBuffer.c   **** //    47/63:        OCR1A=5
  34:rowBuffer.c   **** //    63/63:        OCR1A=6
  35:rowBuffer.c   **** //
  36:rowBuffer.c   **** //  For faster pixels: these values could be stored in a settingsBuffer
  37:rowBuffer.c   **** //  (instead of a frame-buffer based on color values)
  38:rowBuffer.c   **** //  we have: 
  39:rowBuffer.c   **** //                             0    1    2    3
  40:rowBuffer.c   **** //                 ColorVal:  00   01   10   11
  41:rowBuffer.c   **** //     Red (OCR1D): 0,3,4,6  000, 011, 100, 110
  42:rowBuffer.c   **** //   Green (DTL1):  0,1,2,3  000, 001, 010, 011
  43:rowBuffer.c   **** //    Blue (OCR1A): 4,5,6    100, 101, 110, 110
  44:rowBuffer.c   **** //           (I guess it could be noted that Blue's bit2 is always 1)
  45:rowBuffer.c   **** //           (also: OCR1A = 7 is totally acceptable, 
  46:rowBuffer.c   **** //                  so blueOCR=0x4|blueColor)
  47:rowBuffer.c   **** //           ( Similar can be said for Red... 7 is acceptable)
  48:rowBuffer.c   **** //  For memory space, we could fit these values directly in a single byte
  49:rowBuffer.c   **** //    Red Mask: 0x07
  50:rowBuffer.c   **** //  Green Mask: 0x14
  51:rowBuffer.c   **** //   Blue Mask: 0x60
  52:rowBuffer.c   **** //
  53:rowBuffer.c   **** //  Options: mask and shift, no extra memory
  54:rowBuffer.c   **** //           andi for red
  55:rowBuffer.c   **** //           andi for green + 3 shifts
  56:rowBuffer.c   **** //           5 shifts for blue
  57:rowBuffer.c   **** //           ... 10 cycles (12 pixels)
  58:rowBuffer.c   **** //           If green is the low two bits:
  59:rowBuffer.c   **** //           andi for green
  60:rowBuffer.c   **** //           andi for red + 2 shifts
  61:rowBuffer.c   **** //           5 shifts for blue
  62:rowBuffer.c   **** //           ... 9 cycles (11 pixels)
  63:rowBuffer.c   **** //          + 3 register writes (3 cycles) = 12cycles
  64:rowBuffer.c   **** //          + 1 SRAM read (2 cycles) = 14 cycles (16 pixels)
  65:rowBuffer.c   **** //           ALSO: 5 shifts TOTAL, usable?
  66:rowBuffer.c   **** //         (This may be outdated... and doesn't take into account
  67:rowBuffer.c   **** //          mov instructions... so see the code instead of believing this)
  68:rowBuffer.c   **** //         BUT:
  69:rowBuffer.c   **** //          64 pixels across * 64 pixels down is 4096 bytes
  70:rowBuffer.c   **** //          WAY more than my RAM
  71:rowBuffer.c   **** //          So either way we need to precalculate each row before
  72:rowBuffer.c   **** //          displaying it
  73:rowBuffer.c   **** //          Could be as simple as loading direct from program memory
  74:rowBuffer.c   **** 
  75:rowBuffer.c   **** 
  76:rowBuffer.c   **** 
  77:rowBuffer.c   **** #define LOADROW	TRUE
  78:rowBuffer.c   **** 
  79:rowBuffer.c   **** #define RB_WIDTH 64 //100
  80:rowBuffer.c   **** #define RB_HEIGHT 48
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 120


  81:rowBuffer.c   **** uint8_t rowBuffer[RB_WIDTH];
  82:rowBuffer.c   **** 
  83:rowBuffer.c   **** 
  84:rowBuffer.c   **** //Convert from a frameBuffer color to a rowBuffer setting value...
  85:rowBuffer.c   **** uint8_t fb_to_rb(uint8_t fbColor)
  86:rowBuffer.c   **** {
 1290               		.stabn	68,0,86,.LM132-.LFBB12
 1291               	.LM132:
 1292               	.LFBB12:
 1293               	/* prologue: function */
 1294               	/* frame size = 0 */
  87:rowBuffer.c   ****    uint8_t rb = 0;
  88:rowBuffer.c   **** 
  89:rowBuffer.c   ****    //rb bit: 7 6 5 4 3 2 1 0
  90:rowBuffer.c   ****    //        \_ _/ \_ _/ \ /
  91:rowBuffer.c   ****    //          V     V    V
  92:rowBuffer.c   ****    //          |     |    Green Setting
  93:rowBuffer.c   ****    //          |     Red Setting
  94:rowBuffer.c   ****    //          Blue Setting
  95:rowBuffer.c   **** 
  96:rowBuffer.c   ****    // Frame Buffer color/shade values:
  97:rowBuffer.c   ****    //fb bit: 7 6 5 4 3 2 1 0
  98:rowBuffer.c   ****    //        \ / \ / \ / \ /
  99:rowBuffer.c   ****    //         V   V   V   V
 100:rowBuffer.c   ****    //         |   |   |   Red Value (0-3)
 101:rowBuffer.c   ****    //         |   |   Green Value (0-3)
 102:rowBuffer.c   ****    //         |   Blue Value (0-3)
 103:rowBuffer.c   ****    //         Alpha... only partially implemented
 104:rowBuffer.c   **** 
 105:rowBuffer.c   **** #warning "This isn't at all optimized..."
 106:rowBuffer.c   ****    // Blue setting = Blue Value | 0x04
 107:rowBuffer.c   ****    uint8_t blueValue = (fbColor & 0x30) >> 4;
 1295               		.stabn	68,0,107,.LM133-.LFBB12
 1296               	.LM133:
 1297 0554 682F      		mov r22,r24
 1298 0556 70E0      		ldi r23,lo8(0)
 108:rowBuffer.c   ****    rb = (blueValue << 5) | 0x80;
 109:rowBuffer.c   **** 
 110:rowBuffer.c   ****    // Red setting = redVal << 1 | redVal & 0x01
 111:rowBuffer.c   ****    uint8_t redValue = (fbColor & 0x03);
 112:rowBuffer.c   ****    rb |= ((redValue << 1) | (redValue & 0x01)) << 2;
 1299               		.stabn	68,0,112,.LM134-.LFBB12
 1300               	.LM134:
 1301 0558 8370      		andi r24,lo8(3)
 1302 055a 90E0      		ldi r25,lo8(0)
 1303 055c 9C01      		movw r18,r24
 1304 055e 2170      		andi r18,lo8(1)
 1305 0560 3070      		andi r19,hi8(1)
 1306 0562 880F      		lsl r24
 1307 0564 991F      		rol r25
 1308 0566 282B      		or r18,r24
 1309 0568 392B      		or r19,r25
 1310 056a 220F      		lsl r18
 1311 056c 331F      		rol r19
 1312 056e 220F      		lsl r18
 1313 0570 331F      		rol r19
 1314 0572 2068      		ori r18,lo8(-128)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 121


 1315 0574 AB01      		movw r20,r22
 1316 0576 4073      		andi r20,lo8(48)
 1317 0578 5070      		andi r21,hi8(48)
 1318 057a 440F      		lsl r20
 1319 057c 551F      		rol r21
 1320 057e 242B      		or r18,r20
 1321 0580 CB01      		movw r24,r22
 1322 0582 8C70      		andi r24,lo8(12)
 1323 0584 9070      		andi r25,hi8(12)
 1324 0586 9595      		asr r25
 1325 0588 8795      		ror r24
 1326 058a 9595      		asr r25
 1327 058c 8795      		ror r24
 113:rowBuffer.c   **** 
 114:rowBuffer.c   ****    // Green Setting = Green Value...
 115:rowBuffer.c   ****    uint8_t greenValue = (fbColor & 0x0C) >> 2;
 116:rowBuffer.c   ****    rb |= greenValue;
 117:rowBuffer.c   **** 
 118:rowBuffer.c   ****    return rb;
 119:rowBuffer.c   **** }
 1328               		.stabn	68,0,119,.LM135-.LFBB12
 1329               	.LM135:
 1330 058e 822B      		or r24,r18
 1331               	/* epilogue start */
 1332 0590 0895      		ret
 1333               		.size	fb_to_rb, .-fb_to_rb
 1334               		.stabs	"rb:r(3,2)",64,0,87,18
 1335               		.stabn	192,0,0,.LFBB12-.LFBB12
 1336               		.stabn	224,0,0,.Lscope12-.LFBB12
 1337               	.Lscope12:
 1338               		.stabs	"",36,0,0,.Lscope12-.LFBB12
 1339               		.stabd	78,0,0
 1340               		.stabs	"pll_enable:F(0,15)",36,0,1340,pll_enable
 1341               	.global	pll_enable
 1342               		.type	pll_enable, @function
 1343               	pll_enable:
 1344               		.stabd	46,0,0
 1345               		.stabs	"main.c",132,0,0,.Ltext6
 1346               	.Ltext6:
1341:main.c        **** {
 1347               		.stabn	68,0,1341,.LM136-.LFBB13
 1348               	.LM136:
 1349               	.LFBB13:
 1350               	/* prologue: function */
 1351               	/* frame size = 0 */
1351:main.c        ****    setbit(PLLE, PLLCSR);
 1352               		.stabn	68,0,1351,.LM137-.LFBB13
 1353               	.LM137:
 1354 0592 89B5      		in r24,73-0x20
 1355 0594 8260      		ori r24,lo8(2)
 1356 0596 89BD      		out 73-0x20,r24
 1357               	.LBB118:
 1358               	.LBB119:
 1359               	.LBB120:
 1360               	.LBB121:
 1361               	.LBB122:
 1362               	.LBB123:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 122


 1363               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext7
 1364               	.Ltext7:
   1:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 123


  56:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 1365               		.stabn	68,0,105,.LM138-.LFBB13
 1366               	.LM138:
 1367 0598 88EC      		ldi r24,lo8(200)
 1368 059a 90E0      		ldi r25,hi8(200)
 1369               	/* #APP */
 1370               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1371 059c 0197      		1: sbiw r24,1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 124


 1372 059e 01F4      		brne 1b
 1373               	 ;  0 "" 2
 1374               	/* #NOAPP */
 1375 05a0 00C0      		rjmp .L96
 1376               	.L97:
 1377               	.LBE123:
 1378               	.LBE122:
 1379               	.LBE121:
 1380               	.LBE120:
 1381               	.LBE119:
 1382               	.LBE118:
 1383               		.stabs	"main.c",132,0,0,.Ltext8
 1384               	.Ltext8:
1359:main.c        ****       asm("nop");
 1385               		.stabn	68,0,1359,.LM139-.LFBB13
 1386               	.LM139:
 1387               	/* #APP */
 1388               	 ;  1359 "main.c" 1
 1389 05a2 0000      		nop
 1390               	 ;  0 "" 2
 1391               	/* #NOAPP */
 1392               	.L96:
1357:main.c        ****    while(!getbit(PLOCK, PLLCSR))
 1393               		.stabn	68,0,1357,.LM140-.LFBB13
 1394               	.LM140:
 1395 05a4 09B4      		in __tmp_reg__,73-0x20
 1396 05a6 00FE      		sbrs __tmp_reg__,0
 1397 05a8 00C0      		rjmp .L97
1362:main.c        ****    setbit(PCKE, PLLCSR);
 1398               		.stabn	68,0,1362,.LM141-.LFBB13
 1399               	.LM141:
 1400 05aa 89B5      		in r24,73-0x20
 1401 05ac 8460      		ori r24,lo8(4)
 1402 05ae 89BD      		out 73-0x20,r24
 1403               	/* epilogue start */
1364:main.c        **** }
 1404               		.stabn	68,0,1364,.LM142-.LFBB13
 1405               	.LM142:
 1406 05b0 0895      		ret
 1407               		.size	pll_enable, .-pll_enable
 1408               		.stabs	"__count:r(3,4)",64,0,138,24
 1409               		.stabn	192,0,0,.LBB122-.LFBB13
 1410               		.stabn	224,0,0,.LBE122-.LFBB13
 1411               	.Lscope13:
 1412               		.stabs	"",36,0,0,.Lscope13-.LFBB13
 1413               		.stabd	78,0,0
 1414               		.stabs	"lvds_timerInit:F(0,15)",36,0,1366,lvds_timerInit
 1415               	.global	lvds_timerInit
 1416               		.type	lvds_timerInit, @function
 1417               	lvds_timerInit:
 1418               		.stabd	46,0,0
1367:main.c        **** {
 1419               		.stabn	68,0,1367,.LM143-.LFBB14
 1420               	.LM143:
 1421               	.LFBB14:
 1422               	/* prologue: function */
 1423               	/* frame size = 0 */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 125


1373:main.c        ****    OCR1C = 6;
 1424               		.stabn	68,0,1373,.LM144-.LFBB14
 1425               	.LM144:
 1426 05b2 86E0      		ldi r24,lo8(6)
 1427 05b4 8BBD      		out 75-0x20,r24
1376:main.c        **** 	CLOCK_OCR = 3; //2; //3;
 1428               		.stabn	68,0,1376,.LM145-.LFBB14
 1429               	.LM145:
 1430 05b6 83E0      		ldi r24,lo8(3)
 1431 05b8 8CBD      		out 76-0x20,r24
1408:main.c        ****    OSCCAL = OSCCAL_VAL;
 1432               		.stabn	68,0,1408,.LM146-.LFBB14
 1433               	.LM146:
 1434 05ba 8FEF      		ldi r24,lo8(-1)
 1435 05bc 81BF      		out 81-0x20,r24
1475:main.c        **** 	pll_enable();
 1436               		.stabn	68,0,1475,.LM147-.LFBB14
 1437               	.LM147:
 1438 05be 00D0      		rcall pll_enable
1487:main.c        **** 	writeMasked(CSBITS, 
 1439               		.stabn	68,0,1487,.LM148-.LFBB14
 1440               	.LM148:
 1441 05c0 8FB5      		in r24,79-0x20
 1442 05c2 807F      		andi r24,lo8(-16)
 1443 05c4 8460      		ori r24,lo8(4)
 1444 05c6 8FBD      		out 79-0x20,r24
1494:main.c        **** 	writeMasked(DTPSBITS,
 1445               		.stabn	68,0,1494,.LM149-.LFBB14
 1446               	.LM149:
 1447 05c8 8FB5      		in r24,79-0x20
 1448 05ca 8063      		ori r24,lo8(48)
 1449 05cc 8FBD      		out 79-0x20,r24
1506:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
 1450               		.stabn	68,0,1506,.LM150-.LFBB14
 1451               	.LM150:
 1452 05ce 80B7      		in r24,80-0x20
 1453 05d0 8260      		ori r24,lo8(2)
 1454 05d2 80BF      		out 80-0x20,r24
1509:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
 1455               		.stabn	68,0,1509,.LM151-.LFBB14
 1456               	.LM151:
 1457 05d4 80B7      		in r24,80-0x20
 1458 05d6 8160      		ori r24,lo8(1)
 1459 05d8 80BF      		out 80-0x20,r24
1511:main.c        **** 	setbit(PWM1D, TCCR1C);
 1460               		.stabn	68,0,1511,.LM152-.LFBB14
 1461               	.LM152:
 1462 05da 87B5      		in r24,71-0x20
 1463 05dc 8160      		ori r24,lo8(1)
 1464 05de 87BD      		out 71-0x20,r24
1515:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
 1465               		.stabn	68,0,1515,.LM153-.LFBB14
 1466               	.LM153:
 1467 05e0 B99A      		sbi 55-0x20,1
1517:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
 1468               		.stabn	68,0,1517,.LM154-.LFBB14
 1469               	.LM154:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 126


 1470 05e2 BA9A      		sbi 55-0x20,2
1518:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
 1471               		.stabn	68,0,1518,.LM155-.LFBB14
 1472               	.LM155:
 1473 05e4 BB9A      		sbi 55-0x20,3
1519:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
 1474               		.stabn	68,0,1519,.LM156-.LFBB14
 1475               	.LM156:
 1476 05e6 BD9A      		sbi 55-0x20,5
1522:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
 1477               		.stabn	68,0,1522,.LM157-.LFBB14
 1478               	.LM157:
 1479 05e8 86B5      		in r24,70-0x20
 1480 05ea 8C7F      		andi r24,lo8(-4)
 1481 05ec 86BD      		out 70-0x20,r24
1589:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
 1482               		.stabn	68,0,1589,.LM158-.LFBB14
 1483               	.LM158:
 1484 05ee 89E0      		ldi r24,lo8(9)
 1485 05f0 87BD      		out 71-0x20,r24
1592:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
 1486               		.stabn	68,0,1592,.LM159-.LFBB14
 1487               	.LM159:
 1488 05f2 83E6      		ldi r24,lo8(99)
 1489 05f4 80BF      		out 80-0x20,r24
1623:main.c        ****  	Nada_init();
 1490               		.stabn	68,0,1623,.LM160-.LFBB14
 1491               	.LM160:
 1492 05f6 80E3      		ldi r24,lo8(48)
 1493 05f8 84BD      		out 68-0x20,r24
 1494 05fa 84E0      		ldi r24,lo8(4)
 1495 05fc 8DBD      		out 77-0x20,r24
 1496               	/* epilogue start */
1624:main.c        **** }
 1497               		.stabn	68,0,1624,.LM161-.LFBB14
 1498               	.LM161:
 1499 05fe 0895      		ret
 1500               		.size	lvds_timerInit, .-lvds_timerInit
 1501               	.Lscope14:
 1502               		.stabs	"",36,0,0,.Lscope14-.LFBB14
 1503               		.stabd	78,0,0
 1504               		.stabs	"lcd_Init:F(0,15)",36,0,870,lcd_Init
 1505               	.global	lcd_Init
 1506               		.type	lcd_Init, @function
 1507               	lcd_Init:
 1508               		.stabd	46,0,0
 1509               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext9
 1510               	.Ltext9:
   1:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //lcdStuff 0.51ncf-git
   2:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
   3:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.51ncf-git first attempt at using git for uploading to googleCode...
   4:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        this version isn't yet used by any projects
   5:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.50ncf cleanup, colorOverride is unused...
   6:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				SMILEY -> LCD_SMILEY
   7:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf-1 loadRow unused... removal untested...
   8:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf drawPix...
   9:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-6 HSYNC_INACTIVE, etc. definable elsewhere
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 127


  10:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-5 Adding BLUE_VERT_BAR_REVERSED
  11:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-4 Adding NOTES: DON'T START WITH BLUE_DIAG_BAR
  12:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-3 T_DV and T_Vlow overrideable
  13:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-2 Not sure if I've modified it between... but here: 
  14:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        FRAME_COUNT_TO_DELAY wasn't defined, giving warnings
  15:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-1 updateLCD() has return-values for state-switches
  16:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (VFP, VSync, VBP, DE)
  17:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        ACTUALLY, that's unnecessary... state-transitions can be
  18:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        determined by vSync and dataEnable...
  19:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf Haven't been keeping these backed up regularly...
  20:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        More toward realtime adjustable timing values
  21:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        V Front Porch now occurs at the beginning of the frame, instead
  22:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        of at the end...
  23:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  24:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.20ncf More Timing Value experiment preparation... 
  25:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-3ish looking into reloading methods for e.g. experimenting with
  26:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          timing values: sdramThing2.0-7
  27:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          How to "move" timing-values around data which needn't be
  28:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          changed...
  29:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-andsomemore
  30:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Added MAKELONG to fix integer overflow warnings
  31:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Revised it from "... + MAKELONG" to "MAKELONG(...)"
  32:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (The +MAKELONG version is lost in the ether... if you *really*
  33:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //           want it, there's a localized version in sdramThing2.0-6)
  34:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-1ish - Adding HSYNC_COUNT_FRAME_COMPLETE
  35:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               Removal of LVDS_PRESCALER stuff...
  36:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf - Stolen from LCDdirectLVDS/54-moreColorStuff/main.c
  37:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Removal of LCDdirectLVDS-specific stuff...
  38:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				A little bit of rewriting of notes to be more generalized
  39:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          All delay_cyc references replaced with delay_Dots,
  40:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //					math changed accordingly...
  41:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  42:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  43:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I hereby declare this FPD-Link simulation technique to forever be called
  44:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  PW-BANGing
  45:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  46:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o 0.10ncf-4: (sdramThing2.0v8-28)
  47:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DON'T START WITH BLUE_DIAG_BAR
  48:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Unless you want to be depressed
  49:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Good Starting Point DE_BLUE
  50:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  51:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  52:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  53:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //new notes a/o 0.10ncf-3ish:
  54:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The basic idea is that timing is something that needs to be experimented
  55:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // with, often... so, for cases where LCD timing/drawing data is loaded
  56:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // beforehand (e.g. sdramThing2.0-7), it would be nice not to have to
  57:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // reload *all* the data, only to change the necessary timing data
  58:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  59:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Neglecting the SDRAM for a second, we have essentially:
  60:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (The exact placement is not necessarily in order... e.g. DH_DOTS could
  61:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  be at the end of a row, or at the beginning... VSYNC rows could be at
  62:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  the top, or at the bottom.....)
  63:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (See also notes "Here's how it worked pre-lvds:", which actually are a
  64:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   bit off, e.g. I don't think VSYNC L->H was delayed by DE_TIME after
  65:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Hsync)
  66:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 128


  67:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS + HD_DOTS + DH_DOTS = "Horizontal Blank Time"
  68:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (This "front/back" thing always confused me...
  69:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DH_DOTS is *in front of* Hsync as far as *time* is concerned...
  70:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  i.e. looking at a 'scope trace... But something about reading left-to-
  71:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  right causes me to feel like "front" is the furthest to the right
  72:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  which would be *later* in time... weird.
  73:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
  74:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  75:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |--|<--H_LOW_DOTS                       "Horiz Front Porch"
  76:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  |--|<--HD_DOTS="Horiz Back Porch"    |<---->|<--DH_DOTS
  77:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .      |
  78:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<............................................./
  79:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .    
  80:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        v  v  .                                 .      
  81:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V _______________________________________________  \ VSYNC Rows
  82:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  83:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_Vlow times)
  84:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .
  85:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .      "Vsync Back Porch"
  86:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  87:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  88:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_VD times)
  89:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .         "Vbp should be
  90:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              v                                 v          static"
  91:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************
  92:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  93:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  94:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  95:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
  96:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  97:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *<------ DE_ACTIVE_DOTS --------->*        (Repeat V_COUNT
  98:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *         =1024 times)
  99:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     .   Displayed Pixels
 100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *
 101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
 104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
 106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************      
 108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                      "Vsync Front Porch"
 109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
 110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_DV times)
 112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #warning "TODO Maybe: LCDdirectLVDS (which so far is the only version which synced with such low re
 115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Front vs. Back porches....
 117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   If I were to draw a car driving down a street... 
 118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I would draw it with its front to the right, driving to the right...
 119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       _____/\________     \O/
 121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ...|__   _________   __\     |
 122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...\_/         \_/       / \							//
 123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 129


 124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person is *in front of* the car... which means the car has not yet
 125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   arrived at the person, but will soon... 
 126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (later in time, not *before* in time)
 127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This is my logic...
 128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So The "Horizontal Front Porch", to me, should be to the RIGHT of the
 129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Horizontal Sync Pulse...
 130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But that ain't how it is (unless I've confused myself into a circle
 131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   where my logic is actually right, and I just think it's wrong?)
 132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   
 133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  By the logic that the front porch occurs *before* the sync pulse,
 134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ... I suppose we could think of a person in front of a house... it
 135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   makes more sense, anyhow, since it's a porch in front of a house, 
 136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   not person in front of a car.
 137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person's walking into the house, crosses the *front*-porch 
 138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   *before* enterring the doorway. If he continues walking all the way
 139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   through the house and out the back-door, he'll be crossing the *back*
 140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   porch later in time...
 141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Right, so the logic makes sense... but for some reason I have to run 
 143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  through this whole diatribe every time I see the terms.
 144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Heh, and even after going through it, the damned thing seems backwards.
 145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Probably because I drew it with the front-porch to the right side...)
 146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (AND THEN there's the issue that it seems to me like the front-porch
 147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the left of the drawing-area whereas the back-porch
 148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the right of it... rather than to the HSYNC pulse)
 149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Anyways, all that drawing was to figure out where to position this
 152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in memory, such that it would be the least processing-effort to modify
 153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // timing values for testing... (because loading the SDRAM's free-running 
 154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // data takes ~20minutes!)
 155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Options LTN, IDT, or TESTVALS
 159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
 160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DISPLAY
 161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //oldNote:
 165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it seems the speed (at least for the LTN) isn't so important after all
 167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This could be used to my advantage...
 168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
 169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Thus, pixels could be skinnier, thus higher-resolution.
 170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Or more instructions could be used for the same resolution
 171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   allowing, e.g. sprites from program-memory, without necessitating a
 172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   large (or any?) frame-buffer...
 173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This would normally be 0 for the highest-speed frame-refresh possible
 176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // However, increasing this value can slow the frame-refresh rate
 177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if desired
 178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. 50000 causes it to refresh ~ every few seconds
 179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (durn-near the limit for how long the LCD will retain an image)
 180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The benefit being that it doesn't flicker at annoying rates for
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 130


 181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  stationary images
 182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  worth exploring...
 183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This may be highly dependent on the screen capabilities...
 184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   of course, this sorta thing is undocumented
 185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   it just has to be experimented with
 186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   likely be driven DC... not sure what the long term effects are.
 188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This could be a hell of a lot more sophisticated...
 189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. refresh after a frameBuffer change
 190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      refresh based on a seconds-timer
 191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...
 192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AS-IS: Does refreshes completely independent of the frame-buffer
 193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      if it's too slow, some images may be missed completely.
 194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      This is not true for FRAME_SYNC TRUE (below)
 195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (and it's not really useful anymore with FRAME_SYNC)
 196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o sdramThing2.0, this is not really relevent...
 197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	if the frame needs updating, just stop free-running, right?
 198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	well, doing-so might cause issues, since the LVDS clock will not be
 199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    running... this is a TBD
 200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //New Idea:
 204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Disable the Hsync timer interrupt after the frame completes
 205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and reenable elsewhere...
 206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (It seems pixels changing from one shade to another take an
 207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate step halfway between)
 208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Thus, two updates then a pause might clear that up)
 209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   is the same...)
 211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (but it is an interesting effect)
 212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Reworded: Having several frame refreshes before a pause helps to
 214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  "solidify" the color changes... especially the sharp changes 
 215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (e.g. yellow<->black)
 216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
 217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   in LCDdirect that was only connected such that R, G, and B were each
 218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   either full-off or full-on, i.e. all Red bits were connected to a
 219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   single output pin (full on when 1, full off when 0).
 220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I hadn't attributed it to improper refresh synchronization
 221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   as the refresh rate was too fast to see... That's a handy way to get
 222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  connected with each color 
 224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  If you WANT this effect (for intermediate shades?) 
 226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   set FRAME_COUNT_TO_DELAY to 1
 227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Then, each change of color will (apparently) result in a value halfway
 228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between the old color and the new color
 229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Not sure whether it's an electrical problem, but these half-shades 
 230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   depends on the goal...
 232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FRAME_COUNT_TO_DELAY 2//7//1//5//2//3
 233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN appears to be content with my pseudo-LVDS scheme.
 237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IAXG has never unblanked
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 131


 238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Even though suitable timings were found with SwitchResX
 239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Maybe due to psuedo-LVDS
 240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            slight timing issues // It probably doesn't work with all cases...
 241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Definitely with drawPix/Images...(RC oscillator variances?)
 242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            glitches when switching LVDS states 
 243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 (thought I had that figured out, originally)
 244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      The fact the LTN appears to recognize the signalling suggests the
 245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG would be worth further exploration...
 246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         Unfortunately, the CCFT blew out my inverter
 247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        And I must have put it back together incorrectly
 248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (backlight filters out of order or flipped?)
 249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (which actually makes for some very interesting
 250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         visuals, but hard to develop with)
 251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG: uses DE, V, and H
 252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             At low pixel-clock DE is active for fewer pixels...
 253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              Last Tested: 680 was full-screen
 254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             Nice because it increases the frame-rate!
 255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      LTN:  uses DE only
 256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
 259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Though I am currently running with OSCAL set to the highest frequency
 261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   and the PLL seems to be syncing at about 128MHz)
 262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (New Note, a/o sdramThing2.0v5... it's kinda ironic that I was able to
 263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   run it at 128MHz with nothing more than an AVR and some gates...
 264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   seeing as how sdramThing has been fidgetty just running at 8MHz
 265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Anyways, an eventual goal is to run at 133MHz+, using basically
 266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   nothing more than the SDRAM itself for timing and refreshes...
 267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   would allow for full resolution and full color-depth)
 268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Wiring:
 273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   simplest of all:
 275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's spec'd to run from 4.5-5.5V, and its propagation delays and slew
 279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     yet it's working...
 281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, the output voltages are right in the LVDS range,
 282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
 283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (Don't forget the LCD has a 100ohm resistor between
 284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         RXinN/clk+ and RXinN/clk-)
 285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's probably best to use two XORs from the same chip for a single
 287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    LVDS channel, since different chips may have slightly different
 288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    characteristics. 
 289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The entire circuit, thus, requires TWO 74LS86's 
 291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (four XORs apiece, two per LVDS channel, 8-total)
 292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              VCC3V3   VCC3V3
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 132


 295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                           ______________
 296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---\ \-_                        |  LCD (1 channel
 297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |       of 4)
 298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk-  | ----.
 299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   AVR, etc.         | |    _-                      |     |
 300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3.3V TTL >---+---/ /___-                        |     \ 100
 301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   output       |                                   |     /
 302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     \ ohms
 303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     /
 304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                `---\ \-_                        |     |
 305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |     |
 306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk+  | ----'
 307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    _-                      |
 308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---/ /___-                        |
 309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                          |
 310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               GND      GND
 311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Also used: The TTL 74AHC series...
 314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
 316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (with a 100ohm load in the LCD)
 318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     channels, I had to implement Red and Green with the LS 
 321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     before switching all channels to the LS... Using different chips
 322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (specifically, different TYPES of chips) for different channels
 323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     signals are synchronized, but the red and green signals were shifted
 325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     a bit or two (resulting in "Black" appearing green)
 326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  For other circuits attempted, see oldNotes.txt
 328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (and boy there were many, involving voltage dividers, AC coupling,
 329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      reference voltages, BJT differential amplifiers... I doubt I 
 330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      documented them all, or even most. Whoda thunk the simplest, 
 331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      especially under- AND over-spec'd--timing, supply voltage, and
 332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      output voltage--would be the one...?)
 333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LVDS/FPD-Link timing:
 335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
 338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____               |____.____.____.____
 340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |            |         |
 342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^  ^ | 
 347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<--Not Blue-->|         |
 348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^ ^  |  
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 133


 352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<------->|-Not Green    |
 353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^^     
 357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<-->|-Not Red
 358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Of course: The "Not Green/Red" bits above are least-significant-bits
 360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              and basically have little/no visible effect
 361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Implementations/prospects:
 364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowBuffer.c (more like row-settings-buffer)
 365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     calculate a row's worth of pixels before drawing that row
 366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (uses packed color settings in a single byte per drawable pixel)
 367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     64 drawable pixels across, regardless of LVDS speed
 368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * For faster pixels: these settings values could be stored 
 369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (not implemented)
 371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowSegBuffer.c
 372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     also calculates an entire row before drawing it
 373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     instead of storing pixels, store "segments"
 374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     i.e. each segment is defined by a color value and a length
 375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Number of segments is limited only by memory...
 376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      e.g. 64 segments per row (max) is 64*3Bytes
 377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Three bytes for color, and *really simple* packing for seg-length
 378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       as high as one LCD pixel.
 380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (with packing)
 382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      only adds two clock cycles to each "pixel", so probably worth it
 384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   In Any Case: There's not enough RAM for a full frame
 386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          64 pixels across * 64 pixels down is 4096 bytes
 387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          So whatever method, we need to precalculate each row before
 388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          displaying it
 389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Could be as simple as loading direct from program memory
 390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Since low-bits are barely visible, their effect is neglected.
 393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE/V/H Timing (LCDdirectLVDS):
 396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |  0   1    2    3    4    5    6       All: set @ 0
 399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____                         OCR1C = 6 
 400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Clock:    /                   \    .    .    /         Complementary-
 401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                             Output Mode
 402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                          required for DT
 403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____ ____ ____ ____ ____ ____|____    
 405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state2                      |    
 407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_BLUE: >|    DT=X, OCR=0
 408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         Watch the transition!! -------^
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 134


 409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DC_DISABLED:
 411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   maxBlue: >\____|		DT=0, OCR=5
 412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             See below for more blue settings...
 413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____      ____ ____|____ 
 415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state1              | 
 417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\______________|    DT=3, OCR=3
 418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DC_DISABLED:
 419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Not much can be done...
 420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____           ____ ____ ____|____ 
 422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state3              |
 424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\____|		DT=4, OCR=5
 427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____                ____ ____|____ 
 429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state4          | 
 431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >__________________________________|    DT=X, OCR=0
 432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             TransitionWatch!!! -------^
 433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             Shouldn't matter... DT from no-edge
 434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >\________________________|		DT=0, OCR=1
 436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____ ____ ____ ____|____ 
 438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state0                  |     
 440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\____|		DT=3, OCR=5
 443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //So far this is the only case I've seen:
 445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Vsync
 446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_ACTIVE
 447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_ACTIVE		0
 448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_INACTIVE
 450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_INACTIVE	1
 451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Hsync
 453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_ACTIVE
 454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_ACTIVE		0
 455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_INACTIVE
 457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_INACTIVE	1
 458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE (active high)
 460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_ACTIVE
 461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_ACTIVE			1
 462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_INACTIVE
 464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_INACTIVE		0
 465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 135


 466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HERE!
 468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Transitions: OLD!!!!! WRONG!!!!
 473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (are they? There're several additional transitions, now, for one.)
 474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The idea is to reduce the number of instructions between each
 475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS "state."
 476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  These are implemented below in the case:
 477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    "#else //NOT FULL_INIT_TESTS"
 478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Since each instruction takes *longer than* a single pixel
 479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    two instructions would *at best* occur on two consecutive pixels
 480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Thus, there's likely to be a transition-glitch
 481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (e.g. old OCR value with new DT value)
 482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Note that the new DT values are implemented at the next corresponding
 483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    edge after the DT-write instruction completes
 484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    New OCR values are delayed until the next TCNT reset to 0
 487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Initial:
 489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	H			OCR=2
 492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H		->	Nada		OCR=NADA_OCR
 493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	V			DT=3
 495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	V+H		OCR=0
 496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V+H	->	V			OCR=NADA_OCR
 497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	Nada		DT=2
 498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	DE			DT=1
 500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DE	->	Nada		DT=2
 501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(REMOVE_DC) && REMOVE_DC)
 504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Unused, normally...
 507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
 509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
 511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else //!REMOVE_DC
 514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Nada init
 515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Unused, normally...
 518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 136


 523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //REMOVE_DC
 527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FULL_INIT_TESTS TRUE
 530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Display is DE-Only (doesn't use H/Vsync)
 532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Shouldn't be necessary to select this if it is,
 533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since DE timing is the same either way
 534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // but I want to test whether a single-bit is being detected
 535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  single bit, which might explain why the other display didn't work)
 537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //These are just examples... the project should define them:
 538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
 540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()      Nada_init()
 541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()    Nada_init()
 542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()    Nada_init()
 543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()      Nada_init()
 544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()      Nada_init()
 545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()      Nada_init()
 546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()     DE_init()
 547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DE_init()
 548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if(DE_BLUE)
 550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "...The display should be blank"
 552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
 553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Use full initialization of each LVDS state
 554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (might not be good during transitions, but should guarantee
 555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  steady-state, in case my transitions aren't correct...)
 556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()		Vsync_init()
 558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()		VplusH_init()
 559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()		Vsync_init()
 560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()		Nada_init()
 561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()		Hsync_init()
 562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()		Nada_init()
 563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()		DEonly_init()
 564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DEblue_init()
 565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()		Nada_init()
 566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else	//NOT FULL_INIT_TESTS
 570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 																	 //for easy-scoping
 573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync() { OCR1A=0; }
 575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromVplusH() { OCR1A=4; }
 576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
 577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()   { OCR1A=3; }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 137


 580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()   { OCR1A=4; }
 581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //End Of FULL_INIT_TESTS
 589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The typical patterns look like this (not at all to scale):
 594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ----______------------------------------------------______-- V
 595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
 597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      __________-__-__-__-__-__-__-__-__-__-__________________  DE
 599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 
 600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ^^^^\														//blah
 601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             1234 5?
 602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Pixels are sent during DE High (basically all the CPU will be used here)
 603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Ideally, 
 604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  there won't be any glitches when changing from one state to another
 605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Init (pre 1):
 607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DeadTimerRising=1
 608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The states are:
 610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Not necessarily accurate, just looking into necessary changes)
 611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (from Vsync L->H)
 612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1  NothingActive (long, No DE, VporchFrontTimes)
 614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2  Hsync
 616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3  NothingActive (short)
 618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4  DE
 620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5  NothingActive(?)
 622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7  Repeat 2-5 for each row
 624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8  NothingActive (long, No DE, VporchBackTimes)
 626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9  V w/o H
 628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   10 V w/  H
 630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   11 Repeat 9-10 for Vsync time...
 632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Here's how it worked pre-lvds:
 635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HSYNC, VSYNC, and DE refer to the actual pins
 636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In the LVDS setup, there're modes corresponding to each pin-combination
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 138


 637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Timer Interrupt:
 639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  loadData:
 640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC active
 641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC Low delay
 642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC inactive
 643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if(dataEnable)
 644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE active
 645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Send row data
 646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE inactive
 647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  //Prep for next interrupt
 648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  switch(hsyncCount++)
 649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync H->L (active)
 650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    1:
 651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC active
 653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync L->H (inactive)
 654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_Vlow:
 655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC inactive
 656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Start of frame
 657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_VD +(T_Vlow):
 658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=TRUE
 659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //All rows have been displayed
 660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    V_COUNT +(T_VD+T_Vlow):
 661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Frame Complete
 663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
 664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          hsyncCount=0
 665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(dataEnable)
 666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Use the remaining time to load the next row to memory
 667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  So:
 669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC active
 679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE (not necessary?)
 680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
 682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC inactive
 691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 139


 694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=TRUE
 703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 708:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 709:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 710:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 711:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 712:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 713:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE
 714:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 715:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 716:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's basically just:
 717:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
 718:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 719:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 720:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 721:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 722:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 723:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 724:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 725:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 726:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 727:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||  .   |        |                      .
 728:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|  .   ^--------^                      .
 729:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |  .                                   .
 730:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 hsyncCount=0 (repeat from Interrupt0)  .
 731:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 732:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 733:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 734:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 735:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 736:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE
 737:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ESPECIALLY THIS FIRST STATE.
 738:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V Front Porch originally (and in these drawings) occurred at the end
 739:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // of the frame...
 740:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // More logically, it now starts at the beginning of the frame
 741:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (Also removing this initial "glitch" of a single interrupt with
 742:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NothingActive)
 743:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 744:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE (a/o 0.30, for certain)
 745:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOW to compare with LVDS states:
 746:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 747:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 748:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 749:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 750:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 140


 751:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 752:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 753:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 754:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 755:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- V w/o H  \ These two toggle until
 756:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- V w/ H   / next LCD state...
 757:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 758:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- V w/o H > Intermediate change of state
 759:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 760:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From Previous State (?)
 761:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         /
 762:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 763:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 764:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
 765:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 766:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 767:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 768:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 769:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 770:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 771:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 772:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- NothingActive  \ These two toggle until
 773:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- H_Only         / next LCD state...
 774:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 775:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- NothingActive > Intermediate change of state
 776:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 777:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- V w/o H   \ From previous state
 778:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- V w/ H    /
 779:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 780:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 781:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
 782:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 783:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 784:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 785:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 786:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 787:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^              ^ ^^        ^ 
 788:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        |
 789:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        +--- NothingActive  \  These four
 790:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | |+------------ DE              | cycle until
 791:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | +------------- NothingActive   | next LCD state...
 792:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              +--------------- H_Only  ^      /
 793:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |                                       |
 794:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From previous   |
 795:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         / state           +-This intermediate state
 796:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                may not be necessary
 797:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                (IAXG01 shows 160 dots!)
 798:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 799:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 800:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 801:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 802:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 803:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 804:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 805:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 806:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 807:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^^        ^    ^ ^
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 141


 808:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | |
 809:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | +--- NothingActive \  These two toggle
 810:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    +----- H_Only        /  until next LCD state
 811:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |
 812:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        +---- NothingActive \ 								//blah
 813:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |+------------- DE             |  From previous state
 814:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +-------------- NothingActive  |
 815:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +---------------- H_Only        /
 816:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 817:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's essentially just:
 818:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
 819:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 820:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 821:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 822:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 823:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 824:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 825:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 826:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 827:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 828:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^             .                                   .
 829:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |             .....................................
 830:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +--- NothingActive \											//blah
 831:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +----- H_Only        / From previous state...
 832:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 833:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 834:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 835:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS State transitions:
 836:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1 H_Only
 837:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2 NothingActive
 838:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 839:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3 V w/o H
 840:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4 V w/ H
 841:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    
 842:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 3,4)
 843:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 844:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5 V w/o H
 845:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 846:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   6 NothingActive
 847:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7 H_Only
 848:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 849:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 6,7)
 850:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 851:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8 NothingActive
 852:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 853:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9 H_Only
 854:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  10 NothingActive
 855:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  11 DE
 856:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  12 NothingActive
 857:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 858:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 9-12)
 859:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 860:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  13 H_Only
 861:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  14 NothingActive
 862:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 863:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 13-14)
 864:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 142


 865:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   These should be reviewed to determine which changes are necessary
 866:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between each state...
 867:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (the fewer changes, the less likely we'll glitch...?)
 868:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 869:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 870:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void lcd_Init(void)
 871:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1511               		.stabn	68,0,871,.LM162-.LFBB15
 1512               	.LM162:
 1513               	.LFBB15:
 1514               	/* prologue: function */
 1515               	/* frame size = 0 */
 872:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  	Nada_init();
 1516               		.stabn	68,0,872,.LM163-.LFBB15
 1517               	.LM163:
 1518 0600 80E3      		ldi r24,lo8(48)
 1519 0602 84BD      		out 68-0x20,r24
 1520 0604 84E0      		ldi r24,lo8(4)
 1521 0606 8DBD      		out 77-0x20,r24
 1522               	/* epilogue start */
 873:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 1523               		.stabn	68,0,873,.LM164-.LFBB15
 1524               	.LM164:
 1525 0608 0895      		ret
 1526               		.size	lcd_Init, .-lcd_Init
 1527               	.Lscope15:
 1528               		.stabs	"",36,0,0,.Lscope15-.LFBB15
 1529               		.stabd	78,0,0
 1530               		.stabs	"updateLCD:F(3,2)",36,0,1165,updateLCD
 1531               	.global	updateLCD
 1532               		.type	updateLCD, @function
 1533               	updateLCD:
 1534               		.stabd	46,0,0
 874:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 875:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 876:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TESTVALS	0
 877:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define LTN 1
 878:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define IDT 2
 879:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 880:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 881:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //TIMING:
 882:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Measurements below (in microseconds) are referring to preLVDS
 883:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  There may be other such old-notes...
 884:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 885:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 886:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<--T_Hhigh-->| |<-T_Hlow
 887:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    __   _____________   ____________  3.6V
 888:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H    |_|             |_|           _  0V
 889:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 890:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Data Enable
 891:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Only active when there's valid pixel data
 892:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       (For a dual-pixel 1024x768 display:
 893:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         for 512 of the 717 clocks in HSYNC-active)
 894:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Low during Vsync... (~720us)
 895:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 896:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 897:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech display: 136 dots
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 143


 898:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //2-136+
 899:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech, last used: 40
 900:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Last used 8
 901:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN: 1072<=1344<=1500 clocks per line, 1024DE... Hsync unused
 902:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // SEE Hlow_Delay() notes if this value is large!
 903:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 904:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef H_LOW_DOTS
 905:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 906:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	8
 907:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 908:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS   40//8//1//40 //30 //2//136
 909:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 910:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
 911:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 							  // And having a value here increases codesize
 912:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 913:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 914:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 915:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //H is set low immediately upon entry of the timer interrupt
 916:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // its low-time is controlled via nops
 917:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (so if HLow is long for a particular display, this might need revising)
 918:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 919:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if((!defined(HLOW_DELAY_OVERRIDE) || !HLOW_DELAY_OVERRIDE) \
 920:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		                                         && !defined(Hlow_Delay))
 921:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hlow_Delay() \
 922:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	delay_Dots(H_LOW_DOTS)
 923:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 924:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 925:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 926:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 927:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 928:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This was found expermentally with SwitchResX
 929:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 680
 930:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (IDTech had some oddities regarding slow pixel-clocks, where pixels
 931:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  would be repeated, regardless of the pixel-clock, thus, for slow clocks
 932:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it has the effect of *stretching* the image, thus 680 "pixels" across
 933:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  instead of its 1024 *physical* pixels)
 934:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 1024
 935:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
 936:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        it does, however, affect the vertical(!)
 937:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // If I recall Correctly, this is used only for setting the timer interrupt
 938:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  rate...
 939:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 940:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
 941:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 942:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
 943:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 944:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
 945:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 946:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 947:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 948:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
 949:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  90-320+
 950:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Total Time: 1206<=1344<=2047
 951:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
 952:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Excess waits should be thrown in DH (since that's between interrupts)
 953:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //T_HD is the time from H inactivated to DE activated
 954:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka H back-porch: 1-160+
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 144


 955:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 50
 956:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 5
 957:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 958:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_DOTS
 959:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 960:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 5
 961:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 962:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
 963:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 964:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 50//5
 965:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 966:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 967:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 968:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_Delay
 969:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_Delay()	delay_Dots(HD_DOTS)
 970:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 971:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 972:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think this was just a mistake. This change to delay_Dots a/o 0.10ncf
 973:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (untested in LCDdirectLVDS)
 974:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //delay_cyc(HD_DOTS)
 975:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 976:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 977:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is the number of CPU cycles between DE->L and Horiz->L
 978:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is just used in calculating the OCR value...
 979:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // aka H Front Porch: 0-24+
 980:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 24
 981:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 46
 982:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 1072-1024-1-1 = 46
 983:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DH_DOTS
 984:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 985:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	46
 986:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 987:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
 988:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 989:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	0//1000//100//46
 990:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 991:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 992:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 993:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |
 994:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       v
 995:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      T_DH
 996:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
 997:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H   __.  ____________  .___________
 998:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      .|_|  .        .|_|  .
 999:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _.     .________.     .___________
1000:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |_____| 512clk |_____|
1001:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ^              ^
1002:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       \___________   \                        (just avoiding \ warning)
1003:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                   \  |     768 Hsyncs
1004:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    v v
1005:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _             _ _ _ _ _ _ _ _ _ _ 
1006:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |___________| | | | | | | | | | |______
1007:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1008:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1009:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1010:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1011:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 29
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 145


1012:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1013:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Frame: 772<=806<=1000 lines...
1014:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1015:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_VD
1016:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1017:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1018:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1019:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define  T_VD 29 //3//29 //7 //29
1020:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1021:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1022:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1023:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1024:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1025:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync front porch: 1-3+
1026:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 3
1027:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1028:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_DV
1029:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1030:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1031:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1032:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3//3 //1 //3
1033:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1034:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1035:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1036:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1037:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1038:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //1-6+ (1 is used by the first switch-case...)
1039:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 6
1040:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN Last used 16
1041:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 772 - 768 - 1 - 1 = 2
1042:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_Vlow
1043:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1044:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 16
1045:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1046:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow	6 //16//6 //2 //6
1047:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1048:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 32
1049:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1050:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1051:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1052:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 768
1053:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef V_COUNT
1054:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1055:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1056:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1057:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1058:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1059:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #if (LVDS_PRESCALER == 8)
1060:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define V_COUNT 768
1061:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #else
1062:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  #define V_COUNT	(768*2/3)
1063:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #endif
1064:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1065:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1066:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1067:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                       
1068:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      |           
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 146


1069:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      V           
1070:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              |<-T_DV>|           |<-T_VD-->|
1071:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .       .           .         .
1072:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _____________||__.   124us   .____||___________________
1073:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V           .   ||  |___________|    ||   .
1074:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
1075:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
1076:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .   ||                   ||   .
1077:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
1078:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   | | | | |___||___________________||___| | | | | | | | |
1079:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                  ||                   ||
1080:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1081:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        1
1082:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        |
1083:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        v               
1084:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _________________   ___________________   _____________
1085:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V                   |_|                   |_|
1086:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
1087:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
1088:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          ^
1089:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          |
1090:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          2
1091:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1092:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1093:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1094:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_COUNT_FRAME_COMPLETE  \
1095:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY)
1096:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_DV = 3
1097:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V_COUNT = 768 
1098:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_VD = 3
1099:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_Vlow = 32
1100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // FRAME_UPDATE_DELAY = 0
1101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 806
1102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(FRAME_UPDATE_DELAY != 0)
1104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "FRAME_UPDATE_DELAY is no longer implemented..."
1105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#if(HSYNC_COUNT_FRAME_COMPLETE & 0x01)
1109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #warning "Total vertical lines might need to be even!"
1110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //This should be fixed...
1111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#endif
1112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_HSYNC \
1115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS = 100
1117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HD_DOTS = 50 
1118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE_ACTIVE_DOTS = 1024
1119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DH_DOTS = 0
1120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 1174
1121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define MAKELONG (0L)
1124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_FRAME \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 147


1126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  ((MAKELONG(HSYNC_COUNT_FRAME_COMPLETE)) * (MAKELONG(DOT_COUNT_PER_HSYNC)))
1127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 946,244
1128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Hlow_Delay 		H_LOW_DOTS
1130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //HD_Delay			HD_DOTS	
1131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DE_ACTIVE_DOTS
1132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DH_DOTS
1133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
1138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t dataEnable = 0;
1142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t vSync = 0;
1143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint16_t hsyncCount = 0;
1144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //frameCount=0 can be used in main to detect whether we've completed a 
1146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  a frame AND its FRAME_UPDATE_DELAY
1147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(FRAME_COUNT_TO_DELAY) && (FRAME_COUNT_TO_DELAY != 0))
1148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t frameCount = 0;
1149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*
1152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum) \
1154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	__attribute__((__always_inline__));
1155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
1156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Returns TRUE when the frame is complete
1158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Should send nada (and maybe hsyncs?) thereafter(?)
1159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In sdramThing2.0, when this returns TRUE, the SDRAM loading is complete
1160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // EXCEPT: the final HD_Dots' FR_READ/ACTIVATE commands will point to a
1161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  non-existent "next" Hsync... these commands need to be rewritten to
1162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  point to the "first" Hsync. This is handled in sdramThing2.0's code
1163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Used to be:
1164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //SIGNAL(TIMER0_COMPA_vect)
1165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t updateLCD(void)
1166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1535               		.stabn	68,0,1166,.LM165-.LFBB16
 1536               	.LM165:
 1537               	.LFBB16:
 1538               	/* prologue: function */
 1539               	/* frame size = 0 */
1167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	uint8_t frameComplete = FALSE;
1168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//static uint8_t frameCount = 0;
1170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	while(TCNT0L != 7){};
1173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This won't work... who knows how many cycles interrupt-entry will be
1174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Above should fix that...
1175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//I think this was just an indicator for scope triggering...
1176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// not relevent for 
1177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	setpinPORT(PB2, PORTB);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 148


1178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	clrpinPORT(PB2, PORTB);
1179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Hsync and Actually draw the pixels... (when DE is active)
1182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This takes a LONG time and will occupy most of the CPU...
1183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... IN THIS INTERRUPT
1184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
1185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
 1540               		.stabn	68,0,1185,.LM166-.LFBB16
 1541               	.LM166:
 1542 060a 2091 0000 		lds r18,dataEnable
 1543               	.LBB124:
 1544               	.LBB125:
1186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
1188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
1190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//V Front Porch, begins with initLCD
1192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync H->L (Begin V-Sync)
1194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_DV:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
1196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
1199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync L->H (Begin V Back Porch)
1201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_Vlow + T_DV:
1202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	if(hfm_nextOutput(&modulator))
1203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 0xff;
1204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	else
1205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 7;
1206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
1209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Start of frame (DE active)
1211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_VD +(T_Vlow + T_DV):
1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// All rows have been displayed
1215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Return to V Front Porch
1216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case V_COUNT +(T_VD + T_Vlow + T_DV):
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
1218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	break;
1219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Frame complete
1220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//case HSYNC_COUNT_FRAME_COMPLETE:
1221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
1223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(FRAME_COUNT_TO_DELAY != 0)
1224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//static uint8_t frameCount = 0;
1225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameCount++;
1226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
1227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				frameCount = 0;
1229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 149


1230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
1231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			
1234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
1235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Yeah, guess that makes sense... Must be Nada...
1236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameComplete = TRUE;
1237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		default:
1239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(LOADROW) && LOADROW)
1244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Load the next row into the row(seg)buffer
1245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//data is enabled after T_VD+T_Vlow...
1246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
1247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
1248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This note was written long before the above was commented-out...
1251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//So...?
1252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// Here is where loadRow used to be called
1253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// it has been moved to oldNotes.txt, but it would make more sense
1254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to look at LCDdirectLVDS <25 or LCDdirect
1255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// loadRow used the time between DE inactive and the next Hsync
1256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
1257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus, DE could gain more pixels because there would be fewer
1258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// calculations to determine the memory location to write from
1259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This effect has since been minimized
1260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// BUT loadRow might be necessary for program-memory-based images...
1261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	return frameComplete;
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //See LCDdirectLVDS for an example...
1267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // basically it loads a single row into a buffer for the next dateEnable
1268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (either the row-buffer or the row-segment-buffer) 
1269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This has been *greatly* reduced, is not at all functional, just
1270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // to give an idea of loadRow's purpose.
1271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(LOADROW) && LOADROW)
1272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum)
1273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//e.g....
1275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	tet_drawRow(rbRowNum, rowBuffer);
1276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...	
1278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	rowBuffer[i] = fb_to_rb(colorVal);
1279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...
1281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
1282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
1283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			for(i=0; i<FB_WIDTH; i++)
1285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 150


1287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				if(!(temp & 0xC0))
1288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
1289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
1293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//HORIZONTAL_COLOR_BARS
1295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	for(i=0; i<RB_WIDTH; i++)
1296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowBuffer[i] = fb_to_rb(rowNum);
1297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Good for syncing to have white on both borders...
1299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	newSeg(1, 0x06, (6<<4) | 3);
1300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //LOAD_ROW
1303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Including inactive pixel-clocks (timing)
1306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DotCount per row...
1307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TOTAL_CYC_COUNT was used for the timer-interrupt in LCDdirectLVDS
1308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This was DOTS_TO_CYC(DISPLAY_DOT_COUNT) + ROW_CALCULATION_CYCS
1309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  ROW_CALCULATION_CYCS was 50,000 (!!!)
1310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DOTS_TO_CYC(dots), last-used, was dots*7 (LVDS_PRESCALER nullified /8)
1311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So, the overall dot-count per row was... 
1312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DISPLAY_DOT_COUNT + ROW_CALCULATION_DOTS
1313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     where ROW_CALCULATION_DOTS = 50,000cyc/7 = 7142 dots
1314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     So... the overall dot-count per row was *MUCH* longer than usual
1315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Pretty certain there's not nearly enough memory to simulate that
1316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (in sdramThing2.0)
1317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But It does suggest that it would be worthwhile to try to stretch
1318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   the rows as much as possible...
1319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   During this time, NADA is sent normally, (V=H, H=H, DE=L)
1320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Or Vsync (V=L, H=H, DE=L)
1321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Maybe something could be simulated with PWM again, if necessary...
1322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Certainly not at full-speed)
1323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_DOT_COUNT \
1324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
1330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
1332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void init_timer0Hsync(void)
1343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 151


1344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//T_HD + T_DH + T_low + T_DE
1345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// For the original system, 19.865us = 695 dot-clocks
1346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// We'd need to take advantage of the 16-bit timer
1347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  OCR1A may not be written properly (with a temporary high-byte)
1348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... not sure.
1349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
1350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is a hack, for testing syncability with long row-calculations
1352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // before actually drawing it... e.g. loading from program memory
1353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This value needs to be larger than the calculation time
1354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // otherwise, it seems, syncing isn't stable
1355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
1356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
1357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_CYC_COUNT	(DOTS_TO_CYC(DISPLAY_DOT_COUNT))
1359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
1360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
1362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // apparently an effect of the display, definitely not a code-thing
1363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in which case the vertical resolution decreases
1364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // though, this could be used to advantage... 
1365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. more processing time outside the drawing interrupts?)
1366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOTE that if the value is too small and calculations take longer in some
1367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // lines than others (?), those lines may repeat, or syncing could be off
1368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (LVDS_PRESCALER == 8)
1369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 1//20
1370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
1371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
1373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
1374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TOTAL_CYC_COUNT \
1377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
1378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
1379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define TOTAL_CYC_COUNT 2000
1380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TOTAL_CYC_COUNT > 255)
1381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Adding +7 causes it to round up (hopefully)
1382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
1383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV	CLKDIV8
1384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
1385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS > 255)
1386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
1387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
1388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_CLKDIV CLKDIV64
1389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #if (TIMER0_TCNTS > 255)
1390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
1391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
1392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_CLKDIV CLKDIV256
1393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #if (TIMER0_TCNTS > 255)
1394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
1395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
1396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_CLKDIV	CLKDIV1024
1397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #endif
1398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #endif
1399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS == 0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 152


1401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "TIMER0_OCRVAL == 0"
1402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
1405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV CLKDIV1
1406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //For testing, I want to see the pulses with the 'scope
1410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Unless the timer is divisible by 7 the pulses will not align with the
1411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // timer overflow...
1412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
1413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
1414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // and we'll only start visualizing *after* the extra TCNTs...
1415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Since the timer counts from 0 to (and including) OCR1A
1416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Add one to this test...
1417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
1418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
1419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
1420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
1421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
1423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
1424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
1425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
1426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
1428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
1429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
1430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
1431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
1433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
1434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
1435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
1436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
1438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
1439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
1440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
1441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
1443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
1444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
1445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
1446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS) % 7) == 0)
1448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS) % 7 == 0"
1449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
1450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
1451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else
1453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "WTF?"
1454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
1457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 153


1458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TIMER0_OCRVAL > 255)
1460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
1461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
1464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
1465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
1466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
1467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define fullBlue()	DEblue_init()
1470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Either use one of the ones here, or define your own...
1474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is the drawable row number on the LCD...
1475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //static __inline__ void drawPix(uint16_t rowNum);
1476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum) \
1480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
1483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //drawPix loads each pixel individually... It doesn't use a for-loop
1484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since that would take away from actual pixel-drawing time...
1485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think it's been removed... but here's a (non-functional) example...
1486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+1));	 
1489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+2));	 
1490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+3)); 
1491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+61));
1493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+62));
1494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+63));
1495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// WriteColor writes the pixel *after* the calculations...
1496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus the pixel appears basically after writeColor completes
1497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// These nops assure the 64th pixel is fully-displayed before exitting
1498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
1499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
1501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*		reg[17] = colorBuffer[rowNum][17];                         
1503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[17]);                         
1504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[20] = colorBuffer[rowNum][20];                         
1506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[20]);  
1507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		
1508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
1509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[0] = colorBuffer[rowNum][0];
1510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[0]);
1511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[10] = colorBuffer[rowNum][10];
1513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[10]);
1514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 154


1515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Display the rest as black...
1516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(0);
1517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else		//ROW_SEG_BUFFER
1519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (0<<COM1B1) | (1<<COM1B0)
1523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (1<<PWM1A) | (1<<PWM1B) );
1524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		drawSegs();
1526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DE->Nada transition expects fullBlue...
1529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Also helps to show the edge of the DE timing...
1530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          
1535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Among the things that don't make sense...
1536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// This appears to go into affect BEFORE delay_cyc (?)
1537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// as, without a pull-up resistor on the /OC1B output, 
1538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// green seems to be floating between the last pixel and the
1539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// delay_cyc (!)
1540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Disable complementary-output for Green 
1541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
1543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<COM1B1) | (0<<COM1B0)
1545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<PWM1A) | (1<<PWM1B) );
1546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		fullBlue();
1548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //0
1550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          G) groovy little spiral...
1554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
1559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				   | (0<<COM1B1) | (1<<COM1B0)
1561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					| (1<<PWM1A) | (1<<PWM1B) );
1562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8 early... appears to be syncing on Blue signal
1565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // thus we get diagonal data including Hsync (colored in red) along the
1566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // as a diagonal stripe at the right
1567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
1568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t blueCyc = DOTS_TO_CYC(rowNum);
1571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 155


1572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t blueDots = rowNum;
1573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t notBlueDots = DE_ACTIVE_DOTS - blueDots;
1574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(notBlueCyc);
1577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(notBlueDots);
1578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(notBlueDots);
1579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(blueCyc);
1581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(blueDots);
1582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(blueDots);
1583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-31ish: LooksPromising, but delayed
1588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // also LVDS bit-shifts causing vertical striping
1589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
1590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-32 nogo... syncs at end of blue instead of Hsync
1605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR_REVERSED) && BLUE_VERT_BAR_REVERSED)
1606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
1617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(DE_BLUE) && DE_BLUE)
1622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
1626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS);
1627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS);
1628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 156


1629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_BORDER) && (BLUE_BORDER!=0))
1633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - BLUE_BORDER*2);
1639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
1647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
1648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		if(rowNum <= 256)
1649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=0;
1650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		else
1651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=1;
1652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
1653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//#warning "see 'shouldBe' here..."
1654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Should be:
1655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
1656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//rowNum = rowNum / (768/FB_HEIGHT);
1657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DEonly_fromNada();
1660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       drawPix(rowNum);
1661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Nada_init();
1662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "THIS ISN'T SAFE"
1663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
1664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Drawing Methods...
1665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       //Disable complementary-output for Green 
1672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
1674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<COM1B1) | (0<<COM1B0)
1676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<PWM1A) | (1<<PWM1B) );
1677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//colorOverride removed in LVDS, revisit LCDdirect50
1680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AND HERE!!!
1685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 157


1686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is only used when DE is active...
1687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and should be 0 at *drawn row* 0
1688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable)
1689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//H Active pulse...
1691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(vSync)
 1545               		.stabn	68,0,1691,.LM167-.LFBB16
 1546               	.LM167:
 1547 060e 8091 0000 		lds r24,vSync
 1548 0612 8823      		tst r24
 1549 0614 01F0      		breq .L104
1692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync_fromNada() is called at the end of the last interupt
1694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       VplusH_fromVsync();
 1550               		.stabn	68,0,1694,.LM168-.LFBB16
 1551               	.LM168:
 1552 0616 1DBC      		out 77-0x20,__zero_reg__
 1553               	.LBB126:
 1554               	.LBB127:
 1555               	.LBB128:
 1556               	.LBB129:
 1557               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext10
 1558               	.Ltext10:
 1559               		.stabn	68,0,105,.LM169-.LFBB16
 1560               	.LM169:
 1561 0618 8FEA      		ldi r24,lo8(175)
 1562 061a 90E0      		ldi r25,hi8(175)
 1563               	/* #APP */
 1564               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1565 061c 0197      		1: sbiw r24,1
 1566 061e 01F4      		brne 1b
 1567               	 ;  0 "" 2
 1568               	/* #NOAPP */
 1569               	.LBE129:
 1570               	.LBE128:
 1571               	.LBE127:
 1572               	.LBE126:
 1573               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext11
 1574               	.Ltext11:
1695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Vsync_fromVplusH();
 1575               		.stabn	68,0,1696,.LM170-.LFBB16
 1576               	.LM170:
 1577 0620 85E0      		ldi r24,lo8(5)
 1578 0622 00C0      		rjmp .L115
 1579               	.L104:
1697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    else
1700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hsync_fromNada();
 1580               		.stabn	68,0,1701,.LM171-.LFBB16
 1581               	.LM171:
 1582 0624 83E0      		ldi r24,lo8(3)
 1583 0626 8DBD      		out 77-0x20,r24
 1584               	.LBB130:
 1585               	.LBB131:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 158


 1586               	.LBB132:
 1587               	.LBB133:
 1588               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext12
 1589               	.Ltext12:
 1590               		.stabn	68,0,105,.LM172-.LFBB16
 1591               	.LM172:
 1592 0628 8FEA      		ldi r24,lo8(175)
 1593 062a 90E0      		ldi r25,hi8(175)
 1594               	/* #APP */
 1595               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1596 062c 0197      		1: sbiw r24,1
 1597 062e 01F4      		brne 1b
 1598               	 ;  0 "" 2
 1599               	/* #NOAPP */
 1600               	.LBE133:
 1601               	.LBE132:
 1602               	.LBE131:
 1603               	.LBE130:
 1604               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext13
 1605               	.Ltext13:
1702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Nada_fromHsync();
 1606               		.stabn	68,0,1703,.LM173-.LFBB16
 1607               	.LM173:
 1608 0630 84E0      		ldi r24,lo8(4)
 1609               	.L115:
 1610 0632 8DBD      		out 77-0x20,r24
 1611               	.LBB134:
 1612               	.LBB135:
 1613               	.LBB136:
 1614               	.LBB137:
 1615               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext14
 1616               	.Ltext14:
 1617               		.stabn	68,0,105,.LM174-.LFBB16
 1618               	.LM174:
 1619 0634 88E5      		ldi r24,lo8(88)
 1620 0636 90E0      		ldi r25,hi8(88)
 1621               	/* #APP */
 1622               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1623 0638 0197      		1: sbiw r24,1
 1624 063a 01F4      		brne 1b
 1625               	 ;  0 "" 2
 1626               	/* #NOAPP */
 1627               	.LBE137:
 1628               	.LBE136:
 1629               	.LBE135:
 1630               	.LBE134:
 1631               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext15
 1632               	.Ltext15:
1704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(dataEnable)
 1633               		.stabn	68,0,1707,.LM175-.LFBB16
 1634               	.LM175:
 1635 063c 2223      		tst r18
 1636 063e 01F4      		brne .+2
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 159


 1637 0640 00C0      		rjmp .L106
 1638               	.LBB138:
 1639               	.LBB139:
 1640               		.stabs	"main.c",132,0,0,.Ltext16
 1641               	.Ltext16:
3886:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 1642               		.stabn	68,0,3886,.LM176-.LFBB16
 1643               	.LM176:
 1644 0642 83E5      		ldi r24,lo8(83)
 1645 0644 80BF      		out 80-0x20,r24
 1646               	.LBB140:
 1647               	.LBB141:
 1648               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext17
 1649               	.Ltext17:
 402:rowSegBuffer.c **** 
 403:rowSegBuffer.c **** 
 404:rowSegBuffer.c **** static __inline__ \
 405:rowSegBuffer.c **** void drawSegs(void) \
 406:rowSegBuffer.c **** 	__attribute__((__always_inline__));
 407:rowSegBuffer.c **** 
 408:rowSegBuffer.c **** 
 409:rowSegBuffer.c **** void drawSegs(void)
 410:rowSegBuffer.c **** {
 411:rowSegBuffer.c **** #warning "This might need to be modified such that DE is active *with* the first pixel... and compl
 412:rowSegBuffer.c **** 	//Declared volatile *just in case* I decide to use it after the asm...
 413:rowSegBuffer.c **** 	// (as modified by the asm)
 414:rowSegBuffer.c **** 	volatile uint8_t *byteptr = &(rowSegBuffer[0].red_length);
 415:rowSegBuffer.c **** 
 416:rowSegBuffer.c **** 	//These should only be used in the asm...
 417:rowSegBuffer.c **** 	// declaring them here, instead of using specific registers in asm
 418:rowSegBuffer.c **** 	// should help assure that those registers aren't clobbered
 419:rowSegBuffer.c **** 	// if used elsewhere
 420:rowSegBuffer.c **** 	//volatile uint8_t r=0, rl=0, g=0, b=0;
 421:rowSegBuffer.c **** 
 422:rowSegBuffer.c **** 	//uint8_t r, rl, g, b;
 423:rowSegBuffer.c **** 
 424:rowSegBuffer.c **** 	//Basic idea:
 425:rowSegBuffer.c **** 
 426:rowSegBuffer.c **** 	//do{
 427:rowSegBuffer.c **** 	//  red_length = rowSegBuffer[n].red_length;
 428:rowSegBuffer.c **** 	//  green      = rowSegBuffer[n].green;
 429:rowSegBuffer.c **** 	//  blue       = rowSegBuffer[n].blue;
 430:rowSegBuffer.c **** 	//  
 431:rowSegBuffer.c **** 	//  OCR1D = red_length&0x0f;
 432:rowSegBuffer.c **** 	//  DT1   = green;
 433:rowSegBuffer.c **** 	//  OCR1A = blue;
 434:rowSegBuffer.c **** 	//
 435:rowSegBuffer.c **** 	//  red_length &= 0xf0;
 436:rowSegBuffer.c **** 	//  if(!red_length)
 437:rowSegBuffer.c **** 	//     break;
 438:rowSegBuffer.c **** 	//
 439:rowSegBuffer.c **** 	//  while(red_length)
 440:rowSegBuffer.c **** 	//		red_length -= 0x10;
 441:rowSegBuffer.c **** 	// } while(1);
 442:rowSegBuffer.c **** 
 443:rowSegBuffer.c **** 	//This looks like it should work...
 444:rowSegBuffer.c **** 	// but there are some oddities
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 160


 445:rowSegBuffer.c **** 	// in this case, registers are loaded such that andi can't be used
 446:rowSegBuffer.c **** 	// but and can... thus it's a few instructions larger...
 447:rowSegBuffer.c **** 	/*
 448:rowSegBuffer.c **** 	do
 449:rowSegBuffer.c **** 	{
 450:rowSegBuffer.c **** 		rl = *(byteptr++);
 451:rowSegBuffer.c **** 		r = rl;
 452:rowSegBuffer.c **** 		r &= 0x0f;
 453:rowSegBuffer.c **** 		g = *(byteptr++);
 454:rowSegBuffer.c **** 		b = *(byteptr++);
 455:rowSegBuffer.c **** 
 456:rowSegBuffer.c **** 		//just testing pushes and pops...
 457:rowSegBuffer.c **** 		// apparently the optimizer realizes which registers are in use
 458:rowSegBuffer.c **** 		// in the (only) call to drawSegs() and doesn't bother to push the
 459:rowSegBuffer.c **** 		// the rest...
 460:rowSegBuffer.c **** //		drawSegs();
 461:rowSegBuffer.c **** 		OCR1D = r;
 462:rowSegBuffer.c **** 		DT1 = g;
 463:rowSegBuffer.c **** 		OCR1A = b;
 464:rowSegBuffer.c **** 
 465:rowSegBuffer.c **** 		rl &= 0xf0;
 466:rowSegBuffer.c **** 
 467:rowSegBuffer.c **** 		if(!rl)
 468:rowSegBuffer.c **** 			break;
 469:rowSegBuffer.c **** 
 470:rowSegBuffer.c **** 		while(rl)
 471:rowSegBuffer.c **** 			rl -= 0x10;
 472:rowSegBuffer.c **** 	} while(1);
 473:rowSegBuffer.c **** */
 474:rowSegBuffer.c **** 
 475:rowSegBuffer.c **** 	//LoadNext:
 476:rowSegBuffer.c **** 	//  ld   Rredlength, Z+	(Red|length)								2
 477:rowSegBuffer.c **** 	//  ld   Rgreen, Z+	(Green)											2
 478:rowSegBuffer.c **** 	//  ld   Rblue, Z+	(Blue)											2
 479:rowSegBuffer.c **** 	//	 mov  Rred, Rredlength												1
 480:rowSegBuffer.c **** 	//  andi Rred, 0x0f				//Remove length from Rred		1
 481:rowSegBuffer.c **** 	//  out  OCR1D, Rred														1
 482:rowSegBuffer.c **** 	//  out  DT1, Rgreen														1
 483:rowSegBuffer.c **** 	//  out  OCR1A, Rblue													1
 484:rowSegBuffer.c **** 
 485:rowSegBuffer.c **** 	//  andi Rredlength, 0xf0		//Remove red from length		1
 486:rowSegBuffer.c **** 	//  breq Done						// if length==0, we're done	1 2
 487:rowSegBuffer.c **** 
 488:rowSegBuffer.c **** 	//Counter:
 489:rowSegBuffer.c **** 	//  subi Rlength, 0x10			//Subtract 0x10 each time...	1
 490:rowSegBuffer.c **** 	//  breq LoadNext					// if length==0, next segment	1 2
 491:rowSegBuffer.c **** 	//  rjmp Counter					// else, next counter loop    2
 492:rowSegBuffer.c **** 
 493:rowSegBuffer.c **** 	//Done:
 494:rowSegBuffer.c **** 
 495:rowSegBuffer.c **** 	// Thus, minimum inter-pixel time is 16 clock cycles
 496:rowSegBuffer.c **** 	// (14 for the last one)
 497:rowSegBuffer.c **** 	// This cannot be reuced by using a separate byte for red and length
 498:rowSegBuffer.c **** 	// because the mov and andi in LoadNext would be replaced by a ld
 499:rowSegBuffer.c **** 
 500:rowSegBuffer.c **** 	// To make the counter take longer between each count,
 501:rowSegBuffer.c **** 	// decrement it by a smaller number...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 161


 502:rowSegBuffer.c **** 
 503:rowSegBuffer.c **** //	drawSegs();
 504:rowSegBuffer.c **** /*
 505:rowSegBuffer.c **** __asm__ __volatile__
 506:rowSegBuffer.c **** 	(
 507:rowSegBuffer.c **** 	"LoadNext_%=: \n\t"
 508:rowSegBuffer.c **** 	 	"ld %1, %a0+ ; \n\t"		//%a1 refers to XYZ whichever is selected
 509:rowSegBuffer.c **** 		"mov %2, %1 ; \n\t"		// Load R (+length)
 510:rowSegBuffer.c **** 		"andi %2, 0x0f ; \n\t"	//Remove length from Rred
 511:rowSegBuffer.c **** 		"ld %3, %a0+ ; \n\t"		//Load G	
 512:rowSegBuffer.c **** 		"ld %4, %a0+ ; \n\t"		//Load B
 513:rowSegBuffer.c **** 		"out %5, %2 ; \n\t"	// Write OCR1D (Red)
 514:rowSegBuffer.c **** 		"out %6, %3 ; \n\t"		// Write DT1 (Green)
 515:rowSegBuffer.c **** 		"out %7, %4 ; \n\t"	// Write OCR1A (Blue)
 516:rowSegBuffer.c **** 
 517:rowSegBuffer.c **** 		"andi %1, 0xf0 ; \n\t"	// Remove red from length
 518:rowSegBuffer.c **** 		"breq Done_%= ; \n\t"		// if length==0 from the start, we're done
 519:rowSegBuffer.c **** 
 520:rowSegBuffer.c **** 	"Counter_%=: \n\t"
 521:rowSegBuffer.c **** 		"subi %1, 0x10 ; \n\t"	//Decrement the counter by 0x10
 522:rowSegBuffer.c **** 		"breq LoadNext_%= ; \n\t"	// if we've decremented to 0, next segment
 523:rowSegBuffer.c **** 
 524:rowSegBuffer.c **** 	"Done_%=: \n\t"
 525:rowSegBuffer.c **** 		:								//No output register...
 526:rowSegBuffer.c **** 		: "e" (byteptr),			//byteptr: %0, r/w and assigned to X,Y,orZ
 527:rowSegBuffer.c **** 		  "d"  (rl),				//rl: %1, andi and subi will be used
 528:rowSegBuffer.c **** 		  "d"  (r),					//r: %2, andi will be used
 529:rowSegBuffer.c **** 		  "r"  (g),					//g: %3
 530:rowSegBuffer.c **** 		  "r"  (b),					//b: %4
 531:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1D)), //OCR1D: %5
 532:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(DT1)),	//DT1: %6
 533:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1A))	//OCR1A %7
 534:rowSegBuffer.c **** 	);
 535:rowSegBuffer.c **** */
 536:rowSegBuffer.c **** 
 537:rowSegBuffer.c **** __asm__ __volatile__
 1650               		.stabn	68,0,537,.LM177-.LFBB16
 1651               	.LM177:
 1652 0646 E0E0      		ldi r30,lo8(rowSegBuffer)
 1653 0648 F0E0      		ldi r31,hi8(rowSegBuffer)
 1654               	/* #APP */
 1655               	 ;  537 "rowSegBuffer.c" 1
 1656               		LoadNext_974: 
 1657 064a 4191      		ld r20, Z+ ; 
 1658 064c 542F      		mov r21, r20 ; 
 1659 064e 5770      		andi r21, 7 ; 
 1660 0650 6191      		ld r22, Z+ ; 
 1661 0652 762F      		mov r23, r22 ; 
 1662 0654 6F70      		andi r22, 0x0f ; 
 1663 0656 7295      		swap r23 ; 
 1664 0658 7F70      		andi r23, 0x0f 
 1665 065a 5ABD      		out 42, r21 ; 
 1666 065c 64BD      		out 36, r22 ; 
 1667 065e 7DBD      		out 45, r23 ; 
 1668 0660 487F      		andi r20, 248 ; 
 1669 0662 01F0      		breq Done_974 ; 
 1670 0664 0000      		nop ; 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 162


 1671 0666 0000      		nop ; 
 1672               		Counter_974: 
 1673 0668 4850      		subi r20, 8 ; 
 1674 066a 01F0      		breq LoadNext_974 ; 
 1675 066c 0000      		nop ; 
 1676 066e 0000      		nop ; 
 1677 0670 0000      		nop ; 
 1678 0672 0000      		nop ; 
 1679 0674 0000      		nop ; 
 1680 0676 0000      		nop ; 
 1681 0678 0000      		nop ; 
 1682 067a 0000      		nop ; 
 1683 067c 0000      		nop ; 
 1684 067e 0000      		nop ; 
 1685 0680 0000      		nop ; 
 1686 0682 0000      		nop ; 
 1687 0684 0000      		nop ; 
 1688 0686 0000      		nop ; 
 1689 0688 0000      		nop ; 
 1690 068a 0000      		nop ; 
 1691 068c 00C0      		rjmp Counter_974 ; 
 1692               		Done_974: 
 1693               		
 1694               	 ;  0 "" 2
 1695               	/* #NOAPP */
 1696               	.LBE141:
 1697               	.LBE140:
 1698               		.stabs	"main.c",132,0,0,.Ltext18
 1699               	.Ltext18:
3930:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 1700               		.stabn	68,0,3930,.LM178-.LFBB16
 1701               	.LM178:
 1702 068e 83E6      		ldi r24,lo8(99)
 1703 0690 80BF      		out 80-0x20,r24
3934:main.c        **** 		fullBlue();
 1704               		.stabn	68,0,3934,.LM179-.LFBB16
 1705               	.LM179:
 1706 0692 14BC      		out 68-0x20,__zero_reg__
 1707 0694 86E0      		ldi r24,lo8(6)
 1708 0696 8DBD      		out 77-0x20,r24
3935:main.c        **** 		Nada_fromDEonly();
 1709               		.stabn	68,0,3935,.LM180-.LFBB16
 1710               	.LM180:
 1711 0698 80E3      		ldi r24,lo8(48)
 1712 069a 84BD      		out 68-0x20,r24
 1713               	.L106:
 1714               	.LBE139:
 1715               	.LBE138:
 1716               	.LBE125:
 1717               	.LBE124:
 1718               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext19
 1719               	.Ltext19:
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
 1720               		.stabn	68,0,1187,.LM181-.LFBB16
 1721               	.LM181:
 1722 069c 8091 0000 		lds r24,hsyncCount
 1723 06a0 9091 0000 		lds r25,(hsyncCount)+1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 163


 1724 06a4 0196      		adiw r24,1
 1725 06a6 9093 0000 		sts (hsyncCount)+1,r25
 1726 06aa 8093 0000 		sts hsyncCount,r24
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
 1727               		.stabn	68,0,1189,.LM182-.LFBB16
 1728               	.LM182:
 1729 06ae 8332      		cpi r24,35
 1730 06b0 9105      		cpc r25,__zero_reg__
 1731 06b2 01F0      		breq .L109
 1732 06b4 8432      		cpi r24,36
 1733 06b6 9105      		cpc r25,__zero_reg__
 1734 06b8 00F4      		brsh .L112
 1735 06ba 8330      		cpi r24,3
 1736 06bc 9105      		cpc r25,__zero_reg__
 1737 06be 01F4      		brne .L116
 1738 06c0 00C0      		rjmp .L119
 1739               	.L112:
 1740 06c2 8632      		cpi r24,38
 1741 06c4 9105      		cpc r25,__zero_reg__
 1742 06c6 01F0      		breq .L110
 1743 06c8 23E0      		ldi r18,hi8(806)
 1744 06ca 8632      		cpi r24,lo8(806)
 1745 06cc 9207      		cpc r25,r18
 1746 06ce 01F4      		brne .L116
 1747 06d0 00C0      		rjmp .L120
 1748               	.L119:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 1749               		.stabn	68,0,1195,.LM183-.LFBB16
 1750               	.LM183:
 1751 06d2 1092 0000 		sts dataEnable,__zero_reg__
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
 1752               		.stabn	68,0,1197,.LM184-.LFBB16
 1753               	.LM184:
 1754 06d6 81E0      		ldi r24,lo8(1)
 1755 06d8 8093 0000 		sts vSync,r24
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
 1756               		.stabn	68,0,1198,.LM185-.LFBB16
 1757               	.LM185:
 1758 06dc 80E4      		ldi r24,lo8(64)
 1759 06de 84BD      		out 68-0x20,r24
 1760 06e0 85E0      		ldi r24,lo8(5)
 1761 06e2 00C0      		rjmp .L117
 1762               	.L109:
1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
 1763               		.stabn	68,0,1207,.LM186-.LFBB16
 1764               	.LM186:
 1765 06e4 1092 0000 		sts vSync,__zero_reg__
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
 1766               		.stabn	68,0,1208,.LM187-.LFBB16
 1767               	.LM187:
 1768 06e8 80E3      		ldi r24,lo8(48)
 1769 06ea 84BD      		out 68-0x20,r24
 1770 06ec 84E0      		ldi r24,lo8(4)
 1771               	.L117:
 1772 06ee 8DBD      		out 77-0x20,r24
 1773 06f0 00C0      		rjmp .L116
 1774               	.L110:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 164


1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
 1775               		.stabn	68,0,1212,.LM188-.LFBB16
 1776               	.LM188:
 1777 06f2 81E0      		ldi r24,lo8(1)
 1778 06f4 8093 0000 		sts dataEnable,r24
 1779               	.L116:
 1780 06f8 80E0      		ldi r24,lo8(0)
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
 1781               		.stabn	68,0,1213,.LM189-.LFBB16
 1782               	.LM189:
 1783 06fa 0895      		ret
 1784               	.L120:
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 1785               		.stabn	68,0,1217,.LM190-.LFBB16
 1786               	.LM190:
 1787 06fc 1092 0000 		sts dataEnable,__zero_reg__
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
 1788               		.stabn	68,0,1222,.LM191-.LFBB16
 1789               	.LM191:
 1790 0700 1092 0000 		sts (hsyncCount)+1,__zero_reg__
 1791 0704 1092 0000 		sts hsyncCount,__zero_reg__
 1792 0708 81E0      		ldi r24,lo8(1)
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 1793               		.stabn	68,0,1263,.LM192-.LFBB16
 1794               	.LM192:
 1795 070a 0895      		ret
 1796               		.size	updateLCD, .-updateLCD
 1797               		.stabs	"frameComplete:r(3,2)",64,0,1167,24
 1798               		.stabn	192,0,0,.LFBB16-.LFBB16
 1799               		.stabs	"__count:r(3,4)",64,0,1688,24
 1800               		.stabn	192,0,0,.LBB128-.LFBB16
 1801               		.stabn	224,0,0,.LBE128-.LFBB16
 1802               		.stabs	"__count:r(3,4)",64,0,1688,24
 1803               		.stabn	192,0,0,.LBB132-.LFBB16
 1804               		.stabn	224,0,0,.LBE132-.LFBB16
 1805               		.stabs	"__count:r(3,4)",64,0,1688,24
 1806               		.stabn	192,0,0,.LBB136-.LFBB16
 1807               		.stabn	224,0,0,.LBE136-.LFBB16
 1808               		.stabn	224,0,0,.Lscope16-.LFBB16
 1809               	.Lscope16:
 1810               		.stabs	"",36,0,0,.Lscope16-.LFBB16
 1811               		.stabd	78,0,0
 1812               		.stabs	"init_timer0Hsync:F(0,15)",36,0,3096,init_timer0Hsync
 1813               	.global	init_timer0Hsync
 1814               		.type	init_timer0Hsync, @function
 1815               	init_timer0Hsync:
 1816               		.stabd	46,0,0
 1817               		.stabs	"main.c",132,0,0,.Ltext20
 1818               	.Ltext20:
3097:main.c        **** {
 1819               		.stabn	68,0,3097,.LM193-.LFBB17
 1820               	.LM193:
 1821               	.LFBB17:
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
3217:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
 1824               		.stabn	68,0,3217,.LM194-.LFBB17
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 165


 1825               	.LM194:
 1826 070c 83EE      		ldi r24,lo8(-29)
 1827 070e 83BB      		out 51-0x20,r24
3218:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
 1828               		.stabn	68,0,3218,.LM195-.LFBB17
 1829               	.LM195:
 1830 0710 80E0      		ldi r24,lo8(0)
 1831 0712 62E0      		ldi r22,lo8(2)
 1832 0714 00D0      		rcall timer_setWGM
3219:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
 1833               		.stabn	68,0,3219,.LM196-.LFBB17
 1834               	.LM196:
 1835 0716 80E0      		ldi r24,lo8(0)
 1836 0718 68E0      		ldi r22,lo8(8)
 1837 071a 00D0      		rcall timer_selectDivisor
3220:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
 1838               		.stabn	68,0,3220,.LM197-.LFBB17
 1839               	.LM197:
 1840 071c 80E0      		ldi r24,lo8(0)
 1841 071e 60E0      		ldi r22,lo8(0)
 1842 0720 41E0      		ldi r20,lo8(1)
 1843 0722 00D0      		rcall timer_compareMatchIntSetup
 1844               	/* epilogue start */
3221:main.c        **** }
 1845               		.stabn	68,0,3221,.LM198-.LFBB17
 1846               	.LM198:
 1847 0724 0895      		ret
 1848               		.size	init_timer0Hsync, .-init_timer0Hsync
 1849               	.Lscope17:
 1850               		.stabs	"",36,0,0,.Lscope17-.LFBB17
 1851               		.stabd	78,0,0
 1852               		.stabs	"main:F(0,1)",36,0,4201,main
 1853               	.global	main
 1854               		.type	main, @function
 1855               	main:
 1856               		.stabd	46,0,0
4202:main.c        **** {
 1857               		.stabn	68,0,4202,.LM199-.LFBB18
 1858               	.LM199:
 1859               	.LFBB18:
 1860               	/* prologue: function */
 1861               	/* frame size = 0 */
4210:main.c        **** 	tetInit(7);
 1862               		.stabn	68,0,4210,.LM200-.LFBB18
 1863               	.LM200:
 1864 0726 87E0      		ldi r24,lo8(7)
 1865 0728 00D0      		rcall tetInit
4212:main.c        **** 	init_timer0Hsync();
 1866               		.stabn	68,0,4212,.LM201-.LFBB18
 1867               	.LM201:
 1868 072a 00D0      		rcall init_timer0Hsync
4219:main.c        **** 	lvds_timerInit();
 1869               		.stabn	68,0,4219,.LM202-.LFBB18
 1870               	.LM202:
 1871 072c 00D0      		rcall lvds_timerInit
 1872               	.L126:
4345:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 166


 1873               		.stabn	68,0,4345,.LM203-.LFBB18
 1874               	.LM203:
 1875 072e 8091 0000 		lds r24,frameCount
 1876 0732 8823      		tst r24
 1877 0734 01F4      		brne .L124
 1878               	.L129:
 1879 0736 89B7      		in r24,89-0x20
 1880 0738 8071      		andi r24,lo8(16)
 1881 073a 01F4      		brne .L129
4399:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
 1882               		.stabn	68,0,4399,.LM204-.LFBB18
 1883               	.LM204:
 1884 073c 60E0      		ldi r22,lo8(0)
 1885 073e 41E0      		ldi r20,lo8(1)
 1886 0740 00D0      		rcall timer_compareMatchIntSetup
 1887 0742 00C0      		rjmp .L126
 1888               	.L124:
 1889               	.L131:
 1890 0744 00C0      		rjmp .L131
 1891               		.size	main, .-main
 1892               	.Lscope18:
 1893               		.stabs	"",36,0,0,.Lscope18-.LFBB18
 1894               		.stabd	78,0,0
 1895               		.stabs	"__vector_14:F(0,15)",36,0,2105,__vector_14
 1896               	.global	__vector_14
 1897               		.type	__vector_14, @function
 1898               	__vector_14:
 1899               		.stabd	46,0,0
2106:main.c        **** {
 1900               		.stabn	68,0,2106,.LM205-.LFBB19
 1901               	.LM205:
 1902               	.LFBB19:
 1903 0746 1F92      		push __zero_reg__
 1904 0748 0F92      		push r0
 1905 074a 0FB6      		in r0,__SREG__
 1906 074c 0F92      		push r0
 1907 074e 1124      		clr __zero_reg__
 1908 0750 9F92      		push r9
 1909 0752 AF92      		push r10
 1910 0754 BF92      		push r11
 1911 0756 CF92      		push r12
 1912 0758 DF92      		push r13
 1913 075a EF92      		push r14
 1914 075c FF92      		push r15
 1915 075e 0F93      		push r16
 1916 0760 1F93      		push r17
 1917 0762 2F93      		push r18
 1918 0764 3F93      		push r19
 1919 0766 4F93      		push r20
 1920 0768 5F93      		push r21
 1921 076a 6F93      		push r22
 1922 076c 7F93      		push r23
 1923 076e 8F93      		push r24
 1924 0770 9F93      		push r25
 1925 0772 AF93      		push r26
 1926 0774 BF93      		push r27
 1927 0776 EF93      		push r30
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 167


 1928 0778 FF93      		push r31
 1929 077a DF93      		push r29
 1930 077c CF93      		push r28
 1931 077e 00D0      		rcall .
 1932 0780 CDB7      		in r28,__SP_L__
 1933 0782 DEB7      		in r29,__SP_H__
 1934               	/* prologue: Signal */
 1935               	/* frame size = 2 */
2121:main.c        **** 	if(updateLCD())
 1936               		.stabn	68,0,2121,.LM206-.LFBB19
 1937               	.LM206:
 1938 0784 00D0      		rcall updateLCD
 1939 0786 8823      		tst r24
 1940 0788 01F0      		breq .L133
2125:main.c        **** 			frameCount++;
 1941               		.stabn	68,0,2125,.LM207-.LFBB19
 1942               	.LM207:
 1943 078a 8091 0000 		lds r24,frameCount.2279
 1944 078e 8F5F      		subi r24,lo8(-(1))
 1945 0790 8093 0000 		sts frameCount.2279,r24
2126:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
 1946               		.stabn	68,0,2126,.LM208-.LFBB19
 1947               	.LM208:
 1948 0794 8830      		cpi r24,lo8(8)
 1949 0796 01F4      		brne .L133
2128:main.c        **** 				frameCount = 0;
 1950               		.stabn	68,0,2128,.LM209-.LFBB19
 1951               	.LM209:
 1952 0798 1092 0000 		sts frameCount.2279,__zero_reg__
2129:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
 1953               		.stabn	68,0,2129,.LM210-.LFBB19
 1954               	.LM210:
 1955 079c 80E0      		ldi r24,lo8(0)
 1956 079e 60E0      		ldi r22,lo8(0)
 1957 07a0 40E0      		ldi r20,lo8(0)
 1958 07a2 00D0      		rcall timer_compareMatchIntSetup
 1959               	.L133:
2138:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
 1960               		.stabn	68,0,2138,.LM211-.LFBB19
 1961               	.LM211:
 1962 07a4 0091 0000 		lds r16,hsyncCount
 1963 07a8 1091 0000 		lds r17,(hsyncCount)+1
 1964 07ac 0352      		subi r16,lo8(-(-35))
 1965 07ae 1040      		sbci r17,hi8(-(-35))
 1966 07b0 23E0      		ldi r18,hi8(768)
 1967 07b2 0030      		cpi r16,lo8(768)
 1968 07b4 1207      		cpc r17,r18
 1969 07b6 00F0      		brlo .+2
 1970 07b8 00C0      		rjmp .L175
 1971               	.LBB159:
 1972               	.LBB160:
2946:main.c        **** 	if(rowNum == 0)
 1973               		.stabn	68,0,2946,.LM212-.LFBB19
 1974               	.LM212:
 1975 07ba 0115      		cp r16,__zero_reg__
 1976 07bc 1105      		cpc r17,__zero_reg__
 1977 07be 01F4      		brne .L135
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 168


2948:main.c        **** 		lastThetaOffset+=16;
 1978               		.stabn	68,0,2948,.LM213-.LFBB19
 1979               	.LM213:
 1980 07c0 8091 0000 		lds r24,lastThetaOffset.2294
 1981 07c4 9091 0000 		lds r25,(lastThetaOffset.2294)+1
 1982 07c8 4096      		adiw r24,16
 1983 07ca 9093 0000 		sts (lastThetaOffset.2294)+1,r25
 1984 07ce 8093 0000 		sts lastThetaOffset.2294,r24
2949:main.c        **** 		frameCount++;
 1985               		.stabn	68,0,2949,.LM214-.LFBB19
 1986               	.LM214:
 1987 07d2 8091 0000 		lds r24,frameCount.2295
 1988 07d6 8F5F      		subi r24,lo8(-(1))
 1989 07d8 8093 0000 		sts frameCount.2295,r24
 1990               	.L135:
 1991               	.LBB161:
 1992               	.LBB162:
 1993               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext21
 1994               	.Ltext21:
 161:rowSegBuffer.c **** 	segPosition = 0;
 1995               		.stabn	68,0,161,.LM215-.LFBB19
 1996               	.LM215:
 1997 07dc 1092 0000 		sts segPosition,__zero_reg__
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 1998               		.stabn	68,0,164,.LM216-.LFBB19
 1999               	.LM216:
 2000 07e0 86E0      		ldi r24,lo8(6)
 2001 07e2 8093 0000 		sts rowSegBuffer,r24
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 2002               		.stabn	68,0,165,.LM217-.LFBB19
 2003               	.LM217:
 2004 07e6 83E6      		ldi r24,lo8(99)
 2005 07e8 8093 0000 		sts rowSegBuffer+1,r24
 2006               	.LBE162:
 2007               	.LBE161:
 2008               		.stabs	"main.c",132,0,0,.Ltext22
 2009               	.Ltext22:
2955:main.c        **** 	addSegfb(3, _W);
 2010               		.stabn	68,0,2955,.LM218-.LFBB19
 2011               	.LM218:
 2012 07ec 83E0      		ldi r24,lo8(3)
 2013 07ee 90E0      		ldi r25,hi8(3)
 2014 07f0 67E0      		ldi r22,lo8(7)
 2015 07f2 43E7      		ldi r20,lo8(115)
 2016 07f4 00D0      		rcall addSeg
2957:main.c        **** 	uint8_t sineVal = (uint8_t)((int8_t)128 + 
 2017               		.stabn	68,0,2957,.LM219-.LFBB19
 2018               	.LM219:
 2019 07f6 8091 0000 		lds r24,lastThetaOffset.2294
 2020 07fa 9091 0000 		lds r25,(lastThetaOffset.2294)+1
 2021 07fe 800F      		add r24,r16
 2022 0800 911F      		adc r25,r17
 2023 0802 00D0      		rcall sineRaw8
2958:main.c        **** 			sineRaw8(rowNum+lastThetaOffset));
 2024               		.stabn	68,0,2958,.LM220-.LFBB19
 2025               	.LM220:
 2026 0804 70E8      		ldi r23,lo8(-128)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 169


 2027 0806 F72E      		mov r15,r23
 2028 0808 F80E      		add r15,r24
2960:main.c        **** 	uint8_t nextSineVal = (uint8_t)((int8_t)128 +
 2029               		.stabn	68,0,2960,.LM221-.LFBB19
 2030               	.LM221:
 2031 080a 8091 0000 		lds r24,lastThetaOffset.2294
 2032 080e 9091 0000 		lds r25,(lastThetaOffset.2294)+1
 2033 0812 0196      		adiw r24,1
 2034 0814 800F      		add r24,r16
 2035 0816 911F      		adc r25,r17
 2036 0818 00D0      		rcall sineRaw8
2961:main.c        **** 			sineRaw8(rowNum+1+lastThetaOffset));
 2037               		.stabn	68,0,2961,.LM222-.LFBB19
 2038               	.LM222:
 2039 081a 8058      		subi r24,lo8(-(-128))
2967:main.c        **** 	if(nextSineVal < sineVal)
 2040               		.stabn	68,0,2967,.LM223-.LFBB19
 2041               	.LM223:
 2042 081c 8F15      		cp r24,r15
 2043 081e 00F4      		brsh .L136
2969:main.c        **** 		length = (sineVal - nextSineVal);
 2044               		.stabn	68,0,2969,.LM224-.LFBB19
 2045               	.LM224:
 2046 0820 EF2C      		mov r14,r15
 2047 0822 E81A      		sub r14,r24
2972:main.c        **** 		sineVal-=length;//*4;
 2048               		.stabn	68,0,2972,.LM225-.LFBB19
 2049               	.LM225:
 2050 0824 FE18      		sub r15,r14
 2051 0826 00C0      		rjmp .L137
 2052               	.L136:
2974:main.c        **** 	else if(nextSineVal > sineVal)
 2053               		.stabn	68,0,2974,.LM226-.LFBB19
 2054               	.LM226:
 2055 0828 F816      		cp r15,r24
 2056 082a 00F4      		brsh .L138
2975:main.c        **** 		length = (nextSineVal - sineVal);
 2057               		.stabn	68,0,2975,.LM227-.LFBB19
 2058               	.LM227:
 2059 082c E82E      		mov r14,r24
 2060 082e EF18      		sub r14,r15
 2061               	.L137:
2979:main.c        **** 	if(length == 0)
 2062               		.stabn	68,0,2979,.LM228-.LFBB19
 2063               	.LM228:
 2064 0830 EE20      		tst r14
 2065 0832 01F4      		brne .L139
 2066               	.L138:
 2067 0834 EE24      		clr r14
 2068 0836 E394      		inc r14
 2069               	.L139:
2984:main.c        **** 	uint8_t j = frameCount;
 2070               		.stabn	68,0,2984,.LM229-.LFBB19
 2071               	.LM229:
 2072 0838 9090 0000 		lds r9,frameCount.2295
 2073 083c E0E0      		ldi r30,lo8(0)
 2074               	.LBB163:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 170


 2075               	.LBB164:
 2076               		.stabs	"fbColors.h",132,0,0,.Ltext23
 2077               	.Ltext23:
   1:fbColors.h    **** // 7 6 5 4 3 2 1 0
   2:fbColors.h    **** // a a b b g g r r
   3:fbColors.h    **** //             0 0 = 0x00
   4:fbColors.h    **** //             0 1 = 0x01
   5:fbColors.h    **** //             1 0 = 0x02
   6:fbColors.h    **** //             1 1 = 0x03
   7:fbColors.h    **** //         0 0     = 0x00
   8:fbColors.h    **** //         0 1     = 0x04
   9:fbColors.h    **** //         1 0     = 0x08
  10:fbColors.h    **** //         1 1     = 0x0C
  11:fbColors.h    **** //     0 0         = 0x00
  12:fbColors.h    **** //     0 1         = 0x10
  13:fbColors.h    **** //     1 0         = 0x20
  14:fbColors.h    **** //     1 1         = 0x30
  15:fbColors.h    **** 
  16:fbColors.h    **** 
  17:fbColors.h    **** //Takes three values, from 0-3 each...
  18:fbColors.h    **** #define rgb(r,g,b) (((r)&0x03) | (((g)&0x03)<<2) | (((b)&0x03)<<4))
  19:fbColors.h    **** 
  20:fbColors.h    **** 
  21:fbColors.h    **** #define _R  0x03	//0x03						00 00 11
  22:fbColors.h    **** #define _O  0x07	//0x03 | 0x10				00 01 11
  23:fbColors.h    **** #define _Y  0x0F  //0x03 | 0x0C           00 11 11
  24:fbColors.h    **** #define _G 0x0C	//       0x0C				00 11 00
  25:fbColors.h    **** #define _C 0x3C   //       0x0C | 0x30    11 11 00
  26:fbColors.h    **** #define _B 0x30	//              0x30		11 00 00
  27:fbColors.h    **** #define _V 0x13   //0x03 |        0x10		01 00 11
  28:fbColors.h    **** #define _M  0x33	//0x03 |			 0x30		11 00 11
  29:fbColors.h    **** #define _K  0x00	//								00 00 00
  30:fbColors.h    **** #define _W 0x3F	//0x03 | 0x0C | 0x30		11 11 11
  31:fbColors.h    **** #define _r 0x01	//0x01						00 00 01
  32:fbColors.h    **** #define _g 0x04	//			0x04				00 01 00
  33:fbColors.h    **** #define _b 0x10	//					 0x10		01 00 00
  34:fbColors.h    **** #define _c 0x14	//			0x04	 0x10		01 01 00
  35:fbColors.h    **** #define _m 0x11	//0x01 |			 0x10		01 00 01
  36:fbColors.h    **** #define _y 0x05	//0x01 | 0x04				00 01 01
  37:fbColors.h    **** #define _k 0x15	//0x01 | 0x04 | 0x10		01 01 01
  38:fbColors.h    **** #define Tr 0xC0   //Transparent
  39:fbColors.h    **** 
  40:fbColors.h    **** 
  41:fbColors.h    **** //Creates a "gradient" effect, where no color-change is greater than 1
  42:fbColors.h    **** // for each change in value
  43:fbColors.h    **** // except at the crossover from full-blue back to 0... (0x30)
  44:fbColors.h    **** static __inline__ \
  45:fbColors.h    **** uint8_t rgbGradient(uint8_t value) \
  46:fbColors.h    **** 	__attribute__((__always_inline__));
  47:fbColors.h    **** 
  48:fbColors.h    **** uint8_t rgbGradient(uint8_t value)
  49:fbColors.h    **** {
  50:fbColors.h    **** 	while(value > 0x2f)
  51:fbColors.h    **** 		value -= 0x30;
  52:fbColors.h    **** 
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 171


 2078               		.stabn	68,0,54,.LM230-.LFBB19
 2079               	.LM230:
 2080 083e 63E0      		ldi r22,lo8(3)
 2081 0840 D62E      		mov r13,r22
 2082               	.LBE164:
 2083               	.LBE163:
 2084               		.stabs	"main.c",132,0,0,.Ltext24
 2085               	.Ltext24:
2994:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
 2086               		.stabn	68,0,2994,.LM231-.LFBB19
 2087               	.LM231:
 2088 0842 AF2C      		mov r10,r15
 2089 0844 BB24      		clr r11
 2090               	.L146:
2989:main.c        **** 		J++;
 2091               		.stabn	68,0,2989,.LM232-.LFBB19
 2092               	.LM232:
 2093 0846 CE2E      		mov r12,r30
 2094 0848 C394      		inc r12
 2095 084a 6C2D      		mov r22,r12
 2096 084c 690D      		add r22,r9
 2097 084e 00C0      		rjmp .L140
 2098               	.L141:
 2099               	.LBB166:
 2100               	.LBB165:
 2101               		.stabs	"fbColors.h",132,0,0,.Ltext25
 2102               	.Ltext25:
  51:fbColors.h    **** 		value -= 0x30;
 2103               		.stabn	68,0,51,.LM233-.LFBB19
 2104               	.LM233:
 2105 0850 6053      		subi r22,lo8(-(-48))
 2106               	.L140:
  50:fbColors.h    **** 	while(value > 0x2f)
 2107               		.stabn	68,0,50,.LM234-.LFBB19
 2108               	.LM234:
 2109 0852 6033      		cpi r22,lo8(48)
 2110 0854 00F4      		brsh .L141
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2111               		.stabn	68,0,53,.LM235-.LFBB19
 2112               	.LM235:
 2113 0856 462F      		mov r20,r22
 2114 0858 4370      		andi r20,lo8(3)
 2115               		.stabn	68,0,54,.LM236-.LFBB19
 2116               	.LM236:
 2117 085a 70E0      		ldi r23,lo8(0)
 2118 085c 62FF      		sbrs r22,2
 2119 085e 00C0      		rjmp .L142
 2120 0860 3D2D      		mov r19,r13
 2121 0862 341B      		sub r19,r20
 2122 0864 432F      		mov r20,r19
 2123               	.L142:
  55:fbColors.h    **** 	uint8_t G = ((value)&0x0C)>>2; 
 2124               		.stabn	68,0,55,.LM237-.LFBB19
 2125               	.LM237:
 2126 0866 9B01      		movw r18,r22
 2127 0868 2C70      		andi r18,lo8(12)
 2128 086a 3070      		andi r19,hi8(12)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 172


 2129 086c 3595      		asr r19
 2130 086e 2795      		ror r18
 2131 0870 3595      		asr r19
 2132 0872 2795      		ror r18
  56:fbColors.h    **** 	uint8_t g = ((value)&0x10) ? (3-G) : G ; 
 2133               		.stabn	68,0,56,.LM238-.LFBB19
 2134               	.LM238:
 2135 0874 64FF      		sbrs r22,4
 2136 0876 00C0      		rjmp .L143
 2137 0878 8D2D      		mov r24,r13
 2138 087a 821B      		sub r24,r18
 2139 087c 282F      		mov r18,r24
 2140               	.L143:
  57:fbColors.h    **** 	uint8_t B = ((value)&0x30) >> 4; 
 2141               		.stabn	68,0,57,.LM239-.LFBB19
 2142               	.LM239:
 2143 087e CB01      		movw r24,r22
 2144 0880 8073      		andi r24,lo8(48)
 2145 0882 9070      		andi r25,hi8(48)
 2146 0884 34E0      		ldi r19,4
 2147 0886 9595      	1:	asr r25
 2148 0888 8795      		ror r24
 2149 088a 3A95      		dec r19
 2150 088c 01F4      		brne 1b
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2151               		.stabn	68,0,58,.LM240-.LFBB19
 2152               	.LM240:
 2153 088e 66FF      		sbrs r22,6
 2154 0890 00C0      		rjmp .L144
 2155 0892 9D2D      		mov r25,r13
 2156 0894 981B      		sub r25,r24
 2157 0896 892F      		mov r24,r25
 2158               	.L144:
  59:fbColors.h    **** 
  60:fbColors.h    **** 	return rgb(r,g,b);
 2159               		.stabn	68,0,60,.LM241-.LFBB19
 2160               	.LM241:
 2161 0898 30E0      		ldi r19,lo8(0)
 2162 089a 2370      		andi r18,lo8(3)
 2163 089c 3070      		andi r19,hi8(3)
 2164 089e 220F      		lsl r18
 2165 08a0 331F      		rol r19
 2166 08a2 220F      		lsl r18
 2167 08a4 331F      		rol r19
 2168 08a6 4370      		andi r20,lo8(3)
 2169 08a8 422B      		or r20,r18
 2170 08aa 90E0      		ldi r25,lo8(0)
 2171 08ac 8370      		andi r24,lo8(3)
 2172 08ae 9070      		andi r25,hi8(3)
 2173 08b0 B4E0      		ldi r27,4
 2174 08b2 880F      	1:	lsl r24
 2175 08b4 991F      		rol r25
 2176 08b6 BA95      		dec r27
 2177 08b8 01F4      		brne 1b
 2178 08ba 482B      		or r20,r24
 2179               	.LBE165:
 2180               	.LBE166:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 173


 2181               		.stabs	"main.c",132,0,0,.Ltext26
 2182               	.Ltext26:
2994:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
 2183               		.stabn	68,0,2994,.LM242-.LFBB19
 2184               	.LM242:
 2185 08bc 8C2D      		mov r24,r12
 2186 08be 90E0      		ldi r25,lo8(0)
 2187 08c0 65E0      		ldi r22,lo8(5)
 2188 08c2 70E0      		ldi r23,hi8(5)
 2189 08c4 00D0      		rcall __mulhi3
 2190 08c6 242F      		mov r18,r20
 2191 08c8 30E0      		ldi r19,lo8(0)
 2192 08ca F42F      		mov r31,r20
 2193 08cc F170      		andi r31,lo8(1)
 2194 08ce 4073      		andi r20,lo8(48)
 2195 08d0 8A15      		cp r24,r10
 2196 08d2 9B05      		cpc r25,r11
 2197 08d4 00F4      		brsh .L145
2997:main.c        **** 		addSegfb(WIDTH, rgbVal);
 2198               		.stabn	68,0,2997,.LM243-.LFBB19
 2199               	.LM243:
 2200 08d6 B901      		movw r22,r18
 2201 08d8 6370      		andi r22,lo8(3)
 2202 08da 7070      		andi r23,hi8(3)
 2203 08dc 660F      		lsl r22
 2204 08de 771F      		rol r23
 2205 08e0 6F2B      		or r22,r31
 2206 08e2 4064      		ori r20,lo8(64)
 2207 08e4 2C70      		andi r18,lo8(12)
 2208 08e6 3070      		andi r19,hi8(12)
 2209 08e8 3595      		asr r19
 2210 08ea 2795      		ror r18
 2211 08ec 3595      		asr r19
 2212 08ee 2795      		ror r18
 2213 08f0 422B      		or r20,r18
 2214 08f2 85E0      		ldi r24,lo8(5)
 2215 08f4 90E0      		ldi r25,hi8(5)
 2216 08f6 00D0      		rcall addSeg
 2217 08f8 EC2D      		mov r30,r12
 2218 08fa 00C0      		rjmp .L146
 2219               	.L145:
3002:main.c        **** 	addSegfb(sineVal-(uint16_t)J*(uint16_t)WIDTH, rgbVal); 
 2220               		.stabn	68,0,3002,.LM244-.LFBB19
 2221               	.LM244:
 2222 08fc 8E2F      		mov r24,r30
 2223 08fe 90E0      		ldi r25,lo8(0)
 2224 0900 65E0      		ldi r22,lo8(5)
 2225 0902 70E0      		ldi r23,hi8(5)
 2226 0904 00D0      		rcall __mulhi3
 2227 0906 B901      		movw r22,r18
 2228 0908 6370      		andi r22,lo8(3)
 2229 090a 7070      		andi r23,hi8(3)
 2230 090c 660F      		lsl r22
 2231 090e 771F      		rol r23
 2232 0910 6F2B      		or r22,r31
 2233 0912 4064      		ori r20,lo8(64)
 2234 0914 2C70      		andi r18,lo8(12)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 174


 2235 0916 3070      		andi r19,hi8(12)
 2236 0918 3595      		asr r19
 2237 091a 2795      		ror r18
 2238 091c 3595      		asr r19
 2239 091e 2795      		ror r18
 2240 0920 422B      		or r20,r18
 2241 0922 9501      		movw r18,r10
 2242 0924 281B      		sub r18,r24
 2243 0926 390B      		sbc r19,r25
 2244 0928 C901      		movw r24,r18
 2245 092a 00D0      		rcall addSeg
3004:main.c        **** 	addSegfb(length, _W); 
 2246               		.stabn	68,0,3004,.LM245-.LFBB19
 2247               	.LM245:
 2248 092c 8E2D      		mov r24,r14
 2249 092e 90E0      		ldi r25,lo8(0)
 2250 0930 67E0      		ldi r22,lo8(7)
 2251 0932 43E7      		ldi r20,lo8(115)
 2252 0934 00D0      		rcall addSeg
3005:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
 2253               		.stabn	68,0,3005,.LM246-.LFBB19
 2254               	.LM246:
 2255 0936 6801      		movw r12,r16
 2256 0938 83E0      		ldi r24,3
 2257 093a D694      	1:	lsr r13
 2258 093c C794      		ror r12
 2259 093e 8A95      		dec r24
 2260 0940 01F4      		brne 1b
 2261 0942 8C2D      		mov r24,r12
 2262 0944 9C2D      		mov r25,r12
 2263 0946 00C0      		rjmp .L147
 2264               	.L148:
 2265               	.LBB167:
 2266               	.LBB168:
 2267               		.stabs	"fbColors.h",132,0,0,.Ltext27
 2268               	.Ltext27:
  51:fbColors.h    **** 		value -= 0x30;
 2269               		.stabn	68,0,51,.LM247-.LFBB19
 2270               	.LM247:
 2271 0948 9053      		subi r25,lo8(-(-48))
 2272               	.L147:
  50:fbColors.h    **** 	while(value > 0x2f)
 2273               		.stabn	68,0,50,.LM248-.LFBB19
 2274               	.LM248:
 2275 094a 9033      		cpi r25,lo8(48)
 2276 094c 00F4      		brsh .L148
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2277               		.stabn	68,0,53,.LM249-.LFBB19
 2278               	.LM249:
 2279 094e 692F      		mov r22,r25
 2280 0950 6370      		andi r22,lo8(3)
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2281               		.stabn	68,0,54,.LM250-.LFBB19
 2282               	.LM250:
 2283 0952 92FF      		sbrs r25,2
 2284 0954 00C0      		rjmp .L149
 2285 0956 23E0      		ldi r18,lo8(3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 175


 2286 0958 261B      		sub r18,r22
 2287 095a 622F      		mov r22,r18
 2288               	.L149:
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2289               		.stabn	68,0,58,.LM251-.LFBB19
 2290               	.LM251:
 2291 095c 982F      		mov r25,r24
 2292 095e 00C0      		rjmp .L152
 2293               	.L153:
 2294               	.LBE168:
 2295               	.LBE167:
 2296               	.LBB169:
 2297               	.LBB170:
  51:fbColors.h    **** 		value -= 0x30;
 2298               		.stabn	68,0,51,.LM252-.LFBB19
 2299               	.LM252:
 2300 0960 9053      		subi r25,lo8(-(-48))
 2301               	.L152:
  50:fbColors.h    **** 	while(value > 0x2f)
 2302               		.stabn	68,0,50,.LM253-.LFBB19
 2303               	.LM253:
 2304 0962 9033      		cpi r25,lo8(48)
 2305 0964 00F4      		brsh .L153
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2306               		.stabn	68,0,53,.LM254-.LFBB19
 2307               	.LM254:
 2308 0966 792F      		mov r23,r25
 2309 0968 7370      		andi r23,lo8(3)
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2310               		.stabn	68,0,54,.LM255-.LFBB19
 2311               	.LM255:
 2312 096a 92FF      		sbrs r25,2
 2313 096c 00C0      		rjmp .L154
 2314 096e 23E0      		ldi r18,lo8(3)
 2315 0970 271B      		sub r18,r23
 2316 0972 722F      		mov r23,r18
 2317               	.L154:
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2318               		.stabn	68,0,58,.LM256-.LFBB19
 2319               	.LM256:
 2320 0974 282F      		mov r18,r24
 2321 0976 00C0      		rjmp .L157
 2322               	.L158:
 2323               	.LBE170:
 2324               	.LBE169:
 2325               	.LBB171:
 2326               	.LBB172:
  51:fbColors.h    **** 		value -= 0x30;
 2327               		.stabn	68,0,51,.LM257-.LFBB19
 2328               	.LM257:
 2329 0978 2053      		subi r18,lo8(-(-48))
 2330               	.L157:
  50:fbColors.h    **** 	while(value > 0x2f)
 2331               		.stabn	68,0,50,.LM258-.LFBB19
 2332               	.LM258:
 2333 097a 2033      		cpi r18,lo8(48)
 2334 097c 00F4      		brsh .L158
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 176


  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2335               		.stabn	68,0,54,.LM259-.LFBB19
 2336               	.LM259:
 2337 097e 30E0      		ldi r19,lo8(0)
  57:fbColors.h    **** 	uint8_t B = ((value)&0x30) >> 4; 
 2338               		.stabn	68,0,57,.LM260-.LFBB19
 2339               	.LM260:
 2340 0980 A901      		movw r20,r18
 2341 0982 4073      		andi r20,lo8(48)
 2342 0984 5070      		andi r21,hi8(48)
 2343 0986 B4E0      		ldi r27,4
 2344 0988 5595      	1:	asr r21
 2345 098a 4795      		ror r20
 2346 098c BA95      		dec r27
 2347 098e 01F4      		brne 1b
 2348 0990 542F      		mov r21,r20
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2349               		.stabn	68,0,58,.LM261-.LFBB19
 2350               	.LM261:
 2351 0992 26FF      		sbrs r18,6
 2352 0994 00C0      		rjmp .L179
 2353 0996 93E0      		ldi r25,lo8(3)
 2354 0998 941B      		sub r25,r20
 2355 099a 592F      		mov r21,r25
 2356 099c 00C0      		rjmp .L179
 2357               	.L162:
 2358               	.LBE172:
 2359               	.LBE171:
 2360               	.LBB173:
 2361               	.LBB174:
  51:fbColors.h    **** 		value -= 0x30;
 2362               		.stabn	68,0,51,.LM262-.LFBB19
 2363               	.LM262:
 2364 099e 8053      		subi r24,lo8(-(-48))
 2365               	.L179:
  50:fbColors.h    **** 	while(value > 0x2f)
 2366               		.stabn	68,0,50,.LM263-.LFBB19
 2367               	.LM263:
 2368 09a0 8033      		cpi r24,lo8(48)
 2369 09a2 00F4      		brsh .L162
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2370               		.stabn	68,0,54,.LM264-.LFBB19
 2371               	.LM264:
 2372 09a4 90E0      		ldi r25,lo8(0)
  55:fbColors.h    **** 	uint8_t G = ((value)&0x0C)>>2; 
 2373               		.stabn	68,0,55,.LM265-.LFBB19
 2374               	.LM265:
 2375 09a6 9C01      		movw r18,r24
 2376 09a8 2C70      		andi r18,lo8(12)
 2377 09aa 3070      		andi r19,hi8(12)
 2378 09ac 3595      		asr r19
 2379 09ae 2795      		ror r18
 2380 09b0 3595      		asr r19
 2381 09b2 2795      		ror r18
 2382 09b4 422F      		mov r20,r18
  56:fbColors.h    **** 	uint8_t g = ((value)&0x10) ? (3-G) : G ; 
 2383               		.stabn	68,0,56,.LM266-.LFBB19
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 177


 2384               	.LM266:
 2385 09b6 84FF      		sbrs r24,4
 2386 09b8 00C0      		rjmp .L164
 2387 09ba 23E0      		ldi r18,lo8(3)
 2388 09bc 241B      		sub r18,r20
 2389 09be 422F      		mov r20,r18
 2390               	.L164:
 2391               	.LBE174:
 2392               	.LBE173:
 2393               		.stabs	"main.c",132,0,0,.Ltext28
 2394               	.Ltext28:
3005:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
 2395               		.stabn	68,0,3005,.LM267-.LFBB19
 2396               	.LM267:
 2397 09c0 21E0      		ldi r18,lo8(257)
 2398 09c2 31E0      		ldi r19,hi8(257)
 2399 09c4 2F19      		sub r18,r15
 2400 09c6 3109      		sbc r19,__zero_reg__
 2401 09c8 7170      		andi r23,lo8(1)
 2402 09ca 6370      		andi r22,lo8(3)
 2403 09cc 660F      		lsl r22
 2404 09ce 672B      		or r22,r23
 2405 09d0 952F      		mov r25,r21
 2406 09d2 9295      		swap r25
 2407 09d4 9073      		andi r25,lo8(48)
 2408 09d6 9064      		ori r25,lo8(64)
 2409 09d8 4370      		andi r20,lo8(3)
 2410 09da 492B      		or r20,r25
 2411 09dc C901      		movw r24,r18
 2412 09de 8E19      		sub r24,r14
 2413 09e0 9109      		sbc r25,__zero_reg__
 2414 09e2 00D0      		rcall addSeg
3007:main.c        **** 	addSegfb(3, _W);
 2415               		.stabn	68,0,3007,.LM268-.LFBB19
 2416               	.LM268:
 2417 09e4 83E0      		ldi r24,lo8(3)
 2418 09e6 90E0      		ldi r25,hi8(3)
 2419 09e8 67E0      		ldi r22,lo8(7)
 2420 09ea 43E7      		ldi r20,lo8(115)
 2421 09ec 00D0      		rcall addSeg
 2422               	.LBB175:
3011:main.c        **** 		addSegfb(3, _R);
 2423               		.stabn	68,0,3011,.LM269-.LFBB19
 2424               	.LM269:
 2425 09ee 83E0      		ldi r24,lo8(3)
 2426 09f0 90E0      		ldi r25,hi8(3)
 2427 09f2 67E0      		ldi r22,lo8(7)
 2428 09f4 40E4      		ldi r20,lo8(64)
 2429 09f6 00D0      		rcall addSeg
3021:main.c        **** 		char thisChar = (rowNum/8)%('~'-' '+1) + ' '; //pgm_read_byte(&(string[rowNum/8])); 
 2430               		.stabn	68,0,3021,.LM270-.LFBB19
 2431               	.LM270:
 2432 09f8 C601      		movw r24,r12
 2433 09fa 6FE5      		ldi r22,lo8(95)
 2434 09fc 70E0      		ldi r23,hi8(95)
 2435 09fe 00D0      		rcall __udivmodhi4
 2436 0a00 805E      		subi r24,lo8(-(32))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 178


 2437 0a02 8983      		std Y+1,r24
 2438 0a04 C801      		movw r24,r16
 2439 0a06 8770      		andi r24,lo8(7)
 2440 0a08 9070      		andi r25,hi8(7)
 2441 0a0a F1E0      		ldi r31,lo8(1)
 2442 0a0c EF2E      		mov r14,r31
 2443 0a0e F12C      		mov r15,__zero_reg__
 2444 0a10 00C0      		rjmp 2f
 2445 0a12 EE0C      	1:	lsl r14
 2446 0a14 FF1C      		rol r15
 2447 0a16 8A95      	2:	dec r24
 2448 0a18 02F4      		brpl 1b
 2449 0a1a E0E8      		ldi r30,lo8(640)
 2450 0a1c AE2E      		mov r10,r30
 2451 0a1e E2E0      		ldi r30,hi8(640)
 2452 0a20 BE2E      		mov r11,r30
 2453               	.L168:
 2454               	.LBB176:
3028:main.c        **** 			if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
 2455               		.stabn	68,0,3028,.LM271-.LFBB19
 2456               	.LM271:
 2457 0a22 E981      		ldd r30,Y+1
 2458 0a24 C501      		movw r24,r10
 2459 0a26 8E0F      		add r24,r30
 2460 0a28 911D      		adc r25,__zero_reg__
 2461 0a2a FC01      		movw r30,r24
 2462 0a2c E050      		subi r30,lo8(-(characters))
 2463 0a2e F040      		sbci r31,hi8(-(characters))
 2464               	/* #APP */
 2465               	 ;  3028 "main.c" 1
 2466 0a30 8491      		lpm r24, Z
 2467               		
 2468               	 ;  0 "" 2
 2469               	/* #NOAPP */
 2470               	.LBE176:
 2471 0a32 90E0      		ldi r25,lo8(0)
 2472 0a34 8E21      		and r24,r14
 2473 0a36 9F21      		and r25,r15
 2474 0a38 0097      		sbiw r24,0
 2475 0a3a 01F0      		breq .L166
3029:main.c        **** 				addSegfb(1, _Y); //0x06, (4<<4) | 3);
 2476               		.stabn	68,0,3029,.LM272-.LFBB19
 2477               	.LM272:
 2478 0a3c 81E0      		ldi r24,lo8(1)
 2479 0a3e 90E0      		ldi r25,hi8(1)
 2480 0a40 67E0      		ldi r22,lo8(7)
 2481 0a42 43E4      		ldi r20,lo8(67)
 2482 0a44 00C0      		rjmp .L180
 2483               	.L166:
3031:main.c        **** 				addSegfb(1, _R); //0x06, (4<<4) | 0);
 2484               		.stabn	68,0,3031,.LM273-.LFBB19
 2485               	.LM273:
 2486 0a46 81E0      		ldi r24,lo8(1)
 2487 0a48 90E0      		ldi r25,hi8(1)
 2488 0a4a 67E0      		ldi r22,lo8(7)
 2489 0a4c 40E4      		ldi r20,lo8(64)
 2490               	.L180:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 179


 2491 0a4e 00D0      		rcall addSeg
 2492 0a50 20EA      		ldi r18,lo8(-96)
 2493 0a52 3FEF      		ldi r19,hi8(-96)
 2494 0a54 A20E      		add r10,r18
 2495 0a56 B31E      		adc r11,r19
3026:main.c        **** 		for(i=8; i>0; i--)
 2496               		.stabn	68,0,3026,.LM274-.LFBB19
 2497               	.LM274:
 2498 0a58 30E8      		ldi r19,lo8(-128)
 2499 0a5a A316      		cp r10,r19
 2500 0a5c 3FEF      		ldi r19,hi8(-128)
 2501 0a5e B306      		cpc r11,r19
 2502 0a60 01F4      		brne .L168
3034:main.c        **** 		addSegfb(3, _R); //0x06, (4<<4) | 0);
 2503               		.stabn	68,0,3034,.LM275-.LFBB19
 2504               	.LM275:
 2505 0a62 83E0      		ldi r24,lo8(3)
 2506 0a64 90E0      		ldi r25,hi8(3)
 2507 0a66 67E0      		ldi r22,lo8(7)
 2508 0a68 40E4      		ldi r20,lo8(64)
 2509 0a6a 00D0      		rcall addSeg
3036:main.c        **** 		addSegfb(1, _W); //0x04, (6<<4) | 3);
 2510               		.stabn	68,0,3036,.LM276-.LFBB19
 2511               	.LM276:
 2512 0a6c 81E0      		ldi r24,lo8(1)
 2513 0a6e 90E0      		ldi r25,hi8(1)
 2514 0a70 67E0      		ldi r22,lo8(7)
 2515 0a72 43E7      		ldi r20,lo8(115)
 2516 0a74 00D0      		rcall addSeg
3042:main.c        **** 		strncpy_P(&thisChar, tqbf+(rowNum/8), 1);
 2517               		.stabn	68,0,3042,.LM277-.LFBB19
 2518               	.LM277:
 2519 0a76 B601      		movw r22,r12
 2520 0a78 6050      		subi r22,lo8(-(__c.2313))
 2521 0a7a 7040      		sbci r23,hi8(-(__c.2313))
 2522 0a7c CE01      		movw r24,r28
 2523 0a7e 0196      		adiw r24,1
 2524 0a80 41E0      		ldi r20,lo8(1)
 2525 0a82 50E0      		ldi r21,hi8(1)
 2526 0a84 00D0      		rcall strncpy_P
3044:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0, (6<<4) | 0);
 2527               		.stabn	68,0,3044,.LM278-.LFBB19
 2528               	.LM278:
 2529 0a86 83E0      		ldi r24,lo8(3)
 2530 0a88 90E0      		ldi r25,hi8(3)
 2531 0a8a 60E0      		ldi r22,lo8(0)
 2532 0a8c 40E5      		ldi r20,lo8(80)
 2533 0a8e 00D0      		rcall addSeg
3046:main.c        **** 		if(rowNum/8 < strlen_P(tqbf))
 2534               		.stabn	68,0,3046,.LM279-.LFBB19
 2535               	.LM279:
 2536 0a90 80E0      		ldi r24,lo8(__c.2313)
 2537 0a92 90E0      		ldi r25,hi8(__c.2313)
 2538 0a94 00D0      		rcall strlen_P
 2539 0a96 C816      		cp r12,r24
 2540 0a98 D906      		cpc r13,r25
 2541 0a9a 00F4      		brsh .L169
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 180


 2542 0a9c 70E8      		ldi r23,lo8(640)
 2543 0a9e C72E      		mov r12,r23
 2544 0aa0 72E0      		ldi r23,hi8(640)
 2545 0aa2 D72E      		mov r13,r23
 2546               	.L172:
 2547               	.LBB177:
3050:main.c        **** 				if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
 2548               		.stabn	68,0,3050,.LM280-.LFBB19
 2549               	.LM280:
 2550 0aa4 E981      		ldd r30,Y+1
 2551 0aa6 C601      		movw r24,r12
 2552 0aa8 8E0F      		add r24,r30
 2553 0aaa 911D      		adc r25,__zero_reg__
 2554 0aac FC01      		movw r30,r24
 2555 0aae E050      		subi r30,lo8(-(characters))
 2556 0ab0 F040      		sbci r31,hi8(-(characters))
 2557               	/* #APP */
 2558               	 ;  3050 "main.c" 1
 2559 0ab2 8491      		lpm r24, Z
 2560               		
 2561               	 ;  0 "" 2
 2562               	/* #NOAPP */
 2563               	.LBE177:
 2564 0ab4 90E0      		ldi r25,lo8(0)
 2565 0ab6 8E21      		and r24,r14
 2566 0ab8 9F21      		and r25,r15
 2567 0aba 0097      		sbiw r24,0
 2568 0abc 01F0      		breq .L170
3051:main.c        **** 					addSegfb(1, rgb(3,0,1));//_C); //0, (6<<4) | 3);
 2569               		.stabn	68,0,3051,.LM281-.LFBB19
 2570               	.LM281:
 2571 0abe 81E0      		ldi r24,lo8(1)
 2572 0ac0 90E0      		ldi r25,hi8(1)
 2573 0ac2 67E0      		ldi r22,lo8(7)
 2574 0ac4 00C0      		rjmp .L181
 2575               	.L170:
3053:main.c        **** 					addSegfb(1, rgb(0,0,1));//_B); //0, (6<<4) | 0);
 2576               		.stabn	68,0,3053,.LM282-.LFBB19
 2577               	.LM282:
 2578 0ac6 81E0      		ldi r24,lo8(1)
 2579 0ac8 90E0      		ldi r25,hi8(1)
 2580 0aca 60E0      		ldi r22,lo8(0)
 2581               	.L181:
 2582 0acc 40E5      		ldi r20,lo8(80)
 2583 0ace 00D0      		rcall addSeg
 2584 0ad0 20EA      		ldi r18,lo8(-96)
 2585 0ad2 3FEF      		ldi r19,hi8(-96)
 2586 0ad4 C20E      		add r12,r18
 2587 0ad6 D31E      		adc r13,r19
3048:main.c        **** 			for(i=8; i>0; i--)
 2588               		.stabn	68,0,3048,.LM283-.LFBB19
 2589               	.LM283:
 2590 0ad8 30E8      		ldi r19,lo8(-128)
 2591 0ada C316      		cp r12,r19
 2592 0adc 3FEF      		ldi r19,hi8(-128)
 2593 0ade D306      		cpc r13,r19
 2594 0ae0 01F4      		brne .L172
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 181


 2595 0ae2 00C0      		rjmp .L173
 2596               	.L169:
3057:main.c        **** 			addSegfb(8, rgb(0,0,1));//_B); //0,(6<<4) | 0);
 2597               		.stabn	68,0,3057,.LM284-.LFBB19
 2598               	.LM284:
 2599 0ae4 88E0      		ldi r24,lo8(8)
 2600 0ae6 90E0      		ldi r25,hi8(8)
 2601 0ae8 60E0      		ldi r22,lo8(0)
 2602 0aea 40E5      		ldi r20,lo8(80)
 2603 0aec 00D0      		rcall addSeg
 2604               	.L173:
3059:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0,(6<<4)|0);
 2605               		.stabn	68,0,3059,.LM285-.LFBB19
 2606               	.LM285:
 2607 0aee 83E0      		ldi r24,lo8(3)
 2608 0af0 90E0      		ldi r25,hi8(3)
 2609 0af2 60E0      		ldi r22,lo8(0)
 2610 0af4 40E5      		ldi r20,lo8(80)
 2611 0af6 00D0      		rcall addSeg
 2612               	.LBE175:
3067:main.c        **** 		addSegfb(1, (i+rowNum/4)&0x3f);
 2613               		.stabn	68,0,3067,.LM286-.LFBB19
 2614               	.LM286:
 2615 0af8 1695      		lsr r17
 2616 0afa 0795      		ror r16
 2617 0afc 1695      		lsr r17
 2618 0afe 0795      		ror r16
 2619 0b00 20E0      		ldi r18,lo8(0)
 2620               	.L174:
 2621 0b02 402F      		mov r20,r16
 2622 0b04 602F      		mov r22,r16
 2623 0b06 6370      		andi r22,lo8(3)
 2624 0b08 660F      		lsl r22
 2625 0b0a 802F      		mov r24,r16
 2626 0b0c 8170      		andi r24,lo8(1)
 2627 0b0e 682B      		or r22,r24
 2628 0b10 4073      		andi r20,lo8(48)
 2629 0b12 4064      		ori r20,lo8(64)
 2630 0b14 C801      		movw r24,r16
 2631 0b16 8C70      		andi r24,lo8(12)
 2632 0b18 9070      		andi r25,hi8(12)
 2633 0b1a 9695      		lsr r25
 2634 0b1c 8795      		ror r24
 2635 0b1e 9695      		lsr r25
 2636 0b20 8795      		ror r24
 2637 0b22 482B      		or r20,r24
 2638 0b24 81E0      		ldi r24,lo8(1)
 2639 0b26 90E0      		ldi r25,hi8(1)
 2640 0b28 2A83      		std Y+2,r18
 2641 0b2a 00D0      		rcall addSeg
3066:main.c        **** 	for(i=0; i<64; i++)
 2642               		.stabn	68,0,3066,.LM287-.LFBB19
 2643               	.LM287:
 2644 0b2c 2A81      		ldd r18,Y+2
 2645 0b2e 2F5F      		subi r18,lo8(-(1))
 2646 0b30 0F5F      		subi r16,lo8(-(1))
 2647 0b32 1F4F      		sbci r17,hi8(-(1))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 182


 2648 0b34 2034      		cpi r18,lo8(64)
 2649 0b36 01F4      		brne .L174
3069:main.c        **** 	addSegfb(3, _W); //0x06, (6<<4) | 3);
 2650               		.stabn	68,0,3069,.LM288-.LFBB19
 2651               	.LM288:
 2652 0b38 83E0      		ldi r24,lo8(3)
 2653 0b3a 90E0      		ldi r25,hi8(3)
 2654 0b3c 67E0      		ldi r22,lo8(7)
 2655 0b3e 43E7      		ldi r20,lo8(115)
 2656 0b40 00D0      		rcall addSeg
3071:main.c        **** 	segTerminate();
 2657               		.stabn	68,0,3071,.LM289-.LFBB19
 2658               	.LM289:
 2659 0b42 00D0      		rcall segTerminate
 2660               	.L175:
 2661               	/* epilogue start */
 2662               	.LBE160:
 2663               	.LBE159:
2150:main.c        **** }
 2664               		.stabn	68,0,2150,.LM290-.LFBB19
 2665               	.LM290:
 2666 0b44 0F90      		pop __tmp_reg__
 2667 0b46 0F90      		pop __tmp_reg__
 2668 0b48 CF91      		pop r28
 2669 0b4a DF91      		pop r29
 2670 0b4c FF91      		pop r31
 2671 0b4e EF91      		pop r30
 2672 0b50 BF91      		pop r27
 2673 0b52 AF91      		pop r26
 2674 0b54 9F91      		pop r25
 2675 0b56 8F91      		pop r24
 2676 0b58 7F91      		pop r23
 2677 0b5a 6F91      		pop r22
 2678 0b5c 5F91      		pop r21
 2679 0b5e 4F91      		pop r20
 2680 0b60 3F91      		pop r19
 2681 0b62 2F91      		pop r18
 2682 0b64 1F91      		pop r17
 2683 0b66 0F91      		pop r16
 2684 0b68 FF90      		pop r15
 2685 0b6a EF90      		pop r14
 2686 0b6c DF90      		pop r13
 2687 0b6e CF90      		pop r12
 2688 0b70 BF90      		pop r11
 2689 0b72 AF90      		pop r10
 2690 0b74 9F90      		pop r9
 2691 0b76 0F90      		pop r0
 2692 0b78 0FBE      		out __SREG__,r0
 2693 0b7a 0F90      		pop r0
 2694 0b7c 1F90      		pop __zero_reg__
 2695 0b7e 1895      		reti
 2696               		.size	__vector_14, .-__vector_14
 2697               		.stabs	"frameCount:V(3,2)",38,0,2107,frameCount.2279
 2698               		.stabn	192,0,0,.LFBB19-.LFBB19
 2699               		.stabs	"sineVal:r(3,2)",64,0,2957,15
 2700               		.stabs	"nextSineVal:r(3,2)",64,0,2960,24
 2701               		.stabs	"length:r(3,2)",64,0,2963,14
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 183


 2702               		.stabs	"J:r(3,2)",64,0,2983,30
 2703               		.stabs	"j:r(3,2)",64,0,2984,9
 2704               		.stabs	"i:r(3,2)",64,0,3065,18
 2705               		.stabn	192,0,0,.LBB160-.LFBB19
 2706               		.stabs	"r:r(3,2)",64,0,54,20
 2707               		.stabs	"g:r(3,2)",64,0,56,18
 2708               		.stabs	"b:r(3,2)",64,0,58,24
 2709               		.stabn	192,0,0,.LBB164-.LFBB19
 2710               		.stabn	224,0,0,.LBE164-.LFBB19
 2711               		.stabs	"r:r(3,2)",64,0,54,20
 2712               		.stabs	"g:r(3,2)",64,0,56,18
 2713               		.stabs	"b:r(3,2)",64,0,58,24
 2714               		.stabn	192,0,0,.LBB165-.LFBB19
 2715               		.stabn	224,0,0,.LBE165-.LFBB19
 2716               		.stabs	"r:r(3,2)",64,0,54,22
 2717               		.stabn	192,0,0,.LBB168-.LFBB19
 2718               		.stabn	224,0,0,.LBE168-.LFBB19
 2719               		.stabs	"r:r(3,2)",64,0,54,23
 2720               		.stabn	192,0,0,.LBB170-.LFBB19
 2721               		.stabn	224,0,0,.LBE170-.LFBB19
 2722               		.stabs	"b:r(3,2)",64,0,58,21
 2723               		.stabn	192,0,0,.LBB172-.LFBB19
 2724               		.stabn	224,0,0,.LBE172-.LFBB19
 2725               		.stabs	"value:r(3,2)",64,0,3005,24
 2726               		.stabn	192,0,0,.LBB173-.LFBB19
 2727               		.stabs	"g:r(3,2)",64,0,56,20
 2728               		.stabn	192,0,0,.LBB174-.LFBB19
 2729               		.stabn	224,0,0,.LBE174-.LFBB19
 2730               		.stabn	224,0,0,.LBE173-.LFBB19
 2731               		.stabs	"thisChar:(0,2)",128,0,3021,1
 2732               		.stabn	192,0,0,.LBB175-.LFBB19
 2733               		.stabs	"__result:r(3,2)",64,0,3028,24
 2734               		.stabn	192,0,0,.LBB176-.LFBB19
 2735               		.stabn	224,0,0,.LBE176-.LFBB19
 2736               		.stabs	"__result:r(3,2)",64,0,3050,24
 2737               		.stabn	192,0,0,.LBB177-.LFBB19
 2738               		.stabn	224,0,0,.LBE177-.LFBB19
 2739               		.stabn	224,0,0,.LBE175-.LFBB19
 2740               		.stabn	224,0,0,.LBE160-.LFBB19
 2741               		.stabn	224,0,0,.Lscope19-.LFBB19
 2742               	.Lscope19:
 2743               		.stabs	"",36,0,0,.Lscope19-.LFBB19
 2744               		.stabd	78,0,0
 2745               	.global	header
 2746               		.section	.progmem.data,"a",@progbits
 2747               		.type	header, @object
 2748               		.size	header, 36
 2749               	header:
 2750 0000 4C43 4464 		.string	"LCDdirectLVDS59 2013-12-13 02:09:09"
 2750      6972 6563 
 2750      744C 5644 
 2750      5335 3920 
 2750      3230 3133 
 2751               	.global	characters
 2752               		.type	characters, @object
 2753               		.size	characters, 768
 2754               	characters:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 184


 2755 0024 00        		.byte	0
 2756 0025 0C        		.byte	12
 2757 0026 36        		.byte	54
 2758 0027 36        		.byte	54
 2759 0028 0C        		.byte	12
 2760 0029 00        		.byte	0
 2761 002a 1C        		.byte	28
 2762 002b 06        		.byte	6
 2763 002c 18        		.byte	24
 2764 002d 06        		.byte	6
 2765 002e 00        		.byte	0
 2766 002f 00        		.byte	0
 2767 0030 00        		.byte	0
 2768 0031 00        		.byte	0
 2769 0032 00        		.byte	0
 2770 0033 60        		.byte	96
 2771 0034 1E        		.byte	30
 2772 0035 0C        		.byte	12
 2773 0036 1E        		.byte	30
 2774 0037 1E        		.byte	30
 2775 0038 38        		.byte	56
 2776 0039 3F        		.byte	63
 2777 003a 1C        		.byte	28
 2778 003b 3F        		.byte	63
 2779 003c 1E        		.byte	30
 2780 003d 1E        		.byte	30
 2781 003e 00        		.byte	0
 2782 003f 00        		.byte	0
 2783 0040 18        		.byte	24
 2784 0041 00        		.byte	0
 2785 0042 06        		.byte	6
 2786 0043 1E        		.byte	30
 2787 0044 3E        		.byte	62
 2788 0045 0C        		.byte	12
 2789 0046 3F        		.byte	63
 2790 0047 3C        		.byte	60
 2791 0048 3F        		.byte	63
 2792 0049 7F        		.byte	127
 2793 004a 7F        		.byte	127
 2794 004b 3C        		.byte	60
 2795 004c 33        		.byte	51
 2796 004d 1E        		.byte	30
 2797 004e 78        		.byte	120
 2798 004f 67        		.byte	103
 2799 0050 0F        		.byte	15
 2800 0051 63        		.byte	99
 2801 0052 63        		.byte	99
 2802 0053 1C        		.byte	28
 2803 0054 3F        		.byte	63
 2804 0055 1E        		.byte	30
 2805 0056 3F        		.byte	63
 2806 0057 1E        		.byte	30
 2807 0058 3F        		.byte	63
 2808 0059 33        		.byte	51
 2809 005a 33        		.byte	51
 2810 005b 63        		.byte	99
 2811 005c 63        		.byte	99
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 185


 2812 005d 33        		.byte	51
 2813 005e 7F        		.byte	127
 2814 005f 1E        		.byte	30
 2815 0060 03        		.byte	3
 2816 0061 1E        		.byte	30
 2817 0062 08        		.byte	8
 2818 0063 00        		.byte	0
 2819 0064 0C        		.byte	12
 2820 0065 00        		.byte	0
 2821 0066 07        		.byte	7
 2822 0067 00        		.byte	0
 2823 0068 38        		.byte	56
 2824 0069 00        		.byte	0
 2825 006a 1C        		.byte	28
 2826 006b 00        		.byte	0
 2827 006c 07        		.byte	7
 2828 006d 0C        		.byte	12
 2829 006e 18        		.byte	24
 2830 006f 07        		.byte	7
 2831 0070 0E        		.byte	14
 2832 0071 00        		.byte	0
 2833 0072 00        		.byte	0
 2834 0073 00        		.byte	0
 2835 0074 00        		.byte	0
 2836 0075 00        		.byte	0
 2837 0076 00        		.byte	0
 2838 0077 00        		.byte	0
 2839 0078 08        		.byte	8
 2840 0079 00        		.byte	0
 2841 007a 00        		.byte	0
 2842 007b 00        		.byte	0
 2843 007c 00        		.byte	0
 2844 007d 00        		.byte	0
 2845 007e 00        		.byte	0
 2846 007f 38        		.byte	56
 2847 0080 18        		.byte	24
 2848 0081 07        		.byte	7
 2849 0082 6E        		.byte	110
 2850 0083 0E        		.byte	14
 2851 0084 00        		.byte	0
 2852 0085 1E        		.byte	30
 2853 0086 36        		.byte	54
 2854 0087 36        		.byte	54
 2855 0088 3E        		.byte	62
 2856 0089 63        		.byte	99
 2857 008a 36        		.byte	54
 2858 008b 06        		.byte	6
 2859 008c 0C        		.byte	12
 2860 008d 0C        		.byte	12
 2861 008e 66        		.byte	102
 2862 008f 0C        		.byte	12
 2863 0090 00        		.byte	0
 2864 0091 00        		.byte	0
 2865 0092 00        		.byte	0
 2866 0093 30        		.byte	48
 2867 0094 33        		.byte	51
 2868 0095 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 186


 2869 0096 33        		.byte	51
 2870 0097 33        		.byte	51
 2871 0098 3C        		.byte	60
 2872 0099 03        		.byte	3
 2873 009a 06        		.byte	6
 2874 009b 33        		.byte	51
 2875 009c 33        		.byte	51
 2876 009d 33        		.byte	51
 2877 009e 00        		.byte	0
 2878 009f 00        		.byte	0
 2879 00a0 0C        		.byte	12
 2880 00a1 00        		.byte	0
 2881 00a2 0C        		.byte	12
 2882 00a3 33        		.byte	51
 2883 00a4 63        		.byte	99
 2884 00a5 1E        		.byte	30
 2885 00a6 66        		.byte	102
 2886 00a7 66        		.byte	102
 2887 00a8 36        		.byte	54
 2888 00a9 46        		.byte	70
 2889 00aa 46        		.byte	70
 2890 00ab 66        		.byte	102
 2891 00ac 33        		.byte	51
 2892 00ad 0C        		.byte	12
 2893 00ae 30        		.byte	48
 2894 00af 66        		.byte	102
 2895 00b0 06        		.byte	6
 2896 00b1 77        		.byte	119
 2897 00b2 67        		.byte	103
 2898 00b3 36        		.byte	54
 2899 00b4 66        		.byte	102
 2900 00b5 33        		.byte	51
 2901 00b6 66        		.byte	102
 2902 00b7 33        		.byte	51
 2903 00b8 2D        		.byte	45
 2904 00b9 33        		.byte	51
 2905 00ba 33        		.byte	51
 2906 00bb 63        		.byte	99
 2907 00bc 63        		.byte	99
 2908 00bd 33        		.byte	51
 2909 00be 33        		.byte	51
 2910 00bf 06        		.byte	6
 2911 00c0 06        		.byte	6
 2912 00c1 18        		.byte	24
 2913 00c2 1C        		.byte	28
 2914 00c3 00        		.byte	0
 2915 00c4 0C        		.byte	12
 2916 00c5 00        		.byte	0
 2917 00c6 06        		.byte	6
 2918 00c7 00        		.byte	0
 2919 00c8 30        		.byte	48
 2920 00c9 00        		.byte	0
 2921 00ca 36        		.byte	54
 2922 00cb 00        		.byte	0
 2923 00cc 06        		.byte	6
 2924 00cd 00        		.byte	0
 2925 00ce 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 187


 2926 00cf 06        		.byte	6
 2927 00d0 0C        		.byte	12
 2928 00d1 00        		.byte	0
 2929 00d2 00        		.byte	0
 2930 00d3 00        		.byte	0
 2931 00d4 00        		.byte	0
 2932 00d5 00        		.byte	0
 2933 00d6 00        		.byte	0
 2934 00d7 00        		.byte	0
 2935 00d8 0C        		.byte	12
 2936 00d9 00        		.byte	0
 2937 00da 00        		.byte	0
 2938 00db 00        		.byte	0
 2939 00dc 00        		.byte	0
 2940 00dd 00        		.byte	0
 2941 00de 00        		.byte	0
 2942 00df 0C        		.byte	12
 2943 00e0 18        		.byte	24
 2944 00e1 0C        		.byte	12
 2945 00e2 3B        		.byte	59
 2946 00e3 13        		.byte	19
 2947 00e4 00        		.byte	0
 2948 00e5 1E        		.byte	30
 2949 00e6 36        		.byte	54
 2950 00e7 7F        		.byte	127
 2951 00e8 03        		.byte	3
 2952 00e9 33        		.byte	51
 2953 00ea 1C        		.byte	28
 2954 00eb 03        		.byte	3
 2955 00ec 06        		.byte	6
 2956 00ed 18        		.byte	24
 2957 00ee 3C        		.byte	60
 2958 00ef 0C        		.byte	12
 2959 00f0 00        		.byte	0
 2960 00f1 00        		.byte	0
 2961 00f2 00        		.byte	0
 2962 00f3 18        		.byte	24
 2963 00f4 3B        		.byte	59
 2964 00f5 0C        		.byte	12
 2965 00f6 30        		.byte	48
 2966 00f7 30        		.byte	48
 2967 00f8 36        		.byte	54
 2968 00f9 1F        		.byte	31
 2969 00fa 03        		.byte	3
 2970 00fb 30        		.byte	48
 2971 00fc 33        		.byte	51
 2972 00fd 33        		.byte	51
 2973 00fe 0C        		.byte	12
 2974 00ff 0C        		.byte	12
 2975 0100 06        		.byte	6
 2976 0101 3F        		.byte	63
 2977 0102 18        		.byte	24
 2978 0103 30        		.byte	48
 2979 0104 7B        		.byte	123
 2980 0105 33        		.byte	51
 2981 0106 66        		.byte	102
 2982 0107 03        		.byte	3
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 188


 2983 0108 66        		.byte	102
 2984 0109 16        		.byte	22
 2985 010a 16        		.byte	22
 2986 010b 03        		.byte	3
 2987 010c 33        		.byte	51
 2988 010d 0C        		.byte	12
 2989 010e 30        		.byte	48
 2990 010f 36        		.byte	54
 2991 0110 06        		.byte	6
 2992 0111 7F        		.byte	127
 2993 0112 6F        		.byte	111
 2994 0113 63        		.byte	99
 2995 0114 66        		.byte	102
 2996 0115 33        		.byte	51
 2997 0116 66        		.byte	102
 2998 0117 07        		.byte	7
 2999 0118 0C        		.byte	12
 3000 0119 33        		.byte	51
 3001 011a 33        		.byte	51
 3002 011b 63        		.byte	99
 3003 011c 36        		.byte	54
 3004 011d 33        		.byte	51
 3005 011e 19        		.byte	25
 3006 011f 06        		.byte	6
 3007 0120 0C        		.byte	12
 3008 0121 18        		.byte	24
 3009 0122 36        		.byte	54
 3010 0123 00        		.byte	0
 3011 0124 18        		.byte	24
 3012 0125 1E        		.byte	30
 3013 0126 3E        		.byte	62
 3014 0127 1E        		.byte	30
 3015 0128 30        		.byte	48
 3016 0129 1E        		.byte	30
 3017 012a 06        		.byte	6
 3018 012b 6E        		.byte	110
 3019 012c 36        		.byte	54
 3020 012d 0E        		.byte	14
 3021 012e 1E        		.byte	30
 3022 012f 66        		.byte	102
 3023 0130 0C        		.byte	12
 3024 0131 37        		.byte	55
 3025 0132 1F        		.byte	31
 3026 0133 1E        		.byte	30
 3027 0134 3B        		.byte	59
 3028 0135 6E        		.byte	110
 3029 0136 1B        		.byte	27
 3030 0137 3E        		.byte	62
 3031 0138 3E        		.byte	62
 3032 0139 33        		.byte	51
 3033 013a 33        		.byte	51
 3034 013b 63        		.byte	99
 3035 013c 63        		.byte	99
 3036 013d 33        		.byte	51
 3037 013e 3F        		.byte	63
 3038 013f 0C        		.byte	12
 3039 0140 18        		.byte	24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 189


 3040 0141 0C        		.byte	12
 3041 0142 00        		.byte	0
 3042 0143 39        		.byte	57
 3043 0144 00        		.byte	0
 3044 0145 0C        		.byte	12
 3045 0146 00        		.byte	0
 3046 0147 36        		.byte	54
 3047 0148 1E        		.byte	30
 3048 0149 18        		.byte	24
 3049 014a 6E        		.byte	110
 3050 014b 00        		.byte	0
 3051 014c 06        		.byte	6
 3052 014d 18        		.byte	24
 3053 014e FF        		.byte	-1
 3054 014f 3F        		.byte	63
 3055 0150 00        		.byte	0
 3056 0151 3F        		.byte	63
 3057 0152 00        		.byte	0
 3058 0153 0C        		.byte	12
 3059 0154 3F        		.byte	63
 3060 0155 0C        		.byte	12
 3061 0156 1C        		.byte	28
 3062 0157 1C        		.byte	28
 3063 0158 33        		.byte	51
 3064 0159 30        		.byte	48
 3065 015a 1F        		.byte	31
 3066 015b 18        		.byte	24
 3067 015c 1E        		.byte	30
 3068 015d 3E        		.byte	62
 3069 015e 0C        		.byte	12
 3070 015f 0C        		.byte	12
 3071 0160 03        		.byte	3
 3072 0161 00        		.byte	0
 3073 0162 30        		.byte	48
 3074 0163 18        		.byte	24
 3075 0164 7B        		.byte	123
 3076 0165 33        		.byte	51
 3077 0166 3E        		.byte	62
 3078 0167 03        		.byte	3
 3079 0168 66        		.byte	102
 3080 0169 1E        		.byte	30
 3081 016a 1E        		.byte	30
 3082 016b 03        		.byte	3
 3083 016c 3F        		.byte	63
 3084 016d 0C        		.byte	12
 3085 016e 30        		.byte	48
 3086 016f 1E        		.byte	30
 3087 0170 06        		.byte	6
 3088 0171 6B        		.byte	107
 3089 0172 7B        		.byte	123
 3090 0173 63        		.byte	99
 3091 0174 3E        		.byte	62
 3092 0175 33        		.byte	51
 3093 0176 3E        		.byte	62
 3094 0177 1C        		.byte	28
 3095 0178 0C        		.byte	12
 3096 0179 33        		.byte	51
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 190


 3097 017a 33        		.byte	51
 3098 017b 6B        		.byte	107
 3099 017c 1C        		.byte	28
 3100 017d 1E        		.byte	30
 3101 017e 0C        		.byte	12
 3102 017f 06        		.byte	6
 3103 0180 18        		.byte	24
 3104 0181 18        		.byte	24
 3105 0182 63        		.byte	99
 3106 0183 00        		.byte	0
 3107 0184 00        		.byte	0
 3108 0185 30        		.byte	48
 3109 0186 66        		.byte	102
 3110 0187 33        		.byte	51
 3111 0188 3E        		.byte	62
 3112 0189 33        		.byte	51
 3113 018a 0F        		.byte	15
 3114 018b 33        		.byte	51
 3115 018c 6E        		.byte	110
 3116 018d 0C        		.byte	12
 3117 018e 18        		.byte	24
 3118 018f 36        		.byte	54
 3119 0190 0C        		.byte	12
 3120 0191 7F        		.byte	127
 3121 0192 33        		.byte	51
 3122 0193 33        		.byte	51
 3123 0194 66        		.byte	102
 3124 0195 33        		.byte	51
 3125 0196 36        		.byte	54
 3126 0197 03        		.byte	3
 3127 0198 0C        		.byte	12
 3128 0199 33        		.byte	51
 3129 019a 33        		.byte	51
 3130 019b 63        		.byte	99
 3131 019c 36        		.byte	54
 3132 019d 33        		.byte	51
 3133 019e 19        		.byte	25
 3134 019f 07        		.byte	7
 3135 01a0 00        		.byte	0
 3136 01a1 38        		.byte	56
 3137 01a2 00        		.byte	0
 3138 01a3 69        		.byte	105
 3139 01a4 00        		.byte	0
 3140 01a5 0C        		.byte	12
 3141 01a6 00        		.byte	0
 3142 01a7 7F        		.byte	127
 3143 01a8 30        		.byte	48
 3144 01a9 0C        		.byte	12
 3145 01aa 3B        		.byte	59
 3146 01ab 00        		.byte	0
 3147 01ac 06        		.byte	6
 3148 01ad 18        		.byte	24
 3149 01ae 3C        		.byte	60
 3150 01af 0C        		.byte	12
 3151 01b0 00        		.byte	0
 3152 01b1 00        		.byte	0
 3153 01b2 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 191


 3154 01b3 06        		.byte	6
 3155 01b4 37        		.byte	55
 3156 01b5 0C        		.byte	12
 3157 01b6 06        		.byte	6
 3158 01b7 30        		.byte	48
 3159 01b8 7F        		.byte	127
 3160 01b9 30        		.byte	48
 3161 01ba 33        		.byte	51
 3162 01bb 0C        		.byte	12
 3163 01bc 33        		.byte	51
 3164 01bd 30        		.byte	48
 3165 01be 00        		.byte	0
 3166 01bf 00        		.byte	0
 3167 01c0 06        		.byte	6
 3168 01c1 3F        		.byte	63
 3169 01c2 18        		.byte	24
 3170 01c3 0C        		.byte	12
 3171 01c4 7B        		.byte	123
 3172 01c5 3F        		.byte	63
 3173 01c6 66        		.byte	102
 3174 01c7 03        		.byte	3
 3175 01c8 66        		.byte	102
 3176 01c9 16        		.byte	22
 3177 01ca 16        		.byte	22
 3178 01cb 73        		.byte	115
 3179 01cc 33        		.byte	51
 3180 01cd 0C        		.byte	12
 3181 01ce 33        		.byte	51
 3182 01cf 36        		.byte	54
 3183 01d0 46        		.byte	70
 3184 01d1 63        		.byte	99
 3185 01d2 73        		.byte	115
 3186 01d3 63        		.byte	99
 3187 01d4 06        		.byte	6
 3188 01d5 3B        		.byte	59
 3189 01d6 1E        		.byte	30
 3190 01d7 38        		.byte	56
 3191 01d8 0C        		.byte	12
 3192 01d9 33        		.byte	51
 3193 01da 33        		.byte	51
 3194 01db 7F        		.byte	127
 3195 01dc 36        		.byte	54
 3196 01dd 0C        		.byte	12
 3197 01de 46        		.byte	70
 3198 01df 06        		.byte	6
 3199 01e0 30        		.byte	48
 3200 01e1 18        		.byte	24
 3201 01e2 00        		.byte	0
 3202 01e3 00        		.byte	0
 3203 01e4 00        		.byte	0
 3204 01e5 3E        		.byte	62
 3205 01e6 66        		.byte	102
 3206 01e7 03        		.byte	3
 3207 01e8 33        		.byte	51
 3208 01e9 3F        		.byte	63
 3209 01ea 06        		.byte	6
 3210 01eb 33        		.byte	51
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 192


 3211 01ec 66        		.byte	102
 3212 01ed 0C        		.byte	12
 3213 01ee 18        		.byte	24
 3214 01ef 1E        		.byte	30
 3215 01f0 0C        		.byte	12
 3216 01f1 6B        		.byte	107
 3217 01f2 33        		.byte	51
 3218 01f3 33        		.byte	51
 3219 01f4 66        		.byte	102
 3220 01f5 33        		.byte	51
 3221 01f6 36        		.byte	54
 3222 01f7 1E        		.byte	30
 3223 01f8 0C        		.byte	12
 3224 01f9 33        		.byte	51
 3225 01fa 33        		.byte	51
 3226 01fb 6B        		.byte	107
 3227 01fc 1C        		.byte	28
 3228 01fd 33        		.byte	51
 3229 01fe 0C        		.byte	12
 3230 01ff 0C        		.byte	12
 3231 0200 18        		.byte	24
 3232 0201 0C        		.byte	12
 3233 0202 00        		.byte	0
 3234 0203 0E        		.byte	14
 3235 0204 00        		.byte	0
 3236 0205 00        		.byte	0
 3237 0206 00        		.byte	0
 3238 0207 36        		.byte	54
 3239 0208 1F        		.byte	31
 3240 0209 66        		.byte	102
 3241 020a 33        		.byte	51
 3242 020b 00        		.byte	0
 3243 020c 0C        		.byte	12
 3244 020d 0C        		.byte	12
 3245 020e 66        		.byte	102
 3246 020f 0C        		.byte	12
 3247 0210 0E        		.byte	14
 3248 0211 00        		.byte	0
 3249 0212 0C        		.byte	12
 3250 0213 03        		.byte	3
 3251 0214 33        		.byte	51
 3252 0215 0C        		.byte	12
 3253 0216 33        		.byte	51
 3254 0217 33        		.byte	51
 3255 0218 30        		.byte	48
 3256 0219 33        		.byte	51
 3257 021a 33        		.byte	51
 3258 021b 06        		.byte	6
 3259 021c 33        		.byte	51
 3260 021d 18        		.byte	24
 3261 021e 0C        		.byte	12
 3262 021f 0E        		.byte	14
 3263 0220 0C        		.byte	12
 3264 0221 00        		.byte	0
 3265 0222 0C        		.byte	12
 3266 0223 00        		.byte	0
 3267 0224 03        		.byte	3
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 193


 3268 0225 33        		.byte	51
 3269 0226 66        		.byte	102
 3270 0227 66        		.byte	102
 3271 0228 36        		.byte	54
 3272 0229 46        		.byte	70
 3273 022a 06        		.byte	6
 3274 022b 66        		.byte	102
 3275 022c 33        		.byte	51
 3276 022d 0C        		.byte	12
 3277 022e 33        		.byte	51
 3278 022f 66        		.byte	102
 3279 0230 66        		.byte	102
 3280 0231 63        		.byte	99
 3281 0232 63        		.byte	99
 3282 0233 36        		.byte	54
 3283 0234 06        		.byte	6
 3284 0235 1E        		.byte	30
 3285 0236 36        		.byte	54
 3286 0237 33        		.byte	51
 3287 0238 0C        		.byte	12
 3288 0239 33        		.byte	51
 3289 023a 1E        		.byte	30
 3290 023b 77        		.byte	119
 3291 023c 63        		.byte	99
 3292 023d 0C        		.byte	12
 3293 023e 63        		.byte	99
 3294 023f 06        		.byte	6
 3295 0240 60        		.byte	96
 3296 0241 18        		.byte	24
 3297 0242 00        		.byte	0
 3298 0243 00        		.byte	0
 3299 0244 00        		.byte	0
 3300 0245 33        		.byte	51
 3301 0246 66        		.byte	102
 3302 0247 33        		.byte	51
 3303 0248 33        		.byte	51
 3304 0249 03        		.byte	3
 3305 024a 06        		.byte	6
 3306 024b 3E        		.byte	62
 3307 024c 66        		.byte	102
 3308 024d 0C        		.byte	12
 3309 024e 18        		.byte	24
 3310 024f 36        		.byte	54
 3311 0250 0C        		.byte	12
 3312 0251 63        		.byte	99
 3313 0252 33        		.byte	51
 3314 0253 33        		.byte	51
 3315 0254 3E        		.byte	62
 3316 0255 3E        		.byte	62
 3317 0256 06        		.byte	6
 3318 0257 30        		.byte	48
 3319 0258 2C        		.byte	44
 3320 0259 33        		.byte	51
 3321 025a 1E        		.byte	30
 3322 025b 7F        		.byte	127
 3323 025c 36        		.byte	54
 3324 025d 3E        		.byte	62
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 194


 3325 025e 26        		.byte	38
 3326 025f 0C        		.byte	12
 3327 0260 18        		.byte	24
 3328 0261 0C        		.byte	12
 3329 0262 00        		.byte	0
 3330 0263 F3        		.byte	-13
 3331 0264 00        		.byte	0
 3332 0265 0C        		.byte	12
 3333 0266 00        		.byte	0
 3334 0267 36        		.byte	54
 3335 0268 0C        		.byte	12
 3336 0269 63        		.byte	99
 3337 026a 6E        		.byte	110
 3338 026b 00        		.byte	0
 3339 026c 18        		.byte	24
 3340 026d 06        		.byte	6
 3341 026e 00        		.byte	0
 3342 026f 00        		.byte	0
 3343 0270 0C        		.byte	12
 3344 0271 00        		.byte	0
 3345 0272 0C        		.byte	12
 3346 0273 01        		.byte	1
 3347 0274 1E        		.byte	30
 3348 0275 3F        		.byte	63
 3349 0276 3F        		.byte	63
 3350 0277 1E        		.byte	30
 3351 0278 30        		.byte	48
 3352 0279 1E        		.byte	30
 3353 027a 1E        		.byte	30
 3354 027b 06        		.byte	6
 3355 027c 1E        		.byte	30
 3356 027d 0E        		.byte	14
 3357 027e 0C        		.byte	12
 3358 027f 0C        		.byte	12
 3359 0280 18        		.byte	24
 3360 0281 00        		.byte	0
 3361 0282 06        		.byte	6
 3362 0283 0C        		.byte	12
 3363 0284 1E        		.byte	30
 3364 0285 33        		.byte	51
 3365 0286 3F        		.byte	63
 3366 0287 3C        		.byte	60
 3367 0288 3F        		.byte	63
 3368 0289 7F        		.byte	127
 3369 028a 0F        		.byte	15
 3370 028b 7C        		.byte	124
 3371 028c 33        		.byte	51
 3372 028d 1E        		.byte	30
 3373 028e 1E        		.byte	30
 3374 028f 67        		.byte	103
 3375 0290 7F        		.byte	127
 3376 0291 63        		.byte	99
 3377 0292 63        		.byte	99
 3378 0293 1C        		.byte	28
 3379 0294 0F        		.byte	15
 3380 0295 38        		.byte	56
 3381 0296 67        		.byte	103
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 195


 3382 0297 1E        		.byte	30
 3383 0298 1E        		.byte	30
 3384 0299 3F        		.byte	63
 3385 029a 0C        		.byte	12
 3386 029b 63        		.byte	99
 3387 029c 63        		.byte	99
 3388 029d 1E        		.byte	30
 3389 029e 7F        		.byte	127
 3390 029f 1E        		.byte	30
 3391 02a0 40        		.byte	64
 3392 02a1 1E        		.byte	30
 3393 02a2 00        		.byte	0
 3394 02a3 00        		.byte	0
 3395 02a4 00        		.byte	0
 3396 02a5 6E        		.byte	110
 3397 02a6 3D        		.byte	61
 3398 02a7 1E        		.byte	30
 3399 02a8 6E        		.byte	110
 3400 02a9 1E        		.byte	30
 3401 02aa 0F        		.byte	15
 3402 02ab 30        		.byte	48
 3403 02ac 67        		.byte	103
 3404 02ad 1E        		.byte	30
 3405 02ae 1B        		.byte	27
 3406 02af 67        		.byte	103
 3407 02b0 1E        		.byte	30
 3408 02b1 63        		.byte	99
 3409 02b2 33        		.byte	51
 3410 02b3 1E        		.byte	30
 3411 02b4 06        		.byte	6
 3412 02b5 30        		.byte	48
 3413 02b6 0F        		.byte	15
 3414 02b7 1F        		.byte	31
 3415 02b8 18        		.byte	24
 3416 02b9 6E        		.byte	110
 3417 02ba 0C        		.byte	12
 3418 02bb 36        		.byte	54
 3419 02bc 63        		.byte	99
 3420 02bd 30        		.byte	48
 3421 02be 3F        		.byte	63
 3422 02bf 38        		.byte	56
 3423 02c0 18        		.byte	24
 3424 02c1 07        		.byte	7
 3425 02c2 00        		.byte	0
 3426 02c3 46        		.byte	70
 3427 02c4 00        		.byte	0
 3428 02c5 00        		.byte	0
 3429 02c6 00        		.byte	0
 3430 02c7 00        		.byte	0
 3431 02c8 00        		.byte	0
 3432 02c9 00        		.byte	0
 3433 02ca 00        		.byte	0
 3434 02cb 00        		.byte	0
 3435 02cc 00        		.byte	0
 3436 02cd 00        		.byte	0
 3437 02ce 00        		.byte	0
 3438 02cf 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 196


 3439 02d0 06        		.byte	6
 3440 02d1 00        		.byte	0
 3441 02d2 00        		.byte	0
 3442 02d3 00        		.byte	0
 3443 02d4 00        		.byte	0
 3444 02d5 00        		.byte	0
 3445 02d6 00        		.byte	0
 3446 02d7 00        		.byte	0
 3447 02d8 00        		.byte	0
 3448 02d9 00        		.byte	0
 3449 02da 00        		.byte	0
 3450 02db 00        		.byte	0
 3451 02dc 00        		.byte	0
 3452 02dd 00        		.byte	0
 3453 02de 00        		.byte	0
 3454 02df 06        		.byte	6
 3455 02e0 00        		.byte	0
 3456 02e1 00        		.byte	0
 3457 02e2 00        		.byte	0
 3458 02e3 00        		.byte	0
 3459 02e4 00        		.byte	0
 3460 02e5 00        		.byte	0
 3461 02e6 00        		.byte	0
 3462 02e7 00        		.byte	0
 3463 02e8 00        		.byte	0
 3464 02e9 00        		.byte	0
 3465 02ea 00        		.byte	0
 3466 02eb 00        		.byte	0
 3467 02ec 00        		.byte	0
 3468 02ed 00        		.byte	0
 3469 02ee 00        		.byte	0
 3470 02ef 00        		.byte	0
 3471 02f0 00        		.byte	0
 3472 02f1 00        		.byte	0
 3473 02f2 00        		.byte	0
 3474 02f3 00        		.byte	0
 3475 02f4 00        		.byte	0
 3476 02f5 00        		.byte	0
 3477 02f6 00        		.byte	0
 3478 02f7 00        		.byte	0
 3479 02f8 00        		.byte	0
 3480 02f9 00        		.byte	0
 3481 02fa 00        		.byte	0
 3482 02fb 00        		.byte	0
 3483 02fc 00        		.byte	0
 3484 02fd 00        		.byte	0
 3485 02fe 00        		.byte	0
 3486 02ff 00        		.byte	0
 3487 0300 00        		.byte	0
 3488 0301 00        		.byte	0
 3489 0302 00        		.byte	0
 3490 0303 FF        		.byte	-1
 3491 0304 00        		.byte	0
 3492 0305 00        		.byte	0
 3493 0306 00        		.byte	0
 3494 0307 00        		.byte	0
 3495 0308 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 197


 3496 0309 00        		.byte	0
 3497 030a 00        		.byte	0
 3498 030b 1F        		.byte	31
 3499 030c 00        		.byte	0
 3500 030d 00        		.byte	0
 3501 030e 0E        		.byte	14
 3502 030f 00        		.byte	0
 3503 0310 00        		.byte	0
 3504 0311 00        		.byte	0
 3505 0312 00        		.byte	0
 3506 0313 00        		.byte	0
 3507 0314 0F        		.byte	15
 3508 0315 78        		.byte	120
 3509 0316 00        		.byte	0
 3510 0317 00        		.byte	0
 3511 0318 00        		.byte	0
 3512 0319 00        		.byte	0
 3513 031a 00        		.byte	0
 3514 031b 00        		.byte	0
 3515 031c 00        		.byte	0
 3516 031d 1F        		.byte	31
 3517 031e 00        		.byte	0
 3518 031f 00        		.byte	0
 3519 0320 00        		.byte	0
 3520 0321 00        		.byte	0
 3521 0322 00        		.byte	0
 3522 0323 F4        		.byte	-12
 3523               	.global	pieceNum
 3524               	.global	pieceNum
 3525               		.section .bss
 3526               		.type	pieceNum, @object
 3527               		.size	pieceNum, 1
 3528               	pieceNum:
 3529 0000 00        		.skip 1,0
 3530               	.global	pieceOrientation
 3531               	.global	pieceOrientation
 3532               		.type	pieceOrientation, @object
 3533               		.size	pieceOrientation, 1
 3534               	pieceOrientation:
 3535 0001 00        		.skip 1,0
 3536               	.global	pieceTopRow
 3537               	.global	pieceTopRow
 3538               		.type	pieceTopRow, @object
 3539               		.size	pieceTopRow, 1
 3540               	pieceTopRow:
 3541 0002 00        		.skip 1,0
 3542               	.global	pieceLeftCol
 3543               	.global	pieceLeftCol
 3544               		.type	pieceLeftCol, @object
 3545               		.size	pieceLeftCol, 1
 3546               	pieceLeftCol:
 3547 0003 00        		.skip 1,0
 3548               	.global	tetColorScheme
 3549               	.global	tetColorScheme
 3550               		.type	tetColorScheme, @object
 3551               		.size	tetColorScheme, 1
 3552               	tetColorScheme:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 198


 3553 0004 00        		.skip 1,0
 3554               	.global	pgm_tetPiece
 3555               		.section	.progmem.data
 3556               		.type	pgm_tetPiece, @object
 3557               		.size	pgm_tetPiece, 56
 3558               	pgm_tetPiece:
 3559 0324 F000      		.word	240
 3560 0326 2222      		.word	8738
 3561 0328 F000      		.word	240
 3562 032a 2222      		.word	8738
 3563 032c 600C      		.word	3168
 3564 032e 6402      		.word	612
 3565 0330 600C      		.word	3168
 3566 0332 6402      		.word	612
 3567 0334 C006      		.word	1728
 3568 0336 408C      		.word	-29632
 3569 0338 C006      		.word	1728
 3570 033a 408C      		.word	-29632
 3571 033c E004      		.word	1248
 3572 033e C404      		.word	1220
 3573 0340 E400      		.word	228
 3574 0342 6404      		.word	1124
 3575 0344 E008      		.word	2272
 3576 0346 4C04      		.word	1100
 3577 0348 E200      		.word	226
 3578 034a 4406      		.word	1604
 3579 034c E002      		.word	736
 3580 034e 440C      		.word	3140
 3581 0350 E800      		.word	232
 3582 0352 4604      		.word	1094
 3583 0354 6006      		.word	1632
 3584 0356 6006      		.word	1632
 3585 0358 6006      		.word	1632
 3586 035a 6006      		.word	1632
 3587               	.global	segPosition
 3588               	.global	segPosition
 3589               		.section .bss
 3590               		.type	segPosition, @object
 3591               		.size	segPosition, 1
 3592               	segPosition:
 3593 0005 00        		.skip 1,0
 3594               	.global	dataEnable
 3595               	.global	dataEnable
 3596               		.type	dataEnable, @object
 3597               		.size	dataEnable, 1
 3598               	dataEnable:
 3599 0006 00        		.skip 1,0
 3600               	.global	vSync
 3601               	.global	vSync
 3602               		.type	vSync, @object
 3603               		.size	vSync, 1
 3604               	vSync:
 3605 0007 00        		.skip 1,0
 3606               	.global	hsyncCount
 3607               	.global	hsyncCount
 3608               		.type	hsyncCount, @object
 3609               		.size	hsyncCount, 2
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 199


 3610               	hsyncCount:
 3611 0008 0000      		.skip 2,0
 3612               	.global	frameCount
 3613               	.global	frameCount
 3614               		.type	frameCount, @object
 3615               		.size	frameCount, 1
 3616               	frameCount:
 3617 000a 00        		.skip 1,0
 3618               	.global	pgm_image1
 3619               		.section	.progmem.data
 3620               		.type	pgm_image1, @object
 3621               		.size	pgm_image1, 256
 3622               	pgm_image1:
 3623 035c C0        		.byte	-64
 3624 035d C0        		.byte	-64
 3625 035e C0        		.byte	-64
 3626 035f C0        		.byte	-64
 3627 0360 C0        		.byte	-64
 3628 0361 00        		.byte	0
 3629 0362 00        		.byte	0
 3630 0363 00        		.byte	0
 3631 0364 00        		.byte	0
 3632 0365 00        		.byte	0
 3633 0366 00        		.byte	0
 3634 0367 C0        		.byte	-64
 3635 0368 C0        		.byte	-64
 3636 0369 C0        		.byte	-64
 3637 036a C0        		.byte	-64
 3638 036b C0        		.byte	-64
 3639 036c C0        		.byte	-64
 3640 036d C0        		.byte	-64
 3641 036e C0        		.byte	-64
 3642 036f 00        		.byte	0
 3643 0370 00        		.byte	0
 3644 0371 0F        		.byte	15
 3645 0372 0F        		.byte	15
 3646 0373 0F        		.byte	15
 3647 0374 0F        		.byte	15
 3648 0375 0F        		.byte	15
 3649 0376 0F        		.byte	15
 3650 0377 00        		.byte	0
 3651 0378 00        		.byte	0
 3652 0379 C0        		.byte	-64
 3653 037a C0        		.byte	-64
 3654 037b C0        		.byte	-64
 3655 037c C0        		.byte	-64
 3656 037d C0        		.byte	-64
 3657 037e 00        		.byte	0
 3658 037f 00        		.byte	0
 3659 0380 0F        		.byte	15
 3660 0381 0F        		.byte	15
 3661 0382 0F        		.byte	15
 3662 0383 0F        		.byte	15
 3663 0384 0F        		.byte	15
 3664 0385 0F        		.byte	15
 3665 0386 0F        		.byte	15
 3666 0387 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 200


 3667 0388 00        		.byte	0
 3668 0389 00        		.byte	0
 3669 038a C0        		.byte	-64
 3670 038b C0        		.byte	-64
 3671 038c C0        		.byte	-64
 3672 038d 00        		.byte	0
 3673 038e 00        		.byte	0
 3674 038f 0F        		.byte	15
 3675 0390 0F        		.byte	15
 3676 0391 0F        		.byte	15
 3677 0392 0F        		.byte	15
 3678 0393 0F        		.byte	15
 3679 0394 0F        		.byte	15
 3680 0395 0F        		.byte	15
 3681 0396 0F        		.byte	15
 3682 0397 0F        		.byte	15
 3683 0398 0F        		.byte	15
 3684 0399 00        		.byte	0
 3685 039a 00        		.byte	0
 3686 039b C0        		.byte	-64
 3687 039c C0        		.byte	-64
 3688 039d 00        		.byte	0
 3689 039e 0F        		.byte	15
 3690 039f 0F        		.byte	15
 3691 03a0 0F        		.byte	15
 3692 03a1 00        		.byte	0
 3693 03a2 0F        		.byte	15
 3694 03a3 0F        		.byte	15
 3695 03a4 0F        		.byte	15
 3696 03a5 0F        		.byte	15
 3697 03a6 00        		.byte	0
 3698 03a7 0F        		.byte	15
 3699 03a8 0F        		.byte	15
 3700 03a9 0F        		.byte	15
 3701 03aa 00        		.byte	0
 3702 03ab C0        		.byte	-64
 3703 03ac 00        		.byte	0
 3704 03ad 0F        		.byte	15
 3705 03ae 0F        		.byte	15
 3706 03af 0F        		.byte	15
 3707 03b0 00        		.byte	0
 3708 03b1 00        		.byte	0
 3709 03b2 00        		.byte	0
 3710 03b3 0F        		.byte	15
 3711 03b4 0F        		.byte	15
 3712 03b5 00        		.byte	0
 3713 03b6 00        		.byte	0
 3714 03b7 00        		.byte	0
 3715 03b8 0F        		.byte	15
 3716 03b9 0F        		.byte	15
 3717 03ba 0F        		.byte	15
 3718 03bb 00        		.byte	0
 3719 03bc 00        		.byte	0
 3720 03bd 0F        		.byte	15
 3721 03be 0F        		.byte	15
 3722 03bf 0F        		.byte	15
 3723 03c0 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 201


 3724 03c1 00        		.byte	0
 3725 03c2 0F        		.byte	15
 3726 03c3 0F        		.byte	15
 3727 03c4 0F        		.byte	15
 3728 03c5 0F        		.byte	15
 3729 03c6 00        		.byte	0
 3730 03c7 0F        		.byte	15
 3731 03c8 0F        		.byte	15
 3732 03c9 0F        		.byte	15
 3733 03ca 0F        		.byte	15
 3734 03cb 00        		.byte	0
 3735 03cc 00        		.byte	0
 3736 03cd 0F        		.byte	15
 3737 03ce 0F        		.byte	15
 3738 03cf 0F        		.byte	15
 3739 03d0 0F        		.byte	15
 3740 03d1 0F        		.byte	15
 3741 03d2 0F        		.byte	15
 3742 03d3 0F        		.byte	15
 3743 03d4 0F        		.byte	15
 3744 03d5 0F        		.byte	15
 3745 03d6 0F        		.byte	15
 3746 03d7 0F        		.byte	15
 3747 03d8 0F        		.byte	15
 3748 03d9 0F        		.byte	15
 3749 03da 0F        		.byte	15
 3750 03db 00        		.byte	0
 3751 03dc 00        		.byte	0
 3752 03dd 0F        		.byte	15
 3753 03de 0F        		.byte	15
 3754 03df 0F        		.byte	15
 3755 03e0 0F        		.byte	15
 3756 03e1 0F        		.byte	15
 3757 03e2 0F        		.byte	15
 3758 03e3 0F        		.byte	15
 3759 03e4 0F        		.byte	15
 3760 03e5 0F        		.byte	15
 3761 03e6 0F        		.byte	15
 3762 03e7 0F        		.byte	15
 3763 03e8 0F        		.byte	15
 3764 03e9 0F        		.byte	15
 3765 03ea 0F        		.byte	15
 3766 03eb 00        		.byte	0
 3767 03ec 00        		.byte	0
 3768 03ed 0F        		.byte	15
 3769 03ee 0F        		.byte	15
 3770 03ef 00        		.byte	0
 3771 03f0 00        		.byte	0
 3772 03f1 0F        		.byte	15
 3773 03f2 0F        		.byte	15
 3774 03f3 0F        		.byte	15
 3775 03f4 0F        		.byte	15
 3776 03f5 0F        		.byte	15
 3777 03f6 0F        		.byte	15
 3778 03f7 00        		.byte	0
 3779 03f8 00        		.byte	0
 3780 03f9 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 202


 3781 03fa 0F        		.byte	15
 3782 03fb 00        		.byte	0
 3783 03fc 00        		.byte	0
 3784 03fd 0F        		.byte	15
 3785 03fe 0F        		.byte	15
 3786 03ff 0F        		.byte	15
 3787 0400 00        		.byte	0
 3788 0401 00        		.byte	0
 3789 0402 0F        		.byte	15
 3790 0403 0F        		.byte	15
 3791 0404 0F        		.byte	15
 3792 0405 0F        		.byte	15
 3793 0406 00        		.byte	0
 3794 0407 00        		.byte	0
 3795 0408 0F        		.byte	15
 3796 0409 0F        		.byte	15
 3797 040a 0F        		.byte	15
 3798 040b 00        		.byte	0
 3799 040c C0        		.byte	-64
 3800 040d 00        		.byte	0
 3801 040e 0F        		.byte	15
 3802 040f 0F        		.byte	15
 3803 0410 0F        		.byte	15
 3804 0411 00        		.byte	0
 3805 0412 00        		.byte	0
 3806 0413 00        		.byte	0
 3807 0414 00        		.byte	0
 3808 0415 00        		.byte	0
 3809 0416 00        		.byte	0
 3810 0417 0F        		.byte	15
 3811 0418 0F        		.byte	15
 3812 0419 0F        		.byte	15
 3813 041a 00        		.byte	0
 3814 041b C0        		.byte	-64
 3815 041c C0        		.byte	-64
 3816 041d 00        		.byte	0
 3817 041e 00        		.byte	0
 3818 041f 0F        		.byte	15
 3819 0420 0F        		.byte	15
 3820 0421 0F        		.byte	15
 3821 0422 0F        		.byte	15
 3822 0423 0F        		.byte	15
 3823 0424 0F        		.byte	15
 3824 0425 0F        		.byte	15
 3825 0426 0F        		.byte	15
 3826 0427 0F        		.byte	15
 3827 0428 0F        		.byte	15
 3828 0429 00        		.byte	0
 3829 042a 00        		.byte	0
 3830 042b C0        		.byte	-64
 3831 042c C0        		.byte	-64
 3832 042d C0        		.byte	-64
 3833 042e 00        		.byte	0
 3834 042f 00        		.byte	0
 3835 0430 0F        		.byte	15
 3836 0431 0F        		.byte	15
 3837 0432 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 203


 3838 0433 0F        		.byte	15
 3839 0434 0F        		.byte	15
 3840 0435 0F        		.byte	15
 3841 0436 0F        		.byte	15
 3842 0437 0F        		.byte	15
 3843 0438 00        		.byte	0
 3844 0439 00        		.byte	0
 3845 043a C0        		.byte	-64
 3846 043b C0        		.byte	-64
 3847 043c C0        		.byte	-64
 3848 043d C0        		.byte	-64
 3849 043e C0        		.byte	-64
 3850 043f 00        		.byte	0
 3851 0440 00        		.byte	0
 3852 0441 0F        		.byte	15
 3853 0442 0F        		.byte	15
 3854 0443 0F        		.byte	15
 3855 0444 0F        		.byte	15
 3856 0445 0F        		.byte	15
 3857 0446 0F        		.byte	15
 3858 0447 00        		.byte	0
 3859 0448 00        		.byte	0
 3860 0449 C0        		.byte	-64
 3861 044a C0        		.byte	-64
 3862 044b C0        		.byte	-64
 3863 044c C0        		.byte	-64
 3864 044d C0        		.byte	-64
 3865 044e C0        		.byte	-64
 3866 044f C0        		.byte	-64
 3867 0450 C0        		.byte	-64
 3868 0451 00        		.byte	0
 3869 0452 00        		.byte	0
 3870 0453 00        		.byte	0
 3871 0454 00        		.byte	0
 3872 0455 00        		.byte	0
 3873 0456 00        		.byte	0
 3874 0457 C0        		.byte	-64
 3875 0458 C0        		.byte	-64
 3876 0459 C0        		.byte	-64
 3877 045a C0        		.byte	-64
 3878 045b C0        		.byte	-64
 3879               	.global	pgm_image2
 3880               		.type	pgm_image2, @object
 3881               		.size	pgm_image2, 256
 3882               	pgm_image2:
 3883 045c C0        		.byte	-64
 3884 045d C0        		.byte	-64
 3885 045e C0        		.byte	-64
 3886 045f C0        		.byte	-64
 3887 0460 C0        		.byte	-64
 3888 0461 00        		.byte	0
 3889 0462 00        		.byte	0
 3890 0463 00        		.byte	0
 3891 0464 00        		.byte	0
 3892 0465 00        		.byte	0
 3893 0466 00        		.byte	0
 3894 0467 C0        		.byte	-64
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 204


 3895 0468 C0        		.byte	-64
 3896 0469 C0        		.byte	-64
 3897 046a C0        		.byte	-64
 3898 046b C0        		.byte	-64
 3899 046c C0        		.byte	-64
 3900 046d C0        		.byte	-64
 3901 046e C0        		.byte	-64
 3902 046f 00        		.byte	0
 3903 0470 00        		.byte	0
 3904 0471 0F        		.byte	15
 3905 0472 0F        		.byte	15
 3906 0473 0F        		.byte	15
 3907 0474 0F        		.byte	15
 3908 0475 0F        		.byte	15
 3909 0476 0F        		.byte	15
 3910 0477 00        		.byte	0
 3911 0478 00        		.byte	0
 3912 0479 C0        		.byte	-64
 3913 047a C0        		.byte	-64
 3914 047b C0        		.byte	-64
 3915 047c C0        		.byte	-64
 3916 047d C0        		.byte	-64
 3917 047e 00        		.byte	0
 3918 047f 00        		.byte	0
 3919 0480 0F        		.byte	15
 3920 0481 0F        		.byte	15
 3921 0482 0F        		.byte	15
 3922 0483 0F        		.byte	15
 3923 0484 0F        		.byte	15
 3924 0485 0F        		.byte	15
 3925 0486 0F        		.byte	15
 3926 0487 0F        		.byte	15
 3927 0488 00        		.byte	0
 3928 0489 00        		.byte	0
 3929 048a C0        		.byte	-64
 3930 048b C0        		.byte	-64
 3931 048c C0        		.byte	-64
 3932 048d 00        		.byte	0
 3933 048e 00        		.byte	0
 3934 048f 0F        		.byte	15
 3935 0490 0F        		.byte	15
 3936 0491 0F        		.byte	15
 3937 0492 0F        		.byte	15
 3938 0493 0F        		.byte	15
 3939 0494 0F        		.byte	15
 3940 0495 0F        		.byte	15
 3941 0496 0F        		.byte	15
 3942 0497 0F        		.byte	15
 3943 0498 0F        		.byte	15
 3944 0499 00        		.byte	0
 3945 049a 00        		.byte	0
 3946 049b C0        		.byte	-64
 3947 049c C0        		.byte	-64
 3948 049d 00        		.byte	0
 3949 049e 0F        		.byte	15
 3950 049f 0F        		.byte	15
 3951 04a0 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 205


 3952 04a1 00        		.byte	0
 3953 04a2 0F        		.byte	15
 3954 04a3 0F        		.byte	15
 3955 04a4 0F        		.byte	15
 3956 04a5 0F        		.byte	15
 3957 04a6 0F        		.byte	15
 3958 04a7 0F        		.byte	15
 3959 04a8 0F        		.byte	15
 3960 04a9 0F        		.byte	15
 3961 04aa 00        		.byte	0
 3962 04ab C0        		.byte	-64
 3963 04ac 00        		.byte	0
 3964 04ad 0F        		.byte	15
 3965 04ae 0F        		.byte	15
 3966 04af 0F        		.byte	15
 3967 04b0 00        		.byte	0
 3968 04b1 00        		.byte	0
 3969 04b2 00        		.byte	0
 3970 04b3 0F        		.byte	15
 3971 04b4 0F        		.byte	15
 3972 04b5 00        		.byte	0
 3973 04b6 0F        		.byte	15
 3974 04b7 0F        		.byte	15
 3975 04b8 0F        		.byte	15
 3976 04b9 0F        		.byte	15
 3977 04ba 0F        		.byte	15
 3978 04bb 00        		.byte	0
 3979 04bc 00        		.byte	0
 3980 04bd 0F        		.byte	15
 3981 04be 0F        		.byte	15
 3982 04bf 0F        		.byte	15
 3983 04c0 0F        		.byte	15
 3984 04c1 00        		.byte	0
 3985 04c2 0F        		.byte	15
 3986 04c3 0F        		.byte	15
 3987 04c4 0F        		.byte	15
 3988 04c5 0F        		.byte	15
 3989 04c6 00        		.byte	0
 3990 04c7 00        		.byte	0
 3991 04c8 0F        		.byte	15
 3992 04c9 0F        		.byte	15
 3993 04ca 0F        		.byte	15
 3994 04cb 00        		.byte	0
 3995 04cc 00        		.byte	0
 3996 04cd 0F        		.byte	15
 3997 04ce 0F        		.byte	15
 3998 04cf 0F        		.byte	15
 3999 04d0 0F        		.byte	15
 4000 04d1 0F        		.byte	15
 4001 04d2 0F        		.byte	15
 4002 04d3 0F        		.byte	15
 4003 04d4 0F        		.byte	15
 4004 04d5 0F        		.byte	15
 4005 04d6 0F        		.byte	15
 4006 04d7 0F        		.byte	15
 4007 04d8 0F        		.byte	15
 4008 04d9 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 206


 4009 04da 0F        		.byte	15
 4010 04db 00        		.byte	0
 4011 04dc 00        		.byte	0
 4012 04dd 0F        		.byte	15
 4013 04de 0F        		.byte	15
 4014 04df 0F        		.byte	15
 4015 04e0 0F        		.byte	15
 4016 04e1 0F        		.byte	15
 4017 04e2 0F        		.byte	15
 4018 04e3 0F        		.byte	15
 4019 04e4 0F        		.byte	15
 4020 04e5 0F        		.byte	15
 4021 04e6 0F        		.byte	15
 4022 04e7 0F        		.byte	15
 4023 04e8 0F        		.byte	15
 4024 04e9 0F        		.byte	15
 4025 04ea 0F        		.byte	15
 4026 04eb 00        		.byte	0
 4027 04ec 00        		.byte	0
 4028 04ed 0F        		.byte	15
 4029 04ee 0F        		.byte	15
 4030 04ef 00        		.byte	0
 4031 04f0 00        		.byte	0
 4032 04f1 0F        		.byte	15
 4033 04f2 0F        		.byte	15
 4034 04f3 0F        		.byte	15
 4035 04f4 0F        		.byte	15
 4036 04f5 0F        		.byte	15
 4037 04f6 0F        		.byte	15
 4038 04f7 00        		.byte	0
 4039 04f8 00        		.byte	0
 4040 04f9 0F        		.byte	15
 4041 04fa 0F        		.byte	15
 4042 04fb 00        		.byte	0
 4043 04fc 00        		.byte	0
 4044 04fd 0F        		.byte	15
 4045 04fe 0F        		.byte	15
 4046 04ff 0F        		.byte	15
 4047 0500 00        		.byte	0
 4048 0501 00        		.byte	0
 4049 0502 0F        		.byte	15
 4050 0503 0F        		.byte	15
 4051 0504 0F        		.byte	15
 4052 0505 0F        		.byte	15
 4053 0506 00        		.byte	0
 4054 0507 00        		.byte	0
 4055 0508 0F        		.byte	15
 4056 0509 0F        		.byte	15
 4057 050a 0F        		.byte	15
 4058 050b 00        		.byte	0
 4059 050c C0        		.byte	-64
 4060 050d 00        		.byte	0
 4061 050e 0F        		.byte	15
 4062 050f 0F        		.byte	15
 4063 0510 0F        		.byte	15
 4064 0511 00        		.byte	0
 4065 0512 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 207


 4066 0513 00        		.byte	0
 4067 0514 00        		.byte	0
 4068 0515 00        		.byte	0
 4069 0516 00        		.byte	0
 4070 0517 0F        		.byte	15
 4071 0518 0F        		.byte	15
 4072 0519 0F        		.byte	15
 4073 051a 00        		.byte	0
 4074 051b C0        		.byte	-64
 4075 051c C0        		.byte	-64
 4076 051d 00        		.byte	0
 4077 051e 00        		.byte	0
 4078 051f 0F        		.byte	15
 4079 0520 0F        		.byte	15
 4080 0521 0F        		.byte	15
 4081 0522 00        		.byte	0
 4082 0523 03        		.byte	3
 4083 0524 00        		.byte	0
 4084 0525 03        		.byte	3
 4085 0526 00        		.byte	0
 4086 0527 0F        		.byte	15
 4087 0528 0F        		.byte	15
 4088 0529 00        		.byte	0
 4089 052a 00        		.byte	0
 4090 052b C0        		.byte	-64
 4091 052c C0        		.byte	-64
 4092 052d C0        		.byte	-64
 4093 052e 00        		.byte	0
 4094 052f 00        		.byte	0
 4095 0530 0F        		.byte	15
 4096 0531 0F        		.byte	15
 4097 0532 00        		.byte	0
 4098 0533 03        		.byte	3
 4099 0534 03        		.byte	3
 4100 0535 03        		.byte	3
 4101 0536 00        		.byte	0
 4102 0537 0F        		.byte	15
 4103 0538 00        		.byte	0
 4104 0539 00        		.byte	0
 4105 053a C0        		.byte	-64
 4106 053b C0        		.byte	-64
 4107 053c C0        		.byte	-64
 4108 053d C0        		.byte	-64
 4109 053e C0        		.byte	-64
 4110 053f 00        		.byte	0
 4111 0540 00        		.byte	0
 4112 0541 0F        		.byte	15
 4113 0542 0F        		.byte	15
 4114 0543 00        		.byte	0
 4115 0544 00        		.byte	0
 4116 0545 00        		.byte	0
 4117 0546 0F        		.byte	15
 4118 0547 00        		.byte	0
 4119 0548 00        		.byte	0
 4120 0549 C0        		.byte	-64
 4121 054a C0        		.byte	-64
 4122 054b C0        		.byte	-64
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 208


 4123 054c C0        		.byte	-64
 4124 054d C0        		.byte	-64
 4125 054e C0        		.byte	-64
 4126 054f C0        		.byte	-64
 4127 0550 C0        		.byte	-64
 4128 0551 00        		.byte	0
 4129 0552 00        		.byte	0
 4130 0553 00        		.byte	0
 4131 0554 00        		.byte	0
 4132 0555 00        		.byte	0
 4133 0556 00        		.byte	0
 4134 0557 C0        		.byte	-64
 4135 0558 C0        		.byte	-64
 4136 0559 C0        		.byte	-64
 4137 055a C0        		.byte	-64
 4138 055b C0        		.byte	-64
 4139               		.lcomm frameCount.2279,1
 4140               		.type	__c.2313, @object
 4141               		.size	__c.2313, 49
 4142               	__c.2313:
 4143 055c 2054 6865 		.string	" The Quick Brown Fox Jumped Over The Lazy Dog! \177"
 4143      2051 7569 
 4143      636B 2042 
 4143      726F 776E 
 4143      2046 6F78 
 4144               		.lcomm frameCount.2295,1
 4145               		.lcomm lastThetaOffset.2294,2
 4146               		.lcomm last_rbValue.2029,1
 4147               		.lcomm newPieceHitCount.1827,1
 4148               		.lcomm callCount.1826,1
 4149               		.comm tetRow,72,1
 4150               		.comm rowSegBuffer,138,1
 4151               		.comm rowBuffer,64,1
 4152               		.comm pimage,2,1
 4153               		.data
 4154               		.type	CSWTCH.58, @object
 4155               		.size	CSWTCH.58, 7
 4156               	CSWTCH.58:
 4157 0000 03        		.byte	3
 4158 0001 07        		.byte	7
 4159 0002 0F        		.byte	15
 4160 0003 0C        		.byte	12
 4161 0004 3C        		.byte	60
 4162 0005 30        		.byte	48
 4163 0006 33        		.byte	51
 4164               		.type	CSWTCH.61, @object
 4165               		.size	CSWTCH.61, 7
 4166               	CSWTCH.61:
 4167 0007 01        		.byte	1
 4168 0008 04        		.byte	4
 4169 0009 10        		.byte	16
 4170 000a 14        		.byte	20
 4171 000b 11        		.byte	17
 4172 000c 05        		.byte	5
 4173 000d 15        		.byte	21
 4174               		.stabs	"header:G(0,16)=ar(0,17)=r(0,17);0;0177777;;0;35;(3,2)",32,0,16,0
 4175               		.stabs	"characters:G(0,18)=ar(0,17);0;7;(0,19)=ar(0,17);0;95;(3,2)",32,0,30,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 209


 4176               		.stabs	"pgm_tetPiece:G(0,20)=ar(0,17);0;6;(0,21)=ar(0,17);0;3;(3,4)",32,0,488,0
 4177               		.stabs	"tetRow:G(0,22)=ar(0,17);0;17;(3,6)",32,0,52,0
 4178               		.stabs	"pieceNum:G(3,2)",32,0,91,0
 4179               		.stabs	"pieceOrientation:G(3,2)",32,0,92,0
 4180               		.stabs	"pieceTopRow:G(3,2)",32,0,94,0
 4181               		.stabs	"pieceLeftCol:G(3,2)",32,0,95,0
 4182               		.stabs	"tetColorScheme:G(3,2)",32,0,414,0
 4183               		.stabs	"rowSegBuffer:G(0,23)=ar(0,17);0;68;(13,2)",32,0,108,0
 4184               		.stabs	"segPosition:G(3,2)",32,0,153,0
 4185               		.stabs	"rowBuffer:G(0,24)=ar(0,17);0;63;(3,2)",32,0,81,0
 4186               		.stabs	"pimage:G(0,25)=*(3,2)",32,0,2078,0
 4187               		.stabs	"dataEnable:G(3,2)",32,0,1141,0
 4188               		.stabs	"vSync:G(3,2)",32,0,1142,0
 4189               		.stabs	"hsyncCount:G(3,4)",32,0,1143,0
 4190               		.stabs	"frameCount:G(3,2)",32,0,1148,0
 4191               		.stabs	"pgm_image1:G(0,26)=ar(0,17);0;255;(3,2)",32,0,4051,0
 4192               		.stabs	"pgm_image2:G(0,26)",32,0,4117,0
 4193               		.text
 4194               		.stabs	"",100,0,0,.Letext0
 4195               	.Letext0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 210


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:2      *ABS*:0000003f __SREG__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3      *ABS*:0000003e __SP_H__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4      *ABS*:0000003d __SP_L__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:6      *ABS*:00000001 __zero_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:114    .text:00000000 getTetBrick
                            *COM*:00000048 tetRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:165    .text:00000036 setTetBrick
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:249    .text:000000b2 tetInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:319    .text:000000f0 tetUpdate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4146   .bss:00000010 newPieceHitCount.1827
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3534   .bss:00000001 pieceOrientation
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3546   .bss:00000003 pieceLeftCol
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3540   .bss:00000002 pieceTopRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4147   .bss:00000011 callCount.1826
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3528   .bss:00000000 pieceNum
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3558   .progmem.data:00000324 pgm_tetPiece
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:752    .text:00000340 tetBrick_to_fb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3552   .bss:00000004 tetColorScheme
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4156   .data:00000000 CSWTCH.58
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4166   .data:00000007 CSWTCH.61
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:805    .text:00000370 segClear
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3592   .bss:00000005 segPosition
                            *COM*:0000008a rowSegBuffer
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:836    .text:00000382 segTerminate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:913    .text:000003da newSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1033   .text:0000045a stretchSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1137   .text:000004b8 addSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1194   .text:000004ee rbpix_to_seg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4145   .bss:0000000f last_rbValue.2029
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1286   .text:00000554 fb_to_rb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1343   .text:00000592 pll_enable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1417   .text:000005b2 lvds_timerInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1507   .text:00000600 lcd_Init
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1533   .text:0000060a updateLCD
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3598   .bss:00000006 dataEnable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3604   .bss:00000007 vSync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1656   .text:0000064a LoadNext_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1692   .text:0000068e Done_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1672   .text:00000668 Counter_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3610   .bss:00000008 hsyncCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1815   .text:0000070c init_timer0Hsync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1855   .text:00000726 main
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3616   .bss:0000000a frameCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:1898   .text:00000746 __vector_14
                             .bss:0000000b frameCount.2279
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4144   .bss:0000000d lastThetaOffset.2294
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4139   .bss:0000000c frameCount.2295
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:2754   .progmem.data:00000024 characters
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:4142   .progmem.data:0000055c __c.2313
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:2749   .progmem.data:00000000 header
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3622   .progmem.data:0000035c pgm_image1
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s:3882   .progmem.data:0000045c pgm_image2
                            *COM*:00000040 rowBuffer
                            *COM*:00000002 pimage
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccvEp5Jj.s 			page 211



UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulhi3
timer_setWGM
timer_selectDivisor
timer_compareMatchIntSetup
sineRaw8
__udivmodhi4
strncpy_P
strlen_P
