GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 1


   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.stabs	"/Users/meh/_avrProjects/LCDdirectLVDS/59-reallyCommon2/",100,0,2,.Ltext0
  10               		.stabs	"main.c",100,0,2,.Ltext0
  11               		.text
  12               	.Ltext0:
  13               		.stabs	"gcc2_compiled.",60,0,0,0
  14               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  15               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  16               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  17               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  18               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  19               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  20               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  21               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  22               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  23               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  24               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  25               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  26               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  29               		.stabs	"projInfo.h",130,0,0,0
  30               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdint.h",130,0,0,0
  32               		.stabs	"int8_t:t(3,1)=(0,10)",128,0,121,0
  33               		.stabs	"uint8_t:t(3,2)=(0,11)",128,0,122,0
  34               		.stabs	"int16_t:t(3,3)=(0,1)",128,0,123,0
  35               		.stabs	"uint16_t:t(3,4)=(0,4)",128,0,124,0
  36               		.stabs	"int32_t:t(3,5)=(0,3)",128,0,125,0
  37               		.stabs	"uint32_t:t(3,6)=(0,5)",128,0,126,0
  38               		.stabs	"int64_t:t(3,7)=(0,6)",128,0,128,0
  39               		.stabs	"uint64_t:t(3,8)=(0,7)",128,0,129,0
  40               		.stabs	"intptr_t:t(3,9)=(3,3)",128,0,142,0
  41               		.stabs	"uintptr_t:t(3,10)=(3,4)",128,0,147,0
  42               		.stabs	"int_least8_t:t(3,11)=(3,1)",128,0,159,0
  43               		.stabs	"uint_least8_t:t(3,12)=(3,2)",128,0,164,0
  44               		.stabs	"int_least16_t:t(3,13)=(3,3)",128,0,169,0
  45               		.stabs	"uint_least16_t:t(3,14)=(3,4)",128,0,174,0
  46               		.stabs	"int_least32_t:t(3,15)=(3,5)",128,0,179,0
  47               		.stabs	"uint_least32_t:t(3,16)=(3,6)",128,0,184,0
  48               		.stabs	"int_least64_t:t(3,17)=(3,7)",128,0,192,0
  49               		.stabs	"uint_least64_t:t(3,18)=(3,8)",128,0,199,0
  50               		.stabs	"int_fast8_t:t(3,19)=(3,1)",128,0,213,0
  51               		.stabs	"uint_fast8_t:t(3,20)=(3,2)",128,0,218,0
  52               		.stabs	"int_fast16_t:t(3,21)=(3,3)",128,0,223,0
  53               		.stabs	"uint_fast16_t:t(3,22)=(3,4)",128,0,228,0
  54               		.stabs	"int_fast32_t:t(3,23)=(3,5)",128,0,233,0
  55               		.stabs	"uint_fast32_t:t(3,24)=(3,6)",128,0,238,0
  56               		.stabs	"int_fast64_t:t(3,25)=(3,7)",128,0,246,0
  57               		.stabs	"uint_fast64_t:t(3,26)=(3,8)",128,0,253,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 2


  58               		.stabs	"intmax_t:t(3,27)=(3,7)",128,0,273,0
  59               		.stabs	"uintmax_t:t(3,28)=(3,8)",128,0,278,0
  60               		.stabn	162,0,0,0
  61               		.stabs	"int_farptr_t:t(2,1)=(3,5)",128,0,77,0
  62               		.stabs	"uint_farptr_t:t(2,2)=(3,6)",128,0,81,0
  63               		.stabn	162,0,0,0
  64               		.stabn	162,0,0,0
  65               		.stabs	"main.h",130,0,0,0
  66               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/io.h",130,0,0,0
  67               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdlib.h",130,0,0,0
  72               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/include/stddef.h",130,0,0,0
  73               		.stabs	"size_t:t(8,1)=(0,4)",128,0,211,0
  74               		.stabs	"wchar_t:t(8,2)=(0,1)",128,0,323,0
  75               		.stabn	162,0,0,0
  76               		.stabs	"div_t:t(7,1)=(7,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,71,0
  77               		.stabs	"ldiv_t:t(7,3)=(7,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,77,0
  78               		.stabs	"__compar_fn_t:t(7,5)=(7,6)=*(7,7)=f(0,1)",128,0,80,0
  79               		.stabn	162,0,0,0
  80               		.stabs	"_commonCode_localized/heartbeat/1.21/heartbeat.h",130,0,0,0
  81               		.stabs	"./_commonCode_localized/hfModulation/0.93/hfModulation.h",130,0,0,0
  82               		.stabs	"hfm_t:t(10,1)=(10,2)=B(10,3)=s6runningSum:(3,4),0,16;desiredSum:(3,4),16,16;maxPower:(3,2)
  83               		.stabn	162,0,0,0
  84               		.stabn	162,0,0,0
  85               		.stabn	162,0,0,0
  86               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  87               		.stabs	"prog_void:t(11,1)=(11,2)=(11,2)",128,0,217,0
  88               		.stabs	"prog_char:t(11,3)=(11,4)=@s8;r(11,4);0;255;",128,0,218,0
  89               		.stabs	"prog_uchar:t(11,5)=(11,6)=@s8;r(11,6);0;255;",128,0,219,0
  90               		.stabs	"prog_int8_t:t(11,7)=(11,8)=(0,10)",128,0,221,0
  91               		.stabs	"prog_uint8_t:t(11,9)=(11,10)=(0,11)",128,0,222,0
  92               		.stabs	"prog_int16_t:t(11,11)=(11,12)=(0,1)",128,0,223,0
  93               		.stabs	"prog_uint16_t:t(11,13)=(11,14)=(0,4)",128,0,224,0
  94               		.stabs	"prog_int32_t:t(11,15)=(11,16)=(0,3)",128,0,225,0
  95               		.stabs	"prog_uint32_t:t(11,17)=(11,18)=(0,5)",128,0,226,0
  96               		.stabs	"prog_int64_t:t(11,19)=(11,20)=(0,6)",128,0,228,0
  97               		.stabs	"prog_uint64_t:t(11,21)=(11,22)=(0,7)",128,0,229,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"_commonCode_localized/sineTable/0.99/sineTable.h",130,0,0,0
 100               		.stabs	"theta_t:t(12,1)=(3,3)",128,0,69,0
 101               		.stabs	"sine_t:t(12,2)=(3,3)",128,0,96,0
 102               		.stabs	"mult_t:t(12,3)=(3,5)",128,0,99,0
 103               		.stabs	"axis_t:t(12,4)=(3,5)",128,0,114,0
 104               		.stabn	162,0,0,0
 105               		.stabs	"rowSegBuffer.c",130,0,0,0
 106               		.stabs	"_NONAME_:T(13,1)=s2red_length:(3,2),0,8;green_blue:(3,2),8,8;;",128,0,0,0
 107               		.stabs	"seg_t:t(13,2)=(13,1)",128,0,103,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"getTetBrick:F(3,2)",36,0,393,getTetBrick
 110               		.stabs	"row:P(3,2)",64,0,393,24
 111               		.stabs	"col:P(3,2)",64,0,393,22
 112               	.global	getTetBrick
 113               		.type	getTetBrick, @function
 114               	getTetBrick:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 3


 115               		.stabd	46,0,0
 116               		.stabs	"tetStuff.c",132,0,0,.Ltext1
 117               	.Ltext1:
   1:tetStuff.c    **** //YEP. In a previous version (long before the row-seg-buffer)
   2:tetStuff.c    **** // Tetris was dang-near completion...
   3:tetStuff.c    **** // each block was a single drawable pixel
   4:tetStuff.c    **** // so it was pretty durn ugly.
   5:tetStuff.c    **** // But the refresh-rate was fast-enough at the time and the pixels were
   6:tetStuff.c    **** //  large-enough to make it playable
   7:tetStuff.c    **** // It was, in fact, my lifelong-goal to write Tetris... Ever since I
   8:tetStuff.c    **** // started "coding" in HyperCard.
   9:tetStuff.c    **** // Maybe something groovy could be done with low-refresh-rates...
  10:tetStuff.c    **** // "PredictaTris"... where hand-eye-coordination is handy, it doesn't
  11:tetStuff.c    **** // require much in the way of memory... Could be the same game, the same
  12:tetStuff.c    **** // speeds... just that the screen updates once a second, so you have to 
  13:tetStuff.c    **** // remember your moves and plan 'em out... crazy.
  14:tetStuff.c    **** 
  15:tetStuff.c    **** 
  16:tetStuff.c    **** #if (TRUE)
  17:tetStuff.c    **** 
  18:tetStuff.c    **** //in main...
  19:tetStuff.c    **** uint8_t fb_to_rb(uint8_t fbColor);
  20:tetStuff.c    **** 
  21:tetStuff.c    **** // Tetris:
  22:tetStuff.c    **** // 10 across
  23:tetStuff.c    **** // 18 up
  24:tetStuff.c    **** // 7 pieces (colors = 3 bits each)
  25:tetStuff.c    **** // Using 4 bits, for easy-access: 90 bytes
  26:tetStuff.c    **** // Using 3 bits: 67.5 bytes
  27:tetStuff.c    **** // How about a happy-medium... use 32-bits for a row...
  28:tetStuff.c    **** #define TET_HEIGHT	18
  29:tetStuff.c    **** #define TET_WIDTH		10
  30:tetStuff.c    **** #define TET_TOP_ROW  (0)
  31:tetStuff.c    **** 
  32:tetStuff.c    **** extern uint16_t pgm_tetPiece[7][4];
  33:tetStuff.c    **** #define bin4x4(b15,b14,b13,b12,\
  34:tetStuff.c    **** 		         b11,b10, b9, b8,\
  35:tetStuff.c    **** 		          b7, b6, b5, b4,\
  36:tetStuff.c    ****                 b3, b2, b1, b0)\
  37:tetStuff.c    ****          ((bin(b15,b14,b13,b12,b11,b10, b9, b8) << 8) | \
  38:tetStuff.c    **** 			          (bin( b7, b6, b5, b4, b3, b2, b1, b0)))
  39:tetStuff.c    **** 
  40:tetStuff.c    **** #define getTetPieceBrick(piece, orientation, row, col) \
  41:tetStuff.c    **** 	   getbit((row*4+col), pgm_getTetPiece(piece,orientation))
  42:tetStuff.c    **** 
  43:tetStuff.c    **** #define pgm_getTetPiece(piece,orientation) \
  44:tetStuff.c    **** 	   ((uint16_t)pgm_read_word(&(pgm_tetPiece[piece][orientation])))
  45:tetStuff.c    **** 
  46:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col);
  47:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val);
  48:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick);
  49:tetStuff.c    **** 	
  50:tetStuff.c    **** //For now, let's just test that it works...
  51:tetStuff.c    **** // (This could be implemented with bitfields?)
  52:tetStuff.c    **** uint32_t tetRow[TET_HEIGHT];
  53:tetStuff.c    **** 
  54:tetStuff.c    **** void tetInit(uint8_t filledRows)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 4


  55:tetStuff.c    **** {
  56:tetStuff.c    **** 	uint8_t row;
  57:tetStuff.c    **** 
  58:tetStuff.c    **** 	//Clear the board...
  59:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
  60:tetStuff.c    **** 		tetRow[row]=0;
  61:tetStuff.c    **** #if (TRUE) //Load random-ish "bricks" for testing...
  62:tetStuff.c    **** 	uint8_t col;
  63:tetStuff.c    **** 	//Now, leaving the first several rows blank for piece-testing...
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
  65:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
  66:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
  67:tetStuff.c    **** 
  68:tetStuff.c    **** #endif
  69:tetStuff.c    **** #if (FALSE) //Just throw some random pieces in for testing... Dun Woik
  70:tetStuff.c    **** 	row = 0;
  71:tetStuff.c    **** 	uint8_t col;
  72:tetStuff.c    **** 	uint8_t piece = 0;
  73:tetStuff.c    **** 	uint8_t pieceRow;
  74:tetStuff.c    **** 
  75:tetStuff.c    **** 	for(col=0; col<TET_WIDTH; col++)
  76:tetStuff.c    **** 	{
  77:tetStuff.c    **** 		piece = col/4;
  78:tetStuff.c    **** 
  79:tetStuff.c    **** 		for(pieceRow=0; pieceRow<4; pieceRow++)
  80:tetStuff.c    **** 			setTetBrick(pieceRow + row, col, (row+col) & 0x07);
  81:tetStuff.c    **** 				  	//(getTetPieceBrick(piece,0,pieceRow,col)) ? piece : 0);
  82:tetStuff.c    **** 
  83:tetStuff.c    **** 		row+=4;
  84:tetStuff.c    **** 
  85:tetStuff.c    **** 	}
  86:tetStuff.c    **** #endif
  87:tetStuff.c    **** }
  88:tetStuff.c    **** 
  89:tetStuff.c    **** 
  90:tetStuff.c    **** //Also determines color (pieceNum+1)...
  91:tetStuff.c    **** uint8_t pieceNum = 0;
  92:tetStuff.c    **** uint8_t pieceOrientation = 0;
  93:tetStuff.c    **** //Upper-Left corner
  94:tetStuff.c    **** uint8_t pieceTopRow = 0;
  95:tetStuff.c    **** uint8_t pieceLeftCol = 0;
  96:tetStuff.c    **** #define PIECE_HEIGHT 4
  97:tetStuff.c    **** #define PIECE_WIDTH	4
  98:tetStuff.c    **** #define NUM_PIECES	7
  99:tetStuff.c    **** #define PIECE_STARTCOL 3
 100:tetStuff.c    **** #define PIECE_STARTROW 0
 101:tetStuff.c    **** 
 102:tetStuff.c    **** 
 103:tetStuff.c    **** static __inline__ \
 104:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[]) \
 105:tetStuff.c    **** 	  __attribute__((__always_inline__));
 106:tetStuff.c    **** //This assumes rowBuffer[] points to the first column we should draw
 107:tetStuff.c    **** // it could be called as, e.g. tet_drawRow(rbRowNum, &RealRowBuffer[5])
 108:tetStuff.c    **** // to shift it right five pixels...
 109:tetStuff.c    **** // rowNum corresponds to the row in drawable pixels
 110:tetStuff.c    **** // (though this may change later... for, e.g. high vertical resolution)
 111:tetStuff.c    **** // (e.g. for brick separators...)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 5


 112:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[])
 113:tetStuff.c    **** {
 114:tetStuff.c    **** 	uint8_t i; 
 115:tetStuff.c    **** 
 116:tetStuff.c    **** 	if( (rowNum >= TET_TOP_ROW) &&
 117:tetStuff.c    **** 		 (rowNum < TET_TOP_ROW+TET_HEIGHT) )
 118:tetStuff.c    **** 	{
 119:tetStuff.c    **** 		//left border:
 120:tetStuff.c    **** 		rowBuffer[0]=fb_to_rb(_W);
 121:tetStuff.c    **** 
 122:tetStuff.c    **** 		//Draw active (and inactive) bricks
 123:tetStuff.c    **** 		for(i=1; i<=TET_WIDTH; i++)
 124:tetStuff.c    **** 		{
 125:tetStuff.c    **** 			rowBuffer[i]=
 126:tetStuff.c    **** 				fb_to_rb(tetBrick_to_fb(
 127:tetStuff.c    **** 							getTetBrick(rowNum-TET_TOP_ROW,i-1)));
 128:tetStuff.c    **** 		}
 129:tetStuff.c    **** 
 130:tetStuff.c    **** 		//right border:
 131:tetStuff.c    **** 		rowBuffer[i]=fb_to_rb(_W);
 132:tetStuff.c    **** 
 133:tetStuff.c    **** 		//SEE NOTE in main.c re: _b and _c -> _W syncing...
 134:tetStuff.c    **** 	}
 135:tetStuff.c    **** 	//bottom border:
 136:tetStuff.c    **** 	else if(rowNum == TET_TOP_ROW+TET_HEIGHT)
 137:tetStuff.c    **** 		for(i=0; i<=TET_WIDTH+1; i++)
 138:tetStuff.c    **** 			rowBuffer[i]=fb_to_rb(_W);
 139:tetStuff.c    **** //	else
 140:tetStuff.c    **** //		return;
 141:tetStuff.c    **** 
 142:tetStuff.c    **** 
 143:tetStuff.c    **** 	//Active (falling) piece:
 144:tetStuff.c    **** 
 145:tetStuff.c    **** 	if((rowNum >= pieceTopRow) &&
 146:tetStuff.c    **** 		(rowNum < pieceTopRow+PIECE_HEIGHT) )
 147:tetStuff.c    **** 	{
 148:tetStuff.c    **** 		uint8_t pieceRowNum = rowNum - pieceTopRow;
 149:tetStuff.c    **** 
 150:tetStuff.c    **** 		for(i=0; i<PIECE_WIDTH; i++)
 151:tetStuff.c    **** 		{
 152:tetStuff.c    **** 			uint8_t pieceBrick = 
 153:tetStuff.c    **** 					getTetPieceBrick(pieceNum, pieceOrientation, 
 154:tetStuff.c    **** 										  pieceRowNum, i);
 155:tetStuff.c    **** 
 156:tetStuff.c    **** 			//Only draw piece pixels (not black/empty pixels)
 157:tetStuff.c    **** 			// (we don't want to overwrite nearby bricks)
 158:tetStuff.c    **** 			if(pieceBrick)
 159:tetStuff.c    **** 			//+1 for the left border...
 160:tetStuff.c    **** 				rowBuffer[i+1+pieceLeftCol] =
 161:tetStuff.c    **** 						fb_to_rb(tetBrick_to_fb(pieceNum+1));
 162:tetStuff.c    **** 		}
 163:tetStuff.c    **** 	}
 164:tetStuff.c    **** 
 165:tetStuff.c    **** 
 166:tetStuff.c    **** 
 167:tetStuff.c    **** 
 168:tetStuff.c    **** 	//Draw "TETRIS" vertically...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 6


 169:tetStuff.c    **** #define CHARACTER_START_COL   14 //FB_WIDTH
 170:tetStuff.c    ****    //i=FB_WIDTH;
 171:tetStuff.c    ****    i=CHARACTER_START_COL;
 172:tetStuff.c    **** 
 173:tetStuff.c    ****    uint8_t charRow;
 174:tetStuff.c    ****    uint8_t color;
 175:tetStuff.c    ****    char character;
 176:tetStuff.c    ****    switch(rowNum/8)
 177:tetStuff.c    ****    {
 178:tetStuff.c    ****          case 0:
 179:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 180:tetStuff.c    ****             character = 'T';
 181:tetStuff.c    ****             color = _R;
 182:tetStuff.c    ****             break;
 183:tetStuff.c    ****          case 1:
 184:tetStuff.c    ****             //charRow = getCharRow('E', rowNum%8);
 185:tetStuff.c    ****             character = 'E';
 186:tetStuff.c    ****             color = _O;
 187:tetStuff.c    ****             break;
 188:tetStuff.c    ****          case 2:
 189:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 190:tetStuff.c    ****             character = 'T';
 191:tetStuff.c    ****             color = _Y;
 192:tetStuff.c    ****             break;
 193:tetStuff.c    ****          case 3:
 194:tetStuff.c    ****             { 
 195:tetStuff.c    ****                uint8_t z, temp;
 196:tetStuff.c    ****                
 197:tetStuff.c    ****                //Reverse the "R" to make it look Russian
 198:tetStuff.c    ****                // And shift it one left...
 199:tetStuff.c    ****                temp = getCharRow('R', rowNum%8);
 200:tetStuff.c    ****                
 201:tetStuff.c    ****                for(z=0; z<8; z++)
 202:tetStuff.c    ****                {
 203:tetStuff.c    ****                   writebit(7-z, charRow, getbit(z,temp));
 204:tetStuff.c    ****                }  
 205:tetStuff.c    ****                //Characters are reversed... bit 0 is far-left
 206:tetStuff.c    ****                //So to shift a character left, I must shift its bits right
 207:tetStuff.c    ****                // (right?)
 208:tetStuff.c    ****                charRow >>= 1;
 209:tetStuff.c    ****                color = _G; 
 210:tetStuff.c    ****             }  
 211:tetStuff.c    ****             break;
 212:tetStuff.c    ****          case 4:
 213:tetStuff.c    ****             //charRow = getCharRow('I', rowNum%8);
 214:tetStuff.c    ****             character = 'I';
 215:tetStuff.c    ****             color = _C; 
 216:tetStuff.c    ****             break;
 217:tetStuff.c    ****          case 5:
 218:tetStuff.c    ****             //charRow = getCharRow('S', rowNum%8);
 219:tetStuff.c    ****             character = 'S';
 220:tetStuff.c    ****             color = _B; 
 221:tetStuff.c    ****             break;
 222:tetStuff.c    ****          default:
 223:tetStuff.c    ****             character = ' ';
 224:tetStuff.c    ****             //charRow = 0;
 225:tetStuff.c    ****             break;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 7


 226:tetStuff.c    ****    }     
 227:tetStuff.c    **** 
 228:tetStuff.c    **** 	//Load charRow for all cases except the backwards "R"
 229:tetStuff.c    **** 	// which is handled above...      
 230:tetStuff.c    ****    if(rowNum/8 != 3)
 231:tetStuff.c    ****          charRow = getCharRow(character, rowNum%8);
 232:tetStuff.c    **** 
 233:tetStuff.c    ****    i++;
 234:tetStuff.c    **** 
 235:tetStuff.c    ****    uint8_t j;
 236:tetStuff.c    ****    for(j=0; j<8; j++)
 237:tetStuff.c    ****          if(getbit(j, charRow))
 238:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x25;
 239:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(color); //0x25);
 240:tetStuff.c    ****          else
 241:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x01;
 242:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(0x00);
 243:tetStuff.c    **** 
 244:tetStuff.c    **** 
 245:tetStuff.c    **** }
 246:tetStuff.c    **** 
 247:tetStuff.c    **** void tetUpdate(void)
 248:tetStuff.c    **** {
 249:tetStuff.c    **** 	//For now, we're just experimenting with the different pieces/
 250:tetStuff.c    **** 	// orientations/positions...	
 251:tetStuff.c    **** 	static uint8_t callCount = 0;
 252:tetStuff.c    **** 	static uint8_t newPieceHitCount=0;
 253:tetStuff.c    **** 
 254:tetStuff.c    **** 	uint8_t new_pieceOrientation;
 255:tetStuff.c    **** 	uint8_t new_pieceTopRow;
 256:tetStuff.c    **** 	uint8_t new_pieceLeftCol;
 257:tetStuff.c    **** //	uint8_t new_pieceNum;
 258:tetStuff.c    **** 
 259:tetStuff.c    **** 	uint8_t pieceRow;
 260:tetStuff.c    **** 	uint8_t pieceCol;
 261:tetStuff.c    **** 
 262:tetStuff.c    **** 	uint8_t noChange = FALSE;
 263:tetStuff.c    **** 	uint8_t settle = FALSE;
 264:tetStuff.c    **** 
 265:tetStuff.c    **** 	if(newPieceHitCount == 5)
 266:tetStuff.c    **** 	{
 267:tetStuff.c    **** 		newPieceHitCount = 0;
 268:tetStuff.c    **** 		tetInit(0);
 269:tetStuff.c    **** 	}
 270:tetStuff.c    **** 
 271:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 272:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 273:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 274:tetStuff.c    **** 
 275:tetStuff.c    **** 	if(callCount%4 == 2)
 276:tetStuff.c    ****    {
 277:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 278:tetStuff.c    ****       if (new_pieceOrientation==4)
 279:tetStuff.c    **** 			new_pieceOrientation=0;
 280:tetStuff.c    **** 	}
 281:tetStuff.c    **** 
 282:tetStuff.c    ****       if(callCount%4==0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 8


 283:tetStuff.c    ****       {  
 284:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 285:tetStuff.c    **** 		}
 286:tetStuff.c    **** 
 287:tetStuff.c    **** 		if(callCount%4==3)
 288:tetStuff.c    **** 		{
 289:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 290:tetStuff.c    ****       }
 291:tetStuff.c    **** 
 292:tetStuff.c    **** 	callCount++;
 293:tetStuff.c    **** 
 294:tetStuff.c    **** 
 295:tetStuff.c    **** 
 296:tetStuff.c    **** 
 297:tetStuff.c    **** 
 298:tetStuff.c    **** 	//Check for collision in the new piece position/orientation...
 299:tetStuff.c    **** 	//Starting from the bottom... (intentional wraparound)
 300:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 301:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 302:tetStuff.c    **** 		{
 303:tetStuff.c    **** 			//This isn't particularly efficient...
 304:tetStuff.c    **** 			// rereading each time...
 305:tetStuff.c    **** 			uint8_t pieceBrick =
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 307:tetStuff.c    **** 											  pieceRow, pieceCol);
 308:tetStuff.c    **** 
 309:tetStuff.c    **** 			uint8_t boardRow = new_pieceTopRow + pieceRow;
 310:tetStuff.c    **** 
 311:tetStuff.c    **** 			uint8_t boardCol = new_pieceLeftCol + pieceCol;
 312:tetStuff.c    **** 
 313:tetStuff.c    **** 			uint8_t boardBrick = getTetBrick(boardRow, boardCol);
 314:tetStuff.c    **** 
 315:tetStuff.c    **** 
 316:tetStuff.c    **** 			if(pieceBrick)
 317:tetStuff.c    **** 			{
 318:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 319:tetStuff.c    **** 				{
 320:tetStuff.c    **** 					noChange = TRUE;
 321:tetStuff.c    **** 					settle = TRUE;
 322:tetStuff.c    **** 					break;
 323:tetStuff.c    **** 				}
 324:tetStuff.c    **** 
 325:tetStuff.c    **** 				//There's some plausibility for some oddities here...
 326:tetStuff.c    **** 				// revisit 41-15.zip
 327:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 328:tetStuff.c    **** 				{
 329:tetStuff.c    **** 				   noChange = TRUE;
 330:tetStuff.c    **** 				   break;
 331:tetStuff.c    **** 				}
 332:tetStuff.c    **** 
 333:tetStuff.c    **** 
 334:tetStuff.c    **** 				if(boardBrick)
 335:tetStuff.c    **** 				{
 336:tetStuff.c    **** 					//Must be a settle...
 337:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 338:tetStuff.c    **** 						(new_pieceLeftCol == pieceLeftCol))
 339:tetStuff.c    **** 						settle = TRUE;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 9


 340:tetStuff.c    **** 
 341:tetStuff.c    **** 					noChange = TRUE;
 342:tetStuff.c    **** 					break;
 343:tetStuff.c    **** 				}
 344:tetStuff.c    **** 			}
 345:tetStuff.c    **** 		}
 346:tetStuff.c    **** 
 347:tetStuff.c    **** 
 348:tetStuff.c    **** 
 349:tetStuff.c    **** 
 350:tetStuff.c    **** 
 351:tetStuff.c    **** 	if(!noChange)
 352:tetStuff.c    **** 	{
 353:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 354:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 355:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 356:tetStuff.c    **** 	}
 357:tetStuff.c    **** 
 358:tetStuff.c    **** 	if(settle)
 359:tetStuff.c    **** 	{
 360:tetStuff.c    **** 		// Check if we've hit on a new piece...
 361:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 362:tetStuff.c    **** 		   (pieceLeftCol == PIECE_STARTCOL) &&
 363:tetStuff.c    **** 		   (pieceOrientation == 0))
 364:tetStuff.c    **** 		   newPieceHitCount++;
 365:tetStuff.c    **** 
 366:tetStuff.c    **** 
 367:tetStuff.c    **** 		//Load the piece into the board...
 368:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 369:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 370:tetStuff.c    **** 			{
 371:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 372:tetStuff.c    **** 										  pieceRow, pieceCol))
 373:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 374:tetStuff.c    **** 								pieceLeftCol+pieceCol,
 375:tetStuff.c    **** 								pieceNum+1);
 376:tetStuff.c    **** 			}
 377:tetStuff.c    **** 
 378:tetStuff.c    **** 
 379:tetStuff.c    **** 		//Load a new piece...
 380:tetStuff.c    **** 		pieceNum++;
 381:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 382:tetStuff.c    **** 			pieceNum = 0;
 383:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 384:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 385:tetStuff.c    **** 		pieceOrientation = 0;
 386:tetStuff.c    **** 	}
 387:tetStuff.c    **** 
 388:tetStuff.c    **** }
 389:tetStuff.c    **** 
 390:tetStuff.c    **** //returns a 3-bit value
 391:tetStuff.c    **** // 0 corresponds to no brick
 392:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 393:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col)
 394:tetStuff.c    **** {
 118               		.stabn	68,0,394,.LM0-.LFBB1
 119               	.LM0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 10


 120               	.LFBB1:
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               		.stabn	68,0,394,.LM1-.LFBB1
 124               	.LM1:
 125 0000 E82F      		mov r30,r24
 126 0002 F0E0      		ldi r31,lo8(0)
 127 0004 EE0F      		lsl r30
 128 0006 FF1F      		rol r31
 129 0008 EE0F      		lsl r30
 130 000a FF1F      		rol r31
 131 000c E050      		subi r30,lo8(-(tetRow))
 132 000e F040      		sbci r31,hi8(-(tetRow))
 133 0010 862F      		mov r24,r22
 134 0012 90E0      		ldi r25,lo8(0)
 135 0014 63E0      		ldi r22,lo8(3)
 136 0016 70E0      		ldi r23,hi8(3)
 137 0018 00D0      		rcall __mulhi3
 138 001a 2081      		ld r18,Z
 139 001c 3181      		ldd r19,Z+1
 140 001e 4281      		ldd r20,Z+2
 141 0020 5381      		ldd r21,Z+3
 142 0022 00C0      		rjmp 2f
 143 0024 5695      	1:	lsr r21
 144 0026 4795      		ror r20
 145 0028 3795      		ror r19
 146 002a 2795      		ror r18
 147 002c 8A95      	2:	dec r24
 148 002e 02F4      		brpl 1b
 395:tetStuff.c    **** 	//uint8_t tetCol = col*3;
 396:tetStuff.c    **** //	uint8_t tetMask = '\007';
 397:tetStuff.c    **** 	
 398:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
 399:tetStuff.c    **** 
 400:tetStuff.c    **** }
 149               		.stabn	68,0,400,.LM2-.LFBB1
 150               	.LM2:
 151 0030 822F      		mov r24,r18
 152 0032 8770      		andi r24,lo8(7)
 153               	/* epilogue start */
 154 0034 0895      		ret
 155               		.size	getTetBrick, .-getTetBrick
 156               	.Lscope1:
 157               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 158               		.stabd	78,0,0
 159               		.stabs	"setTetBrick:F(0,15)",36,0,406,setTetBrick
 160               		.stabs	"row:P(3,2)",64,0,406,24
 161               		.stabs	"col:P(3,2)",64,0,406,22
 162               		.stabs	"val:P(3,2)",64,0,406,20
 163               	.global	setTetBrick
 164               		.type	setTetBrick, @function
 165               	setTetBrick:
 166               		.stabd	46,0,0
 401:tetStuff.c    **** 
 402:tetStuff.c    **** 
 403:tetStuff.c    **** //val should only be 0-7
 404:tetStuff.c    **** // 0 corresponds to no brick
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 11


 405:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 406:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val)
 407:tetStuff.c    **** {
 167               		.stabn	68,0,407,.LM3-.LFBB2
 168               	.LM3:
 169               	.LFBB2:
 170 0036 0F93      		push r16
 171 0038 1F93      		push r17
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 408:tetStuff.c    **** 	//Clear the old value...
 409:tetStuff.c    **** 	tetRow[row] &= ~(((uint32_t)'\007')<<(3*col));
 174               		.stabn	68,0,409,.LM4-.LFBB2
 175               	.LM4:
 176 003a E82F      		mov r30,r24
 177 003c F0E0      		ldi r31,lo8(0)
 178 003e 862F      		mov r24,r22
 179 0040 90E0      		ldi r25,lo8(0)
 180 0042 63E0      		ldi r22,lo8(3)
 181 0044 70E0      		ldi r23,hi8(3)
 182 0046 00D0      		rcall __mulhi3
 183 0048 A82F      		mov r26,r24
 410:tetStuff.c    **** 	//Write the new value...
 411:tetStuff.c    **** 	tetRow[row] |= (((uint32_t)val)<<(3*col));
 184               		.stabn	68,0,411,.LM5-.LFBB2
 185               	.LM5:
 186 004a EE0F      		lsl r30
 187 004c FF1F      		rol r31
 188 004e EE0F      		lsl r30
 189 0050 FF1F      		rol r31
 190 0052 E050      		subi r30,lo8(-(tetRow))
 191 0054 F040      		sbci r31,hi8(-(tetRow))
 192 0056 67E0      		ldi r22,lo8(7)
 193 0058 70E0      		ldi r23,hi8(7)
 194 005a 80E0      		ldi r24,hlo8(7)
 195 005c 90E0      		ldi r25,hhi8(7)
 196 005e 0A2E      		mov r0,r26
 197 0060 00C0      		rjmp 2f
 198 0062 660F      	1:	lsl r22
 199 0064 771F      		rol r23
 200 0066 881F      		rol r24
 201 0068 991F      		rol r25
 202 006a 0A94      	2:	dec r0
 203 006c 02F4      		brpl 1b
 204 006e 6095      		com r22
 205 0070 7095      		com r23
 206 0072 8095      		com r24
 207 0074 9095      		com r25
 208 0076 0081      		ld r16,Z
 209 0078 1181      		ldd r17,Z+1
 210 007a 2281      		ldd r18,Z+2
 211 007c 3381      		ldd r19,Z+3
 212 007e 6023      		and r22,r16
 213 0080 7123      		and r23,r17
 214 0082 8223      		and r24,r18
 215 0084 9323      		and r25,r19
 216 0086 242F      		mov r18,r20
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 12


 217 0088 30E0      		ldi r19,lo8(0)
 218 008a 40E0      		ldi r20,lo8(0)
 219 008c 50E0      		ldi r21,hi8(0)
 220 008e 00C0      		rjmp 2f
 221 0090 220F      	1:	lsl r18
 222 0092 331F      		rol r19
 223 0094 441F      		rol r20
 224 0096 551F      		rol r21
 225 0098 AA95      	2:	dec r26
 226 009a 02F4      		brpl 1b
 227 009c 622B      		or r22,r18
 228 009e 732B      		or r23,r19
 229 00a0 842B      		or r24,r20
 230 00a2 952B      		or r25,r21
 231 00a4 6083      		st Z,r22
 232 00a6 7183      		std Z+1,r23
 233 00a8 8283      		std Z+2,r24
 234 00aa 9383      		std Z+3,r25
 235               	/* epilogue start */
 412:tetStuff.c    **** }
 236               		.stabn	68,0,412,.LM6-.LFBB2
 237               	.LM6:
 238 00ac 1F91      		pop r17
 239 00ae 0F91      		pop r16
 240 00b0 0895      		ret
 241               		.size	setTetBrick, .-setTetBrick
 242               	.Lscope2:
 243               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 244               		.stabd	78,0,0
 245               		.stabs	"tetInit:F(0,15)",36,0,54,tetInit
 246               		.stabs	"filledRows:P(3,2)",64,0,54,24
 247               	.global	tetInit
 248               		.type	tetInit, @function
 249               	tetInit:
 250               		.stabd	46,0,0
  55:tetStuff.c    **** {
 251               		.stabn	68,0,55,.LM7-.LFBB3
 252               	.LM7:
 253               	.LFBB3:
 254 00b2 0F93      		push r16
 255 00b4 1F93      		push r17
 256               	/* prologue: function */
 257               	/* frame size = 0 */
  55:tetStuff.c    **** {
 258               		.stabn	68,0,55,.LM8-.LFBB3
 259               	.LM8:
 260 00b6 E0E0      		ldi r30,lo8(tetRow)
 261 00b8 F0E0      		ldi r31,hi8(tetRow)
 262               	.L6:
  60:tetStuff.c    **** 		tetRow[row]=0;
 263               		.stabn	68,0,60,.LM9-.LFBB3
 264               	.LM9:
 265 00ba 1192      		st Z+,__zero_reg__
 266 00bc 1192      		st Z+,__zero_reg__
 267 00be 1192      		st Z+,__zero_reg__
 268 00c0 1192      		st Z+,__zero_reg__
  59:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 13


 269               		.stabn	68,0,59,.LM10-.LFBB3
 270               	.LM10:
 271 00c2 90E0      		ldi r25,hi8(tetRow+72)
 272 00c4 E030      		cpi r30,lo8(tetRow+72)
 273 00c6 F907      		cpc r31,r25
 274 00c8 01F4      		brne .L6
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 275               		.stabn	68,0,64,.LM11-.LFBB3
 276               	.LM11:
 277 00ca 12E1      		ldi r17,lo8(18)
 278 00cc 181B      		sub r17,r24
 279 00ce 00C0      		rjmp .L7
 280               	.L9:
 281 00d0 00E0      		ldi r16,lo8(0)
 282               	.L8:
  66:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
 283               		.stabn	68,0,66,.LM12-.LFBB3
 284               	.LM12:
 285 00d2 402F      		mov r20,r16
 286 00d4 410F      		add r20,r17
 287 00d6 4770      		andi r20,lo8(7)
 288 00d8 812F      		mov r24,r17
 289 00da 602F      		mov r22,r16
 290 00dc 00D0      		rcall setTetBrick
  65:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
 291               		.stabn	68,0,65,.LM13-.LFBB3
 292               	.LM13:
 293 00de 0F5F      		subi r16,lo8(-(1))
 294 00e0 0A30      		cpi r16,lo8(10)
 295 00e2 01F4      		brne .L8
  64:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 296               		.stabn	68,0,64,.LM14-.LFBB3
 297               	.LM14:
 298 00e4 1F5F      		subi r17,lo8(-(1))
 299               	.L7:
 300 00e6 1231      		cpi r17,lo8(18)
 301 00e8 00F0      		brlo .L9
 302               	/* epilogue start */
  87:tetStuff.c    **** }
 303               		.stabn	68,0,87,.LM15-.LFBB3
 304               	.LM15:
 305 00ea 1F91      		pop r17
 306 00ec 0F91      		pop r16
 307 00ee 0895      		ret
 308               		.size	tetInit, .-tetInit
 309               		.stabs	"row:r(3,2)",64,0,56,17
 310               		.stabs	"col:r(3,2)",64,0,62,16
 311               		.stabn	192,0,0,.LFBB3-.LFBB3
 312               		.stabn	224,0,0,.Lscope3-.LFBB3
 313               	.Lscope3:
 314               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 315               		.stabd	78,0,0
 316               		.stabs	"tetUpdate:F(0,15)",36,0,247,tetUpdate
 317               	.global	tetUpdate
 318               		.type	tetUpdate, @function
 319               	tetUpdate:
 320               		.stabd	46,0,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 14


 248:tetStuff.c    **** {
 321               		.stabn	68,0,248,.LM16-.LFBB4
 322               	.LM16:
 323               	.LFBB4:
 324 00f0 2F92      		push r2
 325 00f2 3F92      		push r3
 326 00f4 4F92      		push r4
 327 00f6 5F92      		push r5
 328 00f8 6F92      		push r6
 329 00fa 7F92      		push r7
 330 00fc 8F92      		push r8
 331 00fe 9F92      		push r9
 332 0100 AF92      		push r10
 333 0102 BF92      		push r11
 334 0104 CF92      		push r12
 335 0106 DF92      		push r13
 336 0108 EF92      		push r14
 337 010a FF92      		push r15
 338 010c 0F93      		push r16
 339 010e 1F93      		push r17
 340 0110 DF93      		push r29
 341 0112 CF93      		push r28
 342 0114 00D0      		rcall .
 343 0116 CDB7      		in r28,__SP_L__
 344 0118 DEB7      		in r29,__SP_H__
 345               	/* prologue: function */
 346               	/* frame size = 2 */
 265:tetStuff.c    **** 	if(newPieceHitCount == 5)
 347               		.stabn	68,0,265,.LM17-.LFBB4
 348               	.LM17:
 349 011a 8091 0000 		lds r24,newPieceHitCount.1823
 350 011e 8530      		cpi r24,lo8(5)
 351 0120 01F4      		brne .L15
 267:tetStuff.c    **** 		newPieceHitCount = 0;
 352               		.stabn	68,0,267,.LM18-.LFBB4
 353               	.LM18:
 354 0122 1092 0000 		sts newPieceHitCount.1823,__zero_reg__
 268:tetStuff.c    **** 		tetInit(0);
 355               		.stabn	68,0,268,.LM19-.LFBB4
 356               	.LM19:
 357 0126 80E0      		ldi r24,lo8(0)
 358 0128 00D0      		rcall tetInit
 359               	.L15:
 271:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 360               		.stabn	68,0,271,.LM20-.LFBB4
 361               	.LM20:
 362 012a 3090 0000 		lds r3,pieceOrientation
 272:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 363               		.stabn	68,0,272,.LM21-.LFBB4
 364               	.LM21:
 365 012e 4091 0000 		lds r20,pieceLeftCol
 273:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 366               		.stabn	68,0,273,.LM22-.LFBB4
 367               	.LM22:
 368 0132 2090 0000 		lds r2,pieceTopRow
 275:tetStuff.c    **** 	if(callCount%4 == 2)
 369               		.stabn	68,0,275,.LM23-.LFBB4
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 15


 370               	.LM23:
 371 0136 5091 0000 		lds r21,callCount.1822
 372 013a 852F      		mov r24,r21
 373 013c 90E0      		ldi r25,lo8(0)
 374 013e 8370      		andi r24,lo8(3)
 375 0140 9070      		andi r25,hi8(3)
 376 0142 8230      		cpi r24,2
 377 0144 9105      		cpc r25,__zero_reg__
 378 0146 01F4      		brne .L16
 277:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 379               		.stabn	68,0,277,.LM24-.LFBB4
 380               	.LM24:
 381 0148 232D      		mov r18,r3
 382 014a 2F5F      		subi r18,lo8(-(1))
 278:tetStuff.c    ****       if (new_pieceOrientation==4)
 383               		.stabn	68,0,278,.LM25-.LFBB4
 384               	.LM25:
 385 014c 2430      		cpi r18,lo8(4)
 386 014e 01F0      		breq .+2
 387 0150 00C0      		rjmp .L18
 388 0152 00C0      		rjmp .L48
 389               	.L16:
 282:tetStuff.c    ****       if(callCount%4==0)
 390               		.stabn	68,0,282,.LM26-.LFBB4
 391               	.LM26:
 392 0154 0097      		sbiw r24,0
 393 0156 01F4      		brne .L19
 284:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 394               		.stabn	68,0,284,.LM27-.LFBB4
 395               	.LM27:
 396 0158 342F      		mov r19,r20
 397 015a 3F5F      		subi r19,lo8(-(1))
 398 015c 00C0      		rjmp .L43
 399               	.L19:
 287:tetStuff.c    **** 		if(callCount%4==3)
 400               		.stabn	68,0,287,.LM28-.LFBB4
 401               	.LM28:
 402 015e 8330      		cpi r24,3
 403 0160 9105      		cpc r25,__zero_reg__
 404 0162 01F4      		brne .L45
 289:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 405               		.stabn	68,0,289,.LM29-.LFBB4
 406               	.LM29:
 407 0164 2394      		inc r2
 408               	.L45:
 409 0166 342F      		mov r19,r20
 410               	.L43:
 411 0168 232D      		mov r18,r3
 412               	.L20:
 292:tetStuff.c    **** 	callCount++;
 413               		.stabn	68,0,292,.LM30-.LFBB4
 414               	.LM30:
 415 016a 5F5F      		subi r21,lo8(-(1))
 416 016c 5093 0000 		sts callCount.1822,r21
 417               	.LBB107:
 418               	.LBB108:
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 16


 419               		.stabn	68,0,306,.LM31-.LFBB4
 420               	.LM31:
 421 0170 8091 0000 		lds r24,pieceNum
 422 0174 90E0      		ldi r25,lo8(0)
 423 0176 880F      		lsl r24
 424 0178 991F      		rol r25
 425 017a 880F      		lsl r24
 426 017c 991F      		rol r25
 427 017e 820F      		add r24,r18
 428 0180 911D      		adc r25,__zero_reg__
 429 0182 880F      		lsl r24
 430 0184 991F      		rol r25
 431 0186 8050      		subi r24,lo8(-(pgm_tetPiece))
 432 0188 9040      		sbci r25,hi8(-(pgm_tetPiece))
 433 018a 122D      		mov r17,r2
 434 018c 1D5F      		subi r17,lo8(-(3))
 435 018e A0E0      		ldi r26,lo8(0)
 436 0190 B3E0      		ldi r27,lo8(3)
 437 0192 FC01      		movw r30,r24
 438               	/* #APP */
 439               	 ;  306 "tetStuff.c" 1
 440 0194 C590      		lpm r12, Z+
 441 0196 D490      		lpm r13, Z
 442               		
 443               	 ;  0 "" 2
 444               	/* #NOAPP */
 445 0198 00C0      		rjmp .L22
 446               	.L26:
 447               	.LBE108:
 316:tetStuff.c    **** 			if(pieceBrick)
 448               		.stabn	68,0,316,.LM32-.LFBB4
 449               	.LM32:
 450 019a CF01      		movw r24,r30
 451 019c 8E0D      		add r24,r14
 452 019e 9F1D      		adc r25,r15
 453 01a0 2601      		movw r4,r12
 454 01a2 00C0      		rjmp 2f
 455 01a4 5694      	1:	lsr r5
 456 01a6 4794      		ror r4
 457 01a8 8A95      	2:	dec r24
 458 01aa 02F4      		brpl 1b
 459 01ac 40FE      		sbrs r4,0
 460 01ae 00C0      		rjmp .L23
 318:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 461               		.stabn	68,0,318,.LM33-.LFBB4
 462               	.LM33:
 463 01b0 1231      		cpi r17,lo8(18)
 464 01b2 00F4      		brsh .L24
 327:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 465               		.stabn	68,0,327,.LM34-.LFBB4
 466               	.LM34:
 467 01b4 0A30      		cpi r16,lo8(10)
 468 01b6 00F4      		brsh .L25
 334:tetStuff.c    **** 				if(boardBrick)
 469               		.stabn	68,0,334,.LM35-.LFBB4
 470               	.LM35:
 471 01b8 802F      		mov r24,r16
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 17


 472 01ba 90E0      		ldi r25,lo8(0)
 473 01bc 63E0      		ldi r22,lo8(3)
 474 01be 70E0      		ldi r23,hi8(3)
 475 01c0 00D0      		rcall __mulhi3
 476 01c2 2401      		movw r4,r8
 477 01c4 3501      		movw r6,r10
 478 01c6 00C0      		rjmp 2f
 479 01c8 7694      	1:	lsr r7
 480 01ca 6794      		ror r6
 481 01cc 5794      		ror r5
 482 01ce 4794      		ror r4
 483 01d0 8A95      	2:	dec r24
 484 01d2 02F4      		brpl 1b
 485 01d4 842D      		mov r24,r4
 486 01d6 8770      		andi r24,lo8(7)
 487 01d8 01F0      		breq .L23
 337:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 488               		.stabn	68,0,337,.LM36-.LFBB4
 489               	.LM36:
 490 01da 2315      		cp r18,r3
 491 01dc 01F4      		brne .L25
 492 01de 3417      		cp r19,r20
 493 01e0 01F4      		brne .L25
 494 01e2 00C0      		rjmp .L24
 495               	.L23:
 496 01e4 3196      		adiw r30,1
 497 01e6 0F5F      		subi r16,lo8(-(1))
 498               	.LBE107:
 301:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 499               		.stabn	68,0,301,.LM37-.LFBB4
 500               	.LM37:
 501 01e8 E430      		cpi r30,4
 502 01ea F105      		cpc r31,__zero_reg__
 503 01ec 01F4      		brne .L26
 504 01ee 80E0      		ldi r24,lo8(0)
 505 01f0 00C0      		rjmp .L27
 506               	.L24:
 507 01f2 81E0      		ldi r24,lo8(1)
 508 01f4 00C0      		rjmp .L44
 509               	.L25:
 510 01f6 80E0      		ldi r24,lo8(0)
 511               	.L44:
 512 01f8 A1E0      		ldi r26,lo8(1)
 513               	.L27:
 300:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 514               		.stabn	68,0,300,.LM38-.LFBB4
 515               	.LM38:
 516 01fa B150      		subi r27,lo8(-(-1))
 517 01fc 1150      		subi r17,lo8(-(-1))
 518 01fe BF3F      		cpi r27,lo8(-1)
 519 0200 01F0      		breq .L28
 520 0202 8823      		tst r24
 521 0204 01F4      		brne .L28
 522               	.L22:
 523 0206 AA23      		tst r26
 524 0208 01F0      		breq .+2
 525 020a 00C0      		rjmp .L37
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 18


 526               	.LBB111:
 306:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 527               		.stabn	68,0,306,.LM39-.LFBB4
 528               	.LM39:
 529 020c EB2E      		mov r14,r27
 530 020e FF24      		clr r15
 531 0210 EE0C      		lsl r14
 532 0212 FF1C      		rol r15
 533 0214 EE0C      		lsl r14
 534 0216 FF1C      		rol r15
 535               	.LBB109:
 536               	.LBB110:
 398:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
 537               		.stabn	68,0,398,.LM40-.LFBB4
 538               	.LM40:
 539 0218 E12F      		mov r30,r17
 540 021a F0E0      		ldi r31,lo8(0)
 541 021c EE0F      		lsl r30
 542 021e FF1F      		rol r31
 543 0220 EE0F      		lsl r30
 544 0222 FF1F      		rol r31
 545 0224 E050      		subi r30,lo8(-(tetRow))
 546 0226 F040      		sbci r31,hi8(-(tetRow))
 547 0228 8080      		ld r8,Z
 548 022a 9180      		ldd r9,Z+1
 549 022c A280      		ldd r10,Z+2
 550 022e B380      		ldd r11,Z+3
 551 0230 032F      		mov r16,r19
 552 0232 E0E0      		ldi r30,lo8(0)
 553 0234 F0E0      		ldi r31,hi8(0)
 554 0236 00C0      		rjmp .L26
 555               	.L28:
 556               	.LBE110:
 557               	.LBE109:
 558               	.LBE111:
 351:tetStuff.c    **** 	if(!noChange)
 559               		.stabn	68,0,351,.LM41-.LFBB4
 560               	.LM41:
 561 0238 AA23      		tst r26
 562 023a 01F4      		brne .L30
 353:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 563               		.stabn	68,0,353,.LM42-.LFBB4
 564               	.LM42:
 565 023c 2093 0000 		sts pieceOrientation,r18
 354:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 566               		.stabn	68,0,354,.LM43-.LFBB4
 567               	.LM43:
 568 0240 3093 0000 		sts pieceLeftCol,r19
 355:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 569               		.stabn	68,0,355,.LM44-.LFBB4
 570               	.LM44:
 571 0244 2092 0000 		sts pieceTopRow,r2
 572               	.L30:
 358:tetStuff.c    **** 	if(settle)
 573               		.stabn	68,0,358,.LM45-.LFBB4
 574               	.LM45:
 575 0248 8823      		tst r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 19


 576 024a 01F4      		brne .+2
 577 024c 00C0      		rjmp .L37
 361:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 578               		.stabn	68,0,361,.LM46-.LFBB4
 579               	.LM46:
 580 024e 8091 0000 		lds r24,pieceTopRow
 581 0252 8823      		tst r24
 582 0254 01F0      		breq .+2
 583 0256 00C0      		rjmp .L31
 584 0258 8091 0000 		lds r24,pieceLeftCol
 585 025c 8330      		cpi r24,lo8(3)
 586 025e 01F0      		breq .+2
 587 0260 00C0      		rjmp .L31
 588 0262 8091 0000 		lds r24,pieceOrientation
 589 0266 8823      		tst r24
 590 0268 01F0      		breq .+2
 591 026a 00C0      		rjmp .L31
 364:tetStuff.c    **** 		   newPieceHitCount++;
 592               		.stabn	68,0,364,.LM47-.LFBB4
 593               	.LM47:
 594 026c 8091 0000 		lds r24,newPieceHitCount.1823
 595 0270 8F5F      		subi r24,lo8(-(1))
 596 0272 8093 0000 		sts newPieceHitCount.1823,r24
 597 0276 00C0      		rjmp .L31
 598               	.L34:
 599               	.LBB112:
 371:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 600               		.stabn	68,0,371,.LM48-.LFBB4
 601               	.LM48:
 602 0278 4091 0000 		lds r20,pieceNum
 603 027c E42F      		mov r30,r20
 604 027e F0E0      		ldi r31,lo8(0)
 605 0280 EE0F      		lsl r30
 606 0282 FF1F      		rol r31
 607 0284 EE0F      		lsl r30
 608 0286 FF1F      		rol r31
 609 0288 8091 0000 		lds r24,pieceOrientation
 610 028c E80F      		add r30,r24
 611 028e F11D      		adc r31,__zero_reg__
 612 0290 EE0F      		lsl r30
 613 0292 FF1F      		rol r31
 614 0294 E050      		subi r30,lo8(-(pgm_tetPiece))
 615 0296 F040      		sbci r31,hi8(-(pgm_tetPiece))
 616               	/* #APP */
 617               	 ;  371 "tetStuff.c" 1
 618 0298 8591      		lpm r24, Z+
 619 029a 9491      		lpm r25, Z
 620               		
 621               	 ;  0 "" 2
 622               	/* #NOAPP */
 623               	.LBE112:
 624 029c B701      		movw r22,r14
 625 029e 620F      		add r22,r18
 626 02a0 731F      		adc r23,r19
 627 02a2 00C0      		rjmp 2f
 628 02a4 9695      	1:	lsr r25
 629 02a6 8795      		ror r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 20


 630 02a8 6A95      	2:	dec r22
 631 02aa 02F4      		brpl 1b
 632 02ac 80FF      		sbrs r24,0
 633 02ae 00C0      		rjmp .L33
 373:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 634               		.stabn	68,0,373,.LM49-.LFBB4
 635               	.LM49:
 636 02b0 8091 0000 		lds r24,pieceTopRow
 637 02b4 6091 0000 		lds r22,pieceLeftCol
 638 02b8 6E0D      		add r22,r14
 639 02ba 4F5F      		subi r20,lo8(-(1))
 640 02bc 810F      		add r24,r17
 641 02be 2983      		std Y+1,r18
 642 02c0 3A83      		std Y+2,r19
 643 02c2 00D0      		rcall setTetBrick
 644 02c4 3A81      		ldd r19,Y+2
 645 02c6 2981      		ldd r18,Y+1
 646               	.L33:
 647 02c8 0894      		sec
 648 02ca E11C      		adc r14,__zero_reg__
 649 02cc F11C      		adc r15,__zero_reg__
 369:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 650               		.stabn	68,0,369,.LM50-.LFBB4
 651               	.LM50:
 652 02ce 64E0      		ldi r22,lo8(4)
 653 02d0 E616      		cp r14,r22
 654 02d2 F104      		cpc r15,__zero_reg__
 655 02d4 01F4      		brne .L34
 368:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 656               		.stabn	68,0,368,.LM51-.LFBB4
 657               	.LM51:
 658 02d6 1F5F      		subi r17,lo8(-(1))
 659 02d8 2C5F      		subi r18,lo8(-(4))
 660 02da 3F4F      		sbci r19,hi8(-(4))
 661 02dc 1430      		cpi r17,lo8(4)
 662 02de 01F4      		brne .L38
 663 02e0 00C0      		rjmp .L49
 664               	.L31:
 665 02e2 20E0      		ldi r18,lo8(0)
 666 02e4 30E0      		ldi r19,hi8(0)
 667 02e6 10E0      		ldi r17,lo8(0)
 668               	.L38:
 669 02e8 EE24      		clr r14
 670 02ea FF24      		clr r15
 671 02ec 00C0      		rjmp .L34
 672               	.L49:
 380:tetStuff.c    **** 		pieceNum++;
 673               		.stabn	68,0,380,.LM52-.LFBB4
 674               	.LM52:
 675 02ee 8091 0000 		lds r24,pieceNum
 676 02f2 8F5F      		subi r24,lo8(-(1))
 677 02f4 8093 0000 		sts pieceNum,r24
 381:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 678               		.stabn	68,0,381,.LM53-.LFBB4
 679               	.LM53:
 680 02f8 8730      		cpi r24,lo8(7)
 681 02fa 01F4      		brne .L36
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 21


 382:tetStuff.c    **** 			pieceNum = 0;
 682               		.stabn	68,0,382,.LM54-.LFBB4
 683               	.LM54:
 684 02fc 1092 0000 		sts pieceNum,__zero_reg__
 685               	.L36:
 383:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 686               		.stabn	68,0,383,.LM55-.LFBB4
 687               	.LM55:
 688 0300 83E0      		ldi r24,lo8(3)
 689 0302 8093 0000 		sts pieceLeftCol,r24
 384:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 690               		.stabn	68,0,384,.LM56-.LFBB4
 691               	.LM56:
 692 0306 1092 0000 		sts pieceTopRow,__zero_reg__
 385:tetStuff.c    **** 		pieceOrientation = 0;
 693               		.stabn	68,0,385,.LM57-.LFBB4
 694               	.LM57:
 695 030a 1092 0000 		sts pieceOrientation,__zero_reg__
 696 030e 00C0      		rjmp .L37
 697               	.L48:
 388:tetStuff.c    **** }
 698               		.stabn	68,0,388,.LM58-.LFBB4
 699               	.LM58:
 700 0310 20E0      		ldi r18,lo8(0)
 701               	.L18:
 702 0312 342F      		mov r19,r20
 703 0314 00C0      		rjmp .L20
 704               	.L37:
 705               	/* epilogue start */
 706 0316 0F90      		pop __tmp_reg__
 707 0318 0F90      		pop __tmp_reg__
 708 031a CF91      		pop r28
 709 031c DF91      		pop r29
 710 031e 1F91      		pop r17
 711 0320 0F91      		pop r16
 712 0322 FF90      		pop r15
 713 0324 EF90      		pop r14
 714 0326 DF90      		pop r13
 715 0328 CF90      		pop r12
 716 032a BF90      		pop r11
 717 032c AF90      		pop r10
 718 032e 9F90      		pop r9
 719 0330 8F90      		pop r8
 720 0332 7F90      		pop r7
 721 0334 6F90      		pop r6
 722 0336 5F90      		pop r5
 723 0338 4F90      		pop r4
 724 033a 3F90      		pop r3
 725 033c 2F90      		pop r2
 726 033e 0895      		ret
 727               		.size	tetUpdate, .-tetUpdate
 728               		.stabs	"callCount:V(3,2)",38,0,251,callCount.1822
 729               		.stabs	"newPieceHitCount:V(3,2)",38,0,252,newPieceHitCount.1823
 730               		.stabs	"new_pieceOrientation:r(3,2)",64,0,254,3
 731               		.stabs	"new_pieceTopRow:r(3,2)",64,0,255,2
 732               		.stabs	"new_pieceLeftCol:r(3,2)",64,0,256,20
 733               		.stabs	"pieceRow:r(3,2)",64,0,259,27
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 22


 734               		.stabs	"pieceCol:r(3,2)",64,0,260,21
 735               		.stabs	"noChange:r(3,2)",64,0,262,26
 736               		.stabs	"settle:r(3,2)",64,0,263,24
 737               		.stabn	192,0,0,.LFBB4-.LFBB4
 738               		.stabs	"__addr16:r(3,4)",64,0,306,24
 739               		.stabn	192,0,0,.LBB108-.LFBB4
 740               		.stabn	224,0,0,.LBE108-.LFBB4
 741               		.stabs	"__addr16:r(3,4)",64,0,371,30
 742               		.stabn	192,0,0,.LBB112-.LFBB4
 743               		.stabn	224,0,0,.LBE112-.LFBB4
 744               		.stabn	224,0,0,.Lscope4-.LFBB4
 745               	.Lscope4:
 746               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 747               		.stabd	78,0,0
 748               		.stabs	"tetBrick_to_fb:F(3,2)",36,0,416,tetBrick_to_fb
 749               		.stabs	"tetBrick:P(3,2)",64,0,416,24
 750               	.global	tetBrick_to_fb
 751               		.type	tetBrick_to_fb, @function
 752               	tetBrick_to_fb:
 753               		.stabd	46,0,0
 413:tetStuff.c    **** 
 414:tetStuff.c    **** uint8_t tetColorScheme = 0;
 415:tetStuff.c    **** 
 416:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick)
 417:tetStuff.c    **** {
 754               		.stabn	68,0,417,.LM59-.LFBB5
 755               	.LM59:
 756               	.LFBB5:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 418:tetStuff.c    **** 	if(!tetBrick)
 759               		.stabn	68,0,418,.LM60-.LFBB5
 760               	.LM60:
 761 0340 8823      		tst r24
 762 0342 01F0      		breq .L52
 419:tetStuff.c    **** 		return 0;
 420:tetStuff.c    **** 
 421:tetStuff.c    **** 	switch(tetColorScheme)
 763               		.stabn	68,0,421,.LM61-.LFBB5
 764               	.LM61:
 765 0344 9091 0000 		lds r25,tetColorScheme
 766 0348 8150      		subi r24,lo8(-(-1))
 767 034a 9230      		cpi r25,lo8(2)
 768 034c 00F4      		brsh .L53
 769               		.stabs	"main.c",132,0,0,.Ltext2
 770               	.Ltext2:
   1:main.c        **** #include "projInfo.h"   //Don't include in main.h 'cause that's included in other .c's?
   2:main.c        **** #include "main.h"
   3:main.c        **** #include <util/delay.h> //For delay_us in pll_enable
   4:main.c        **** #include <avr/pgmspace.h>
   5:main.c        **** #include _TIMERCOMMON_HEADER_
   6:main.c        **** //#include "../../../_commonCode/charBitmap/0.10/charBitmap.h"
   7:main.c        **** #include _CHARBITMAP_HEADER_
   8:main.c        **** #include "fbColors.h"
   9:main.c        **** 
  10:main.c        **** #include _SINETABLE_HEADER_
  11:main.c        **** #include "tetStuff.c"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 23


  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** 
  17:main.c        **** //The current state is such that basically ONLY the row-segment-buffer
  18:main.c        **** // display-method has been tested for quite some time. The other code
  19:main.c        **** // remains, but I can't promise it still works.
  20:main.c        **** 
  21:main.c        **** //Only one of the following SEG_whatevers should be TRUE
  22:main.c        **** // (Assuming we're using the Row-Segment-Buffer, as explained above).
  23:main.c        **** // IF NONE ARE TRUE:
  24:main.c        **** //  The default is to convert whatever's in the row-buffer into 
  25:main.c        **** //  the row-segment-buffer...
  26:main.c        **** //  This is where my old-code starts getting iffy, as the row-buffer hasn't
  27:main.c        **** //  been used for quite some time.
  28:main.c        **** // Best to stick with assigning one of these SEG_xxx things true.
  29:main.c        **** 
  30:main.c        **** 
  31:main.c        **** //Draws a diagonal white line on a red background...
  32:main.c        **** // I think it's supposed to repeat three times and not fill the entire
  33:main.c        **** // screen... though it's been a long time since I've used this.
  34:main.c        **** //#define SEG_LINE TRUE
  35:main.c        **** 
  36:main.c        **** //A very nice test-pattern... shows a sine-wave, the under-side of which
  37:main.c        **** // is horizontal color-bars, above it is vertical color-bars. 
  38:main.c        **** // Above that is two lines of text, showing all available characters
  39:main.c        **** // And above that is color-patterns using up the remaining Row-Segments
  40:main.c        **** // This is meant to be rotated 90-degrees
  41:main.c        **** // Like SEG_HFM, it might be handy to adjust NUM_SEGMENTS for experimenting
  42:main.c        **** // Note that color-segments which are too long to be stored in a single
  43:main.c        **** // row-segment are automatically put into the next.
  44:main.c        **** // And that existing segments are automatically stretched if the next-added
  45:main.c        **** // segment is the same color.
  46:main.c        **** // This displays all available colors and shows the resolution capabilities
  47:main.c        **** #define SEG_SINE TRUE
  48:main.c        **** 
  49:main.c        **** //Uses "High-Frequency Modulation" to display an interesting pattern...
  50:main.c        **** // HFM is kinda like PWM. The idea is to have an output ON for
  51:main.c        **** //  a certain percentage of the time...
  52:main.c        **** //  In PWM, that's done by turning it on for a fraction of a cycle 
  53:main.c        **** //  (the "width" of the pulse), then off for the remainder.
  54:main.c        **** //  In HFM, it's accomplished by knowing the fraction of time it should be
  55:main.c        **** //  on... (the "power"). The fractions are automatically reduced 5/10->1/2.
  56:main.c        **** //  e.g. if the on-time should be 1/100th of the time, it will be on
  57:main.c        **** //  during one update-period, and off for 99, then repeat.
  58:main.c        **** //  If the on-time should be 1/2 of the time, it will be on during one
  59:main.c        **** //  update, off during the next, on again, and so-on.
  60:main.c        **** //  If the on-time is some strange fraction, like 3/5, it will distribute
  61:main.c        **** //  the pulses accordingly (e.g. on, off, on, off, on, repeat)
  62:main.c        **** //  Thus, the output toggles as quickly as possible to achieve the desired
  63:main.c        **** //  power... thus "High-Frequency"
  64:main.c        **** //  (See _commonCode.../hfModulation/...)
  65:main.c        **** //  I've been using HFM in ways never originally intended: e.g. it can be
  66:main.c        **** //  used for smoothing lines between two distant points...
  67:main.c        **** //  It's used this way in "SEG_RACER" in order to use a low-resolution
  68:main.c        **** //  course in memory, and increase the resolution by knowing that there are
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 24


  69:main.c        **** //  a certain number of rows in which it has to get from point1 to point2
  70:main.c        **** //  so the "power" of the HFM is set to (p2-p1)/numRows.
  71:main.c        **** //  The nice thing about it, is it doesn't use any actual division (which
  72:main.c        **** //  is quite slow) because it knows that every point inbetween will be 
  73:main.c        **** //  traversed.
  74:main.c        **** // THIS visualizes that, and actually looks pretty cool. Like moire
  75:main.c        **** //  patterns, or magnetic-field-lines.
  76:main.c        **** // Each row increases in power, essentially: rowNum/NUM_SEGMENTS
  77:main.c        **** // (Experimenting with NUM_SEGMENTS is fun, in this case, just don't exceed
  78:main.c        **** //  the available memory, and keep in mind that there's a stack and stuff)
  79:main.c        **** //#define SEG_HFM		TRUE
  80:main.c        **** // You can override NUM_SEGMENTS here, for that purpose...
  81:main.c        **** // OTHERWISE, it should probably be handled in rowSegBuffer.c
  82:main.c        **** #if(defined(SEG_HFM) && SEG_HFM)
  83:main.c        ****  #define NUM_SEGMENTS   127 //128 //95//96//128 //68 //128//68
  84:main.c        **** #endif
  85:main.c        **** 
  86:main.c        **** //Displays a Question-Mark box, ala Mario-Brothers. Press the button and
  87:main.c        **** // receive an award (and occasional goomba)
  88:main.c        **** // Demonstrates usage of program-memory-based images... (16x16 pixels WOO!)
  89:main.c        **** //#define SEG_QUESTION	TRUE
  90:main.c        **** 
  91:main.c        **** //A Game! Ala "Racer" from the ol' TI-82 days...
  92:main.c        **** // Use a potentiometer to try to keep the "car" on the race-track
  93:main.c        **** // It gets harder the longer you stay on course!
  94:main.c        **** // (Ideally: when this isn't true, remove ADC stuff from the makefile
  95:main.c        **** //  to save codespace. I don't think I've ever actually paid attention to
  96:main.c        **** //  this...)
  97:main.c        **** //#define SEG_RACER 	TRUE
  98:main.c        **** 
  99:main.c        **** 
 100:main.c        **** 
 101:main.c        **** 
 102:main.c        **** 
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        **** 
 106:main.c        **** //#warning "This needs to be moved... and conditional"
 107:main.c        **** //#include "rowSegBuffer.c"
 108:main.c        **** 
 109:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
 110:main.c        **** #define pgm_readImageByte(image, row, col)   \
 111:main.c        **** 	   pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
 112:main.c        **** 
 113:main.c        **** 
 114:main.c        **** 
 115:main.c        **** // I hereby declare this FPD-Link simulation technique to forever be called
 116:main.c        **** //  PW-BANGing
 117:main.c        **** 
 118:main.c        **** 
 119:main.c        **** //For testing of slower LVDS pixel-rates
 120:main.c        **** // (maybe we can increase the resolution)
 121:main.c        **** // value must be 1, 2, 4, or 8
 122:main.c        **** // This is overridden by 8 when SLOW_LVDS_TEST is true...
 123:main.c        **** // If commented-out the default of 1 is used...
 124:main.c        **** // AFAICT, this only increases codesize in HLow_delay...
 125:main.c        **** // CHANGING THIS MIGHT AFFECT DISPLAYABILITY...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 25


 126:main.c        **** // One place to look is the delay_cyc in drawPix
 127:main.c        **** //  Currently 1, 2, and 8 seem to work.
 128:main.c        **** //  8 no longer works, noticed a/o v46
 129:main.c        **** #define LVDS_PRESCALER 8//2//1//8//2//4//8//2//8//2
 130:main.c        **** //8//2//1//2//2//2//2//2//2//2//2//2//2//2//8//4 //1 //2//4//8//2//4
 131:main.c        **** 
 132:main.c        **** 
 133:main.c        **** //#define LIFE TRUE
 134:main.c        **** #if (defined(LIFE) && LIFE)
 135:main.c        ****  #include "lifeStuff.c"
 136:main.c        **** #endif
 137:main.c        **** 
 138:main.c        **** #define ROW_SEG_BUFFER	TRUE
 139:main.c        **** //now, SEG_STRETCH >= 3 causes weirdness... (repeated rows)
 140:main.c        **** // previously 3 was OK
 141:main.c        **** // This is fixed a/o newSeg, etc.
 142:main.c        **** #define SEG_STRETCH 5//4//3//2//3//4//6//3//4//6	//Stretch pixels using longer segments
 143:main.c        **** 
 144:main.c        **** #if (defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
 145:main.c        ****  #warning "ROW_SEG_BUFFER requires ROW_BUFFER, but this is a hack"
 146:main.c        ****  #if (!defined(LVDS_PRESCALER) || (LVDS_PRESCALER < 2))
 147:main.c        ****   #error "ROW_SEG_BUFFER uses 20cyc/pixel, which isn't compatible with ROW_BUFFER -> width=64, sinc
 148:main.c        ****  #endif
 149:main.c        ****  #define ROW_BUFFER TRUE
 150:main.c        ****  #include "rowSegBuffer.c"
 151:main.c        **** #endif
 152:main.c        **** 
 153:main.c        **** #define ROW_BUFFER TRUE
 154:main.c        **** #if (defined(ROW_BUFFER) && ROW_BUFFER)
 155:main.c        ****  #include "rowBuffer.c"
 156:main.c        **** #endif
 157:main.c        **** 
 158:main.c        **** //Only valid with ROW_BUFFER=TRUE above:
 159:main.c        **** //#define HORIZONTAL_COLOR_BARS TRUE
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** 
 163:main.c        **** 
 164:main.c        **** 
 165:main.c        **** 
 166:main.c        **** 
 167:main.c        **** 
 168:main.c        **** 
 169:main.c        **** 
 170:main.c        **** //See its old definition elsewhere
 171:main.c        **** #define NUM_PSEGS (1024/3+16)
 172:main.c        **** 
 173:main.c        **** 
 174:main.c        **** 
 175:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
 176:main.c        **** 	#include _ADC_HEADER_
 177:main.c        **** //	#include <stdio.h>
 178:main.c        **** 
 179:main.c        **** //Returns 0-9 or -1 if we've reached 0...
 180:main.c        **** int8_t grabDecimal_u32(uint32_t value, uint8_t newVal)
 181:main.c        **** {
 182:main.c        ****    static uint32_t divisor = 1000000000;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 26


 183:main.c        **** 
 184:main.c        ****    static uint32_t thisVal;
 185:main.c        **** 
 186:main.c        ****    if(newVal)
 187:main.c        ****    {
 188:main.c        ****       divisor = 1000000000;
 189:main.c        ****       thisVal = value;
 190:main.c        ****    }
 191:main.c        **** 
 192:main.c        ****    uint8_t decimal = 0;
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** 
 196:main.c        ****    if(divisor == 0)
 197:main.c        ****       return -1;
 198:main.c        **** 
 199:main.c        ****    while(thisVal >= divisor)
 200:main.c        ****    {
 201:main.c        ****       decimal++;
 202:main.c        ****       thisVal -= divisor;
 203:main.c        **** 
 204:main.c        ****    }
 205:main.c        **** 
 206:main.c        **** 
 207:main.c        **** 
 208:main.c        **** 
 209:main.c        ****    divisor /= 10;
 210:main.c        **** 
 211:main.c        ****    return decimal;
 212:main.c        **** }
 213:main.c        **** 
 214:main.c        **** 
 215:main.c        **** //Including raceWidth, and maybe some buffer...
 216:main.c        **** #define RACE_WIDTH_PSEGS	272
 217:main.c        **** 
 218:main.c        **** 
 219:main.c        **** void showScore(uint16_t rowNum, uint32_t score, uint8_t color)
 220:main.c        **** {
 221:main.c        **** 
 222:main.c        **** 	//The first few rows aren't displaying?
 223:main.c        **** //		rowNum-=6;
 224:main.c        **** 		int8_t decimal;
 225:main.c        **** 		uint8_t scoreFound = FALSE;
 226:main.c        **** 
 227:main.c        **** 		static uint32_t thisScore;
 228:main.c        **** 
 229:main.c        **** 		if(rowNum == 0)
 230:main.c        **** 			thisScore = score; // goodCount;
 231:main.c        **** 
 232:main.c        **** 		decimal = grabDecimal_u32(thisScore, 1);
 233:main.c        **** 
 234:main.c        **** 		uint8_t col;
 235:main.c        **** 
 236:main.c        **** 		uint8_t charRow = 0;
 237:main.c        **** 
 238:main.c        **** 		for(col=0; col<NUM_PSEGS-3-RACE_WIDTH_PSEGS; col++)
 239:main.c        **** 		{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 27


 240:main.c        **** //			uint8_t charRow = 0;
 241:main.c        **** 			
 242:main.c        **** 			if(col%8==0)
 243:main.c        **** 			{
 244:main.c        **** 				if((decimal != 0) && (decimal != -1))
 245:main.c        **** 					scoreFound = TRUE;
 246:main.c        **** 
 247:main.c        **** 				if((decimal == -1) || (!scoreFound))
 248:main.c        **** 					charRow = 0;
 249:main.c        **** 				else
 250:main.c        **** 					charRow = getCharRow(decimal+'0', rowNum/2);
 251:main.c        **** 				decimal = grabDecimal_u32(thisScore, 0);
 252:main.c        **** 			}
 253:main.c        **** 
 254:main.c        **** 			if(getbit(col%8, charRow))
 255:main.c        **** 				addSegfb(1,color);
 256:main.c        **** 			else
 257:main.c        **** 				addSegfb(1,_B);
 258:main.c        **** 		}
 259:main.c        **** }	
 260:main.c        **** 
 261:main.c        **** #endif
 262:main.c        **** 
 263:main.c        **** 
 264:main.c        **** 
 265:main.c        **** 
 266:main.c        **** 
 267:main.c        **** 
 268:main.c        **** 
 269:main.c        **** 
 270:main.c        **** //Options LTN, IDT, or TESTVALS
 271:main.c        **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
 272:main.c        **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 273:main.c        **** 
 274:main.c        **** //For Red and Green (NOT Blue) This enables four shades, instead of three
 275:main.c        **** // (including black)
 276:main.c        **** // Doing so increases pixel-processing time, thus the pixel-widths
 277:main.c        **** // (thus decreasing resolution)
 278:main.c        **** // each color takes 9 cycles to process in three-shade mode
 279:main.c        **** // or 12 cycles for red and green, plus 9 for blue in four-shade mode
 280:main.c        **** #define FOUR_SHADES TRUE
 281:main.c        **** 
 282:main.c        **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 283:main.c        **** //  it seems the speed (at least for the LTN) isn't so important after all
 284:main.c        **** //  This could be used to my advantage...
 285:main.c        **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
 286:main.c        **** //  Thus, pixels could be skinnier, thus higher-resolution.
 287:main.c        **** //   Or more instructions could be used for the same resolution
 288:main.c        **** //   allowing, e.g. sprites from program-memory, without necessitating a
 289:main.c        **** //   large (or any?) frame-buffer...
 290:main.c        **** 
 291:main.c        **** 
 292:main.c        **** //This used to be handled by TOOFAST_TEST, but now can be configured here
 293:main.c        **** // 0xff sets the processor to run as fast as possible 
 294:main.c        **** //  (~16MHz? ~128MHz bit-rate)
 295:main.c        **** // 0x00 sets it as slow as possible (~4MHz, ~32MHz bit-rate)
 296:main.c        **** //  good for testing whether odd colors
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 28


 297:main.c        **** //  or bad syncing is due to bits being shifted, etc. 
 298:main.c        **** //  Maybe due to slow "LVDS" conversion chips, or whatnot.
 299:main.c        **** //   This seems to be the case right now... 0xff: black is appearing green
 300:main.c        **** //   There should be *some* green in it, but not this much.
 301:main.c        **** //   Likely due to different propagation delays between my under-driven
 302:main.c        **** //    74LS86's (running red and green), from 3.3V!
 303:main.c        **** //    and the happier and newer 74AHC XOR and OR currently driving the
 304:main.c        **** //    clock and DVH/Blue signals
 305:main.c        **** //  Highly dependent on the screen itself, some may not run at all with
 306:main.c        **** //  such slow bitrates... heck, some may not run at all even at the fastest
 307:main.c        **** // If SLOW_EVERYTHING_TEST is true, this value is overridden
 308:main.c        **** // LTN last used 0x20
 309:main.c        **** #define OSCCAL_VAL	0xff//0x20//0xff //0x00
 310:main.c        **** 
 311:main.c        **** //This would normally be 0 for the highest-speed frame-refresh possible
 312:main.c        **** // However, increasing this value can slow the frame-refresh rate
 313:main.c        **** //   if desired
 314:main.c        **** // e.g. 50000 causes it to refresh ~ every few seconds
 315:main.c        **** //   (durn-near the limit for how long the LCD will retain an image)
 316:main.c        **** // The benefit being that it doesn't flicker at annoying rates for
 317:main.c        **** //  stationary images
 318:main.c        **** //  worth exploring...
 319:main.c        **** // This may be highly dependent on the screen capabilities...
 320:main.c        **** //   of course, this sorta thing is undocumented
 321:main.c        **** //   it just has to be experimented with
 322:main.c        **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 323:main.c        **** //   likely be driven DC... not sure what the long term effects are.
 324:main.c        **** // This could be a hell of a lot more sophisticated...
 325:main.c        **** // e.g. refresh after a frameBuffer change
 326:main.c        **** //      refresh based on a seconds-timer
 327:main.c        **** //      ...
 328:main.c        **** // AS-IS: Does refreshes completely independent of the frame-buffer
 329:main.c        **** //      if it's too slow, some images may be missed completely.
 330:main.c        **** //      This is not true for FRAME_SYNC TRUE (below)
 331:main.c        **** //      (and it's not really useful anymore with FRAME_SYNC)
 332:main.c        **** #define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 333:main.c        **** 
 334:main.c        **** //SHOULD PROBABLY BE REVISITED
 335:main.c        **** // It probably doesn't work with all cases...
 336:main.c        **** // Definitely with drawPix/Images...
 337:main.c        **** //This causes main o update the image *after* FRAME_UPDATE_DELAY
 338:main.c        **** #define FRAME_SYNC TRUE
 339:main.c        **** 
 340:main.c        **** //New Idea:
 341:main.c        **** // Disable the Hsync timer interrupt after the frame completes
 342:main.c        **** //  and reenable elsewhere...
 343:main.c        **** //  (It seems pixels changing from one shade to another take an
 344:main.c        **** //   intermediate step halfway between)
 345:main.c        **** //  (Thus, two updates then a pause might clear that up)
 346:main.c        **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 347:main.c        **** //   is the same...)
 348:main.c        **** //  (but it is an interesting effect)
 349:main.c        **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 350:main.c        **** //  Reworded: Having several frame refreshes before a pause helps to
 351:main.c        **** //  "solidify" the color changes... especially the sharp changes 
 352:main.c        **** //  (e.g. yellow<->black)
 353:main.c        **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 29


 354:main.c        **** //   in LCDdirect that was only connected such that R, G, and B were each
 355:main.c        **** //   either full-off or full-on, i.e. all Red bits were connected to a
 356:main.c        **** //   single output pin (full on when 1, full off when 0).
 357:main.c        **** //   I hadn't attributed it to improper refresh synchronization
 358:main.c        **** //   as the refresh rate was too fast to see... That's a handy way to get
 359:main.c        **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 360:main.c        **** //  connected with each color 
 361:main.c        **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 362:main.c        **** //  If you WANT this effect (for intermediate shades?) 
 363:main.c        **** //   set FRAME_COUNT_TO_DELAY to 1
 364:main.c        **** //  Then, each change of color will (apparently) result in a value halfway
 365:main.c        **** //   between the old color and the new color
 366:main.c        **** //  Not sure whether it's an electrical problem, but these half-shades 
 367:main.c        **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 368:main.c        **** //   depends on the goal...
 369:main.c        **** #define FRAME_COUNT_TO_DELAY 2//7//1//5//2//3
 370:main.c        **** 
 371:main.c        **** 
 372:main.c        **** //These two are mutually-exclusive (BLUE_VERT_BAR overrides DE_BLUE)
 373:main.c        **** // (BLUE_DIAG_BAR overrides both...)
 374:main.c        **** 
 375:main.c        **** 
 376:main.c        **** // Default is drawPix, from program memory...
 377:main.c        **** 
 378:main.c        **** //These are only used in drawPix...
 379:main.c        **** //This probably has no purpose outside of COLOR_BAR_SCROLL below
 380:main.c        **** // Actually, it's kinda funny watcching the top of the smiley's
 381:main.c        **** // head scroll... like he's getting a brain transplant
 382:main.c        **** //#define PIXEL_SCROLL TRUE
 383:main.c        **** 
 384:main.c        **** //This is only valid in drawPix with an image...
 385:main.c        **** #define IMAGE_CHANGE TRUE
 386:main.c        **** 
 387:main.c        **** 
 388:main.c        **** //#define COLOR_BAR_SCROLL TRUE
 389:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
 390:main.c        **** 
 391:main.c        **** //#warning "COLOR_BAR_SCROLL is broken a/o v29, possibly earlier"
 392:main.c        **** // Probably just a timing issue...
 393:main.c        **** 
 394:main.c        **** //Optional, but only useful here...
 395:main.c        ****  #define PIXEL_SCROLL TRUE
 396:main.c        **** 
 397:main.c        ****  //Handles all the displayable colors in a single row for scrolling...
 398:main.c        ****  #define FB_WIDTH 64 //28
 399:main.c        ****  //Two different arrangements of colors...
 400:main.c        ****  #define FB_HEIGHT 2
 401:main.c        **** 
 402:main.c        **** #else //drawPix from program memory
 403:main.c        ****  #define FB_WIDTH	16
 404:main.c        ****  #define FB_HEIGHT 16
 405:main.c        **** #endif
 406:main.c        **** 
 407:main.c        **** 
 408:main.c        **** 
 409:main.c        **** //DC_DE is only used in drawPix...
 410:main.c        **** //#define DC_DE_DISABLE TRUE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 30


 411:main.c        **** //This should remove DC from Vsync, etc...
 412:main.c        **** // Currently only implemented with FULL_INIT_TESTS below...
 413:main.c        **** //#define REMOVE_DC TRUE
 414:main.c        **** 
 415:main.c        **** //#define FULL_INIT_TESTS TRUE
 416:main.c        **** 
 417:main.c        **** 
 418:main.c        **** //#define BLUE_DIAG_BAR TRUE
 419:main.c        **** 
 420:main.c        **** //A single black bar, followed by a single blue bar... ~1/3 and 2/3's width
 421:main.c        **** //#define BLUE_VERT_BAR TRUE
 422:main.c        **** 
 423:main.c        **** //#define DE_BLUE TRUE
 424:main.c        **** // NONE SELECTED DOESN'T SYNC!!! DE not detected???
 425:main.c        **** 
 426:main.c        **** 
 427:main.c        **** //#define DE_ONLY_DISPLAY	TRUE
 428:main.c        **** 
 429:main.c        **** 
 430:main.c        **** //a/0 v24, this allows the clock signal to be affected by DT
 431:main.c        **** // if it works, we'll be able to use Green on /OC1B
 432:main.c        **** // Sort of works... Blues with DT=0 are good, timing's not screwed
 433:main.c        **** // but blues with DT!=0 are damn-near black except for a light pixel
 434:main.c        **** // before-hand
 435:main.c        **** //a/0 v26, this is now required for Green IN MODES OTHER THAN DRAWPIX
 436:main.c        **** // Not sure where that note makes sense...
 437:main.c        **** // a/o 56-36-3ish it's been removed completely.
 438:main.c        **** //DO NOT define CLOCK_INSENSITIVITY_TESTING TRUE
 439:main.c        **** 
 440:main.c        **** // Rather than *possibly* mess with timing (on other displays?)
 441:main.c        **** // Also for testing...
 442:main.c        **** //#define DT0_BLUES_ONLY	TRUE
 443:main.c        **** 
 444:main.c        **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 445:main.c        **** // LTN appears to be content with my pseudo-LVDS scheme.
 446:main.c        **** // IAXG has never unblanked
 447:main.c        **** //      Even though suitable timings were found with SwitchResX
 448:main.c        **** //      Maybe due to psuedo-LVDS
 449:main.c        **** //            slight timing issues // It probably doesn't work with all cases...
 450:main.c        **** // Definitely with drawPix/Images...(RC oscillator variances?)
 451:main.c        **** //            glitches when switching LVDS states 
 452:main.c        **** //                 (thought I had that figured out, originally)
 453:main.c        **** //      The fact the LTN appears to recognize the signalling suggests the
 454:main.c        **** //      IAXG would be worth further exploration...
 455:main.c        **** //         Unfortunately, the CCFT blew out my inverter
 456:main.c        **** //                        And I must have put it back together incorrectly
 457:main.c        **** //                        (backlight filters out of order or flipped?)
 458:main.c        **** //                        (which actually makes for some very interesting
 459:main.c        **** //                         visuals, but hard to develop with)
 460:main.c        **** //      IAXG: uses DE, V, and H
 461:main.c        **** //             At low pixel-clock DE is active for fewer pixels...
 462:main.c        **** //              Last Tested: 680 was full-screen
 463:main.c        **** //             Nice because it increases the frame-rate!
 464:main.c        **** //      LTN:  uses DE only
 465:main.c        **** 
 466:main.c        **** 
 467:main.c        **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 31


 468:main.c        **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 469:main.c        **** //  (Though I am currently running with OSCAL set to the highest frequency
 470:main.c        **** //   and the PLL seems to be syncing at about 128MHz)
 471:main.c        **** 
 472:main.c        **** 
 473:main.c        **** // Wiring:
 474:main.c        **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 475:main.c        **** //   simplest of all:
 476:main.c        **** //
 477:main.c        **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 478:main.c        **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 479:main.c        **** //   It's spec'd to run from 4.5-5.5V, and its propagatio delays and slew
 480:main.c        **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 481:main.c        **** //     yet it's working...
 482:main.c        **** //   Further, the output voltages are right in the LVDS range,
 483:main.c        **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
 484:main.c        **** //      (Don't forget the LCD has a 100ohm resistor between
 485:main.c        **** //         RXinN/clk+ and RXinN/clk-)
 486:main.c        **** //   Most signals are connected as shown (RXin0, RXin2, RXclk)
 487:main.c        **** //   Green is the only one which has RXin1- and RXin1+ swapped
 488:main.c        **** //     since it is on the /OC1B (inverted) output
 489:main.c        **** //   Green may benefit from a pull-up resistor on /OC1B
 490:main.c        **** //     there was some weird noise appearing like a floating-input
 491:main.c        **** //     when the full frame was not filled with pixels
 492:main.c        **** //     (but it should've waited to disable /OC1B until *after* the delays,
 493:main.c        **** //      etc. So I'm not sure what it was)
 494:main.c        **** //
 495:main.c        **** //   It's probably best to use two XORs from the same chip for a single
 496:main.c        **** //    LVDS channel, since different chips may have slightly different
 497:main.c        **** //    characteristics. 
 498:main.c        **** //
 499:main.c        **** //   The entire circuit, thus, requires TWO 74LS86's 
 500:main.c        **** //    (four XORs apiece, two per LVDS channel, 8-total)
 501:main.c        **** //
 502:main.c        **** //
 503:main.c        **** //              VCC3V3   VCC3V3
 504:main.c        **** //                |        |
 505:main.c        **** //                +---\ \-_
 506:main.c        **** //                     | |    -
 507:main.c        **** //                     | | XOR   >------> RXinN/clk-
 508:main.c        **** //   AVR               | |    _-
 509:main.c        **** //   OC1x >----+------/ /___-
 510:main.c        **** //   output    |
 511:main.c        **** //             |   
 512:main.c        **** //             |      
 513:main.c        **** //             `------\ \-_
 514:main.c        **** //                     | |    -
 515:main.c        **** //                     | | XOR   >------> RXinN/clk+
 516:main.c        **** //                     | |    _-
 517:main.c        **** //                +---/ /___-
 518:main.c        **** //                |        |
 519:main.c        **** //               GND      GND
 520:main.c        **** //
 521:main.c        **** //  
 522:main.c        **** //  Also used: The TTL 74AHC series...
 523:main.c        **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 524:main.c        **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 32


 525:main.c        **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 526:main.c        **** //     (with a 100ohm load in the LCD)
 527:main.c        **** //
 528:main.c        **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 529:main.c        **** //     channels, I had to implement Red and Green with the LS 
 530:main.c        **** //     before switching all channels to the LS... Using different chips
 531:main.c        **** //     (specifically, different TYPES of chips) for different channels
 532:main.c        **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 533:main.c        **** //     signals are synchronized, but the red and green signals were shifted
 534:main.c        **** //     a bit or two (resulting in "Black" appearing green, of course
 535:main.c        **** //     true black isn't really possible with my timing scheme... see below)
 536:main.c        **** //
 537:main.c        **** //  For other circuits attempted, see oldNotes.txt
 538:main.c        **** //     (and boy there were many, involving voltage dividers, AC coupling,
 539:main.c        **** //      reference voltages, BJT differential amplifiers... I doubt I 
 540:main.c        **** //      documented them all, or even most. Whoda thunk the simplest, 
 541:main.c        **** //      especially under- AND over-spec'd--timing, supply voltage, and
 542:main.c        **** //      output voltage--would be the one...?)
 543:main.c        **** //
 544:main.c        **** // LVDS/FPD-Link timing:
 545:main.c        **** 
 546:main.c        **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 547:main.c        **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
 548:main.c        **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 549:main.c        **** //            |____.____.____.____               |____.____.____.____
 550:main.c        **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 551:main.c        **** //            |         |            |         |
 552:main.c        **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 553:main.c        **** //            |                                  |
 554:main.c        **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 555:main.c        **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 556:main.c        **** //            | ^  ^ | 
 557:main.c        **** //            |         |<--Not Blue-->|         |
 558:main.c        **** //            |                                  |
 559:main.c        **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 560:main.c        **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 561:main.c        **** //            | ^ ^  |  
 562:main.c        **** //            |         |<------->|-Not Green    |
 563:main.c        **** //
 564:main.c        **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 565:main.c        **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 566:main.c        **** //            | ^^     
 567:main.c        **** //            |         |<-->|-Not Red
 568:main.c        **** //
 569:main.c        **** //   Of course: The Not Green/Red bits above are low-bits and
 570:main.c        **** //              basically have little/no visible effect
 571:main.c        **** //
 572:main.c        **** //
 573:main.c        **** // Ponderings on using /OC1x's and OC1D for other colors...
 574:main.c        **** //    /OC1D could easily be used for another color, unaffected by others
 575:main.c        **** //          since DT1(L) and OCR1D are unused
 576:main.c        **** //
 577:main.c        **** // DE:   Blue Values
 578:main.c        **** //       -----------
 579:main.c        **** //       OCR1A=4,5,6   (OCR1A=6, Full-Blue would force /OC1A low,
 580:main.c        **** //       DT1(H)=0,1,2                      e.g. Green=Full-Green or Off)
 581:main.c        **** //                      Also: OCR1A=4,5 would affect Green
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 33


 582:main.c        **** //                            (DT1(L) is from this edge...)
 583:main.c        **** //                            DT1(H) also affects complementary OC1D
 584:main.c        **** //
 585:main.c        **** // CLK:  OCR1B=3       CLOCK can NOT be complementary-output mode
 586:main.c        **** //                                   (/OC1B unusuable)
 587:main.c        **** //                                   otherwise, DT1 would affect clock
 588:main.c        **** //
 589:main.c        **** //
 590:main.c        **** // CLOCK_INSENSITIVITY_TESTING:
 591:main.c        **** //   (a/o 56-36-3ish, no longer testable)
 592:main.c        **** //    Testing of DE/Blue's DeadTime values on Clocking...
 593:main.c        **** //    	Image-shift (not sure why, more calculations? Not *that* many!)
 594:main.c        **** //       Blue now has only two shades besides black
 595:main.c        **** //         ~66% and 100%
 596:main.c        **** //       Now each blue pixel (the ones appearing black)
 597:main.c        **** //         is bordered by a blue line...
 598:main.c        **** //    All doable. Would have preferred 3 shades besides black,
 599:main.c        **** //       but two isn't bad.
 600:main.c        **** //
 601:main.c        **** //  New Idea: Since CLOCK can be used with DT1H (during DE)
 602:main.c        **** //    DE/Blue DT values are 0, 1, or 2 (D0, D1, D2)
 603:main.c        **** //     Dn corresponds to the low-to-high dead-timer value
 604:main.c        **** //                   (aka counter-reset delay, on OCR1x)
 605:main.c        **** //     dn corresponds to the high-to-low dead-timer value
 606:main.c        **** //                   (aka OCR match delay, on /OCR1x)
 607:main.c        **** //     Cn corresponds to OCR1x=n
 608:main.c        **** //
 609:main.c        **** // This was easier to comprehend in v<26... now it's more informative
 610:main.c        **** //   but harder to view...
 611:main.c        **** //                          OCR1B = 3
 612:main.c        **** //  TCNT:     |  0   1    2    3  | 4    5    6
 613:main.c        **** //
 614:main.c        **** //  CLKideal: /\______________/
 615:main.c        **** //
 616:main.c        **** //            |____ ____ ____.____v              |
 617:main.c        **** //  CLK:   D0>/ D1>/ D2>/         \    .    .    /
 618:main.c        **** //  OC1B      |           |  |
 619:main.c        **** //            |                   |
 620:main.c        **** //            | G2   G1   B1   B0 | G5   G4   G3
 621:main.c        **** //  Green:    |                   |____ ____ ____
 622:main.c        **** //  /OC1B     \    .    .    . d0>/ d1>/ d2>/ d3?\  //
 623:main.c        **** //            |      
 624:main.c        **** //            |
 625:main.c        **** //            | R1   R0   G0   R5   R4   R3   R2
 626:main.c        **** //  Red:      |____ ____ ____ ____ ____ ____ ____
 627:main.c        **** //  OC1D   D0>/ D1>/ D2>/ C2>\ C3>\ C4>\ C5>\ C6...
 628:main.c        **** //                       
 629:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 630:main.c        **** //  /OC1D     \ ^OCR1D>=6^ L>/  M>/  N>/  O>/ P?>...
 631:main.c        **** //                   
 632:main.c        **** //
 633:main.c        **** //              B3   B2   DE   /V   /H   B5   B4
 634:main.c        **** // "Blue/DVH" |____ ____ ____.____.____ ____ ____
 635:main.c        **** //  OC1A:  D0>/ D1>/ D2>/           C4>\ C5>\ C6...
 636:main.c        **** //            |                  
 637:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 638:main.c        **** //  /OC1A:    \  ^^^--OCR1A>=6--^^^  X>/  Y>/ Z?>\  //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 34


 639:main.c        **** //  (usable?)        
 640:main.c        **** //                 X: OCR1A=4, DTL=0
 641:main.c        **** //                 Y: OCR1A=4, DTL=1; OCR1A=5, DTL=0
 642:main.c        **** //                 Z: OCR1A=4, DTL=2; OCR1A=5, DTL=1; OCR1A>=6
 643:main.c        **** 
 644:main.c        **** //I've looked it over extensively, albiet exhaustedly, and it seems
 645:main.c        **** // there's only one way to do this. Unfortunately, DTH=1,2 *does* affect
 646:main.c        **** // the clocking. Everything displays properly, but the lighter shades of 
 647:main.c        **** // blue enabled by DTH=1,2 don't display at all (or dang-near black)
 648:main.c        **** // So there's really no benefit to using DTH=1,2 during DE for blues...
 649:main.c        **** // That gives two (similar) shades of bright blue 63/63 and 47/63
 650:main.c        **** // *'d are arbitrarily chosen for implementation
 651:main.c        **** // F'd are selected when FOUR_SHADES is TRUE
 652:main.c        **** //   (experimentation might show other choices are better)
 653:main.c        **** //
 654:main.c        **** // Red is connected to OC1D, Complementary output is not necessary
 655:main.c        **** //  OCR1D determines its brightness:
 656:main.c        **** //   (+OC1D => RX0+)
 657:main.c        **** //   *Off (0/63): OCR1D = 0  \      //
 658:main.c        **** //    3/63:			OCR1D = 1   > These three appear identical in glColorTest
 659:main.c        **** //    3/63:			OCR1D = 2  /  (G0 Active, from here down)
 660:main.c        **** //   *35/63:		OCR1D = 3
 661:main.c        **** //   F51/63:		OCR1D = 4
 662:main.c        **** //    59/63:		OCR1D = 5  \  These two appear identical in glColorTest
 663:main.c        **** //   *63/63:		OCR1D >= 6 /
 664:main.c        **** //    (+OC1D => RX0-)
 665:main.c        **** //    Not really worth pursuing, next step from 60/63 is 28/63 then 12
 666:main.c        **** //
 667:main.c        **** // Green is connected to /OC1B (the complementary channel to CLK)
 668:main.c        **** //  Its polarity is reversed (but that's easy since we have a single-ended
 669:main.c        **** //  to differential converter, and its outputs can just be swapped)
 670:main.c        **** //  DTL1 determines its brightness (G0 affected by Red):
 671:main.c        **** //   (/OC1B => RX1+)
 672:main.c        **** //    Off (0/63):	DTL1 = 3 (is this possible?)
 673:main.c        **** //    8-9/63:			DTL1 = 2
 674:main.c        **** //    24-25/63:		DTL1 = 1
 675:main.c        **** //    56-57/63:		DTL1 = 0
 676:main.c        **** //   (/OC1B => RX1-)				(B1,0 Active, as well as G2,1)
 677:main.c        **** //	  *Off (6/63):	DTL1 = 0
 678:main.c        **** //   *38-39/63:		DTL1 = 1
 679:main.c        **** //   F54-55/63:		DTL1 = 2
 680:main.c        **** //   *62-63/63:		DTL1 = 3
 681:main.c        **** //
 682:main.c        **** // Blue, as in previous versions, is connected to OC1A, DTH=0 during DE 
 683:main.c        **** //  so as not to interfere with the clock
 684:main.c        **** //  OCR1A determines the brightness (B1,0 active, per Green->RX1-):
 685:main.c        **** //    (+OC1A => RX2+)			      (B3,2 Active from here down)
 686:main.c        **** //    *Off (15/63):	OCR1A=4
 687:main.c        **** //    *47/63:		 	OCR1A=5
 688:main.c        **** //		*63/63:			OCR1A=6
 689:main.c        **** //
 690:main.c        **** // The clock is single-ended (complementary-mode disabled) during NON-DE
 691:main.c        **** //  because the DE/V/H signals (except in DE mode) require DT1H to vary.
 692:main.c        **** //  When DE is active the clock channel (OC1B) is switched to 
 693:main.c        **** //  complementary-output-mode to enable the Green PWM output
 694:main.c        **** //
 695:main.c        **** // For easier viewing:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 35


 696:main.c        **** //   Red: (+OC1D => RX0+)
 697:main.c        **** //    Off (0/63): OCR1D = 0
 698:main.c        **** //    35/63:      OCR1D = 3
 699:main.c        **** //    51/63:      OCR1D = 4	(FOUR_SHADES only)
 700:main.c        **** //    63/63:      OCR1D >= 6
 701:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 702:main.c        **** //    Off (6/63): DTL1 = 0
 703:main.c        **** //    38-39/63:      DTL1 = 1
 704:main.c        **** //    54-55/63:		DTL1 = 2	(FOUR_SHADES only)
 705:main.c        **** //    62-63/63:      DTL1 = 3
 706:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 707:main.c        **** //    Off (15/63):  OCR1A=4
 708:main.c        **** //    47/63:        OCR1A=5
 709:main.c        **** //    63/63:        OCR1A=6
 710:main.c        **** //
 711:main.c        **** 
 712:main.c        **** // Toward creating a GIMP palette... v54.5
 713:main.c        **** // Probably absurd, but this was brown/orange on GIMP and it's yellow here
 714:main.c        **** //
 715:main.c        **** //   Red: (+OC1D => RX0+)
 716:main.c        **** //    Off (0/63): OCR1D = 0	r=0
 717:main.c        **** //    35/63:      OCR1D = 3	r=142
 718:main.c        **** //    51/63:      OCR1D = 4	r=206
 719:main.c        **** //    63/63:      OCR1D >= 6	r=255
 720:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 721:main.c        **** //    Off (6/63): DTL1 = 0		g=24
 722:main.c        **** //    38-39/63:      DTL1 = 1 g=154
 723:main.c        **** //    54-55/63:		DTL1 = 2	g=218
 724:main.c        **** //    62-63/63:      DTL1 = 3 g=251
 725:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 726:main.c        **** //    Off (15/63):  OCR1A=4	b=61
 727:main.c        **** //    47/63:        OCR1A=5	b=190
 728:main.c        **** //    63/63:        OCR1A=6	b=255
 729:main.c        **** //
 730:main.c        **** //  These numbers don't look entirely accurate...
 731:main.c        **** //    they vary depending on the other colors... and why is blue so high
 732:main.c        **** //    even when it's off?
 733:main.c        **** //  Maybe I'm looking at old notes...?
 734:main.c        **** //   SEE lvdsColorExperiments.c Now Here.
 735:main.c        **** 
 736:main.c        **** 
 737:main.c        **** //  Implementations/prospects:
 738:main.c        **** //  * rowBuffer.c (more like row-settings-buffer)
 739:main.c        **** //     calculate a row's worth of pixels before drawing that row
 740:main.c        **** //     (uses packed color settings in a single byte per drawable pixel)
 741:main.c        **** //     64 drawable pixels across, regardless of LVDS speed
 742:main.c        **** //  * For faster pixels: these settings values could be stored 
 743:main.c        **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 744:main.c        **** //     (not implemented)
 745:main.c        **** //  * rowSegBuffer.c
 746:main.c        **** //     also calculates an entire row before drawing it
 747:main.c        **** //     instead of storing pixels, store "segments"
 748:main.c        **** //     i.e. each segment is defined by a color value and a length
 749:main.c        **** //      the color-value is stored as DT/OCR values (not RGB values)
 750:main.c        **** //     Number of segments is limited only by memory...
 751:main.c        **** //      e.g. 64 segments per row (max) is 64*3Bytes
 752:main.c        **** //       Three bytes for color, and *really simple* packing for seg-length
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 36


 753:main.c        **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 754:main.c        **** //       as high as one LCD pixel.
 755:main.c        **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 756:main.c        **** //      (with packing)
 757:main.c        **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 758:main.c        **** //      only adds two clock cycles to each "pixel", so probably worth it
 759:main.c        **** 
 760:main.c        **** //   In Any Case: There's not enough RAM for a full frame
 761:main.c        **** //          64 pixels across * 64 pixels down is 4096 bytes
 762:main.c        **** //          So whatever method, we need to precalculate each row before
 763:main.c        **** //          displaying it
 764:main.c        **** //          Could be as simple as loading direct from program memory
 765:main.c        **** //
 766:main.c        **** 
 767:main.c        **** // Since low-bits are barely visible, their effect is neglected.
 768:main.c        **** //   Thus: Green is affected only by the Compare-Match deadTimer (DT1L)
 769:main.c        **** //         Red is affected only by OCR1D, and could be single-ended
 770:main.c        **** //   OTOH:
 771:main.c        **** //         The Visible blue values (with DT affecting clock)
 772:main.c        **** //         are only the high-two values, which are affected only by OCR1A
 773:main.c        **** //         So counter-reset dead-time (DT1H) needn't be varied
 774:main.c        **** //         And, then, the clock won't be affected at all
 775:main.c        **** //         (assuming we set it to single-ended during DE disabled, for V/H)
 776:main.c        **** //
 777:main.c        **** // NEW CONSIDERATION: "The dead timer delays the waveform by a minimum of
 778:main.c        **** //    "of one count, when DT=0..."
 779:main.c        **** // So changing the clock from single-ended to complementary
 780:main.c        **** //   might actually cause the clock output to be shifted!
 781:main.c        **** 
 782:main.c        **** 
 783:main.c        **** // DE/V/H Timing (LCDdirectLVDS):
 784:main.c        **** //  
 785:main.c        **** //
 786:main.c        **** //            |  0   1    2    3    4    5    6       All: set @ 0
 787:main.c        **** //            |____.____.____.____                         OCR1C = 6 
 788:main.c        **** //  Clock:    /                   \    .    .    /         Complementary-
 789:main.c        **** //                                             Output Mode
 790:main.c        **** //                                                          required for DT
 791:main.c        **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 792:main.c        **** //             ____ ____ ____ ____ ____ ____ ____|____    
 793:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 794:main.c        **** //   state2                      |    
 795:main.c        **** //   DE_BLUE: >|    DT=X, OCR=0
 796:main.c        **** //                         Watch the transition!! -------^
 797:main.c        **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 798:main.c        **** //   DC_DISABLED:
 799:main.c        **** //   maxBlue: >\____|		DT=0, OCR=5
 800:main.c        **** //             See below for more blue settings...
 801:main.c        **** //
 802:main.c        **** //             ____ ____      ____      ____ ____|____ 
 803:main.c        **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 804:main.c        **** //   state1              | 
 805:main.c        **** //            >______________/\______________|    DT=3, OCR=3
 806:main.c        **** //  DC_DISABLED:
 807:main.c        **** //   Not much can be done...
 808:main.c        **** //
 809:main.c        **** //             ____ ____           ____ ____ ____|____ 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 37


 810:main.c        **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 811:main.c        **** //   state3              |
 812:main.c        **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 813:main.c        **** // DC_DISABLED:
 814:main.c        **** //            >___________________/\____|		DT=4, OCR=5
 815:main.c        **** 
 816:main.c        **** //             ____ ____                ____ ____|____ 
 817:main.c        **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 818:main.c        **** //   state4          | 
 819:main.c        **** //            >__________________________________|    DT=X, OCR=0
 820:main.c        **** //                             TransitionWatch!!! -------^
 821:main.c        **** //                             Shouldn't matter... DT from no-edge
 822:main.c        **** // DC_DISABLED:
 823:main.c        **** //            >\________________________|		DT=0, OCR=1
 824:main.c        **** 
 825:main.c        **** //             ____ ____      ____ ____ ____ ____|____ 
 826:main.c        **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 827:main.c        **** //   state0                  |     
 828:main.c        **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 829:main.c        **** // DC_DISABLED:
 830:main.c        **** //            >______________/\____|		DT=3, OCR=5
 831:main.c        **** 
 832:main.c        **** // Transitions: OLD!!!!! WRONG!!!!
 833:main.c        **** //   (are they? There're several additional transitions, now, for one.)
 834:main.c        **** //  The idea is to reduce the number of instructions between each
 835:main.c        **** //  LVDS "state."
 836:main.c        **** //  These are implemented below in the case:
 837:main.c        **** //    "#else //NOT FULL_INIT_TESTS"
 838:main.c        **** //  Since each instruction takes *longer than* a single pixel
 839:main.c        **** //    two instructions would *at best* occur on two consecutive pixels
 840:main.c        **** //    Thus, there's likely to be a transition-glitch
 841:main.c        **** //    (e.g. old OCR value with new DT value)
 842:main.c        **** //  Note that the new DT values are implemented at the next corresponding
 843:main.c        **** //    edge after the DT-write instruction completes
 844:main.c        **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 845:main.c        **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 846:main.c        **** //    New OCR values are delayed until the next TCNT reset to 0
 847:main.c        **** //
 848:main.c        **** //  Initial:
 849:main.c        **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 850:main.c        **** 
 851:main.c        **** //  Nada	->	H			OCR=2
 852:main.c        **** //  H		->	Nada		OCR=NADA_OCR
 853:main.c        **** //  
 854:main.c        **** //  Nada	->	V			DT=3
 855:main.c        **** //  V		->	V+H		OCR=0
 856:main.c        **** //  V+H	->	V			OCR=NADA_OCR
 857:main.c        **** //  V		->	Nada		DT=2
 858:main.c        **** //
 859:main.c        **** //  Nada	->	DE			DT=1
 860:main.c        **** //  DE	->	Nada		DT=2
 861:main.c        **** 
 862:main.c        **** 
 863:main.c        **** #if (defined(REMOVE_DC) && REMOVE_DC)
 864:main.c        **** #error "REMOVE_DC hasn't been tested since lcdStuff, or long prior"
 865:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 866:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 38


 867:main.c        ****  //Unused, normally...
 868:main.c        ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 869:main.c        ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
 870:main.c        ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 871:main.c        ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
 872:main.c        ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 873:main.c        **** 
 874:main.c        **** #else //!REMOVE_DC
 875:main.c        **** //Nada init
 876:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 877:main.c        **** 
 878:main.c        **** //Unused, normally...
 879:main.c        ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 880:main.c        ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 881:main.c        ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 882:main.c        **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 883:main.c        ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
 884:main.c        ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 885:main.c        **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 886:main.c        ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 887:main.c        **** #endif //REMOVE_DC
 888:main.c        **** 
 889:main.c        **** 
 890:main.c        **** //#define FULL_INIT_TESTS TRUE
 891:main.c        **** 
 892:main.c        **** //Display is DE-Only (doesn't use H/Vsync)
 893:main.c        **** // Shouldn't be necessary to select this if it is,
 894:main.c        **** // since DE timing is the same either way
 895:main.c        **** // but I want to test whether a single-bit is being detected
 896:main.c        **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 897:main.c        **** //  single bit, which might explain why the other display didn't work)
 898:main.c        **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
 899:main.c        **** #define Vsync_fromNada()      Nada_init()
 900:main.c        **** #define VplusH_fromVsync()    Nada_init()
 901:main.c        **** #define Vsync_fromVplusH()    Nada_init()
 902:main.c        **** #define Nada_fromVsync()      Nada_init()
 903:main.c        **** #define Hsync_fromNada()      Nada_init()
 904:main.c        **** #define Nada_fromHsync()      Nada_init()
 905:main.c        **** #define DEonly_fromNada()     DE_init()
 906:main.c        **** #define DEblue_fromDEonly()	DE_init()
 907:main.c        **** #define Nada_fromDEblue()		Nada_init()
 908:main.c        ****  #if(DE_BLUE)
 909:main.c        ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 910:main.c        ****   #warning "...The display should be blank"
 911:main.c        ****  #endif
 912:main.c        **** //Use full initialization of each LVDS state
 913:main.c        **** // (might not be good during transitions, but should guarantee
 914:main.c        **** //  steady-state, in case my transitions aren't correct...)
 915:main.c        **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 916:main.c        **** #define Vsync_fromNada()		Vsync_init()
 917:main.c        **** #define VplusH_fromVsync()		VplusH_init()
 918:main.c        **** #define Vsync_fromVplusH()		Vsync_init()
 919:main.c        **** #define Nada_fromVsync()		Nada_init()
 920:main.c        **** #define Hsync_fromNada()		Hsync_init()
 921:main.c        **** #define Nada_fromHsync()		Nada_init()
 922:main.c        **** #define DEonly_fromNada()		DEonly_init()
 923:main.c        **** #define DEblue_fromDEonly()	DEblue_init()
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 39


 924:main.c        **** #define Nada_fromDEonly()		Nada_init()
 925:main.c        **** #define Nada_fromDEblue()		Nada_init()
 926:main.c        **** 
 927:main.c        **** 
 928:main.c        **** #else	//NOT FULL_INIT_TESTS
 929:main.c        **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 930:main.c        **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 931:main.c        **** 																	 //for easy-scoping
 932:main.c        **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 933:main.c        **** #define VplusH_fromVsync() { OCR1A=0; }
 934:main.c        **** //#define Vsync_fromVplusH() { OCR1A=4; }
 935:main.c        **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
 936:main.c        **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 937:main.c        **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 938:main.c        **** #define Hsync_fromNada()   { OCR1A=3; }
 939:main.c        **** #define Nada_fromHsync()   { OCR1A=4; }
 940:main.c        **** 
 941:main.c        **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 942:main.c        **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 943:main.c        **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 944:main.c        **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 945:main.c        **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 946:main.c        **** 
 947:main.c        **** /*
 948:main.c        **** #if (!defined(DE_BLUE) || !DE_BLUE)
 949:main.c        ****  //Nada -> DE
 950:main.c        ****  //#define DE_fromNada()      { DT1=(1<<4); }	//DT1 = (1<<4);
 951:main.c        ****  #define DE_fromNada()      { DT1=(2<<4); }
 952:main.c        ****  //DE -> Nada
 953:main.c        ****  //#define Nada_fromDE()      { DT1=(2<<4); }	//DT1 = (2<<4);
 954:main.c        ****  #define Nada_fromDE()      { DT1=(3<<4); }
 955:main.c        **** #else
 956:main.c        ****  //Nada -> DE
 957:main.c        ****  //#define DE_fromNada()      { OCR1A=0xff; }   //DT1 = (1<<4);
 958:main.c        ****  #define DE_fromNada()      { OCR1A=0xff; }
 959:main.c        ****  //DE -> Nada
 960:main.c        ****  //#define Nada_fromDE()      { OCR1A=3; }   //DT1 = (2<<4);
 961:main.c        ****  #define Nada_fromDE()      { OCR1A=4; }
 962:main.c        **** #endif
 963:main.c        **** */
 964:main.c        **** #endif //End Of FULL_INIT_TESTS
 965:main.c        **** 
 966:main.c        **** 
 967:main.c        **** 
 968:main.c        **** // NOTES:
 969:main.c        **** //    DeadTimer requires
 970:main.c        **** //        COM1x1:0 = 01 ("Complementary Compare Output Mode" ?)
 971:main.c        **** //      Complementary Compare Output Mode:
 972:main.c        **** //        OCW1A: cleared on match, set at BOTTOM
 973:main.c        **** //    If PWM1X (pwm inversion) is used, OC1A = !OCW1A
 974:main.c        **** //        (Does not affect DT)
 975:main.c        **** //
 976:main.c        **** // CLOCK:
 977:main.c        **** //    Can NOT use differential mode with:
 978:main.c        **** //		 OC1B pin is -differential input (through a resistor)
 979:main.c        **** //    /OC1B pin is +differential input (through a resistor)
 980:main.c        **** //    BECAUSE: DeadTimer affects ALL PWM channels
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 40


 981:main.c        **** //
 982:main.c        **** 
 983:main.c        **** //
 984:main.c        **** //
 985:main.c        **** // ISSUES:
 986:main.c        **** //    Using Dead-Timer does not allow for use of complementary outputs
 987:main.c        **** //      as complementary LVDS inputs... 
 988:main.c        **** //      DeadTimer affects ALL PWM channels in complementary mode
 989:main.c        **** //    (e.g. RXclkin+ on OC1B and RXclkin- on /OC1B is not an option)
 990:main.c        **** //
 991:main.c        **** 
 992:main.c        **** 
 993:main.c        **** // The typical patterns look like this (not at all to scale):
 994:main.c        **** //   ----______------------------------------------------___----- V
 995:main.c        **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
 996:main.c        **** //      __________-__-__-__-__-__-__-__-__-__-  DE
 997:main.c        **** //                 
 998:main.c        **** //             ^^^^\														//blah
 999:main.c        **** //             1234 5?
1000:main.c        **** // Pixels are sent during DE High (basically all the CPU will be used here)
1001:main.c        **** //Ideally, 
1002:main.c        **** //  there won't be any glitches when changing from one state to another
1003:main.c        **** //
1004:main.c        **** //  NOTES: PWM1X inversion affects all PWM channels!
1005:main.c        **** //
1006:main.c        **** //  Unchangeables:
1007:main.c        **** //    FastPWM
1008:main.c        **** //		inverted with PWM1X
1009:main.c        **** //
1010:main.c        **** //  Init (pre 1):
1011:main.c        **** //    DeadTimerRising=1
1012:main.c        **** //
1013:main.c        **** //  The states are:
1014:main.c        **** //   (Not necessarily accurate, just looking into necessary changes)
1015:main.c        **** //   (from Vsync L->H)
1016:main.c        **** //
1017:main.c        **** //   1  NothingActive (long, No DE, VporchFrontTimes)
1018:main.c        **** //      *  1<=DeadTimerRising<=5
1019:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1020:main.c        **** //      *  OCR1A == 6
1021:main.c        **** //
1022:main.c        **** //   2  Hsync
1023:main.c        **** //      *  DeadTimer _OFF_ -> Horiz
1024:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1025:main.c        **** //        (OCR1A == 6
1026:main.c        **** //   3  NothingActive (short)
1027:main.c        **** //      *  1<=DeadTimerRising<=5
1028:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1029:main.c        **** //        (OCR1A == 6
1030:main.c        **** //   4  DE
1031:main.c        **** //        (1<=DeadTimerRising<(=?)5 (>1 for blue pixels?) 
1032:main.c        **** //            (==5 cancelled by OCR1A match?)
1033:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1034:main.c        **** //      *  OCR1A = 5 (or 1<=OCR1A<5 for blue pixels?)
1035:main.c        **** //   5  NothingActive(?)
1036:main.c        **** //        (1<=DeadTimerRising<=5
1037:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 41


1038:main.c        **** //      *  OCR1A == 6
1039:main.c        **** //
1040:main.c        **** //   7  Repeat 2-5 for each row
1041:main.c        **** //
1042:main.c        **** //   8  NothingActive (long, No DE, VporchBackTimes)
1043:main.c        **** //      ?  1<=DeadTimerRising<=5
1044:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
1045:main.c        **** //        (OCR1A == 6
1046:main.c        **** //
1047:main.c        **** //   9  V w/o H
1048:main.c        **** //      ?  OFF <= DeadTimer <= (5 - OCR1A)
1049:main.c        **** //     **  OCW1A: cleared at BOTTOM, set at OCR1A
1050:main.c        **** //            ??? What is the effect of changing this while running?
1051:main.c        **** //      *  1 <= OCR1A <= 5
1052:main.c        **** //   10 V w/  H
1053:main.c        **** //      ?   DeadTimer OFF (H -> Low)
1054:main.c        **** //      *   OCW1A: set @ BOTTOM, cleared @ OCR1A
1055:main.c        **** //      *   OCR1A > (=?) OCR1C
1056:main.c        **** //
1057:main.c        **** //   11 Repeat 9-10 for Vsync time...
1058:main.c        **** //
1059:main.c        **** 
1060:main.c        **** // Here's how it worked pre-lvds:
1061:main.c        **** // HSYNC, VSYNC, and DE refer to the actual pins
1062:main.c        **** // In the LVDS setup, there're modes corresponding to each pin-combination
1063:main.c        **** //
1064:main.c        **** // Timer Interrupt:
1065:main.c        **** //  loadData:
1066:main.c        **** //   HSYNC active
1067:main.c        **** //   HSYNC Low delay
1068:main.c        **** //   HSYNC inactive
1069:main.c        **** //   if(dataEnable)
1070:main.c        **** //    DE active
1071:main.c        **** //     Send row data
1072:main.c        **** //    DE inactive
1073:main.c        **** //  //Prep for next interrupt
1074:main.c        **** //  switch(hsyncCount++)
1075:main.c        **** //    //Vsync H->L (active)
1076:main.c        **** //    1:
1077:main.c        **** //          dataEnable=FALSE
1078:main.c        **** //          VSYNC active
1079:main.c        **** //    //Vsync L->H (inactive)
1080:main.c        **** //    T_Vlow:
1081:main.c        **** //          VSYNC inactive
1082:main.c        **** //    //Start of frame
1083:main.c        **** //    T_VD +(T_Vlow):
1084:main.c        **** //          dataEnable=TRUE
1085:main.c        **** //    //All rows have been displayed
1086:main.c        **** //    V_COUNT +(T_VD+T_Vlow):
1087:main.c        **** //          dataEnable=FALSE
1088:main.c        **** //    //Frame Complete
1089:main.c        **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
1090:main.c        **** //          hsyncCount=0
1091:main.c        **** //  if(dataEnable)
1092:main.c        **** //    Use the remaining time to load the next row to memory
1093:main.c        **** 
1094:main.c        **** //  So:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 42


1095:main.c        **** //Interrupt0       End
1096:main.c        **** //    |             |  Interrupt1
1097:main.c        **** //    v             v  v
1098:main.c        **** //  H |_||_||_|
1099:main.c        **** // DE ___________________________________________________ ...
1100:main.c        **** //  V |_____________________________________ ...
1101:main.c        **** //       |        ||
1102:main.c        **** // DETIME^--------^|
1103:main.c        **** //                 |
1104:main.c        **** //                 VSYNC active
1105:main.c        **** //                 dataEnable=FALSE (not necessary?)
1106:main.c        **** //
1107:main.c        **** //InterruptT_Vlow   End
1108:main.c        **** //    |             |
1109:main.c        **** //    v             v
1110:main.c        **** //  H |_||_||_|
1111:main.c        **** // DE ___________________________________________________ ...
1112:main.c        **** //  V _____________| ...
1113:main.c        **** //       |        ||
1114:main.c        **** // DETIME^--------^|
1115:main.c        **** //                 |
1116:main.c        **** //                 VSYNC inactive
1117:main.c        **** //
1118:main.c        **** //
1119:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1120:main.c        **** //    |             |  |            End
1121:main.c        **** //    v             v  v            v
1122:main.c        **** //  H |_||_||_|
1123:main.c        **** // DE ____________________||_______||____ ...
1124:main.c        **** //  V 
1125:main.c        **** //       |        ||      |        |
1126:main.c        **** // DETIME^--------^|      ^--------^
1127:main.c        **** //                 |
1128:main.c        **** //                 dataEnable=TRUE
1129:main.c        **** //
1130:main.c        **** //InterruptV_COUNT  End
1131:main.c        **** //    |             |
1132:main.c        **** //    v             v
1133:main.c        **** //  H |_||_||_|
1134:main.c        **** // DE ___||______________________________________ ...
1135:main.c        **** //  V 
1136:main.c        **** //       |        ||      |        |
1137:main.c        **** // DETIME^--------^|      ^--------^
1138:main.c        **** //                 |
1139:main.c        **** //                 dataEnable=FALSE
1140:main.c        **** //
1141:main.c        **** //
1142:main.c        **** // This isn't really a state, it's basically just:
1143:main.c        **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
1144:main.c        **** //    hsyncCount = 0;
1145:main.c        **** //                    .....................................
1146:main.c        **** //                    .                                   .
1147:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1148:main.c        **** //    |             | .|                                  .
1149:main.c        **** //    v             v .v                                  .
1150:main.c        **** //  H |_||_||_|
1151:main.c        **** // DE ___________________________________________________ .
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 43


1152:main.c        **** //  V |____________________ .
1153:main.c        **** //       |        ||  .   |        |                      .
1154:main.c        **** // DETIME^--------^|  .   ^--------^                      .
1155:main.c        **** //                 |  .                                   .
1156:main.c        **** //                 hsyncCount=0 (repeat from Interrupt0)  .
1157:main.c        **** //                    .                                   .
1158:main.c        **** //                    .....................................
1159:main.c        **** //
1160:main.c        **** 
1161:main.c        **** 
1162:main.c        **** // NOW to compare with LVDS states:
1163:main.c        **** //
1164:main.c        **** //Interrupt0       End
1165:main.c        **** //    |             |  Interrupt1
1166:main.c        **** //    v             v  v
1167:main.c        **** //  H |_||_||_|
1168:main.c        **** // DE ___________________________________________________ ...
1169:main.c        **** //  V |_____________________________________ ...
1170:main.c        **** //    ^ ^          ^   ^ ^
1171:main.c        **** //    | |          |   | |
1172:main.c        **** //    | |          |   | +--- V w/o H  \ These two toggle until
1173:main.c        **** //    | |          |   +----- V w/ H   / next LCD state...
1174:main.c        **** //    | |          |
1175:main.c        **** //    | |          +--------- V w/o H > Intermediate change of state
1176:main.c        **** //    | |
1177:main.c        **** //    | +----- NothingActive  \ From Previous State (?)
1178:main.c        **** //    +------- H_Only         /
1179:main.c        **** 
1180:main.c        **** 
1181:main.c        **** //InterruptT_Vlow   End
1182:main.c        **** //    |             |
1183:main.c        **** //    v             v
1184:main.c        **** //  H |_||_||_|
1185:main.c        **** // DE ___________________________________________________ ...
1186:main.c        **** //  V _____________| ...
1187:main.c        **** //    ^ ^          ^   ^ ^
1188:main.c        **** //    | |          |   | |
1189:main.c        **** //    | |          |   | +--- NothingActive  \ These two toggle until
1190:main.c        **** //    | |          |   +----- H_Only         / next LCD state...
1191:main.c        **** //    | |          |
1192:main.c        **** //    | |          +--------- NothingActive > Intermediate change of state
1193:main.c        **** //    | |
1194:main.c        **** //    | +----- V w/o H   \ From previous state
1195:main.c        **** //    +------- V w/ H    /
1196:main.c        **** 
1197:main.c        **** 
1198:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1199:main.c        **** //    |             |  |            End
1200:main.c        **** //    v             v  v            v
1201:main.c        **** //  H |_||_||_|
1202:main.c        **** // DE ____________________||_______||____ ...
1203:main.c        **** //  V 
1204:main.c        **** //    ^ ^              ^ ^^        ^ 
1205:main.c        **** //    | |              | ||        |
1206:main.c        **** //    | |              | ||        +--- NothingActive  \  These four
1207:main.c        **** //    | |              | |+------------ DE              | cycle until
1208:main.c        **** //    | |              | +------------- NothingActive   | next LCD state...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 44


1209:main.c        **** //    | |              +--------------- H_Only  ^      /
1210:main.c        **** //    | |                                       |
1211:main.c        **** //    | +----- NothingActive  \ From previous   |
1212:main.c        **** //    +------- H_Only         / state           +-This intermediate state
1213:main.c        **** //                                                may not be necessary
1214:main.c        **** //                                                (IAXG01 shows 160 dots!)
1215:main.c        **** 
1216:main.c        **** 
1217:main.c        **** 
1218:main.c        **** //InterruptV_COUNT  End
1219:main.c        **** //    |             |
1220:main.c        **** //    v             v
1221:main.c        **** //  H |_||_||_|
1222:main.c        **** // DE ___||______________________________________ ...
1223:main.c        **** //  V 
1224:main.c        **** //    ^ ^^        ^    ^ ^
1225:main.c        **** //    | ||        |    | |
1226:main.c        **** //    | ||        |    | +--- NothingActive \  These two toggle
1227:main.c        **** //    | ||        |    +----- H_Only        /  until next LCD state
1228:main.c        **** //    | ||        |
1229:main.c        **** //    | ||        +---- NothingActive \ 								//blah
1230:main.c        **** //    | |+------------- DE             |  From previous state
1231:main.c        **** //    | +-------------- NothingActive  |
1232:main.c        **** //    +---------------- H_Only        /
1233:main.c        **** 
1234:main.c        **** // This isn't really a state, it's essentially just:
1235:main.c        **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
1236:main.c        **** //    hsyncCount = 0;
1237:main.c        **** //                    .....................................
1238:main.c        **** //                    .                                   .
1239:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1240:main.c        **** //    |             | .|                                  .
1241:main.c        **** //    v             v .v                                  .
1242:main.c        **** //  H |_||_||_|
1243:main.c        **** // DE ___________________________________________________ .
1244:main.c        **** //  V |____________________ .
1245:main.c        **** //    ^ ^             .                                   .
1246:main.c        **** //    | |             .....................................
1247:main.c        **** //    | +--- NothingActive \											//blah
1248:main.c        **** //    +----- H_Only        / From previous state...
1249:main.c        **** 
1250:main.c        **** 
1251:main.c        **** 
1252:main.c        **** //  LVDS State transitions:
1253:main.c        **** //   1 H_Only
1254:main.c        **** //   2 NothingActive
1255:main.c        **** //
1256:main.c        **** //   3 V w/o H
1257:main.c        **** //   4 V w/ H
1258:main.c        **** //    
1259:main.c        **** //   (repeat 3,4)
1260:main.c        **** //
1261:main.c        **** //   5 V w/o H
1262:main.c        **** //
1263:main.c        **** //   6 NothingActive
1264:main.c        **** //   7 H_Only
1265:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 45


1266:main.c        **** //   (repeat 6,7)
1267:main.c        **** //
1268:main.c        **** //   8 NothingActive
1269:main.c        **** //
1270:main.c        **** //   9 H_Only
1271:main.c        **** //  10 NothingActive
1272:main.c        **** //  11 DE
1273:main.c        **** //  12 NothingActive
1274:main.c        **** //
1275:main.c        **** //  (repeat 9-12)
1276:main.c        **** //
1277:main.c        **** //  13 H_Only
1278:main.c        **** //  14 NothingActive
1279:main.c        **** //
1280:main.c        **** //  (repeat 13-14)
1281:main.c        **** //
1282:main.c        **** //   These should be reviewed to determine which changes are necessary
1283:main.c        **** //   between each state...
1284:main.c        **** //   (the fewer changes, the less likely we'll glitch...?)
1285:main.c        **** 
1286:main.c        **** 
1287:main.c        **** // This'll probably be better rearranged...
1288:main.c        **** //  For now, though, OC1A is in all the notes above, for the D/V/H signal
1289:main.c        **** //  so OC1B is for the clock...
1290:main.c        **** // CHANGING THESE does NOT change channel association.
1291:main.c        **** #define DVH_OCR	OCR1A
1292:main.c        **** #define CLOCK_OCR	OCR1B
1293:main.c        **** 
1294:main.c        **** 
1295:main.c        **** void pll_enable(void)
1296:main.c        **** {
1297:main.c        **** 	//Stolen from threePinIDer109t:
1298:main.c        **** 
1299:main.c        ****    //Set Timer1 to use the "asynchronous clock source" (PLL at 64MHz)
1300:main.c        ****    // With phase-correct PWM (256 steps up, then back down) and CLKDIV1
1301:main.c        ****    // this is 64MHz/512=125kHz
1302:main.c        ****    // The benefit of such high PWM frequency is the low RC values necessary
1303:main.c        ****    //  for filtering to DC.
1304:main.c        ****    // "To change Timer/Counter1 to the async mode follow this procedure"
1305:main.c        ****    // 1: Enable the PLL
1306:main.c        ****    setbit(PLLE, PLLCSR);
1307:main.c        ****    // 2: Wait 100us for the PLL to stabilize
1308:main.c        ****    // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
1309:main.c        ****    _delay_us(100);
1310:main.c        **** //   dmsWait(1);
1311:main.c        ****    // 3: Poll PLOCK until it is set...
1312:main.c        ****    while(!getbit(PLOCK, PLLCSR))
1313:main.c        ****    {
1314:main.c        ****       asm("nop");
1315:main.c        ****    }
1316:main.c        ****    // 4: Set the PCKE bit to enable async mode
1317:main.c        ****    setbit(PCKE, PLLCSR);
1318:main.c        **** 
1319:main.c        **** }
1320:main.c        **** 
1321:main.c        **** void lvds_timerInit(void)
1322:main.c        **** {
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 46


1323:main.c        ****    //Timer1 is used for LVDS (in PLL clocking mode)
1324:main.c        ****   
1325:main.c        ****   	//pll_enable();	
1326:main.c        ****    
1327:main.c        ****    //We want it to count 7 bits, 0-6 and reset at 7
1328:main.c        ****    OCR1C = 6;
1329:main.c        **** 
1330:main.c        **** 	//We want the clock to go low at TCNT=0 and high at TCNT=4
1331:main.c        **** 	CLOCK_OCR = 3; //2; //3;
1332:main.c        ****    
1333:main.c        **** 
1334:main.c        **** // My 'scope is only 20MHz, and I'd rather be able to use the digital mode
1335:main.c        **** // which is even slower...
1336:main.c        **** 
1337:main.c        **** 
1338:main.c        **** //Overridden when SLOW_EVERYTHING_TEST is true...
1339:main.c        **** //#define TOOFAST_TEST TRUE
1340:main.c        **** #warning "HERE AND BELOW, doesn't OSCCAL have special write requirements?"
1341:main.c        **** //OSCCAL = 0x00;
1342:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1343:main.c        **** //FOR TESTING. This should slow the clock...
1344:main.c        **** 	// Gives roughly 4MHz...
1345:main.c        **** 	OSCCAL = 0x00; //0x80; 
1346:main.c        **** 
1347:main.c        **** 	// This should divide the system clock by 256
1348:main.c        **** 	// does this affect the PLL? NO.
1349:main.c        **** 	// The PLL is clocked only by the RC Oscillator
1350:main.c        **** 	//   OSCCAL does affect it.
1351:main.c        **** 	// OPTIONS FOR SIMULATING FULL FUNCTIONALITY AT LOW SPEED:
1352:main.c        **** 	// Run PLL as normal
1353:main.c        **** 	//  Prescale Timer1 and DeadTimer equally
1354:main.c        **** 	//  Prescale System clock equally
1355:main.c        **** 	CLKPR = (1<<CLKPCE);
1356:main.c        **** 	CLKPR = (1<<CLKPS1) | (1<<CLKPS0);	//CLKDIV8
1357:main.c        **** 	//4MHz / 8 = .5Mhz...
1358:main.c        **** 	//PLL is 4MHz*8 = 32MHz
1359:main.c        **** 	// then TimerClockDivisor=8 gives 4MHz
1360:main.c        **** 	pll_enable();
1361:main.c        **** 	#define SLOW_LVDS_TEST TRUE
1362:main.c        **** #elif (defined(OSCCAL_VAL))
1363:main.c        ****    OSCCAL = OSCCAL_VAL;
1364:main.c        **** #endif
1365:main.c        **** 
1366:main.c        **** 
1367:main.c        **** 
1368:main.c        **** #if (defined(SLOW_LVDS_TEST) && SLOW_LVDS_TEST)
1369:main.c        **** 	//This case doesn't really make sense without SLOW_EVERYTHING...
1370:main.c        **** 	//8x prescaler for Timer1
1371:main.c        **** 	#define CSBITS (1<<CS12)
1372:main.c        **** 	//8x prescaler for the dead-timer
1373:main.c        **** 	#define DTPSBITS ((1<<DTPS11) | (1<<DTPS10))
1374:main.c        **** #elif (defined(LVDS_PRESCALER))
1375:main.c        **** 	//Timer1 on the Tiny861 uses a strange CLKDIV scheme...
1376:main.c        **** 	// (but it's nicer!)
1377:main.c        **** 	// The divisor is (1<<(csbits-1))
1378:main.c        **** 	// so a divisor of 1 = (1<<0) = (1<<(1-1)), (csbits = 0x1)
1379:main.c        **** 	// 256 = (1<<8) = (1<<(9-1)), (csbits = 0x9)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 47


1380:main.c        **** 	// 512 = (1<<9) = (1<<(10-1)), (csbits = 0xA)
1381:main.c        **** 	// ...
1382:main.c        **** 	// (0x0 stops the timer)
1383:main.c        **** 	/*
1384:main.c        **** 		uint16_t divisor;
1385:main.c        **** 		uint8_t csbits = 0;
1386:main.c        **** 		for(divisor=CLKDIV; divisor != 0; divisor>>=1)
1387:main.c        **** 		   csbits++;
1388:main.c        **** 			writeMasked(csbits, 0x0f, TCCR1B);
1389:main.c        **** 	*/
1390:main.c        **** 
1391:main.c        **** //#if ((LVDS_PRESCALER != 64) && (LVDS_PRESCALER != 32) && \
1392:main.c        **** //	  (LVDS_PRESCALER != 16) && 
1393:main.c        **** #if ((LVDS_PRESCALER != 8) && \
1394:main.c        **** 	  (LVDS_PRESCALER != 4)  && (LVDS_PRESCALER != 2) && \
1395:main.c        **** 	  (LVDS_PRESCALER != 1))
1396:main.c        **** #error "LVDS_PRESCALER must be a power of 2, from 1 to 8"
1397:main.c        **** #endif
1398:main.c        **** 
1399:main.c        **** 	//Figured this out in cTools/dePower.c...
1400:main.c        **** 	//64 is overkill here, since the deadTimer prescaler only goes to 8...
1401:main.c        **** #define divToCS(div) \
1402:main.c        **** 	( (div == 64) ? 7 : (div == 32) ? 6 : (div == 16) ? 5 : (div == 8) ? 4 \
1403:main.c        **** 	  : (div == 4) ? 3 : (div == 2) ? 2 : (div == 1) ? 1 : 0)
1404:main.c        **** 
1405:main.c        **** 
1406:main.c        **** 	//CSBITS (through PLL/8) (CS10 is bit 0)
1407:main.c        **** 	//CS12:10	CS12	CS11	CS10		PLL division
1408:main.c        **** 	//1			0		0		1			1
1409:main.c        **** 	//2			0		1		0			2
1410:main.c        **** 	//3			0		1		1			4
1411:main.c        **** 	//4			1		0		0			8
1412:main.c        **** 	#define CSBITS divToCS(LVDS_PRESCALER) //<<CS10 should be redundant
1413:main.c        **** 	//DTPSBITS (DTPS10 is bit 4)
1414:main.c        **** 	//DTPS11:10	DTPS11 DTPS10	PLL division
1415:main.c        **** 	//0			0		0			1
1416:main.c        **** 	//1			0		1			2
1417:main.c        **** 	//2			1		0			4
1418:main.c        **** 	//3			1		1			8
1419:main.c        **** 	#define DTPSBITS ((CSBITS-1)<<DTPS10)
1420:main.c        **** 
1421:main.c        **** 	//Whoops! Forgot this (a/o 42-som'n WTF1pix)
1422:main.c        **** 	// so, it's promising to get single-pixel control...
1423:main.c        **** 	//  the result was kinda ugly, though... scroll was quite slow
1424:main.c        **** 	// Further, it was only drawing a certain number of pixels...
1425:main.c        **** 	//  (horizontally... pre LVDS_PRESCALER affecting DOTS_TO_CYC)
1426:main.c        **** 	//  so accessing *all* pixels in a row would make it even slower...
1427:main.c        **** 	// Further, it didn't seem to be paying attention to the fact that
1428:main.c        **** 	// the same pixels are drawn on multiple rows...
1429:main.c        **** 	// WTF? (the image was scaled, proportionately! 1pix x 1pix)
1430:main.c        **** 	pll_enable();
1431:main.c        **** 
1432:main.c        **** #else
1433:main.c        **** 	//No clock divisor
1434:main.c        **** 	#define CSBITS (1<<CS10)
1435:main.c        **** 	//No dead-timer divisor
1436:main.c        **** 	#define DTPSBITS 0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 48


1437:main.c        **** 	pll_enable();
1438:main.c        **** 	//#warning "The PLL configuration code is not in here yet!"
1439:main.c        **** #endif
1440:main.c        **** 
1441:main.c        **** 	//Set the Timer1 clock prescaler...
1442:main.c        **** 	writeMasked(CSBITS, 
1443:main.c        **** 					((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)),
1444:main.c        **** 					TCCR1B);
1445:main.c        **** 
1446:main.c        **** 	//Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
1447:main.c        **** 	// Allegedly this is prescaled from the PCK (or CK)
1448:main.c        **** 	// 	NOT from the Timer1 prescaler...
1449:main.c        **** 	writeMasked(DTPSBITS,
1450:main.c        **** 					((1<<DTPS11) | (1<<DTPS10)),
1451:main.c        **** 					TCCR1B);
1452:main.c        **** 
1453:main.c        **** 
1454:main.c        **** 
1455:main.c        ****    //All LVDS modes (and signals) use FastPWM.. 
1456:main.c        ****  
1457:main.c        ****    //FastPWM
1458:main.c        **** //Now Handled in lvds_xxxOnCompare():
1459:main.c        **** 
1460:main.c        **** 	//These are also written below (excluding PWM1D)
1461:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
1462:main.c        ****                            //Need to do the same for other channels
1463:main.c        ****   
1464:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
1465:main.c        **** 
1466:main.c        **** 	setbit(PWM1D, TCCR1C);
1467:main.c        **** 
1468:main.c        **** 	//PWM1D is not in TCCR1A...
1469:main.c        **** 
1470:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
1471:main.c        **** //	setoutPORT(PB0, PORTB);	//-OC1A 	MOSI unused
1472:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
1473:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
1474:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
1475:main.c        **** 
1476:main.c        **** 
1477:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
1478:main.c        ****                ((1<<WGM11) | (1<<WGM10)), // (affects all PWM channels)
1479:main.c        ****                TCCR1D);
1480:main.c        **** 
1481:main.c        **** 	//OC1A is used, but /OC1A isn't
1482:main.c        **** // Not Valid (deadTime only functions if in complementary-mode):
1483:main.c        **** 	// OTOH: dead-time is not necessary in the only case we need to switch
1484:main.c        **** 	// Most lvds states use clear on compare-match, set at 0
1485:main.c        **** 	// But there is one that uses the opposite
1486:main.c        **** 	// This can be toggled by a single bit-change
1487:main.c        **** 	//  COM1A1 = 1
1488:main.c        **** 	//  COM1A0 value indicates what happens on Compare-Match
1489:main.c        **** 	//					  or ! at BOTTOM
1490:main.c        **** //#define lvds_clrOnCompare() clrbit(COM1A0, TCCR1A)
1491:main.c        **** //#define lvds_setOnCompare() setbit(COM1A0, TCCR1A)
1492:main.c        **** 	//HOWEVER: the alternative is possible:
1493:main.c        **** 	// Use complementary (clear-on-compare)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 49


1494:main.c        **** 	// and single-ended with set-on-compare
1495:main.c        **** 	// COM1A0 = 1
1496:main.c        **** 	// COM1A1 value indicates what happens on Compare-Match
1497:main.c        **** 
1498:main.c        **** /* These are three instructions apiece!
1499:main.c        **** #define lvds_ComplementaryClrOnCompare() clrbit(COM1A1, TCCR1A)
1500:main.c        **** 
1501:main.c        **** #define lvds_setOnCompare() setbit(COM1A1, TCCR1A)
1502:main.c        **** #define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1503:main.c        **** */
1504:main.c        **** 
1505:main.c        **** //Page 99:
1506:main.c        **** // "In Fast PWM Mode ... when the COM1x1:0 bits are set to 01 ...
1507:main.c        **** //  an user programmable Dead Time delay is inserted for 
1508:main.c        **** //  these complementary output pairs (OC1x and OC1x)."
1509:main.c        **** 
1510:main.c        **** //Page 98:
1511:main.c        **** // "The counter is loaded with a 4-bit DT1H or DT1L value from DT1 
1512:main.c        **** //  I/O register, depending on the edge of the Waveform 
1513:main.c        **** //  Output (OCW1x) when the dead time insertion is started."
1514:main.c        **** // In other words, (as it appears from the diagram)
1515:main.c        **** //  the dead-time value is loaded into the counter when the corresponding
1516:main.c        **** //  edge in OCW1x is detected
1517:main.c        **** //  So changing the value of DT1 affects the *next* corresponding edge 
1518:main.c        **** //   (NOT if the dead timer is already running)
1519:main.c        **** 
1520:main.c        **** //Page 96:
1521:main.c        **** // "The OCR1x Registers are double buffered when using any of the 
1522:main.c        **** // Pulse Width Modulation (PWM) modes."
1523:main.c        **** // "The double buffering synchronizes the update of the OCR1x 
1524:main.c        **** // Compare Registers to either top or bottom of the counting sequence.
1525:main.c        **** // The synchronization prevents the occurrence of odd-length, non-sym- 
1526:main.c        **** // metrical PWM pulses, thereby making the output glitch-free."
1527:main.c        **** 
1528:main.c        **** //Page 100:
1529:main.c        **** //"A change of the COM1x1:0 bits state will have effect 
1530:main.c        **** // at the first Compare Match after the bits are written."
1531:main.c        **** //Page 97: HAH!
1532:main.c        **** //"Be aware that the COM1x1:0 bits are not double buffered 
1533:main.c        **** // together with the compare value. 
1534:main.c        **** // Changing the COM1x1:0 bits will take effect immediately."
1535:main.c        **** 
1536:main.c        **** 
1537:main.c        **** //#define lvds_setOnCompare()	
1538:main.c        **** //	TCCR1A = ( (1<<COM1A1) | (1<<COM1A0) 
1539:main.c        **** //			   | (0<<COM1B1) | (1<<COM1B0) 
1540:main.c        **** //			   | (1<<PWM1A) | (1<<PWM1B) )
1541:main.c        **** //#define lvds_ComplementaryClrOnCompare() \ //
1542:main.c        **** 	//Do TCCR1C first, because it contains shadow-bits of TCCR1A that I
1543:main.c        **** 	// don't want to have to rewrite...
1544:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
1545:main.c        **** 				| (1<<PWM1D) );
1546:main.c        **** 
1547:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
1548:main.c        ****             | (1<<COM1B1) | (0<<COM1B0) //Don't use complementary for CLK
1549:main.c        ****             | (1<<PWM1A) | (1<<PWM1B) );
1550:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 50


1551:main.c        **** //#define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1552:main.c        **** 
1553:main.c        **** 	// Enable Complementary-Mode (and thus the dead-timer)
1554:main.c        **** 	// This'll be changed as needed, but we need COM1A0 set prior to that
1555:main.c        **** 
1556:main.c        **** 	//	lvds_clrOnCompare();
1557:main.c        **** //	writeMasked(((0<<COM1A1) | (1<<COM1A0)), 
1558:main.c        **** //					((1<<COM1A1) | (1<<COM1A0)), 
1559:main.c        **** //					TCCR1A);
1560:main.c        **** 
1561:main.c        **** 
1562:main.c        **** 
1563:main.c        **** 	//THIS IS NOT THOROUGHLY THOUGHT-OUT...
1564:main.c        **** 	// as I recall, we need to use /OC1B for the clock output
1565:main.c        **** 	//  because it won't be affected by the deadtime...
1566:main.c        **** //Now Handled in lvds_xxxOnCompare():
1567:main.c        **** //	writeMasked(((0<<COM1B1) | (1<<COM1B0)),
1568:main.c        **** //					((1<<COM1B1) | (1<<COM1B0)),
1569:main.c        **** //					TCCR1A);
1570:main.c        **** 
1571:main.c        ****    //Since PWM inversion affects all channels, great-pains were taken
1572:main.c        ****    // to assure that it needn't be changed in any lvds state...
1573:main.c        ****    // PWM inversion must be enabled:
1574:main.c        **** 
1575:main.c        **** 	//inverted with PWM1X
1576:main.c        **** //   setbit(PWM1X, TCCR1B);
1577:main.c        ****  
1578:main.c        ****  	Nada_init();
1579:main.c        **** }
1580:main.c        **** 
1581:main.c        **** 
1582:main.c        **** //PWM Timing:
1583:main.c        **** // (ATTiny861, Timer1, FastPWM, PWM1X;
1584:main.c        **** //  a/o LCDdirectLVDS1_5_PWMtimingTests):
1585:main.c        **** //
1586:main.c        **** //  PWM output on OC1A
1587:main.c        **** //    if OCR1A = 0, OC1A remains constant High
1588:main.c        **** //       OCR1A = 1, OC1A is low for 2 counts
1589:main.c        **** //       OCR1A = 2, OC1A is low for 3 counts
1590:main.c        **** //       OCR1A = 3, OC1A is low for 4 counts
1591:main.c        **** //       OCR1A = OCR1C, OC1A remains constant Low
1592:main.c        **** //
1593:main.c        **** //    THUS:
1594:main.c        **** //       compare-match occurs when TCNT changes AWAY from match
1595:main.c        **** //         (assuming TCNT starts at 0 for one pulse, 1 for one pulse...)
1596:main.c        **** //       TOP (OCR1C) is included in the count...
1597:main.c        **** //       There is no single-count pulse-width
1598:main.c        **** //         (Though, it seems dead-time could simulate it...)
1599:main.c        **** //         (set a deadtime of 1 on the BOTTOM edge and OCR1A)
1600:main.c        **** //         (but then there's no high for only one clock)
1601:main.c        **** 
1602:main.c        **** 
1603:main.c        **** 
1604:main.c        **** 
1605:main.c        **** //This isn't valid, who knows how many instructions the for loop takes
1606:main.c        **** static __inline__ \
1607:main.c        **** void delay_cyc(int32_t numCyc) \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 51


1608:main.c        **** 	  __attribute__((__always_inline__));
1609:main.c        **** 
1610:main.c        **** //This'll optimze-out in some cases.
1611:main.c        **** // The timings and instructions used are probably specific to the
1612:main.c        **** // instruction-set in the MCU, the GCC version, optimization-level, etc.
1613:main.c        **** // a/o LCDdirectLVDS11 HLow_delay() this is how it's compiling...
1614:main.c        **** 
1615:main.c        **** // The actual number of cycs will probably be a few higher...
1616:main.c        **** // (or who knows, if things optimze-out, e.g. small ~0-8 numCycs)
1617:main.c        **** // Due to init, and division...
1618:main.c        **** // Using rounding-up as well...
1619:main.c        **** 
1620:main.c        **** // the argument is int32_t to allow for negative value testing
1621:main.c        **** // BUT: numCyc is only tested against a uint16_t...
1622:main.c        **** //  the greatest value (?) is (UINT16_MAX - 7)
1623:main.c        **** // (maybe it'd make more sense to do the math outside the delay_cyc call
1624:main.c        **** // and allow the preprocessor to change it to 0, instead of doing it here.
1625:main.c        **** 
1626:main.c        **** //This should probably be reimplemented using _delay_loop_1/2() from 
1627:main.c        **** // util/delay_basic.h
1628:main.c        **** //  1 uses three cycles per count, counts from 1-256, 
1629:main.c        **** //		256 counts: _delay_loop_1(0)
1630:main.c        **** //  2 uses four, counts from 1-65536, 65536 is passed as 0
1631:main.c        **** 
1632:main.c        **** #define DELAY_CYC_DELAY_LOOP TRUE//FALSE
1633:main.c        **** 
1634:main.c        **** #if(defined(DELAY_CYC_DELAY_LOOP) && DELAY_CYC_DELAY_LOOP)
1635:main.c        **** #warning "This has only been tested with v54+... rowSegBuffer, etc."
1636:main.c        **** void delay_cyc(int32_t numCyc)
1637:main.c        **** {
1638:main.c        **** 	if(numCyc <= 0)
1639:main.c        **** 		return;
1640:main.c        **** 
1641:main.c        **** 	uint16_t numLoops = (numCyc+3)/4;
1642:main.c        **** 
1643:main.c        **** 	_delay_loop_2(numLoops);
1644:main.c        **** 
1645:main.c        **** /*	uint32_t delayLoops = (numCyc+3)/4;
1646:main.c        **** 
1647:main.c        **** 	do
1648:main.c        **** 	{
1649:main.c        **** 		delayLoops--;
1650:main.c        **** //		_delay_loop_2(delayLoops&0xffff);
1651:main.c        **** 
1652:main.c        **** //		delayLoops -= (delayLoops&0xffff);
1653:main.c        **** 	} while(delayLoops);
1654:main.c        **** */
1655:main.c        **** /*
1656:main.c        **** 	//Since this is inline, AND it's only called with values computed
1657:main.c        **** 	// at compile time, only one of these should be compiled in...
1658:main.c        **** 	// as necessary...
1659:main.c        **** 	// If called without precomputed value (i.e. a variable)????
1660:main.c        **** 	// Maybe I should only use delay_loop_2...
1661:main.c        **** 	if(numCyc < 256*3)
1662:main.c        **** 		_delay_loop_1(numCyc/&0xff);
1663:main.c        **** 
1664:main.c        **** 	else
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 52


1665:main.c        **** */
1666:main.c        **** }
1667:main.c        **** 
1668:main.c        **** #else
1669:main.c        **** void delay_cyc(int32_t numCyc)
1670:main.c        **** {
1671:main.c        **** 
1672:main.c        **** 	//This shouldn't happen often, but some delay_cyc() calls use math
1673:main.c        **** 	// to calculate the number of cycles, and it could be negative
1674:main.c        **** 	if(numCyc < 0)
1675:main.c        **** 		return;
1676:main.c        **** 											//#Clocks
1677:main.c        **** 	//Two instructions:
1678:main.c        **** 	// ldi r24, 0						//1 			i=0
1679:main.c        **** 	// ldi r25, 0						//1
1680:main.c        **** 	uint16_t i;
1681:main.c        **** 
1682:main.c        **** 
1683:main.c        **** 	//Loop instructions:
1684:main.c        **** 	//nop									//1
1685:main.c        **** 	//adiw  r24, 0x01   ; 1			//2 			i++
1686:main.c        **** 	//cpi   r24, 0x77   ; 119		//1 			i<numCyc (119 in this case)
1687:main.c        **** 	//cpc   r25, r1					//1 			Apparently it's also testing
1688:main.c        **** 											//  			the high byte is 0
1689:main.c        **** 	//brne  .-10        ;			//"1/2"		return to nop
1690:main.c        **** 											//				if I understand, this is two
1691:main.c        **** 											//				cyc when branching
1692:main.c        **** 											//				or one if not (when complete)
1693:main.c        **** 
1694:main.c        **** 	//READ THIS:
1695:main.c        **** 	// Current Compilation Settings: A/O v18:
1696:main.c        **** 	//    THIS LOOP WILL BE UNROLLED if numLoops <= 5!!!
1697:main.c        **** 	//    Which then turns into numLoops*2 cycles (instead of numLoops*8)
1698:main.c        **** 	// 
1699:main.c        **** 	// Here's an attempted hack...
1700:main.c        **** 	//  it *should* optimize the test out in either case, so it's like a 
1701:main.c        **** 	//  preprocessing directive...
1702:main.c        **** 	uint16_t numLoops = (((uint16_t)(numCyc)+7)>>3);
1703:main.c        **** 
1704:main.c        **** 
1705:main.c        **** 	// HACK ATTEMPT 2: THATS A LOT OF CODE.
1706:main.c        **** 		switch(numLoops)
1707:main.c        **** 		{
1708:main.c        **** 			case 5:
1709:main.c        **** 				asm("nop");
1710:main.c        **** 				asm("nop");
1711:main.c        **** 				asm("nop");
1712:main.c        **** 				asm("nop");
1713:main.c        **** 				asm("nop");
1714:main.c        **** 				asm("nop");
1715:main.c        **** 				asm("nop");
1716:main.c        **** 				asm("nop");
1717:main.c        **** 			case 4:
1718:main.c        **** 				asm("nop");
1719:main.c        **** 				asm("nop");
1720:main.c        **** 				asm("nop");
1721:main.c        **** 				asm("nop");
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 53


1722:main.c        **** 				asm("nop");
1723:main.c        **** 				asm("nop");
1724:main.c        **** 				asm("nop");
1725:main.c        **** 				asm("nop");
1726:main.c        **** 			case 3:
1727:main.c        **** 				asm("nop");
1728:main.c        **** 				asm("nop");
1729:main.c        **** 				asm("nop");
1730:main.c        **** 				asm("nop");
1731:main.c        **** 				asm("nop");
1732:main.c        **** 				asm("nop");
1733:main.c        **** 				asm("nop");
1734:main.c        **** 				asm("nop");
1735:main.c        **** 			case 2:
1736:main.c        **** 				asm("nop");
1737:main.c        **** 				asm("nop");
1738:main.c        **** 				asm("nop");
1739:main.c        **** 				asm("nop");
1740:main.c        **** 				asm("nop");
1741:main.c        **** 				asm("nop");
1742:main.c        **** 				asm("nop");
1743:main.c        **** 				asm("nop");
1744:main.c        **** 			case 1:
1745:main.c        **** 				asm("nop");
1746:main.c        **** 				asm("nop");
1747:main.c        **** 				asm("nop");
1748:main.c        **** 				asm("nop");
1749:main.c        **** 				asm("nop");
1750:main.c        **** 				asm("nop");
1751:main.c        **** 				asm("nop");
1752:main.c        **** 				asm("nop");
1753:main.c        **** 				return;
1754:main.c        **** 				break;
1755:main.c        **** 			default:
1756:main.c        **** 				break;
1757:main.c        **** 		}
1758:main.c        **** 	// THUS:
1759:main.c        **** 	// Each loop is 7 cycles, make it 8 by adding an extra nop and we can
1760:main.c        **** 	// use >> instead of / for calculations...
1761:main.c        **** 	// +7 assures rounding-up...
1762:main.c        **** #warning "This loop seems to be optimizing out!"
1763:main.c        **** 	//for(i=0; i<((numCyc+7)>>3); i++)
1764:main.c        **** 	for(i=0; i<numLoops; i++)
1765:main.c        **** 	{
1766:main.c        **** 		//THIS IS A HACK DUE TO OPTIMIZATION, see above
1767:main.c        **** 		// It will NOT likely be happy with different versions of gcc...
1768:main.c        **** 	/*	// NOGO: Apparently it won't expand the loop if this is part of it
1769:main.c        **** 		// so then we have 5 loops AND 8 instructions /within/ the loop
1770:main.c        **** 		// AND the comparison overhead!`
1771:main.c        **** 		if(numLoops <= 5)
1772:main.c        **** 		{
1773:main.c        **** 		   asm("nop");
1774:main.c        **** 			asm("nop");
1775:main.c        **** 		//	asm("nop");
1776:main.c        **** 		//	asm("nop");
1777:main.c        **** 		//	asm("nop");
1778:main.c        **** 		//	asm("nop");
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 54


1779:main.c        **** 		}
1780:main.c        **** 		else
1781:main.c        **** 		{
1782:main.c        **** 			asm("nop");
1783:main.c        **** 			asm("nop");
1784:main.c        **** 		}
1785:main.c        **** 	*/
1786:main.c        **** 		//Apparently this loop will optimize-out without this:
1787:main.c        **** 		// Obviously, one instruction each...
1788:main.c        **** 		asm("nop");
1789:main.c        **** 		asm("nop");
1790:main.c        **** 	}
1791:main.c        **** }
1792:main.c        **** #endif
1793:main.c        **** 
1794:main.c        **** //One dot-clock is 7/8ths of a CPU cycle... (prescaler = 1)
1795:main.c        **** //                 14/8ths with prescaler = 2 ...
1796:main.c        **** //
1797:main.c        **** //    1 dot = 7/8 cyc
1798:main.c        **** //    n dots = n * 7/8 cyc
1799:main.c        **** //
1800:main.c        **** //    1 = 1 dot / (7/8) cyc
1801:main.c        **** //    1 = 8 dots / 7 cyc
1802:main.c        **** //
1803:main.c        **** //  With prescaling = 2:
1804:main.c        **** //
1805:main.c        **** //    1 dot = 7/8 * 2 cyc = 14/8 cyc
1806:main.c        **** //   
1807:main.c        **** //    8/14 dots = 1 cyc
1808:main.c        **** //    n dots = n*14/8 cyc
1809:main.c        **** //   
1810:main.c        **** //    I coulda sworn the prescaler was on the divide-side...
1811:main.c        **** //   Also, is there any benefit to adding +7*LVDS_PRESCALER-1 for rounding?
1812:main.c        **** #define DOTS_TO_CYC(dots) ((((dots)*(7l)*(LVDS_PRESCALER))/8))
1813:main.c        **** 
1814:main.c        **** #define delay_Dots(numDots) delay_cyc(DOTS_TO_CYC(numDots))
1815:main.c        **** 
1816:main.c        **** 
1817:main.c        **** //THESE NOTES ARE OLD:
1818:main.c        **** //This has to be changed every time the DE code is changed...
1819:main.c        **** // Actually, I think it should just match IMAGE_WIDTH
1820:main.c        **** //#define FB_WIDTH 28 //21//19
1821:main.c        **** //#define IMAGE_WIDTH 21
1822:main.c        **** 
1823:main.c        **** 
1824:main.c        **** #define TESTVALS	0
1825:main.c        **** #define LTN 1
1826:main.c        **** #define IDT 2
1827:main.c        **** 
1828:main.c        **** 
1829:main.c        **** //TIMING:
1830:main.c        **** //  Measurements below (in microseconds) are referring to preLVDS
1831:main.c        **** //  There may be other such old-notes...
1832:main.c        **** 
1833:main.c        **** 
1834:main.c        **** //        |<--T_Hhigh-->| |<-T_Hlow
1835:main.c        **** //    __   _____________   ____________  3.6V
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 55


1836:main.c        **** // H    |_|             |_|           _  0V
1837:main.c        **** //
1838:main.c        **** //    Data Enable
1839:main.c        **** //       Only active when there's valid pixel data
1840:main.c        **** //       (for 512 of the 717 clocks in HSYNC-active)
1841:main.c        **** //       Low during Vsync... (~720us)
1842:main.c        **** //
1843:main.c        **** 
1844:main.c        **** //IDTech display: 136 dots
1845:main.c        **** //2-136+
1846:main.c        **** //IDTech, last used: 40
1847:main.c        **** //LTN Last used 8
1848:main.c        **** // LTN: 1072-1344-1500 clocks per line, 1024DE... Hsync unused
1849:main.c        **** // SEE Hlow_Delay() notes if this value is large!
1850:main.c        **** 
1851:main.c        **** #if (DISPLAY == LTN)
1852:main.c        **** #define H_LOW_DOTS	8
1853:main.c        **** #elif (DISPLAY == IDT)
1854:main.c        **** #define H_LOW_DOTS   40//8//1//40 //30 //2//136
1855:main.c        **** #elif (DISPLAY == TESTVALS)
1856:main.c        **** #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
1857:main.c        **** 							  // And having a value here increases codesize
1858:main.c        **** #endif
1859:main.c        **** 
1860:main.c        **** 
1861:main.c        **** //H is set low immediately upon entry of the timer interrupt
1862:main.c        **** // its low-time is controlled via nops
1863:main.c        **** // (so if HLow is long for a particular display, this might need revising)
1864:main.c        **** #define Hlow_Delay() \
1865:main.c        **** 	delay_Dots(H_LOW_DOTS)
1866:main.c        **** 
1867:main.c        **** 
1868:main.c        **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1869:main.c        **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
1870:main.c        **** 
1871:main.c        **** 
1872:main.c        **** 
1873:main.c        **** //This was found expermentally with SwitchResX
1874:main.c        **** //IDTech Last Used: 680
1875:main.c        **** //LTN last used 1024
1876:main.c        **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
1877:main.c        **** //        it does, however, affect the vertical(!)
1878:main.c        **** // If I recall Correctly, this is used only for setting the timer interrupt
1879:main.c        **** //  rate...
1880:main.c        **** #if (DISPLAY == LTN)
1881:main.c        **** #define DE_ACTIVE_DOTS	1024
1882:main.c        **** #elif (DISPLAY == IDT)
1883:main.c        **** #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
1884:main.c        **** #elif (DISPLAY == TESTVALS)
1885:main.c        **** #define DE_ACTIVE_DOTS	1024
1886:main.c        **** #endif
1887:main.c        **** 
1888:main.c        **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
1889:main.c        **** 
1890:main.c        **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
1891:main.c        **** //  90-320+
1892:main.c        **** //Horizontal Total Time: 1206-1344-2047
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 56


1893:main.c        **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
1894:main.c        **** // Excess waits should be thrown in DH (since that's between interrupts)
1895:main.c        **** //T_HD is the time from H inactivated to DE activated
1896:main.c        **** //aka H back-porch: 1-160+
1897:main.c        **** //IDTech Last Used: 50
1898:main.c        **** //LTN last used 5
1899:main.c        **** 
1900:main.c        **** #if (DISPLAY == LTN)
1901:main.c        **** #define HD_DOTS 5
1902:main.c        **** #elif (DISPLAY == IDT)
1903:main.c        **** #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
1904:main.c        **** #elif (DISPLAY == TESTVALS)
1905:main.c        **** #define HD_DOTS 50//5
1906:main.c        **** #endif
1907:main.c        **** 
1908:main.c        **** #define HD_Delay()	delay_Dots(HD_DOTS)
1909:main.c        **** 
1910:main.c        **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1911:main.c        **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1912:main.c        **** 
1913:main.c        **** // This is the number of CPU cycles between DE->L and Horiz->L
1914:main.c        **** // This is just used in calculating the OCR value...
1915:main.c        **** // aka H Front Porch: 0-24+
1916:main.c        **** // IDTech Last Used: 24
1917:main.c        **** // LTN last used 46
1918:main.c        **** // 1072-1024-1-1 = 46
1919:main.c        **** #if (DISPLAY == LTN)
1920:main.c        **** #define DH_DOTS	46
1921:main.c        **** #elif (DISPLAY == IDT)
1922:main.c        **** #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
1923:main.c        **** #elif (DISPLAY == TESTVALS)
1924:main.c        **** #define DH_DOTS	0//1000//100//46
1925:main.c        **** #endif
1926:main.c        **** 
1927:main.c        **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1928:main.c        **** 
1929:main.c        **** //       |
1930:main.c        **** //       v
1931:main.c        **** //      T_DH
1932:main.c        **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
1933:main.c        **** // H   __.  ____________  .___________
1934:main.c        **** //      .|_|  .        .|_|  .
1935:main.c        **** //     _.     .________.     .___________
1936:main.c        **** // DE   |_____| 512clk |_____|
1937:main.c        **** //      ^              ^
1938:main.c        **** //       \___________   \                        (just avoiding \ warning)
1939:main.c        **** //                   \  |     768 Hsyncs
1940:main.c        **** //                    v v
1941:main.c        **** //     _             _ _ _ _ _ _ _ _ _ _ 
1942:main.c        **** // DE   |___________| | | | | | | | | | |______
1943:main.c        **** //
1944:main.c        **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1945:main.c        **** 
1946:main.c        **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1947:main.c        **** // IDTech Last Used: 29
1948:main.c        **** // LTN last used 3
1949:main.c        **** //LTN Frame: 772-806-1000 lines...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 57


1950:main.c        **** #if (DISPLAY == LTN)
1951:main.c        **** #define T_VD 3
1952:main.c        **** #elif (DISPLAY == IDT)
1953:main.c        **** #define  T_VD 29 //3//29 //7 //29
1954:main.c        **** #elif (DISPLAY == TESTVALS)
1955:main.c        **** #define T_VD 3
1956:main.c        **** #endif
1957:main.c        **** 
1958:main.c        **** //aka V-sync front porch: 1-3+
1959:main.c        **** // IDTech Last Used: 3
1960:main.c        **** // LTN last used 3
1961:main.c        **** #if (DISPLAY == LTN)
1962:main.c        **** #define T_DV 3
1963:main.c        **** #elif (DISPLAY == IDT)
1964:main.c        **** #define T_DV 3//3 //1 //3
1965:main.c        **** #elif (DISPLAY == TESTVALS)
1966:main.c        **** #define T_DV 3
1967:main.c        **** #endif
1968:main.c        **** 
1969:main.c        **** //1-6+ (1 is used by the first switch-case...)
1970:main.c        **** // IDTech Last Used: 6
1971:main.c        **** // LTN Last used 16
1972:main.c        **** // 772 - 768 - 1 - 1 = 2
1973:main.c        **** #if (DISPLAY == LTN)
1974:main.c        **** #define T_Vlow 16
1975:main.c        **** #elif (DISPLAY == IDT)
1976:main.c        **** #define T_Vlow	6 //16//6 //2 //6
1977:main.c        **** #elif (DISPLAY == TESTVALS)
1978:main.c        **** #define T_Vlow 32
1979:main.c        **** #endif
1980:main.c        **** 
1981:main.c        **** // IDTech Last Used: 768
1982:main.c        **** #if (DISPLAY == LTN)
1983:main.c        **** #define V_COUNT	768
1984:main.c        **** #elif (DISPLAY == IDT)
1985:main.c        **** #define V_COUNT	768
1986:main.c        **** #elif (DISPLAY == TESTVALS)
1987:main.c        ****  #if (LVDS_PRESCALER == 8)
1988:main.c        ****   #define V_COUNT 768
1989:main.c        ****  #else
1990:main.c        ****   #define V_COUNT	(768*2/3)
1991:main.c        ****  #endif
1992:main.c        **** #endif
1993:main.c        **** 
1994:main.c        **** //                       
1995:main.c        **** //                      |           
1996:main.c        **** //                      V           
1997:main.c        **** //              |<-T_DV>|           |<-T_VD-->|
1998:main.c        **** //              .       .           .         .
1999:main.c        **** //     _____________||__.   124us   .____||___________________
2000:main.c        **** //  V           .   ||  |___________|    ||   .
2001:main.c        **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
2002:main.c        **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
2003:main.c        **** //              .   ||                   ||   .
2004:main.c        **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
2005:main.c        **** // DE   | | | | |___||___________________||___| | | | | | | | |
2006:main.c        **** //                  ||                   ||
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 58


2007:main.c        **** //
2008:main.c        **** //                        1
2009:main.c        **** //                        |
2010:main.c        **** //                        v               
2011:main.c        **** //     _________________   ___________________   _____________
2012:main.c        **** //  V                   |_|                   |_|
2013:main.c        **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
2014:main.c        **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
2015:main.c        **** //                          ^
2016:main.c        **** //                          |
2017:main.c        **** //                          2
2018:main.c        **** 
2019:main.c        **** 
2020:main.c        **** 
2021:main.c        **** 
2022:main.c        **** static __inline__ \
2023:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
2024:main.c        **** 	  __attribute__((__always_inline__));
2025:main.c        **** 
2026:main.c        **** //volatile uint8_t rowBuffer[FB_WIDTH] =
2027:main.c        **** //There's not enough memory for a full frame-buffer...
2028:main.c        **** // but this is how LCDdirect worked, and changing it would be a pain.
2029:main.c        **** //uint8_t settingBuffer[FB_HEIGHT][FB_WIDTH]; 
2030:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
2031:main.c        **** uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH];
2032:main.c        **** #else
2033:main.c        **** uint8_t *pimage;
2034:main.c        **** #endif
2035:main.c        **** 
2036:main.c        **** /* in LCDStuff
2037:main.c        **** uint8_t dataEnable = 0;
2038:main.c        **** uint8_t vSync = 0;
2039:main.c        **** uint16_t hsyncCount = 0;
2040:main.c        **** */
2041:main.c        **** 
2042:main.c        **** /* in LCDStuff, along with the if, woot
2043:main.c        **** //frameCount=0 can be used in main to detect whether we've completed a 
2044:main.c        **** //  a frame AND its FRAME_UPDATE_DELAY
2045:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
2046:main.c        **** uint8_t frameCount = 0;
2047:main.c        **** #endif
2048:main.c        **** */
2049:main.c        **** 
2050:main.c        **** static __inline__ \
2051:main.c        **** void loadRow(uint16_t rowNum) \
2052:main.c        **** 	__attribute__((__always_inline__));
2053:main.c        **** 
2054:main.c        **** 
2055:main.c        **** #include _LCDSTUFF_CFILE_
2056:main.c        **** //#include "../../../_commonCode/lcdStuff/0.50ncf/lcdStuff.c"
2057:main.c        **** //#include "lcdUpdate.c"
2058:main.c        **** 
2059:main.c        **** //SIGNAL(TIMER1_COMPA_vect)
2060:main.c        **** SIGNAL(TIMER0_COMPA_vect)
2061:main.c        **** {
2062:main.c        **** 	static uint8_t frameCount = 0;
2063:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 59


2064:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
2065:main.c        **** 	while(TCNT0L != 7){};
2066:main.c        **** 	//This won't work... who knows how many cycles interrupt-entry will be
2067:main.c        **** 	//Above should fix that...
2068:main.c        **** 	//I believe this was only so I'd have something for the 'scope to
2069:main.c        **** 	// trigger on... 
2070:main.c        **** #error "These shouldn't be used anymore, since PB2 is GREEN"
2071:main.c        **** 	setpinPORT(PB2, PORTB);
2072:main.c        **** 	clrpinPORT(PB2, PORTB);
2073:main.c        **** #endif
2074:main.c        **** 
2075:main.c        **** 
2076:main.c        **** 	if(updateLCD())
2077:main.c        **** 	{
2078:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
2079:main.c        **** 			//static uint8_t frameCount = 0;
2080:main.c        **** 			frameCount++;
2081:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
2082:main.c        **** 			{
2083:main.c        **** 				frameCount = 0;
2084:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
2085:main.c        **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
2086:main.c        **** 			}
2087:main.c        **** #endif
2088:main.c        **** 	}
2089:main.c        **** 
2090:main.c        **** #if(defined(LOADROW) && LOADROW)
2091:main.c        **** 	//Load the next row into the row(seg)buffer
2092:main.c        **** 	//data is enabled after T_VD+T_Vlow...
2093:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
2094:main.c        **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
2095:main.c        **** #endif
2096:main.c        **** 	// Here is where loadRow used to be called
2097:main.c        **** 	// it has been moved to oldNotes.txt, but it would make more sense
2098:main.c        **** 	// to look at LCDdirectLVDS <25 or LCDdirect
2099:main.c        **** 	// loadRow used the time between DE inactive and the next Hsync
2100:main.c        **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
2101:main.c        **** 	// thus, DE could gain more pixels because there would be fewer
2102:main.c        **** 	// calculations to determine the memory location to write from
2103:main.c        **** 	// This effect has since been minimized
2104:main.c        **** 	// BUT loadRow might be necessary for program-memory-based images...
2105:main.c        **** }
2106:main.c        **** 
2107:main.c        **** 
2108:main.c        **** #define nibbletochar(val)	\
2109:main.c        **** 	(((val)<=9) ? ((val) + '0') : ((val) + ('A' - 10)))
2110:main.c        **** 
2111:main.c        **** 
2112:main.c        **** #if 0
2113:main.c        **** uint8_t hexColor = 0;
2114:main.c        **** 
2115:main.c        **** static __inline__ \
2116:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[]) \
2117:main.c        **** 	  __attribute__((__always_inline__));
2118:main.c        **** 
2119:main.c        **** //Takes a nibble and makes it a hex character...
2120:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 60


2121:main.c        **** #define HEXCOLOR_TOPROW 32
2122:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[])
2123:main.c        **** {
2124:main.c        **** //	static uint8_t color = 0;
2125:main.c        **** 
2126:main.c        **** 	if( (rbRowNum >= HEXCOLOR_TOPROW) &&
2127:main.c        **** 		 (rbRowNum < HEXCOLOR_TOPROW+8) )
2128:main.c        **** 	{
2129:main.c        **** 		uint8_t charRow1, charRow2;
2130:main.c        **** 		//uint8_t color;
2131:main.c        **** 
2132:main.c        **** 		charRow1 = 
2133:main.c        **** 			getCharRow(nibbletochar((hexColor)>>4), rbRowNum-HEXCOLOR_TOPROW);
2134:main.c        **** 		charRow2 = 
2135:main.c        **** 			getCharRow(nibbletochar(hexColor&0x0f), rbRowNum-HEXCOLOR_TOPROW);
2136:main.c        **** 
2137:main.c        **** 		uint8_t col;
2138:main.c        **** 		for(col=0; col<8; col++)
2139:main.c        **** 		{
2140:main.c        **** 			if(getbit(col, charRow1))
2141:main.c        **** 				rowBuffer[col+1] = fb_to_rb(hexColor);
2142:main.c        **** 			//else
2143:main.c        **** 			//	rowBuffer[col] = fb_to_rb(0x00);
2144:main.c        **** 
2145:main.c        **** 			if(getbit(col, charRow2))
2146:main.c        **** 				rowBuffer[col+8+1] = fb_to_rb(hexColor);
2147:main.c        **** 		}
2148:main.c        **** 	}
2149:main.c        **** }
2150:main.c        **** #endif //0
2151:main.c        **** 
2152:main.c        **** 
2153:main.c        **** #if(defined(LOADROW) && LOADROW)
2154:main.c        **** #warning "loadRow is currently in an intermediate phase..."
2155:main.c        **** void loadRow(uint16_t rowNum)
2156:main.c        **** {
2157:main.c        **** 
2158:main.c        **** #if 0
2159:main.c        **** 	uint8_t i=0;
2160:main.c        **** 
2161:main.c        **** //	if((rowNum < 0) || (rowNum >= V_COUNT))
2162:main.c        **** //		return;
2163:main.c        **** 
2164:main.c        **** 	//THIS DOES NOT MAKE AN OUNCE OF SENSE TO ME:
2165:main.c        **** 	// why do I need *2 here?! Without it, the image is stretched and cut
2166:main.c        **** 	// in half vertically!
2167:main.c        **** 	// Apparently has to do with delayed Hsyncs due to calculations...?
2168:main.c        **** 	// LIFE with delay = 10 causes 2/3 frame at *2
2169:main.c        **** 	// The screen itself appears to be repeating rows...
2170:main.c        **** #if(!defined(HORIZONTAL_COLOR_BARS) || !HORIZONTAL_COLOR_BARS)
2171:main.c        ****  #if(LVDS_PRESCALER == 8)
2172:main.c        ****   #define ROW_SCALE 1
2173:main.c        ****  #else
2174:main.c        ****   #define ROW_SCALE 2
2175:main.c        ****  #endif
2176:main.c        **** 	uint8_t rbRowNum = ((uint32_t)rowNum)*RB_HEIGHT*ROW_SCALE/V_COUNT;
2177:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 61


2178:main.c        **** 	//Old note pre tet_drawRow... (code deleted a/o v45)	
2179:main.c        **** 	//WITHOUT THIS: syncing seems OK
2180:main.c        **** 	// But this is necessary for the right-border...
2181:main.c        **** 	// Adding it causes syncing problems at _b and _c -> _W
2182:main.c        **** 	// TODO: Look into sync-problems above!!!
2183:main.c        **** 	//  (revisit 41-1)
2184:main.c        **** 	//i++;
2185:main.c        **** 
2186:main.c        **** 	//Clear the rowBuffer, it will be reloaded, where appropriate, after
2187:main.c        **** 	// This isn't particularly speed-efficient, since most pixels will 
2188:main.c        **** 	// be written twice... but it should make things more plug-n-play...
2189:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2190:main.c        **** 		rowBuffer[i]=fb_to_rb(0);
2191:main.c        **** 
2192:main.c        **** 
2193:main.c        **** 	tet_drawRow(rbRowNum, rowBuffer);
2194:main.c        **** 
2195:main.c        **** 
2196:main.c        **** 	hexColor_drawRow(rbRowNum, rowBuffer);
2197:main.c        **** 
2198:main.c        **** 	
2199:main.c        **** 	i=63-40;
2200:main.c        **** 
2201:main.c        **** 	static uint16_t colorShift = 0;
2202:main.c        **** 
2203:main.c        **** 	//!!! This *should* only increment once per frame (RIGHT?)
2204:main.c        **** 	// BUT, set colorShift>>5 to colorShift>>3 or even >>0
2205:main.c        **** 	// and it seems this is not true... WTF, again?
2206:main.c        **** 	if(rbRowNum == 0)
2207:main.c        **** 		colorShift++;
2208:main.c        **** 
2209:main.c        **** 	//Just fill up the remaining pixels with color...
2210:main.c        **** 	// i-- to overwrite the blank column in the characters
2211:main.c        **** 	// Leaving one column of black to check into syncing problems
2212:main.c        **** 	// with LVDS_PRESCALER=8...
2213:main.c        **** 	// apparently, the garbage-lines are related to the last color drawn(?!)
2214:main.c        **** 	for( ;i<RB_WIDTH;i++)
2215:main.c        **** 	{
2216:main.c        **** 			uint8_t colorVal = (i + rbRowNum + (colorShift>>5)) & 0x3f;
2217:main.c        **** 
2218:main.c        **** 			//We don't want Black, since it's used for LIFE...
2219:main.c        **** 			if(colorVal==0)
2220:main.c        **** 				colorVal = 0x15;
2221:main.c        **** 
2222:main.c        **** 			//Only draw colors where there isn't already data
2223:main.c        **** 			// (e.g. LIFE or the SMILEY)
2224:main.c        **** 			// Actually, this can't work, since Black is a possibility...
2225:main.c        **** 			//if(!rowBuffer[i])
2226:main.c        **** 				rowBuffer[i] = fb_to_rb(colorVal);
2227:main.c        **** 	}
2228:main.c        **** 
2229:main.c        **** /* This is now handled in the rowSegBuffer loading...
2230:main.c        **** 	I guess that doesn't fix it for the old non-row-seg case...
2231:main.c        **** 
2232:main.c        **** 	//Apparently *black* causes issues... as well as some dark colors
2233:main.c        **** 	// (certain shades of blue?)
2234:main.c        **** 	// White, as the last pixel, causes syncing to work fine, ish
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 62


2235:main.c        **** 	//And adding a black column doesn't do anything?!
2236:main.c        **** 	// either way, thsi should be redundant due to rowBuffer clearing
2237:main.c        **** 	// and RB_WIDTH-2 in the color-filling
2238:main.c        **** 	// WTF?
2239:main.c        **** 	//rowBuffer[RB_WIDTH-2] = fb_to_rb(_K);
2240:main.c        **** 	rowBuffer[RB_WIDTH-1] = fb_to_rb(_W);
2241:main.c        **** */
2242:main.c        **** 
2243:main.c        **** 	//Draw the smiley on top of the color pixels
2244:main.c        **** #define SMILE_TOP_ROW (20)
2245:main.c        **** #define SMILE_HEIGHT FB_HEIGHT
2246:main.c        **** #define SMILE_SHIFT	(24+(40-FB_WIDTH)/2)
2247:main.c        **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
2248:main.c        **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
2249:main.c        **** 	{
2250:main.c        **** 			for(i=0; i<FB_WIDTH; i++)
2251:main.c        **** 			{
2252:main.c        **** 				uint8_t temp;
2253:main.c        **** 			#if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
2254:main.c        ****          	temp=frameBuffer[rbRowNum-SMILE_TOP_ROW][i];
2255:main.c        **** 			#else
2256:main.c        ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
2257:main.c        **** 			#endif
2258:main.c        **** 
2259:main.c        **** 				if(!(temp & 0xC0))
2260:main.c        **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
2261:main.c        **** 			}
2262:main.c        **** 	}
2263:main.c        **** 
2264:main.c        **** 
2265:main.c        **** 	#if(defined(LIFE) && LIFE)
2266:main.c        **** 	//This has to be called *after* the colored background is drawn...
2267:main.c        **** 	// (that could be changed... with _Tr?)
2268:main.c        **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
2269:main.c        **** 	#endif //LIFE
2270:main.c        **** 
2271:main.c        **** 
2272:main.c        **** #else //HORIZONTAL_COLOR_BARS
2273:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2274:main.c        **** 		rowBuffer[i] = fb_to_rb(rowNum);
2275:main.c        **** #endif
2276:main.c        **** 
2277:main.c        **** 
2278:main.c        **** #endif //0
2279:main.c        **** 
2280:main.c        **** 	
2281:main.c        **** 
2282:main.c        **** //#define SEG_QUESTION TRUE
2283:main.c        **** 	//Isn't BLAH = 1 necessary so we don't get a row with no data?
2284:main.c        **** 	// *looks* like it's working, but I dunno...
2285:main.c        **** #define BLAH 0
2286:main.c        **** 
2287:main.c        **** 
2288:main.c        **** #if(defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
2289:main.c        **** // Wasn't sure where 357 came from... and now I'm wondering where the
2290:main.c        **** // notes I wrote regarding it disappeared to...
2291:main.c        **** // Anyhow, from line 72, if ROW_SEG_BUFFER && !LVDS_PRESCALER
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 63


2292:main.c        **** // "ROW_SEG_BUFFER uses 20cyc/pixel" (doesn't match the math I've 
2293:main.c        **** // elsewhere) 1024/20*7 = 358.4... so maybe that's something to do with it
2294:main.c        **** // TODO: If it was 21cyc/pixel, wouldn't we have perfect alignment with
2295:main.c        **** //       color-transitions and segment widths?
2296:main.c        **** //#define NUM_PSEGS	(1024/3+16) //357
2297:main.c        ****  #if (defined(SEG_RACER) && SEG_RACER)
2298:main.c        ****   #include <stdlib.h>	//rand()
2299:main.c        ****   #define NEXT_COLOR	_R
2300:main.c        ****   #define THIS_COLOR	_G
2301:main.c        ****   #define OVERLAP_COLOR	_Y
2302:main.c        ****   #define BG_COLOR	_C
2303:main.c        ****   #define BG_BAD_COLOR	_M
2304:main.c        **** 
2305:main.c        **** 
2306:main.c        **** 
2307:main.c        **** 	int16_t racerPseg = NUM_PSEGS/2 - 2;
2308:main.c        **** 
2309:main.c        **** 	adc_startConversion();
2310:main.c        **** 	while(adc_isBusy())
2311:main.c        **** 		asm("nop;");
2312:main.c        **** 	racerPseg = (adc_getValue()>>2)+5;
2313:main.c        **** 	if(racerPseg > NUM_PSEGS-2)
2314:main.c        **** 		racerPseg = NUM_PSEGS-2;
2315:main.c        **** 
2316:main.c        **** 	segClear();
2317:main.c        **** 	addSegfb(1, _W);
2318:main.c        **** 	static uint16_t raceWidth = 16;
2319:main.c        **** 	static uint8_t trackPosition = 0;
2320:main.c        ****   #define TRACK_LENGTH	24	//24*32 = 768
2321:main.c        ****   #define TRACK_ROWS	(V_COUNT/TRACK_LENGTH)
2322:main.c        **** 	static uint16_t raceTrack[TRACK_LENGTH*2];
2323:main.c        **** 
2324:main.c        **** 	uint8_t bgColor = BG_COLOR;
2325:main.c        **** 
2326:main.c        **** 	//racePseg += ((rand()&0xff0)>>4)*2/0xff - 1;
2327:main.c        **** 
2328:main.c        **** 	uint8_t thisTrackRow = rowNum/TRACK_ROWS; //(V_COUNT/TRACK_LENGTH);
2329:main.c        **** 	uint8_t thisPosition = thisTrackRow + (trackPosition? TRACK_LENGTH : 0);
2330:main.c        **** 	uint8_t nextPosition = thisTrackRow + (trackPosition? 0 : TRACK_LENGTH);
2331:main.c        **** 
2332:main.c        **** 	static hfm_t thisSmoothingHFM, nextSmoothingHFM;
2333:main.c        **** 	static uint8_t thisTrackGrowing, nextTrackGrowing;
2334:main.c        **** 
2335:main.c        **** /*
2336:main.c        **** 	static theta_t racerTheta = 0;
2337:main.c        **** 	if(racerTheta >= SINE_2PI)
2338:main.c        **** 		racerTheta -= SINE_2PI;
2339:main.c        **** 
2340:main.c        **** 	racerPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2341:main.c        **** 	racerTheta++;
2342:main.c        **** */
2343:main.c        **** 
2344:main.c        **** 	uint8_t outOfTrack = FALSE;
2345:main.c        **** 	typedef struct _IST_BLAH_
2346:main.c        **** 	{
2347:main.c        **** 		uint16_t length;
2348:main.c        **** 		uint8_t color;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 64


2349:main.c        **** 	}	intermediateSeg_t;
2350:main.c        **** 
2351:main.c        **** #define ISEGS_PER_WHATEVER	3
2352:main.c        **** #define IS_SEGS (5*ISEGS_PER_WHATEVER)
2353:main.c        **** 	intermediateSeg_t is[IS_SEGS] = 
2354:main.c        **** 	{ {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2355:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2356:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W} };
2357:main.c        **** 
2358:main.c        **** 	uint8_t isPos = 0;
2359:main.c        **** 
2360:main.c        **** #define addSegIS(len, c) \
2361:main.c        **** ({\
2362:main.c        ****  	is[isPos].length = (len); \
2363:main.c        ****  	is[isPos].color = (c); \
2364:main.c        ****  	isPos+=ISEGS_PER_WHATEVER; \
2365:main.c        ****  	{}; \
2366:main.c        **** })
2367:main.c        **** 
2368:main.c        **** 
2369:main.c        **** 
2370:main.c        **** 	int8_t prevNextPosition;
2371:main.c        **** 	int8_t prevThisPosition;
2372:main.c        **** 
2373:main.c        **** 	static uint16_t thisIS, nextIS;
2374:main.c        **** 
2375:main.c        **** 	static uint8_t level = 1;
2376:main.c        **** 
2377:main.c        **** 
2378:main.c        **** 	if(rowNum%TRACK_ROWS == 0) //(V_COUNT/TRACK_LENGTH) == 0)
2379:main.c        **** 	{
2380:main.c        **** 		prevNextPosition = nextPosition - 1;
2381:main.c        **** 		if(prevNextPosition < 0)
2382:main.c        **** 			prevNextPosition = TRACK_LENGTH*2 - 1; //+prevNextPosition;
2383:main.c        **** 
2384:main.c        **** 		prevThisPosition = thisPosition - 1;
2385:main.c        **** 		if(prevThisPosition < 0)
2386:main.c        **** 			prevThisPosition = TRACK_LENGTH*2 - 1; //+prevThisPosition;
2387:main.c        **** 		
2388:main.c        **** 		static theta_t racerTheta=0;
2389:main.c        **** 
2390:main.c        **** 		int16_t nextTrackPseg;
2391:main.c        **** 
2392:main.c        **** 		nextTrackPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2393:main.c        **** 		racerTheta+=level;
2394:main.c        **** 		if(racerTheta >= SINE_2PI)
2395:main.c        **** 			racerTheta-=SINE_2PI;
2396:main.c        **** /*
2397:main.c        **** 	int8_t randomVal = rand()&0x03;
2398:main.c        **** 	switch(randomVal)
2399:main.c        **** 	{
2400:main.c        **** 		case 1:
2401:main.c        **** 			if(nextTrackPseg < NUM_PSEGS-2-raceWidth)
2402:main.c        **** 				nextTrackPseg += 1;
2403:main.c        **** 			break;
2404:main.c        **** 		case 2:
2405:main.c        **** 			if(nextTrackPseg > 1)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 65


2406:main.c        **** 				nextTrackPseg -= 1;
2407:main.c        **** 			break;
2408:main.c        **** 		default:
2409:main.c        **** 			break;
2410:main.c        **** 	}
2411:main.c        **** */
2412:main.c        **** 
2413:main.c        **** 
2414:main.c        **** 		raceTrack[nextPosition] = nextTrackPseg;
2415:main.c        **** 
2416:main.c        **** 		thisIS = raceTrack[prevThisPosition];
2417:main.c        **** 		nextIS = raceTrack[prevNextPosition];
2418:main.c        **** 		uint8_t nextHFMdist, thisHFMdist;
2419:main.c        **** 
2420:main.c        **** 		if(raceTrack[nextPosition] > nextIS)
2421:main.c        **** 		{
2422:main.c        **** 			nextTrackGrowing = TRUE;
2423:main.c        **** 			nextHFMdist = raceTrack[nextPosition] - nextIS;
2424:main.c        **** 		}
2425:main.c        **** 		else
2426:main.c        **** 		{
2427:main.c        **** 			nextTrackGrowing = FALSE;
2428:main.c        **** 			nextHFMdist = nextIS - raceTrack[nextPosition];
2429:main.c        **** 		}
2430:main.c        **** 		
2431:main.c        **** 		if(raceTrack[thisPosition] > thisIS)
2432:main.c        **** 		{
2433:main.c        **** 			thisTrackGrowing = TRUE;
2434:main.c        **** 			thisHFMdist = raceTrack[thisPosition] - thisIS;
2435:main.c        **** 		}
2436:main.c        **** 		else
2437:main.c        **** 		{
2438:main.c        **** 			thisTrackGrowing = FALSE;
2439:main.c        **** 			thisHFMdist = thisIS - raceTrack[thisPosition];
2440:main.c        **** 		}
2441:main.c        **** 
2442:main.c        **** 		hfm_setup(&nextSmoothingHFM, nextHFMdist, TRACK_ROWS);
2443:main.c        **** 
2444:main.c        **** 		hfm_setup(&thisSmoothingHFM, thisHFMdist, TRACK_ROWS);
2445:main.c        **** 	}
2446:main.c        **** 
2447:main.c        **** 
2448:main.c        **** 	if(thisTrackGrowing)//raceTrack[thisPosition] > raceTrack[prevThisPosition])
2449:main.c        **** 		thisIS += hfm_nextOutput(&thisSmoothingHFM);
2450:main.c        **** 	else
2451:main.c        **** 		thisIS -= hfm_nextOutput(&thisSmoothingHFM);
2452:main.c        **** 
2453:main.c        **** 	if(nextTrackGrowing)//raceTrack[nextPosition] > raceTrack[prevNextPosition])
2454:main.c        **** 		nextIS += hfm_nextOutput(&nextSmoothingHFM);
2455:main.c        **** 	else
2456:main.c        **** 		nextIS -= hfm_nextOutput(&nextSmoothingHFM);
2457:main.c        **** 
2458:main.c        **** 	if(thisIS < nextIS)
2459:main.c        **** 	{
2460:main.c        **** 		addSegIS(thisIS, bgColor);
2461:main.c        **** 
2462:main.c        **** 		//Tracks overlap
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 66


2463:main.c        **** 		if(nextIS < thisIS + raceWidth)
2464:main.c        **** 		{
2465:main.c        **** 			addSegIS(nextIS - thisIS, THIS_COLOR);
2466:main.c        **** 			addSegIS(thisIS + raceWidth - nextIS, OVERLAP_COLOR);
2467:main.c        **** 			addSegIS(nextIS - thisIS, NEXT_COLOR);
2468:main.c        **** 			//outOfTrack=TRUE;
2469:main.c        **** 		}
2470:main.c        **** 		else
2471:main.c        **** 		{
2472:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2473:main.c        **** 			addSegIS(nextIS - thisIS - raceWidth, bgColor);
2474:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
2475:main.c        **** 		}
2476:main.c        **** 
2477:main.c        **** 		//addSegIS(NUM_PSEGS-2-nextIS-raceWidth, bgColor);
2478:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-nextIS-raceWidth, bgColor);
2479:main.c        **** 
2480:main.c        **** 	}
2481:main.c        **** 	else if(thisIS > nextIS)
2482:main.c        **** 	{
2483:main.c        **** 		addSegIS(nextIS, bgColor);
2484:main.c        **** 
2485:main.c        **** 		//Tracks overlap
2486:main.c        **** 		if(thisIS < nextIS + raceWidth)
2487:main.c        **** 		{
2488:main.c        **** 			addSegIS(thisIS - nextIS, NEXT_COLOR);
2489:main.c        **** 			addSegIS(nextIS + raceWidth - thisIS, OVERLAP_COLOR);
2490:main.c        **** 			addSegIS(thisIS - nextIS, THIS_COLOR);
2491:main.c        **** 			//outOfTrack=TRUE;
2492:main.c        **** 		}
2493:main.c        **** 		else
2494:main.c        **** 		{
2495:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
2496:main.c        **** 			addSegIS(thisIS - nextIS - raceWidth, bgColor);
2497:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2498:main.c        **** 		}
2499:main.c        **** 	
2500:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2501:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2502:main.c        **** 	}
2503:main.c        **** 	else //Positions equal
2504:main.c        **** 	{
2505:main.c        **** 		//outOfTrack=TRUE;
2506:main.c        **** 		addSegIS(thisIS, bgColor);
2507:main.c        **** 
2508:main.c        **** 		addSegIS(raceWidth, OVERLAP_COLOR);
2509:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2510:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2511:main.c        **** 	}
2512:main.c        **** /*
2513:main.c        **** addSegfb(raceWidth, _W);
2514:main.c        **** 	addSegfb(NUM_PSEGS-racePseg-raceWidth-2, _R);
2515:main.c        **** */
2516:main.c        **** 	uint8_t isSeg;
2517:main.c        **** 	uint16_t isSegTrackPos = 0;
2518:main.c        **** 	uint16_t oldTrackPos = 0;
2519:main.c        **** 	//uint8_t racerFound = FALSE;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 67


2520:main.c        **** 
2521:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2522:main.c        **** 	{
2523:main.c        **** 		isSegTrackPos += is[isSeg].length;
2524:main.c        **** 
2525:main.c        **** 		//if(!racerFound && 
2526:main.c        **** 		if((isSegTrackPos >= (uint16_t)racerPseg))
2527:main.c        **** 		{
2528:main.c        **** 			//racerFound = TRUE;
2529:main.c        **** 			uint16_t oldLength = is[isSeg].length;
2530:main.c        **** 			is[isSeg].length = racerPseg - oldTrackPos;
2531:main.c        **** 			is[isSeg+1].length = 1;
2532:main.c        **** 			is[isSeg+1].color = _K;
2533:main.c        **** 			//Not sure why this shouldn't be -1...
2534:main.c        **** 			is[isSeg+2].length = oldLength - is[isSeg].length; //- 1;
2535:main.c        **** 			is[isSeg+2].color = is[isSeg].color;
2536:main.c        **** 			if((is[isSeg].color != THIS_COLOR) && (is[isSeg].color != OVERLAP_COLOR))
2537:main.c        **** 				outOfTrack = TRUE;
2538:main.c        **** 			isSeg++;
2539:main.c        **** 			break;
2540:main.c        **** 		}
2541:main.c        **** 		oldTrackPos = isSegTrackPos;
2542:main.c        **** 	}
2543:main.c        **** 
2544:main.c        **** 	
2545:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2546:main.c        ****   	{
2547:main.c        **** 		if(is[isSeg].length == 0)
2548:main.c        **** 			continue;
2549:main.c        **** 		if(outOfTrack && (is[isSeg].color==BG_COLOR))
2550:main.c        **** 			addSegfb(is[isSeg].length, BG_BAD_COLOR);
2551:main.c        **** 		else
2552:main.c        **** 			addSegfb(is[isSeg].length, is[isSeg].color);
2553:main.c        **** 	}
2554:main.c        **** 
2555:main.c        **** 	static uint32_t badCount=0;
2556:main.c        **** 	static uint32_t goodCount=0;
2557:main.c        **** 
2558:main.c        **** 	if(outOfTrack)
2559:main.c        **** 		badCount++;
2560:main.c        **** 	else
2561:main.c        **** 		goodCount++;
2562:main.c        **** 
2563:main.c        **** 	
2564:main.c        **** 	addSegfb(1, _B);
2565:main.c        **** 
2566:main.c        **** 
2567:main.c        **** 	uint8_t percentage = goodCount*100/(badCount+goodCount);
2568:main.c        **** 	static uint32_t lastLevelUpdate = 0;
2569:main.c        **** 
2570:main.c        **** 	if((percentage > 50) && (goodCount - lastLevelUpdate > V_COUNT*3))
2571:main.c        **** 	{
2572:main.c        **** 		lastLevelUpdate = goodCount;
2573:main.c        **** 		level++;
2574:main.c        **** 	}
2575:main.c        **** 
2576:main.c        **** 	if((rowNum>=6) && (rowNum < 22))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 68


2577:main.c        **** 		showScore(rowNum-6, level, _C);
2578:main.c        **** 
2579:main.c        **** 	else if((rowNum>=24) && (rowNum <40))
2580:main.c        **** 		showScore(rowNum-24, goodCount, _G);
2581:main.c        **** 	else if((rowNum >= 42) && rowNum < 58)
2582:main.c        **** 		showScore(rowNum-42, badCount, _R);
2583:main.c        **** 	else if((rowNum >= 60) && (rowNum < 76))
2584:main.c        **** 		showScore(rowNum-60, percentage, _Y);
2585:main.c        **** 
2586:main.c        **** 
2587:main.c        **** 	addSegfb(NUM_PSEGS-2-RACE_WIDTH_PSEGS, _B);
2588:main.c        **** 
2589:main.c        **** 	addSegfb(1, _W);
2590:main.c        **** 	segTerminate();
2591:main.c        **** 
2592:main.c        **** 	if(rowNum >= V_COUNT-1)
2593:main.c        **** 		trackPosition = !trackPosition;
2594:main.c        **** 
2595:main.c        ****  #elif (defined(SEG_HFM) && SEG_HFM)
2596:main.c        **** 	segClear();
2597:main.c        **** 	//Just some experimenting... 1024/3+16 seems to be the width...
2598:main.c        **** 	// == 357 segments (Where does this come from?)
2599:main.c        **** //Pixel Segments...
2600:main.c        **** #define BORDER_PSEGS	1
2601:main.c        **** #define SEGS_AVAILABLE (NUM_SEGMENTS-2)
2602:main.c        **** #define PSEGS_AVAILABLE	(NUM_PSEGS-BORDER_PSEGS*2)
2603:main.c        **** #define HFM_PSEGS	(PSEGS_AVAILABLE/SEGS_AVAILABLE)
2604:main.c        **** #define HFM_PSEGS_REMAINDER	(PSEGS_AVAILABLE%SEGS_AVAILABLE)
2605:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2606:main.c        **** 
2607:main.c        **** 	hfm_t hfmThing;
2608:main.c        **** 	hfm_setup(&hfmThing, (uint8_t)((uint32_t)rowNum*(uint32_t)SEGS_AVAILABLE/V_COUNT), SEGS_AVAILABLE)
2609:main.c        **** 
2610:main.c        **** 	hfm_t hfmColStretcher;
2611:main.c        **** 	hfm_setup(&hfmColStretcher, HFM_PSEGS_REMAINDER, SEGS_AVAILABLE);
2612:main.c        **** 
2613:main.c        **** 	uint16_t pseg;
2614:main.c        **** 	for(pseg=0; pseg<SEGS_AVAILABLE; pseg++)
2615:main.c        **** 	{
2616:main.c        **** 		if(hfm_nextOutput(&hfmThing))
2617:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_R);
2618:main.c        **** 		else
2619:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_C);
2620:main.c        **** 	}
2621:main.c        **** 
2622:main.c        **** 	//addSegfb(NUM_PSEGS-BORDER_PSEGS*2-SEGS_AVAILABLE*HFM_PSEGS, _M);
2623:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2624:main.c        **** 	segTerminate();
2625:main.c        **** 
2626:main.c        ****  #elif (defined(SEG_QUESTION) && SEG_QUESTION)
2627:main.c        **** 
2628:main.c        **** //Actually, this probably won't work right...
2629:main.c        **** // because the rgb values aren't exact like that, right?
2630:main.c        **** // e.g. black = 0,0,0 but it shows as 0,0,60 ish...
2631:main.c        **** // then again, going in reverse like this might work fine...
2632:main.c        **** // due to rounding (seems OK with this color-scheme)
2633:main.c        **** // The idea wasn't so much to be able to input an 8-bit RGB value to get
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 69


2634:main.c        **** // a close match (would probably want rounding up for that, not that it'd
2635:main.c        **** // be even close)
2636:main.c        **** // but to be able to read color-values from GIMP when using the 
2637:main.c        **** //  LCDdirectLVDS color-palette... which isn't especially necessary since
2638:main.c        **** //  now the colors are named with 3-based colors.
2639:main.c        **** #define rgb8(r,g,b) \
2640:main.c        **** 		rgb((((r)*3)/255), (((g)*3)/255), (((b)*3)/255))
2641:main.c        **** 
2642:main.c        **** 
2643:main.c        **** 
2644:main.c        **** //THESE DON'T BELONG HERE
2645:main.c        **** // AND they shouldn't be "Q" specific, at all.
2646:main.c        **** #define Q_WIDTH	16
2647:main.c        **** #define Q_HEIGHT	16
2648:main.c        **** 		//This should be an init-thing, I guess... it's only a 2-cycle
2649:main.c        **** 		// instruction, so it doesn't hurt too much to have it in the loop
2650:main.c        **** 		// BUT it does have to occur a while before the first getpinPORT
2651:main.c        **** 		// to allow time for the pull-ups to do their job
2652:main.c        **** 		setinpuPORT(PB0, PORTB);
2653:main.c        **** 
2654:main.c        **** 	static uint8_t qCount = 0;
2655:main.c        **** 
2656:main.c        **** 	segClear();
2657:main.c        **** 	//Not sure why this is stretched without /2...
2658:main.c        **** 	// I think I ran into this elsewhere as well.
2659:main.c        **** 	//!!! INSTEAD: filled the rest of the row properly...
2660:main.c        **** 	// (wasn't filling up the entire row, due to rounding...
2661:main.c        **** 	//   result was the rows were carrying-over into the next)
2662:main.c        **** 	uint8_t qRow;// = (rowNum*Q_HEIGHT/(V_COUNT)); ///2));
2663:main.c        **** 	uint8_t qCol;
2664:main.c        **** 	
2665:main.c        **** 	//Guess white helps with sync...?
2666:main.c        **** 	// can't hurt.
2667:main.c        **** 	//addSegfb(3, _W);
2668:main.c        **** 	// Looks like some white is already being inserted (or syncing on end-
2669:main.c        **** 	// white?) about 3pixels wide.
2670:main.c        **** 
2671:main.c        **** 	// 1024/3/32 = 10.67... so for every 3 segments, add 2
2672:main.c        **** #define Q_STRETCHTOP	1//0//28//2
2673:main.c        **** #define Q_STRETCHDIV 5//30//3
2674:main.c        **** 	hfm_t colincrementer_hfm;
2675:main.c        **** 	hfm_setup(&colincrementer_hfm, Q_STRETCHTOP, Q_STRETCHDIV);
2676:main.c        **** 
2677:main.c        **** 	for(qCol=0; qCol<Q_WIDTH; qCol++)
2678:main.c        **** 	{
2679:main.c        **** 		//Not sure where this is defined, if it is...
2680:main.c        **** 		// each "segment length" appears to be 3 physical pixels
2681:main.c        **** 		//+1 is a result of random experiments with stretch
2682:main.c        **** 		// resulting in a stretch larger than 1
2683:main.c        **** 		#define Q_SEGLENGTH	(1024/3/Q_WIDTH+1)
2684:main.c        **** 
2685:main.c        **** 	//These are not included in NUM_ICONS
2686:main.c        **** 	#include "icons/Question.h"
2687:main.c        **** 	#include "icons/Solid.h"
2688:main.c        **** 	#include "icons/GoombaDead.h"
2689:main.c        **** 
2690:main.c        **** 	//These are included in NUM_ICONS
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 70


2691:main.c        **** 	#include "icons/1up.h"
2692:main.c        **** 	#include "icons/Biggie.h"
2693:main.c        **** 	#include "icons/StarV.h"
2694:main.c        **** 	#include "icons/FlowerPowerV.h"
2695:main.c        **** 	#include "icons/Goomba.h"
2696:main.c        **** 	#include "icons/Coin.h"
2697:main.c        **** 
2698:main.c        **** 	//Excluding Solid and Question, etc...
2699:main.c        **** 	#define NUM_ICONS 6
2700:main.c        **** 		/*
2701:main.c        **** 		static uint8_t iconSelection = 0;
2702:main.c        **** 		static uint8_t * icon[NUM_ICONS] = { pgm_imageUP, pgm_imageCOIN};
2703:main.c        **** 		static uint8_t iconFrames[NUM_ICONS] = {NUM_UPS, NUM_COINS};
2704:main.c        **** 
2705:main.c        **** 		static uint8_t * p_image = pgm_imageUP; // = icon[0]; //(pgm_imageFLOWER);
2706:main.c        **** 		static uint8_t NumFramesInImage = NUM_UPS; // = NUM_FLOWERS;
2707:main.c        **** 		*/
2708:main.c        **** 		//For changing images...
2709:main.c        **** 		static sprite_t *p_selectedSprite = &spriteQ;
2710:main.c        **** 		static uint16_t buttonPressed = FALSE;
2711:main.c        **** 
2712:main.c        **** #define DEBUGGING_PRESSIMMEDIATE TRUE
2713:main.c        **** 
2714:main.c        **** #if(!defined(DEBUGGING_PRESSIMMEDIATE) || !DEBUGGING_PRESSIMMEDIATE)
2715:main.c        **** 		if((p_selectedSprite == &spriteQ) 
2716:main.c        **** 				|| (p_selectedSprite == &spriteGOOMBA))
2717:main.c        **** #else
2718:main.c        **** 	#warning "Debugging mode... players can change their result!"
2719:main.c        **** #endif
2720:main.c        **** 		if(!getpinPORT(PB0, PORTB))
2721:main.c        **** 		{
2722:main.c        **** 			if(!buttonPressed)
2723:main.c        **** 			{
2724:main.c        **** 				buttonPressed = rowNum;
2725:main.c        **** 				if(buttonPressed == 0)
2726:main.c        **** 					buttonPressed = 1;
2727:main.c        **** 			}
2728:main.c        **** 			else if((rowNum-buttonPressed) >= 64)
2729:main.c        **** 				buttonPressed += 0x4000;
2730:main.c        **** 		}
2731:main.c        **** 
2732:main.c        **** 
2733:main.c        **** #define REALLY_IMMEDIATE	TRUE
2734:main.c        **** #if (defined(REALLY_IMMEDIATE) && REALLY_IMMEDIATE)
2735:main.c        **** 		if((rowNum == 0) || (buttonPressed&0x8000))
2736:main.c        **** #else
2737:main.c        **** 		if(rowNum==0)
2738:main.c        **** #endif
2739:main.c        **** 		{
2740:main.c        **** 			if(!(buttonPressed&0x8000) && !((p_selectedSprite == &spriteQ) ||
2741:main.c        **** 												(p_selectedSprite == &spriteGOOMBA)))
2742:main.c        **** 				buttonPressed = FALSE;
2743:main.c        **** 
2744:main.c        **** 			if(buttonPressed)
2745:main.c        **** 			{
2746:main.c        **** 				if(p_selectedSprite == &spriteGOOMBA)
2747:main.c        **** 				{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 71


2748:main.c        **** 					if(qCount == 1)
2749:main.c        **** 						p_selectedSprite = &spriteDEADGOOMBA;
2750:main.c        **** 
2751:main.c        **** 				}
2752:main.c        **** 				else
2753:main.c        **** 				{
2754:main.c        **** 					//Duh...
2755:main.c        **** 					// But still, 255 % 3 should give a value from 0 to 2
2756:main.c        **** 					//buttonPressed=FALSE;
2757:main.c        **** 					qCount = 0;
2758:main.c        **** 					//static uint8_t iconSelection;
2759:main.c        **** 					//iconSelection++;
2760:main.c        **** 					//iconSelection%=NUM_ICONS;
2761:main.c        **** 					//NumFramesInImage = iconFrames[iconSelection];
2762:main.c        **** //#define RANDOMSPRITE_OVERRIDE 0
2763:main.c        **** #if(defined(RANDOMSPRITE_OVERRIDE))
2764:main.c        **** 					switch(RANDOMSPRITE_OVERRIDE)
2765:main.c        **** #else
2766:main.c        **** 					switch ((buttonPressed-1)%(NUM_ICONS*2))
2767:main.c        **** #endif
2768:main.c        **** 					{
2769:main.c        **** 						case 0:
2770:main.c        **** 							p_selectedSprite = &spriteFLOWER;
2771:main.c        **** 							break;
2772:main.c        **** 						case 1:
2773:main.c        **** 							p_selectedSprite = &sprite1UP;
2774:main.c        **** 							break;
2775:main.c        **** 						case 2:
2776:main.c        **** 							p_selectedSprite = &spriteBIG;
2777:main.c        **** 							break;
2778:main.c        **** 						case 3:
2779:main.c        **** 							p_selectedSprite = &spriteSTAR;
2780:main.c        **** 							break;
2781:main.c        **** 						case 4:
2782:main.c        **** 							p_selectedSprite = &spriteGOOMBA;
2783:main.c        **** 							break;
2784:main.c        **** 						default:
2785:main.c        **** 							p_selectedSprite = &spriteCOIN;
2786:main.c        **** 							break;
2787:main.c        **** 					}
2788:main.c        **** 				}
2789:main.c        **** 
2790:main.c        **** 				//buttonPressed=FALSE;
2791:main.c        **** 			}
2792:main.c        **** 			if(p_selectedSprite == &spriteCOIN)
2793:main.c        **** 			{
2794:main.c        **** 				if(qCount >= 2)
2795:main.c        **** 					p_selectedSprite = &spriteSOLID;
2796:main.c        **** 			}
2797:main.c        **** 			else if(p_selectedSprite != &spriteQ)
2798:main.c        **** 			{
2799:main.c        **** 				if(qCount >= 4)
2800:main.c        **** 				{
2801:main.c        **** 					qCount = 0;
2802:main.c        **** 					if(p_selectedSprite != &spriteSOLID)
2803:main.c        **** 						p_selectedSprite = &spriteSOLID;
2804:main.c        **** 					else
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 72


2805:main.c        **** 						p_selectedSprite = &spriteQ;
2806:main.c        **** 				}
2807:main.c        **** 			}
2808:main.c        **** 
2809:main.c        **** 			buttonPressed = FALSE;
2810:main.c        **** 		}
2811:main.c        **** 
2812:main.c        **** 		qRow = (rowNum*ICON_HEIGHT/(V_COUNT)); ///2));
2813:main.c        **** 		
2814:main.c        **** 
2815:main.c        **** 
2816:main.c        **** 
2817:main.c        **** //		p_image = (icon[iconSelection] + 
2818:main.c        **** //						(qCount%NumFramesInImage)*ICON_HEIGHT*ICON_WIDTH);
2819:main.c        **** 
2820:main.c        **** 		// Should use readImageByte... but it's specific to FB_WIDTH
2821:main.c        **** 		//uint8_t data=
2822:main.c        **** 		//  pgm_read_byte((uint8_t *)(&((p_image)[(qRow)*Q_WIDTH+(qCol)])));
2823:main.c        **** 		uint8_t data;
2824:main.c        **** 	  
2825:main.c        **** 		if(p_selectedSprite == &spriteFLOWER)
2826:main.c        **** 		{
2827:main.c        **** 			if(qRow<FLOWER_PALETTE1_ROW)
2828:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,
2829:main.c        **** 							qCount%(spriteFLOWER.numPalettes-1) + 1, qRow, qCol);
2830:main.c        **** 			else
2831:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,0,qRow, qCol);
2832:main.c        **** 		}
2833:main.c        **** 		else if(p_selectedSprite == &spriteGOOMBA)
2834:main.c        **** 		{
2835:main.c        **** 			uint8_t gCol = qCol;
2836:main.c        **** 			//Goomba moves by flipping horizontally...
2837:main.c        **** 			if(qCount & 0x01)
2838:main.c        **** 				gCol = 15-qCol;
2839:main.c        **** 
2840:main.c        **** 			data = getGimpColorVal(&spriteGOOMBA, 0, qRow, gCol);
2841:main.c        **** 		}
2842:main.c        **** 		else
2843:main.c        **** 		{
2844:main.c        **** 			data = getGimpColorVal(p_selectedSprite, 
2845:main.c        **** 							qCount%p_selectedSprite->numPalettes, qRow, qCol);
2846:main.c        **** 		}
2847:main.c        **** 		data = gimpPixelValToLColor(data);
2848:main.c        **** 
2849:main.c        **** 		addSegfb(Q_SEGLENGTH + hfm_nextOutput(&colincrementer_hfm), data);
2850:main.c        **** 	}
2851:main.c        **** 
2852:main.c        **** 
2853:main.c        **** 	//Wow, is it really so smart as to recognize that rowNum is never >=
2854:main.c        **** 	// V_COUNT?! was 7684 when if(rowNum==0), then 7668 after this bug...
2855:main.c        **** 	//if(rowNum >= V_COUNT)
2856:main.c        **** 	if(rowNum >= V_COUNT-1)
2857:main.c        **** 	{
2858:main.c        **** 		qCount++;
2859:main.c        **** 	}
2860:main.c        **** 
2861:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 73


2862:main.c        **** 	//Wait, what?! We can't fit 1024 segments! But this sorta works
2863:main.c        **** 	// We're gtting syncing, a tiny bit of white-space on the right
2864:main.c        **** 	// which seems reasonable based on shotty math, 
2865:main.c        **** 	//                10     *  32   +  10   *    2       /   3 = 326
2866:main.c        **** 	// but 1024/3 is 341 (where's my math error?)
2867:main.c        **** 	//addSegfb(1024-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2868:main.c        **** 	// But, nope, 341-... doesn't sync (vertical stretching again)
2869:main.c        **** 	// But, 342 does. Sweet. 1024/3=341.33333, actually.
2870:main.c        **** 	//addSegfb(342-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2871:main.c        **** 	// Because it's not 10*2/3, it's 32*2/3=21.3...
2872:main.c        **** 	// which is exactly right
2873:main.c        **** 	// which then doesn't explain why it has whitespace and doesn't sync
2874:main.c        **** 	// without 342 above...
2875:main.c        **** 	// something to do with white being necessary?
2876:main.c        **** 	// Can't recall where 1024/3 was determined, maybe it varies
2877:main.c        **** 	// since the LVDS clock is 7 cycles...?
2878:main.c        **** 	//OK, so maybe we just need a white pixel at the end...
2879:main.c        **** 	// I mean, this works.
2880:main.c        **** 	addSegfb(1,_W);
2881:main.c        **** 
2882:main.c        **** 
2883:main.c        **** 	segTerminate();
2884:main.c        **** 
2885:main.c        ****  #elif (defined(SEG_LINE) && SEG_LINE)
2886:main.c        **** 
2887:main.c        **** 	//syncing issues due to recursion overflowing the stack???
2888:main.c        **** 	// Apparently was
2889:main.c        **** 	segClear();
2890:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
2891:main.c        **** 	newSeg((rowNum&0xff) | BLAH, 0x06, (4<<4) | 0);				//R
2892:main.c        **** 	newSeg(1,0x06, (6<<4) | 3);									//W
2893:main.c        **** 	newSeg((255-(rowNum&0xff)) | BLAH, 0x06, (4<<4) | 0 );	//R
2894:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
2895:main.c        **** 	segTerminate();
2896:main.c        **** 
2897:main.c        ****  #elif (defined(SEG_SINE) && SEG_SINE)
2898:main.c        **** 	static uint16_t lastThetaOffset = 0;
2899:main.c        **** 	static uint8_t frameCount = 0;
2900:main.c        **** 
2901:main.c        **** 	if(rowNum == 0)
2902:main.c        **** 	{
2903:main.c        **** 		lastThetaOffset+=16;
2904:main.c        **** 		frameCount++;
2905:main.c        **** 	}
2906:main.c        **** 	//pgm_read_sine(sineTable[theta])
2907:main.c        **** 
2908:main.c        **** 	segClear();
2909:main.c        **** 	//addSegfb(3,0x06, (6<<4) | 3);
2910:main.c        **** 	addSegfb(3, _W);
2911:main.c        **** 
2912:main.c        **** 	uint8_t sineVal = (uint8_t)((int8_t)128 + 
2913:main.c        **** 			sineRaw8(rowNum+lastThetaOffset));
2914:main.c        **** 
2915:main.c        **** 	uint8_t nextSineVal = (uint8_t)((int8_t)128 +
2916:main.c        **** 			sineRaw8(rowNum+1+lastThetaOffset));
2917:main.c        **** 
2918:main.c        **** 	uint8_t length; 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 74


2919:main.c        **** 
2920:main.c        **** 	//If the step-size is greater than one pixel, we'll see hashing
2921:main.c        **** 	// this should fix that.
2922:main.c        **** 	if(nextSineVal < sineVal)
2923:main.c        **** 	{
2924:main.c        **** 		length = (sineVal - nextSineVal);
2925:main.c        **** 		//This assures that the additional length of the white-segment
2926:main.c        **** 		// goes in the proper direction...
2927:main.c        **** 		sineVal-=length;//*4;
2928:main.c        **** 	}
2929:main.c        **** 	else if(nextSineVal > sineVal)
2930:main.c        **** 		length = (nextSineVal - sineVal);
2931:main.c        **** 		
2932:main.c        **** 	//But we don't want zero-length white segments (where the sine values
2933:main.c        **** 	// are horizontal)
2934:main.c        **** 	if(length == 0)
2935:main.c        **** 		length = 1;
2936:main.c        **** 
2937:main.c        **** 	uint8_t rgbVal=0;
2938:main.c        **** 	uint8_t J=0;
2939:main.c        **** 	uint8_t j = frameCount;
2940:main.c        **** 
2941:main.c        **** #define WIDTH 5//3//4
2942:main.c        **** 	while(1)
2943:main.c        **** 	{
2944:main.c        **** 		J++;
2945:main.c        **** 		j++; // = J+frameCount;
2946:main.c        **** 		
2947:main.c        **** 		rgbVal = rgbGradient(j);
2948:main.c        **** 
2949:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
2950:main.c        **** 			break;
2951:main.c        **** 
2952:main.c        **** 		addSegfb(WIDTH, rgbVal);
2953:main.c        **** 	}
2954:main.c        **** 
2955:main.c        **** 	J--;
2956:main.c        **** 
2957:main.c        **** 	addSegfb(sineVal-(uint16_t)J*(uint16_t)WIDTH, rgbVal); 
2958:main.c        **** 
2959:main.c        **** 	addSegfb(length, _W); 
2960:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
2961:main.c        **** 
2962:main.c        **** 	addSegfb(3, _W);
2963:main.c        **** 
2964:main.c        **** 	//Draw a sideways character...
2965:main.c        **** 	{
2966:main.c        **** 		addSegfb(3, _R);
2967:main.c        **** 
2968:main.c        **** 		uint8_t i;
2969:main.c        **** 
2970:main.c        **** 		//Without + ' ' we get the same alphabet but shifted
2971:main.c        **** 		// starting with the lower-case letters which are shifted down a row
2972:main.c        **** 	   // and some garbage in the top row...
2973:main.c        **** 		// now I get that I'm reading weird memory locations, but this
2974:main.c        **** 		// doesn't seem right. I should be accessing outside the array 
2975:main.c        **** 		// altogether, no? 	
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 75


2976:main.c        **** 		char thisChar = (rowNum/8)%('~'-' '+1) + ' '; //pgm_read_byte(&(string[rowNum/8])); 
2977:main.c        **** 		//'A'; //string[rowNum/8];
2978:main.c        **** 
2979:main.c        **** 		//Ironically, there are exactly the number of characters to be
2980:main.c        **** 		// displayed in 768 lines (plus one on the right, to center)
2981:main.c        **** 		for(i=8; i>0; i--)
2982:main.c        **** 		{
2983:main.c        **** 			if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
2984:main.c        **** 				addSegfb(1, _Y); //0x06, (4<<4) | 3);
2985:main.c        **** 			else
2986:main.c        **** 				addSegfb(1, _R); //0x06, (4<<4) | 0);
2987:main.c        **** 		}
2988:main.c        **** 
2989:main.c        **** 		addSegfb(3, _R); //0x06, (4<<4) | 0);
2990:main.c        **** 
2991:main.c        **** 		addSegfb(1, _W); //0x04, (6<<4) | 3);
2992:main.c        **** 
2993:main.c        **** 		//PGM_P charPtr = strchrnul_P(
2994:main.c        **** 		PGM_P tqbf = PSTR(" The Quick Brown Fox Jumped Over The Lazy Dog!"); 
2995:main.c        **** 		//, rowNum/8);
2996:main.c        **** 
2997:main.c        **** 		strncpy_P(&thisChar, tqbf+(rowNum/8), 1);
2998:main.c        **** 
2999:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0, (6<<4) | 0);
3000:main.c        **** 
3001:main.c        **** 		if(rowNum/8 < strlen_P(tqbf))
3002:main.c        **** 		{
3003:main.c        **** 			for(i=8; i>0; i--)
3004:main.c        **** 			{
3005:main.c        **** 				if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
3006:main.c        **** 					addSegfb(1, rgb(3,0,1));//_C); //0, (6<<4) | 3);
3007:main.c        **** 				else
3008:main.c        **** 					addSegfb(1, rgb(0,0,1));//_B); //0, (6<<4) | 0);
3009:main.c        **** 			}
3010:main.c        **** 		}
3011:main.c        **** 		else
3012:main.c        **** 			addSegfb(8, rgb(0,0,1));//_B); //0,(6<<4) | 0);
3013:main.c        **** 
3014:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0,(6<<4)|0);
3015:main.c        **** 
3016:main.c        **** 	}
3017:main.c        **** 
3018:main.c        **** 	//newSeg(3,0x06,(4<<4) | 0);
3019:main.c        **** 
3020:main.c        **** 	uint8_t i;
3021:main.c        **** 	for(i=0; i<64; i++)
3022:main.c        **** 		addSegfb(1, (i+rowNum/4)&0x3f);
3023:main.c        **** 
3024:main.c        **** 	addSegfb(3, _W); //0x06, (6<<4) | 3);
3025:main.c        **** 
3026:main.c        **** 	segTerminate();
3027:main.c        **** 
3028:main.c        ****  #else //NOT SEG_LINE NOR SEG_SINE NOR ANY OTHERS...
3029:main.c        ****   #if(!defined(SEG_STRETCH))
3030:main.c        **** 	#define SEG_STRETCH 1
3031:main.c        ****   #endif
3032:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 76


3033:main.c        **** 	segClear();
3034:main.c        **** 
3035:main.c        **** 	//Good for syncing to have white on both borders...
3036:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
3037:main.c        **** 	
3038:main.c        **** 	uint16_t i;
3039:main.c        **** 	//i+1 because we don't want to overwrite the white border...
3040:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
3041:main.c        **** 		rbpix_to_seg(rowBuffer[i], i+1, SEG_STRETCH);
3042:main.c        **** 	
3043:main.c        **** 	//white...
3044:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
3045:main.c        **** 	segTerminate();
3046:main.c        ****  #endif //SEG_LINE
3047:main.c        **** #endif //ROW_SEG_BUFFER
3048:main.c        **** }
3049:main.c        **** #endif //LOAD_ROW
3050:main.c        **** 
3051:main.c        **** void init_timer0Hsync(void)
3052:main.c        **** {
3053:main.c        **** 	//T_HD + T_DH + T_low + T_DE
3054:main.c        **** 	// For the original system, 19.865us = 695 dot-clocks
3055:main.c        **** 	// We'd need to take advantage of the 16-bit timer
3056:main.c        **** 	//  OCR1A may not be written properly (with a temporary high-byte)
3057:main.c        **** 	//  ... not sure.
3058:main.c        **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
3059:main.c        **** 
3060:main.c        **** // This is a hack, for testing syncability with long row-calculations
3061:main.c        **** // before actually drawing it... e.g. loading from program memory
3062:main.c        **** // This value needs to be larger than the calculation time
3063:main.c        **** // otherwise, it seems, syncing isn't stable
3064:main.c        **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
3065:main.c        **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
3066:main.c        **** 
3067:main.c        **** #define DISPLAY_CYC_COUNT \
3068:main.c        **** 	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
3069:main.c        **** 
3070:main.c        **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
3071:main.c        **** // apparently an effect of the display, definitely not a code-thing
3072:main.c        **** // in which case the vertical resolution decreases
3073:main.c        **** // though, this could be used to advantage... 
3074:main.c        **** // (e.g. more processing time outside the drawing interrupts?)
3075:main.c        **** // NOTE that if the value is too small and calculations take longer in some
3076:main.c        **** // lines than others (?), those lines may repeat, or syncing could be off
3077:main.c        **** #if (LVDS_PRESCALER == 8)
3078:main.c        ****  //#define ROW_CALCULATION_DELAY 1//20
3079:main.c        ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
3080:main.c        **** #else
3081:main.c        ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
3082:main.c        ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
3083:main.c        **** #endif
3084:main.c        **** 
3085:main.c        **** #define TOTAL_CYC_COUNT \
3086:main.c        **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
3087:main.c        **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
3088:main.c        **** //#define TOTAL_CYC_COUNT 2000
3089:main.c        **** #if (TOTAL_CYC_COUNT > 255)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 77


3090:main.c        ****  //Adding +7 causes it to round up (hopefully)
3091:main.c        ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
3092:main.c        ****  #define TIMER0_CLKDIV	CLKDIV8
3093:main.c        ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
3094:main.c        ****  #if (TIMER0_TCNTS > 255)
3095:main.c        ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
3096:main.c        ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
3097:main.c        ****   #define TIMER0_CLKDIV CLKDIV64
3098:main.c        ****   #if (TIMER0_TCNTS > 255)
3099:main.c        **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
3100:main.c        **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
3101:main.c        **** 	 #define TIMER0_CLKDIV CLKDIV256
3102:main.c        **** 	 #if (TIMER0_TCNTS > 255)
3103:main.c        **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
3104:main.c        **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
3105:main.c        **** 		#define TIMER0_CLKDIV	CLKDIV1024
3106:main.c        **** 	 #endif
3107:main.c        ****   #endif
3108:main.c        ****  #endif
3109:main.c        ****  #if (TIMER0_TCNTS == 0)
3110:main.c        ****   #error "TIMER0_OCRVAL == 0"
3111:main.c        ****  #endif
3112:main.c        **** #else
3113:main.c        ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
3114:main.c        ****  #define TIMER0_CLKDIV CLKDIV1
3115:main.c        **** #endif
3116:main.c        **** 
3117:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
3118:main.c        ****  //For testing, I want to see the pulses with the 'scope
3119:main.c        ****  // Unless the timer is divisible by 7 the pulses will not align with the
3120:main.c        ****  // timer overflow...
3121:main.c        ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
3122:main.c        ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
3123:main.c        ****  // and we'll only start visualizing *after* the extra TCNTs...
3124:main.c        ****  //Since the timer counts from 0 to (and including) OCR1A
3125:main.c        ****  // Add one to this test...
3126:main.c        ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
3127:main.c        ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
3128:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
3129:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
3130:main.c        **** 
3131:main.c        ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
3132:main.c        ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
3133:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
3134:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
3135:main.c        **** 
3136:main.c        ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
3137:main.c        ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
3138:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
3139:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
3140:main.c        **** 
3141:main.c        ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
3142:main.c        ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
3143:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
3144:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
3145:main.c        **** 
3146:main.c        ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 78


3147:main.c        ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
3148:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
3149:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
3150:main.c        **** 
3151:main.c        ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
3152:main.c        ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
3153:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
3154:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
3155:main.c        **** 
3156:main.c        ****  #elif (((TIMER0_TCNTS) % 7) == 0)
3157:main.c        ****   #warning "(TIMER0_TCNTS) % 7 == 0"
3158:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
3159:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
3160:main.c        **** 
3161:main.c        ****  #else
3162:main.c        ****   #error "WTF?"
3163:main.c        ****  #endif
3164:main.c        **** #else
3165:main.c        ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
3166:main.c        **** #endif
3167:main.c        **** 
3168:main.c        **** #if (TIMER0_OCRVAL > 255)
3169:main.c        ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
3170:main.c        **** #endif
3171:main.c        **** 
3172:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
3173:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
3174:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
3175:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
3176:main.c        **** }
3177:main.c        **** 
3178:main.c        **** //For a first go...
3179:main.c        **** // B5 = OCR=5
3180:main.c        **** // B4 = OCR=6+
3181:main.c        **** // B3 = DT=0
3182:main.c        **** // B2 = DT=1
3183:main.c        **** // Possible combinations:
3184:main.c        **** // B3, B2, B5, B4		OCR>6 (DT=0)
3185:main.c        **** // B3, B2, B5			OCR=5, DT=0
3186:main.c        **** // B3, B2				OCR=4, DT=0
3187:main.c        **** //     B2, B5, B4		OCR=6, DT=1 (is OCR=6 possible?)
3188:main.c        **** //     B2, B5			OCR=5, DT=1
3189:main.c        **** //     B2				OCR=4, DT=1
3190:main.c        **** //         B5, B4		OCR=6, DT=2 (is OCR=6 possible?)
3191:main.c        **** //         B5			OCR=5, DT=2
3192:main.c        **** // OCR=6 is full-on...
3193:main.c        **** 
3194:main.c        **** //            |  0   1    2    3    4    5    6    
3195:main.c        **** //            |____ ____ ____ ____ ____ ____ ____
3196:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X
3197:main.c        **** //            |                  
3198:main.c        **** 
3199:main.c        **** // Active Bits     | Brightness   |
3200:main.c        **** //                 | (0-63)       |    Configuration
3201:main.c        **** // ----------------+--------------+-------------------------
3202:main.c        **** // B5  B4  B3  B2  |     60		 |		OCR>6 (DT=0)  //DC
3203:main.c        **** // B5      B3  B2  |     44 		 |		OCR=5, DT=0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 79


3204:main.c        **** // B5          B2  |     36 		 |		OCR=5, DT=1
3205:main.c        **** // B5              |     32 		 |		OCR=5, DT=2  
3206:main.c        **** //         B3  B2  |     12 		 |		OCR=4, DT=0  //Damn-near black...
3207:main.c        **** //             B2  |     4  		 |		OCR=4, DT=1  //Even closer
3208:main.c        **** // None = Black    |     0        |    OCR=4, DT=2
3209:main.c        **** //
3210:main.c        **** // The colors 60, 44, 36, and 32 are all discernable
3211:main.c        **** // (though 36 and 32 mightn't be if not side-by-side)
3212:main.c        **** // 12, 4, and 0 are damn-near identical and may not be worth the overhead
3213:main.c        **** // There is a SIGNIFICANT jump between 32 and 12
3214:main.c        **** //   32 is I'd say half-bright, maybe more
3215:main.c        **** //   12 is damn-near black
3216:main.c        **** 
3217:main.c        **** #define fullBlue()	DEblue_init()
3218:main.c        **** 
3219:main.c        **** /*
3220:main.c        **** static __inline__ \
3221:main.c        **** void writeBlue(uint8_t settingVal) \
3222:main.c        **** 	  __attribute__((__always_inline__));
3223:main.c        **** */
3224:main.c        **** 
3225:main.c        **** #if FALSE
3226:main.c        **** #define GREEN_PIN_MASK	0x03
3227:main.c        **** #define GREEN_PORT		PORTA
3228:main.c        **** #define GREEN_ON			0x01
3229:main.c        **** #define GREEN_ON_STRING	"0x01"
3230:main.c        **** #define GREEN_OFF			0x02
3231:main.c        **** #define GREEN_OFF_STRING "0x02"
3232:main.c        **** // in settingVal: bit 3 is unused by blue (4<=OCR<=6), so use it for green
3233:main.c        **** #define GREEN_SETTING_BIT	3
3234:main.c        **** #define GREEN_SETTING_BIT_STRING	"3"
3235:main.c        **** // for setBlue:
3236:main.c        **** #define GREEN_BLUEVAL_BIT	0
3237:main.c        **** 
3238:main.c        **** #define RED_PIN_MASK		0x0C
3239:main.c        **** #define RED_PORT			PORTA
3240:main.c        **** #define RED_ON				0x04
3241:main.c        **** #define RED_ON_STRING	"0x04"
3242:main.c        **** #define RED_OFF			0x08
3243:main.c        **** #define RED_OFF_STRING	"0x08"
3244:main.c        **** #define RED_SETTING_BIT	7
3245:main.c        **** #define RED_SETTING_BIT_STRING "7"
3246:main.c        **** #define RED_BLUEVAL_BIT	1
3247:main.c        **** 
3248:main.c        **** #define REDGREEN_PORT 	RED_PORT
3249:main.c        **** 
3250:main.c        **** 
3251:main.c        **** void writeBlue(uint8_t settingVal)
3252:main.c        **** {
3253:main.c        **** 	//Best to do these calculations first and write the registers later
3254:main.c        **** 	// it's a noticeable change (green is offset a bit, but much less)
3255:main.c        **** 	uint8_t dt = settingVal & 0x70;
3256:main.c        **** 	uint8_t ocr = settingVal & 0x07;
3257:main.c        **** 
3258:main.c        **** 	//The red and green PORT value will be temporarily calculated here...
3259:main.c        **** 	uint8_t redGreen; 
3260:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 80


3261:main.c        **** 
3262:main.c        **** 	//ASM Notes:
3263:main.c        ****    // avr-libc-user-manual-1.7.0/inline__asm.html
3264:main.c        **** 
3265:main.c        **** 	//This is timing-critical... the amount of time taken in writeBlue
3266:main.c        **** 	// determines the width of each pixel.
3267:main.c        **** 	// Most importantly: if standard C-style if/else statements are used
3268:main.c        **** 	//  it compiles differently each time (based on optimization, etc.)
3269:main.c        **** 	//  Often, though not always, it would compile such that different
3270:main.c        **** 	//  color values would use more instructions than others (branching)...
3271:main.c        **** 	//  It was too unpredictable (and believe me I tried) to code it in C
3272:main.c        **** 	//  and make it consistent. e.g. adding a nop in an else-case caused
3273:main.c        **** 	//  it to compile using brne, but not adding the nop caused breq
3274:main.c        **** 
3275:main.c        **** 	//Simply: if(getbit(greenBit, settingVal)) 	redGreen=GREEN_ON;
3276:main.c        **** 	//        else											redGreen=GREEN_OFF;
3277:main.c        **** __asm__ __volatile__
3278:main.c        **** 		  //SBRC takes 1 cycle if not skipping, 2 (or 3) if skipping
3279:main.c        **** 	     ( "sbrc %1, " GREEN_SETTING_BIT_STRING "; \n\t"				//0,1
3280:main.c        **** 							//Skip the jump if !getbit(GREEN, settingVal)
3281:main.c        **** 			 "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)	//1-
3282:main.c        **** 			 "ldi  %0, " GREEN_OFF_STRING "; \n\t"							//0-
3283:main.c        **** 			 "rjmp .+4; \n\t"  // skip setting GREEN_ON					//0-
3284:main.c        **** 			 "nop; \n\t"
3285:main.c        **** 			 "ldi  %0, " GREEN_ON_STRING "; \n\t"							//1-
3286:main.c        **** 			: "=r" (redGreen)		//redGreen is assigned to %0
3287:main.c        **** 			: "r"  (settingVal)	//settingVal is assigned to %1
3288:main.c        **** 			);
3289:main.c        **** 	//Simply: if(getbit(redBit, settingVal))		redGreen|=RED_ON;
3290:main.c        **** 	//			 else											redGreen|=RED_OFF;
3291:main.c        **** __asm__ __volatile__
3292:main.c        **** 	     ( "sbrc %1, " RED_SETTING_BIT_STRING "; \n\t"
3293:main.c        ****                      //Skip the jump if !getbit(GREEN, settingVal)
3294:main.c        ****           "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)
3295:main.c        ****           "ori  %2, " RED_OFF_STRING "; \n\t"
3296:main.c        ****           "rjmp .+4; \n\t"  // skip setting GREEN_ON
3297:main.c        ****           "nop; \n\t"
3298:main.c        **** 			 "ori  %2, " RED_ON_STRING "; \n\t"
3299:main.c        ****          : "=r" (redGreen)    //redGreen is assigned to %0
3300:main.c        ****          : "r"  (settingVal),  //settingVal is assigned to %1
3301:main.c        **** 			  "d0"  (redGreen) //d is necessary for ori
3302:main.c        ****          );                 // 0 means 2 is shared with 0 for r/w... 
3303:main.c        **** 									 //(its value is also an input)
3304:main.c        **** 	//See notes in [the new] setBlue()
3305:main.c        **** 
3306:main.c        **** 	//Since instructions are longer than pixels, it's damn-near impossible
3307:main.c        **** 	// to have perfectly sharp edges... this order seems best,
3308:main.c        **** 	// but I haven't experimented much
3309:main.c        **** 	// May be that the reverse order is best when switching from lighter
3310:main.c        **** 	// to darker, which would require more overhead to detect
3311:main.c        **** 	// making pixels even longer. Best to have a single-LCD-pixel of ugly
3312:main.c        **** 	// than to make displayable pixels wider, reducing resolution...
3313:main.c        **** 	OCR1A = ocr;
3314:main.c        **** 	DT1 = dt;
3315:main.c        **** 	REDGREEN_PORT = redGreen;
3316:main.c        **** 
3317:main.c        **** 	//This is just to try to mimic 17's timing...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 81


3318:main.c        **** 	// (right now, there's some timing issues, 
3319:main.c        **** 	//   line seems to start somewhat randomly, near the right edge
3320:main.c        **** 	//   some PIXEL_SCROLLs give static...)
3321:main.c        **** 	// <= 46 optimizes out, somehow, even though the code-size is larger
3322:main.c        **** 	// Should be fixed now... (see delay_cyc hacks)
3323:main.c        **** //	delay_Dots(15);
3324:main.c        **** 
3325:main.c        **** }
3326:main.c        **** #endif //FALSE
3327:main.c        **** 
3328:main.c        **** static __inline__ \
3329:main.c        **** void writeColor(uint8_t colorVal) \
3330:main.c        **** 	  __attribute__((__always_inline__));
3331:main.c        **** 
3332:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3333:main.c        **** //THIS IS JUST AN ESTIMATE
3334:main.c        ****  #define WRITE_COLOR_CYCS	(13)
3335:main.c        **** #elif(defined(FOUR_SHADES) && FOUR_SHADES)
3336:main.c        ****  // Roughly...
3337:main.c        ****  #define WRITE_COLOR_CYCS	(12*2+9+3)
3338:main.c        **** #else
3339:main.c        ****  // Roughly...
3340:main.c        ****  #define WRITE_COLOR_CYCS	(9*3+3)
3341:main.c        **** #endif
3342:main.c        **** 
3343:main.c        **** void writeColor(uint8_t colorVal)
3344:main.c        **** {
3345:main.c        **** //#warning "I'm absolutely certain this'll need to be revised, probably asm"
3346:main.c        **** 	//   Red: (+OC1D => RX0+)
3347:main.c        **** 	//    Off (0/63): OCR1D = 0
3348:main.c        **** 	//    35/63:      OCR1D = 3
3349:main.c        **** 	//    63/63:      OCR1D >= 6
3350:main.c        **** 
3351:main.c        **** /* No Shit: This compiles to a 16-bit test!
3352:main.c        **** 	switch((uint8_t)(colorVal & (uint8_t)0x03))
3353:main.c        **** 	{
3354:main.c        **** 		case (uint8_t)0:
3355:main.c        **** 			OCR1D = 0;
3356:main.c        **** 			break;
3357:main.c        **** 		case (uint8_t)1:
3358:main.c        **** 			OCR1D = 3;
3359:main.c        **** 			break;
3360:main.c        **** 		case (uint8_t)2:
3361:main.c        **** 		default:
3362:main.c        **** 			OCR1D = 6;
3363:main.c        **** 			break;
3364:main.c        **** 	}
3365:main.c        **** */
3366:main.c        **** 
3367:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3368:main.c        **** 	// In this case, colorVal is actually settingVal...
3369:main.c        **** 	// Between LDI, these instructions, and OCR/DT register writes
3370:main.c        **** 	// this is 14 cycles... or 16 pixels...
3371:main.c        **** 
3372:main.c        **** 	//										//ldi (colorVal) (2 cyc)
3373:main.c        **** 	//Red: (temp)
3374:main.c        **** 	uint8_t ocrd = colorVal >> 2;	//mov, shl, shl
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 82


3375:main.c        **** 	//Green:
3376:main.c        **** 	uint8_t dt = colorVal & 0x03; //andi
3377:main.c        **** 	//Blue:
3378:main.c        **** 	uint8_t ocra = ocrd >> 3;		//mov, shl, shl, shl
3379:main.c        **** 	//And red...
3380:main.c        **** 	ocrd &= 0x07;						//andi
3381:main.c        **** 											//out OCRD, out DT, out OCRA
3382:main.c        **** 
3383:main.c        **** #else //NOT ROW_BUFFER (FRAMEBUFFER)
3384:main.c        **** 
3385:main.c        **** //	uint8_t redVal; // = colorVal & 0x03;
3386:main.c        **** 	uint8_t ocrd;
3387:main.c        **** 
3388:main.c        **** /*
3389:main.c        **** 	if(redVal == 0x00)
3390:main.c        **** 		ocrd = 0;
3391:main.c        **** 	else if(redVal == 0x01)
3392:main.c        **** 		ocrd = 3;
3393:main.c        **** 	else //2, 3
3394:main.c        **** 		ocrd = 6;
3395:main.c        **** */
3396:main.c        **** #if(defined(FOUR_SHADES) && FOUR_SHADES)
3397:main.c        ****  // "nop; nop; nop;" compiles to just a single nop! 
3398:main.c        ****  //"\n\t" or maybe the space is necessary
3399:main.c        ****  #define FOUR_SHADES_NOPS "nop ; \n\t nop ; \n\t nop ; \n\t"
3400:main.c        **** #else
3401:main.c        ****  #define FOUR_SHADES_NOPS "\n\t"
3402:main.c        **** #endif
3403:main.c        **** 	//Each branch is 9 cycles... (12 with FOUR_SHADES)
3404:main.c        **** __asm__ __volatile__
3405:main.c        **** 	( "mov 	%0, %1 	; \n\t"	// ocrd (redVal) = colorVal			  //1
3406:main.c        **** 	  "andi	%0, 0x03	; \n\t"	// ocrd = ocrd & 0x03					  //1
3407:main.c        **** 	  "brne	red1tst_%=; \n\t"	// if(ocrd != 0x00) jump to red1test  //1`2
3408:main.c        **** 	  "ldi   %0, 0x00	; \n\t"	// (ocrd==0x00) add some delays		  //1 .
3409:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
3410:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
3411:main.c        **** 	  "nop				; \n\t"  //                                    //1 .
3412:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //N .
3413:main.c        **** 	  "rjmp  end_%=	; \n\t"	//   jump to the end						  //2 .
3414:main.c        **** 	  									// (ocrd_reg = redVal_reg = 0)            .
3415:main.c        **** 	"red1tst_%=:"					//"%=" is a unique identifier for this asm.
3416:main.c        **** 										//  invocation, so the label won't be     .
3417:main.c        **** 										//  mistaken from another invocation      .
3418:main.c        **** 	  "cpi	%0, 0x01	; \n\t"	// if(ocrd-0x01 != 0)					  //  1
3419:main.c        **** 	  "brne	red23_%=	; \n\t"	//   jump to red=2,3						  //  1`2
3420:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //  N .
3421:main.c        **** 	  "ldi	%0, 0x03	; \n\t"	// else ocrd = 0x03                   //  1 .
3422:main.c        **** 	  "rjmp	end_%=	; \n\t"	//      jump to the end               //  2 .
3423:main.c        **** 	"red23_%=:"                                                      //    .
3424:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3425:main.c        **** 	  "cpi	%0, 0x02 ; \n\t"	// if(ocrd-0x02 !=0)                  //( . 1
3426:main.c        **** 	  "brne  red3_%=	; \n\t"	//		jump to red=3                   //( . 1`2
3427:main.c        **** 	  "ldi   %0, 0x04 ; \n\t"	// else ocrd=4                        //( . 1 .
3428:main.c        **** 	  "rjmp  end_%=	; \n\t"	//      jump to the end               //( . 2 .
3429:main.c        **** 	"red3_%=:"                                                       //( .   /
3430:main.c        **** #endif                                                              //(  \ /
3431:main.c        ****      "ldi	%0, 0x06	; \n\t"	// ocrd = 0x06                        //    1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 83


3432:main.c        **** 	  "nop				; \n\t"  // one delay...							  //    1
3433:main.c        ****   "end_%=:"
3434:main.c        **** 
3435:main.c        **** 	  : "=r" (ocrd)      //Output only "%0"
3436:main.c        **** 	  : "r"  (colorVal)  //colorVal is "%1"
3437:main.c        **** 	  //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3438:main.c        **** 	);
3439:main.c        **** 
3440:main.c        **** 
3441:main.c        **** //	OCR1D = ocrd;
3442:main.c        **** 
3443:main.c        **** 
3444:main.c        **** 	//   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
3445:main.c        **** 	//    Off (6/63): DTL1 = 0
3446:main.c        **** 	//    38-39/63:      DTL1 = 1
3447:main.c        **** 	//    62-63/63:      DTL1 = 3
3448:main.c        **** /*	switch(colorVal & 0x0C)
3449:main.c        **** 	{
3450:main.c        **** 		case 0x00:
3451:main.c        **** 			DT1 = 0;
3452:main.c        **** 			break;
3453:main.c        **** 		case 0x04:
3454:main.c        **** 			DT1 = 1;
3455:main.c        **** 			break;
3456:main.c        **** 		case 0x08:
3457:main.c        **** 		default:
3458:main.c        **** 			DT1 = 3;
3459:main.c        **** 			break;
3460:main.c        **** 	}
3461:main.c        **** */
3462:main.c        **** //	uint8_t greenVal = colorVal & 0x0C;
3463:main.c        **** 	uint8_t dt;
3464:main.c        **** /*	if(greenVal == 0x00)
3465:main.c        **** 		dt=0;
3466:main.c        **** 	else if(greenVal == 0x04)
3467:main.c        **** 		dt=1;
3468:main.c        **** 	else //0x06, 0x0C
3469:main.c        **** 		dt=3;
3470:main.c        **** */
3471:main.c        ****    //Each branch is 9 cycles... (12 with FOUR_SHADES)
3472:main.c        **** __asm__ __volatile__
3473:main.c        ****    ( "mov   %0, %1   ; \n\t"  // dt (greenVal) = colorVal           //1
3474:main.c        ****      "andi  %0, 0x0C ; \n\t"  // dt = dt & 0x0C                     //1
3475:main.c        ****      "brne  grn4tst_%=; \n\t" // if(dt != 0x00) jump to grn4test    //1`2
3476:main.c        ****      "ldi   %0, 0x00 ; \n\t"  // (dt==0x00) add some delays         //1 .
3477:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3478:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3479:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3480:main.c        ****      FOUR_SHADES_NOPS         //                                    //N .
3481:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3482:main.c        ****    "grn4tst_%=:"              //"%=" is a unique identifier for this asm.
3483:main.c        ****                               //  invocation, so the label won't be     .
3484:main.c        ****                               //  mistaken from another invocation      .
3485:main.c        ****      "cpi   %0, 0x04 ; \n\t"  // if(dt-0x04 != 0)                   //  1
3486:main.c        ****      "brne  grn8C_%= ; \n\t"  //   jump to green=8,C                //  1`2
3487:main.c        ****      "ldi   %0, 0x01 ; \n\t"  // else dt = 0x01                     //  1 .
3488:main.c        ****      FOUR_SHADES_NOPS         //                                    //  N .
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 84


3489:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3490:main.c        ****    "grn8C_%=:"                                                      //    .
3491:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3492:main.c        ****      "cpi   %0, 0x08 ; \n\t"  // if(dt-0x08 !=0)                    //( . 1
3493:main.c        ****      "brne  grn3_%=  ; \n\t"  //    jump to green=3                 //( . 1`2
3494:main.c        ****      "ldi   %0, 0x02 ; \n\t"  // else dt=2                          //( . 1 .
3495:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //( . 2 .
3496:main.c        ****    "grn3_%=:"                                                       //( .   /
3497:main.c        **** #endif                                                              //(  \ /
3498:main.c        ****      "ldi   %0, 0x03 ; \n\t"  // dt = 0x03                          //    1
3499:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3500:main.c        ****    "end_%=:"
3501:main.c        **** 
3502:main.c        ****      : "=r" (dt)      //Output only "%0"
3503:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3504:main.c        ****      //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3505:main.c        ****    );
3506:main.c        **** 
3507:main.c        **** 
3508:main.c        **** 
3509:main.c        **** //	DT1 = dt;
3510:main.c        **** 	//   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
3511:main.c        **** 	//    Off (15/63):  OCR1A=4
3512:main.c        **** 	//    47/63:        OCR1A=5
3513:main.c        **** 	//    63/63:        OCR1A=6
3514:main.c        **** /*	switch(colorVal & 0x30)
3515:main.c        **** 	{
3516:main.c        **** 		case 0x00:
3517:main.c        **** 			OCR1A = 4;
3518:main.c        **** 			break;
3519:main.c        **** 		case 0x10:
3520:main.c        **** 			OCR1A = 5;
3521:main.c        **** 			break;
3522:main.c        **** 		case 0x20:
3523:main.c        **** 		default:
3524:main.c        **** 			OCR1A = 6;
3525:main.c        **** 			break;
3526:main.c        **** 	}
3527:main.c        **** */
3528:main.c        **** //	uint8_t blueVal = colorVal & 0x30;
3529:main.c        **** 	uint8_t ocra;
3530:main.c        **** /*	if(blueVal == 0x00)
3531:main.c        **** 		ocra=4;
3532:main.c        **** 	else if(blueVal == 0x10)
3533:main.c        **** 		ocra=5;
3534:main.c        **** 	else //0x20, 0x30
3535:main.c        **** 		ocra=6;
3536:main.c        **** */
3537:main.c        **** 
3538:main.c        ****    //Each branch is 9 cycles...
3539:main.c        **** __asm__ __volatile__
3540:main.c        ****    ( "mov   %0, %1   ; \n\t"  // ocra (blueVal) = colorVal          //1
3541:main.c        ****      "andi  %0, 0x30 ; \n\t"  // ocra = ocra & 0x30                 //1
3542:main.c        ****      "brne  blu1tst_%=; \n\t" // if(ocra != 0x00) jump to red1test  //1`2
3543:main.c        ****      "ldi   %0, 0x04 ; \n\t"  // (ocra==0x00) add some delays       //1 .
3544:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3545:main.c        ****      "nop            ; \n\t"  //                                    //1 .
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 85


3546:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3547:main.c        ****      "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3548:main.c        ****                               // (ocra_reg = blueVal_reg = 0)            .
3549:main.c        ****    "blu1tst_%=:"              //"%=" is a unique identifier for this asm.
3550:main.c        ****                               //  invocation, so the label won't be     .
3551:main.c        ****                               //  mistaken from another invocation      .
3552:main.c        ****      "cpi   %0, 0x10 ; \n\t"  // if(ocra-0x10 != 0)                 //  1
3553:main.c        ****      "brne  blu23_%= ; \n\t"  //   jump to red=2,3                  //  1`2
3554:main.c        ****      "ldi   %0, 0x05 ; \n\t"  // else ocra = 0x05                   //  1 .
3555:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3556:main.c        ****    "blu23_%=:"                                                      //    .
3557:main.c        ****      "ldi   %0, 0x06 ; \n\t"  // ocra = 0x06                        //    1
3558:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3559:main.c        ****    "end_%=:"
3560:main.c        **** 
3561:main.c        ****      : "=r" (ocra)      //Output only "%0"
3562:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3563:main.c        ****      //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
3564:main.c        ****    );
3565:main.c        **** 
3566:main.c        **** #endif //SETTING vs. FRAMEBUFFER
3567:main.c        **** 
3568:main.c        **** 	DT1 = dt;
3569:main.c        **** 	OCR1D = ocrd;
3570:main.c        **** 	OCR1A=ocra;
3571:main.c        **** }
3572:main.c        **** 
3573:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
3574:main.c        **** void setColor(uint8_t red, uint8_t green, uint8_t blue, 
3575:main.c        **** 					uint8_t row, uint8_t col)
3576:main.c        **** {
3577:main.c        **** 	red = (red > 3) ? 3 : red;
3578:main.c        **** 	green = (green > 3) ? 3 : green;
3579:main.c        **** 	blue = (blue > 3) ? 3 : blue;
3580:main.c        **** 
3581:main.c        **** 	frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
3582:main.c        **** }
3583:main.c        **** #endif
3584:main.c        **** 
3585:main.c        **** /*
3586:main.c        **** void setBlue(uint8_t val, uint8_t r, uint8_t c)
3587:main.c        **** {
3588:main.c        **** 	//Each If statement consists of (rougly):
3589:main.c        **** 	//  comparison (cpi)
3590:main.c        **** 	//  jump if false to next (brcs)
3591:main.c        **** 	//    load immediate -> register
3592:main.c        **** 	//    out OCR1a <- register
3593:main.c        **** 	//    load immediate -> register
3594:main.c        **** 	//    out DT1 <- register
3595:main.c        **** 	//    jump to end of If's...
3596:main.c        **** 
3597:main.c        **** 	//THUS: the brighter the color, the fewer cycles are executed
3598:main.c        **** 	// (fewer comparisons, fewer jumps)
3599:main.c        **** 	
3600:main.c        **** 	// One option: insert NOPs...
3601:main.c        **** 	// Another option (and probably better all 'round):
3602:main.c        **** 	//   Store the OCR1A and DT1 values in the settingBuffer
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 86


3603:main.c        **** 	//   instead of storing the color value
3604:main.c        **** 	//   (IOW: do this test when writing the "settingBuffer"
3605:main.c        **** 	//    instead of when reading)
3606:main.c        **** 	//   Then, here, just write OCR1A and DT1
3607:main.c        **** 	//   If a single-byte is used for both, DT1 could be written directly
3608:main.c        **** 	//     e.g. blueSetting=(DTVal<<4) | OCR1AVal
3609:main.c        **** 	//     DT1 = blueSetting; //OK since /OCR1n outputs are unused
3610:main.c        **** 	//     OCR1A = (blueSetting & 0x0f);
3611:main.c        **** 
3612:main.c        **** 
3613:main.c        **** 
3614:main.c        ****    // | (val & GREEN_SETTING_BIT)  is a hack a/o v20, for GREEN
3615:main.c        ****    uint8_t green =
3616:main.c        ****       getbit(GREEN_BLUEVAL_BIT, val) ? (1<<GREEN_SETTING_BIT) : 0 ;
3617:main.c        ****    uint8_t red =
3618:main.c        ****       getbit(RED_BLUEVAL_BIT, val) ? (1<<RED_SETTING_BIT) : 0 ;
3619:main.c        **** 
3620:main.c        ****    uint8_t redGreen = green | red;
3621:main.c        **** 
3622:main.c        **** 
3623:main.c        **** 
3624:main.c        **** #if(defined(DC_DE_DISABLE) && DC_DE_DISABLE)
3625:main.c        **** // #define NUM_BLUES 5		//Currently Unused... (not including black)
3626:main.c        **** #else
3627:main.c        **** // #define NUM_BLUES 6		//Currently Unused... (not including black)
3628:main.c        **** 
3629:main.c        **** 	if(val>=(60<<2)) 
3630:main.c        **** 	{
3631:main.c        **** 		//OCR1A = 0xff;
3632:main.c        **** 		settingBuffer[r][c] = (0<<4) | 6 | redGreen;
3633:main.c        **** 	}
3634:main.c        **** 	else
3635:main.c        **** #endif
3636:main.c        **** 	if(val >= (44<<2))
3637:main.c        **** 	{
3638:main.c        **** 		//OCR1A = 5;
3639:main.c        **** 		//DT1 = (0<<4);
3640:main.c        **** 		settingBuffer[r][c] = (0<<4) | 5 | redGreen;
3641:main.c        **** 	}
3642:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3643:main.c        **** 	else if(val >= (36<<2)) //OK
3644:main.c        **** 	{
3645:main.c        **** 		//OCR1A = 5;
3646:main.c        **** 		//DT1 = (1<<4);
3647:main.c        **** 		settingBuffer[r][c] = (1<<4) | 5 | redGreen;
3648:main.c        **** 	}
3649:main.c        **** 	else if(val >= (32<<2)) //OK
3650:main.c        **** 	{
3651:main.c        **** 		//DT1=(2<<4);
3652:main.c        **** 		//OCR1A = 5;
3653:main.c        **** 		settingBuffer[r][c] = (2<<4) | 5 | redGreen;
3654:main.c        **** 	}
3655:main.c        **** 	else if(val >= (12<<2)) //DIM
3656:main.c        **** #else //DT0_BLUES_ONLY
3657:main.c        **** 	else //Closest to black we can get with DT=0
3658:main.c        **** #endif
3659:main.c        **** 	{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 87


3660:main.c        **** 		//DT1=(0<<4);
3661:main.c        **** 		//OCR1A = 4;
3662:main.c        **** 		settingBuffer[r][c] = (0<<4) | 4 | redGreen;
3663:main.c        **** 	}
3664:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3665:main.c        **** 	else if(val >= (4<<2)) //DIM
3666:main.c        **** 	{
3667:main.c        **** 		//DT1=(1<<4);
3668:main.c        **** 		//OCR1A = 4;
3669:main.c        **** 		settingBuffer[r][c] = (1<<4) | 4 | redGreen;
3670:main.c        **** 	}
3671:main.c        **** 	else	//Black
3672:main.c        **** 	{
3673:main.c        **** 		//DT1=(2<<4);
3674:main.c        **** 		//OCR1A = 4;
3675:main.c        **** 		settingBuffer[r][c] = (2<<4) | 4 | redGreen;
3676:main.c        **** 	}
3677:main.c        **** #endif
3678:main.c        **** }
3679:main.c        **** */
3680:main.c        **** 
3681:main.c        **** /*
3682:main.c        **** static __inline__ \
3683:main.c        **** void drawPix(uint8_t rowNum) \
3684:main.c        **** 	  __attribute__((__always_inline__));
3685:main.c        **** */
3686:main.c        **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
3687:main.c        **** void drawPix(uint8_t rowNum)
3688:main.c        **** {
3689:main.c        **** 	//uint8_t *setting = &(settingBuffer[rowNum][0]);
3690:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3691:main.c        **** 	uint8_t *color = &(rowBuffer[0]);
3692:main.c        **** #else
3693:main.c        **** 	uint8_t *color = &(frameBuffer[rowNum][0]);
3694:main.c        **** #endif
3695:main.c        **** 	/*
3696:main.c        ****       DEonly_fromNada();
3697:main.c        ****       //Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
3698:main.c        ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3699:main.c        ****                | (0<<COM1B1) | (1<<COM1B0)
3700:main.c        ****                | (1<<PWM1A) | (1<<PWM1B) );
3701:main.c        **** 	*/
3702:main.c        **** 		//The Greenish-bar on the left is due to the time it takes to execute
3703:main.c        **** 		// the first writeColor (since its value is only written at the END)
3704:main.c        **** 		// Thus the greenish-bar is about one write-color wide...
3705:main.c        **** 
3706:main.c        **** 	//Judging by some weird experiences re v21/22,
3707:main.c        **** 	// it's not entirely likely this will be predictable
3708:main.c        **** 	// it may try to recalculate the Z register between writeBlues...
3709:main.c        **** 	// hopefully not, for now. I should probably assemblify this
3710:main.c        **** 		writeColor(*(color+0));
3711:main.c        **** 
3712:main.c        **** 		//Moving this here not only removes (most of) the green bar
3713:main.c        **** 		// but also seems to make the pixel edges significantly sharper
3714:main.c        **** 		// (v29 has ~1/8in of noise, v30 has ~1pixel noise at the right edge)
3715:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3716:main.c        **** 		         | (0<<COM1B1) | (1<<COM1B0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 88


3717:main.c        **** 		         | (1<<PWM1A) | (1<<PWM1B) );
3718:main.c        **** 
3719:main.c        **** 		writeColor(*(color+1));	 
3720:main.c        **** 		writeColor(*(color+2));	 
3721:main.c        **** 		writeColor(*(color+3)); 
3722:main.c        **** 		writeColor(*(color+4));	 
3723:main.c        **** 		writeColor(*(color+5));					 
3724:main.c        **** 		writeColor(*(color+6));  
3725:main.c        **** 		writeColor(*(color+7));                         
3726:main.c        **** 		writeColor(*(color+8));                         
3727:main.c        **** 		writeColor(*(color+9));                         
3728:main.c        **** 		writeColor(*(color+10));                         
3729:main.c        **** 		writeColor(*(color+11));                         
3730:main.c        **** 		writeColor(*(color+12));                         
3731:main.c        **** 		writeColor(*(color+13));                         
3732:main.c        **** 		writeColor(*(color+14));                         
3733:main.c        **** 		writeColor(*(color+15));   
3734:main.c        **** #define COLORS_WRITTEN	16		
3735:main.c        **** #if ( (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL) \
3736:main.c        **** 	|| (defined(ROW_BUFFER) && (ROW_BUFFER)) )
3737:main.c        **** 		writeColor(*(color+16));
3738:main.c        **** 		writeColor(*(color+17));
3739:main.c        **** 		writeColor(*(color+18));
3740:main.c        **** 		writeColor(*(color+19));
3741:main.c        **** writeColor(*(color+20));
3742:main.c        **** writeColor(*(color+21));
3743:main.c        **** writeColor(*(color+22));
3744:main.c        **** writeColor(*(color+23));
3745:main.c        **** writeColor(*(color+24));
3746:main.c        **** writeColor(*(color+25));
3747:main.c        **** writeColor(*(color+26));
3748:main.c        **** writeColor(*(color+27));
3749:main.c        **** #define COLORS_WRITTEN	28
3750:main.c        **** #if (defined(ROW_BUFFER) && (ROW_BUFFER))
3751:main.c        **** writeColor(*(color+28));
3752:main.c        **** writeColor(*(color+29));
3753:main.c        **** writeColor(*(color+30));
3754:main.c        **** writeColor(*(color+31));
3755:main.c        **** //Some sort of syncing problem after 32... (?)
3756:main.c        **** 
3757:main.c        **** writeColor(*(color+32));
3758:main.c        **** writeColor(*(color+33));
3759:main.c        **** writeColor(*(color+34));
3760:main.c        **** writeColor(*(color+35));
3761:main.c        **** writeColor(*(color+36));
3762:main.c        **** writeColor(*(color+37));
3763:main.c        **** writeColor(*(color+38));
3764:main.c        **** writeColor(*(color+39));
3765:main.c        **** writeColor(*(color+40));
3766:main.c        **** writeColor(*(color+41));
3767:main.c        **** writeColor(*(color+42));
3768:main.c        **** writeColor(*(color+43));
3769:main.c        **** writeColor(*(color+44));
3770:main.c        **** writeColor(*(color+45));
3771:main.c        **** writeColor(*(color+46));
3772:main.c        **** writeColor(*(color+47));
3773:main.c        **** writeColor(*(color+48));
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 89


3774:main.c        **** writeColor(*(color+49));
3775:main.c        **** writeColor(*(color+50));
3776:main.c        **** writeColor(*(color+51));
3777:main.c        **** writeColor(*(color+52));
3778:main.c        **** writeColor(*(color+53));
3779:main.c        **** writeColor(*(color+54));
3780:main.c        **** writeColor(*(color+55));
3781:main.c        **** writeColor(*(color+56));
3782:main.c        **** writeColor(*(color+57));
3783:main.c        **** writeColor(*(color+58));
3784:main.c        **** writeColor(*(color+59));
3785:main.c        **** writeColor(*(color+60));
3786:main.c        **** writeColor(*(color+61));
3787:main.c        **** writeColor(*(color+62));
3788:main.c        **** writeColor(*(color+63));
3789:main.c        **** // WriteColor writes the pixel *after* the calculations...
3790:main.c        **** // thus the pixel appears basically after writeColor completes
3791:main.c        **** // These nops assure the 64th pixel is fully-displayed before exitting
3792:main.c        **** // (Not sure how the other following instructions apply to this)
3793:main.c        **** // The number of nops was found experimentally...
3794:main.c        **** asm("nop");
3795:main.c        **** asm("nop");
3796:main.c        **** asm("nop");
3797:main.c        **** asm("nop");
3798:main.c        **** asm("nop");
3799:main.c        **** asm("nop");
3800:main.c        **** asm("nop");
3801:main.c        **** asm("nop");
3802:main.c        **** //count "0" below, as well..
3803:main.c        **** #define COLORS_WRITTEN 65
3804:main.c        **** #endif //ROW_BUFFER
3805:main.c        **** #else
3806:main.c        **** //	writeColor(0);
3807:main.c        **** #endif //COLOR_BARS || ROW_BUFFER
3808:main.c        **** 
3809:main.c        **** /*		reg[17] = colorBuffer[rowNum][17];                         
3810:main.c        **** 		writeColor(reg[17]);                         
3811:main.c        **** 		...
3812:main.c        **** 		reg[20] = colorBuffer[rowNum][20];                         
3813:main.c        **** 		writeColor(reg[20]);  
3814:main.c        **** 		
3815:main.c        **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
3816:main.c        **** 		reg[0] = colorBuffer[rowNum][0];
3817:main.c        **** 		writeColor(reg[0]);
3818:main.c        **** 		...
3819:main.c        **** 		reg[10] = colorBuffer[rowNum][10];
3820:main.c        **** 		writeColor(reg[10]);
3821:main.c        **** */
3822:main.c        **** 		//Display the rest as black...
3823:main.c        **** 		writeColor(0);
3824:main.c        **** 		//writeColor(0xff);
3825:main.c        **** 	  	//delay_Dots(500);//142); //Don't want to disable DE too early...	
3826:main.c        **** 		//900 leaves a buffer for various calculations while also showing
3827:main.c        **** 		// a blue bar at the right-side...
3828:main.c        **** 		//LTN Last Used 900
3829:main.c        **** 		// -68 is from 900's intent, IIRC
3830:main.c        **** 		//  seems arbitrary, but its value (especially if too small)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 90


3831:main.c        **** 		// causes blank lines... (?!)
3832:main.c        **** 		// -60 makes more sense for a delay (was the original post-900)
3833:main.c        **** 		//  (outside DOTS_TO_CYC because it's for cycles used for calcs...
3834:main.c        **** 		// -68 worked for LVDS_PRE=2
3835:main.c        **** 		// -60 for 1
3836:main.c        **** 		// 4 doesn't work... blue-lines
3837:main.c        **** 
3838:main.c        **** #else		//ROW_SEG_BUFFER
3839:main.c        **** void drawPix(uint8_t rowNum)
3840:main.c        **** {
3841:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3842:main.c        **** 	         | (0<<COM1B1) | (1<<COM1B0)
3843:main.c        **** 	         | (1<<PWM1A) | (1<<PWM1B) );
3844:main.c        **** 
3845:main.c        **** 		drawSegs();
3846:main.c        **** 
3847:main.c        **** #if (defined(GB_COMBINED) && GB_COMBINED)
3848:main.c        ****  #define WRITE_COLOR_CYCS 20
3849:main.c        **** #else
3850:main.c        ****  #define WRITE_COLOR_CYCS 16
3851:main.c        **** #endif
3852:main.c        **** #define COLORS_WRITTEN	64
3853:main.c        **** 
3854:main.c        **** #endif
3855:main.c        **** 
3856:main.c        **** 
3857:main.c        **** 
3858:main.c        **** #define ROW_COMPLETION_DELAY \
3859:main.c        **** 		(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60  \
3860:main.c        **** 		 - WRITE_COLOR_CYCS * COLORS_WRITTEN)
3861:main.c        **** /*
3862:main.c        **** 
3863:main.c        **** #error "should add SEG_STRETCH here..."
3864:main.c        **** #if (ROW_COMPLETION_DELAY > 0)
3865:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60 // - 68)// - 60
3866:main.c        **** 				- WRITE_COLOR_CYCS*COLORS_WRITTEN);
3867:main.c        **** #else
3868:main.c        **** #warning "ROW_COMPLETION_DELAY <= 0"
3869:main.c        **** #endif
3870:main.c        **** */		//DE->Nada transition expects fullBlue...
3871:main.c        **** 		//Also helps to show the edge of the DE timing...
3872:main.c        **** 
3873:main.c        **** 		//!!! Not sure what the state is at this point...
3874:main.c        **** 		// could be any DE+Blue level, or could be NADA...
3875:main.c        **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
3876:main.c        ****          
3877:main.c        **** 		//Among the things that don't make sense...
3878:main.c        **** 		// This appears to go into affect BEFORE delay_cyc (?)
3879:main.c        **** 		// as, without a pull-up resistor on the /OC1B output, 
3880:main.c        **** 		// green seems to be floating between the last pixel and the
3881:main.c        **** 		// delay_cyc (!)
3882:main.c        **** 		//Disable complementary-output for Green 
3883:main.c        **** 		//  (on /OC1B, where CLK is OC1B)
3884:main.c        **** 		// Since Nada, V, and H DT's might be bad for clocking.
3885:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3886:main.c        ****          | (1<<COM1B1) | (0<<COM1B0)
3887:main.c        ****          | (1<<PWM1A) | (1<<PWM1B) );
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 91


3888:main.c        **** 
3889:main.c        **** 		fullBlue();
3890:main.c        **** 		Nada_fromDEonly();
3891:main.c        **** }
3892:main.c        **** 
3893:main.c        **** #if 0   //in LCDStuff...
3894:main.c        **** // SCOPING has been removed in LVDS, revisit LCDdirect50
3895:main.c        **** //#else //NOT SCOPING
3896:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable)
3897:main.c        **** {
3898:main.c        **** 	//H Active pulse...
3899:main.c        ****    if(vSync)
3900:main.c        ****    {
3901:main.c        **** 		//Vsync_fromNada() is called at the end of the last interupt
3902:main.c        ****       VplusH_fromVsync();
3903:main.c        ****       Hlow_Delay();
3904:main.c        ****       Vsync_fromVplusH();
3905:main.c        ****       HD_Delay();
3906:main.c        ****    }
3907:main.c        ****    else
3908:main.c        ****    {
3909:main.c        ****       Hsync_fromNada();
3910:main.c        ****       Hlow_Delay();
3911:main.c        ****       Nada_fromHsync();
3912:main.c        ****       HD_Delay();
3913:main.c        ****    }
3914:main.c        **** 
3915:main.c        ****    if(dataEnable)
3916:main.c        ****    {
3917:main.c        **** 
3918:main.c        **** /* WTF, how did this work?! Am I not using drawPix?!
3919:main.c        **** 	Yes, but drawPix calls drawSegs, which doesn't have an argument
3920:main.c        **** 	because loadRow takes the row argument elsewhere, drawSegs just
3921:main.c        **** 	draws 'em
3922:main.c        **** 		//#warning "see 'shouldBe' here..."
3923:main.c        **** 		//Should be:
3924:main.c        **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
3925:main.c        **** 		//rowNum = rowNum / (768/FB_HEIGHT);
3926:main.c        **** */
3927:main.c        **** 
3928:main.c        **** 		//DEonly_fromNada();
3929:main.c        ****       drawPix(rowNum);
3930:main.c        **** 		//Nada_init();
3931:main.c        **** //#warning "THIS ISN'T SAFE"
3932:main.c        **** //		Nada_fromDEonly();
3933:main.c        **** //#endif
3934:main.c        **** 
3935:main.c        **** 	}
3936:main.c        **** }
3937:main.c        **** #endif
3938:main.c        **** /* These are old tests from above, under if(dataEnable)
3939:main.c        **** 	They should all be implemented in lcdStuff.c, but have not been
3940:main.c        **** 	retested since...
3941:main.c        **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
3942:main.c        **** 		uint16_t blueCyc = DOTS_TO_CYC(rowNum);
3943:main.c        **** 		uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
3944:main.c        **** 		
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 92


3945:main.c        **** 		DEonly_fromNada();
3946:main.c        **** 		delay_cyc(notBlueCyc);
3947:main.c        **** 		DEblue_fromDEonly();
3948:main.c        **** 		delay_cyc(blueCyc);
3949:main.c        **** 
3950:main.c        **** 		Nada_fromDEblue();
3951:main.c        **** #elif(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
3952:main.c        **** 		DEonly_fromNada();
3953:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
3954:main.c        **** 		DEblue_fromDEonly();
3955:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
3956:main.c        **** 		Nada_fromDEblue();
3957:main.c        **** #elif(defined(DE_BLUE) && DE_BLUE)
3958:main.c        **** 		DEblue_fromNada();
3959:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
3960:main.c        **** 		Nada_fromDEblue();
3961:main.c        **** #else  //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
3962:main.c        ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
3963:main.c        **** 		if(rowNum <= 256)
3964:main.c        **** 			rowNum=0;
3965:main.c        **** 		else
3966:main.c        **** 			rowNum=1;
3967:main.c        ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
3968:main.c        **** */
3969:main.c        **** 
3970:main.c        **** //Moved Above
3971:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
3972:main.c        **** //#define pgm_readImageByte(image, row, col)	\
3973:main.c        **** //	pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
3974:main.c        **** 
3975:main.c        **** #if( !defined(COLOR_BAR_SCROLL) || !COLOR_BAR_SCROLL)
3976:main.c        **** #if ( (FB_WIDTH != 16) || (FB_HEIGHT != 16) )
3977:main.c        ****  #error "image1 dimensions don't match FB_HEIGHT/WIDTH"
3978:main.c        ****  #error "It's likely I just need to create a specific DRAWIMAGE definition and tests"
3979:main.c        **** #endif
3980:main.c        **** 
3981:main.c        **** #define RED_IMAGEVAL_BIT 0
3982:main.c        **** #define GREEN_IMAGEVAL_BIT 1
3983:main.c        **** #define BLUE_IMAGEVAL_BIT 2
3984:main.c        **** 
3985:main.c        **** /*
3986:main.c        **** #define _R	0x03
3987:main.c        **** #define _O	0x07
3988:main.c        **** #define _G 0x0C
3989:main.c        **** #define _B 0x30
3990:main.c        **** #define _V 0x13
3991:main.c        **** #define _Y	0x0F
3992:main.c        **** #define _C 0x3C
3993:main.c        **** #define _M	0x33
3994:main.c        **** #define _K	0x00
3995:main.c        **** #define _W 0x3F
3996:main.c        **** #define _r 0x01
3997:main.c        **** #define _g 0x04
3998:main.c        **** #define _b 0x10
3999:main.c        **** #define _c 0x14
4000:main.c        **** #define _m 0x11
4001:main.c        **** #define _y 0x05
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 93


4002:main.c        **** #define _k 0x15
4003:main.c        **** #define Tr 0xC0	//Transparet
4004:main.c        **** */
4005:main.c        **** #if (TRUE || (!defined(LIFE) || !LIFE))
4006:main.c        **** uint8_t pgm_image1[256] PROGMEM =
4007:main.c        **** {
4008:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
4009:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4010:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4011:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4012:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_K,Tr,
4013:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_K,_K,_Y,_Y,_Y,_K,
4014:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,
4015:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4016:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4017:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
4018:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4019:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
4020:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4021:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4022:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4023:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
4024:main.c        **** };
4025:main.c        **** #else
4026:main.c        **** /*uint8_t pgm_image1[256] PROGMEM =
4027:main.c        **** {  
4028:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4029:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4030:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4031:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4032:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4033:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4034:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4035:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4036:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4037:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4038:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4039:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4040:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4041:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4042:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4043:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4044:main.c        **** };
4045:main.c        **** */
4046:main.c        **** /*
4047:main.c        **** {  
4048:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4049:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4050:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4051:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
4052:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4053:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4054:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
4055:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
4056:main.c        ****    _K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4057:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
4058:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_R,_K,_K,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 94


4059:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,_K,
4060:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,
4061:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4062:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
4063:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K
4064:main.c        **** };
4065:main.c        **** */
4066:main.c        **** 
4067:main.c        **** 
4068:main.c        **** 
4069:main.c        **** #endif
4070:main.c        **** 
4071:main.c        **** 
4072:main.c        **** uint8_t pgm_image2[256] PROGMEM =
4073:main.c        **** {
4074:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
4075:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
4076:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
4077:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
4078:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,Tr,
4079:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_K,
4080:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4081:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4082:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4083:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
4084:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4085:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
4086:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_K,_R,_K,_R,_K,_Y,_Y,_K,_K,Tr,
4087:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_K,_R,_R,_R,_K,_Y,_K,_K,Tr,Tr,
4088:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_K,_K,_K,_Y,_K,_K,Tr,Tr,Tr,
4089:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
4090:main.c        **** };
4091:main.c        **** #endif //COLOR_BAR_SCROLL
4092:main.c        **** 
4093:main.c        **** /*
4094:main.c        **** #if (IMAGE_WIDTH == 21)
4095:main.c        **** uint8_t mainData[2][768>>5][IMAGE_WIDTH] =
4096:main.c        **** {
4097:main.c        **** 	{
4098:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4099:main.c        **** 	{5,4,3,2,1,6,0,0,0,0,0,0,0,0,0,2,1,6,5,4,3},
4100:main.c        **** 	{4,3,2,1,0,0,0,3,3,3,3,3,3,3,0,0,0,5,4,3,4},
4101:main.c        **** 	{3,2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4102:main.c        **** 	{2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,1,6},
4103:main.c        **** 	{1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,5},
4104:main.c        **** 	{6,0,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,0,4},
4105:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,0,0},
4106:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,3,0},
4107:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,3,0},
4108:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4109:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4110:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4111:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4112:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4113:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4114:main.c        **** 	{6,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,4},
4115:main.c        **** 	{5,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3},
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 95


4116:main.c        **** 	{4,3,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2},
4117:main.c        **** 	{3,2,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4118:main.c        **** 	{2,1,5,5,0,0,0,3,3,3,3,3,3,3,0,0,0,3,2,1,6},
4119:main.c        **** 	{1,6,3,4,3,2,0,0,0,0,0,0,0,0,0,4,3,2,1,6,5},
4120:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4121:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3}
4122:main.c        **** 	},
4123:main.c        **** 	{	
4124:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4125:main.c        **** 	{4,3,2,1,6,5,0,0,0,0,0,0,0,0,0,1,6,5,4,3,2},
4126:main.c        **** 	{3,2,1,6,0,0,0,3,3,3,3,3,3,3,0,0,0,4,3,2,1},
4127:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,2,1,6},
4128:main.c        **** 	{1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,6,5},
4129:main.c        **** 	{6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4},
4130:main.c        **** 	{5,0,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,0,3},
4131:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,3,3,3,3,3,3,3,0,0},
4132:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,3,0,0,0,3,3,3,3,3,0},
4133:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,0},
4134:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4135:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4136:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4137:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4138:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4139:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4140:main.c        **** 	{5,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,3},
4141:main.c        **** 	{4,0,0,3,3,3,3,3,3,0,1,0,1,0,3,3,3,3,0,0,2},
4142:main.c        **** 	{3,2,0,0,3,3,3,3,3,0,1,1,1,0,3,3,3,0,0,2,1},
4143:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,0,0,0,3,3,3,0,0,2,1,6},
4144:main.c        **** 	{1,6,5,4,0,0,0,3,3,3,3,3,3,3,0,0,0,2,1,6,5},
4145:main.c        **** 	{6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,3,2,1,6,5,4},
4146:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4147:main.c        ****    {4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2}
4148:main.c        **** 	}
4149:main.c        **** };
4150:main.c        **** #else
4151:main.c        **** 	#error
4152:main.c        **** #endif
4153:main.c        **** */
4154:main.c        **** 
4155:main.c        **** 
4156:main.c        **** int main(void)
4157:main.c        **** {
4158:main.c        **** 
4159:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
4160:main.c        **** 	adc_takeInput(6);
4161:main.c        **** 	adc_init();
4162:main.c        **** 	adc_select(6);
4163:main.c        **** #endif
4164:main.c        **** 
4165:main.c        **** 	tetInit(7);
4166:main.c        **** 
4167:main.c        **** 	init_timer0Hsync();
4168:main.c        **** 
4169:main.c        **** 	//This starts pretty late... watch out for WDT
4170:main.c        **** 	init_heartBeat();
4171:main.c        **** 
4172:main.c        **** 	setHeartRate(0);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 96


4173:main.c        **** 
4174:main.c        **** 	lvds_timerInit();
4175:main.c        **** 
4176:main.c        **** 	//For synchronizing timer1 settings (to avoid glitches)
4177:main.c        **** 	// count the number of CPU cycles...
4178:main.c        **** 	// depending on how many cycles it takes to start this and whatnot, 
4179:main.c        **** 	// there may be an offset. But the jist is we know every 7 cycles
4180:main.c        **** 	// the timer1 reset is synchronized with the CPU instructions...
4181:main.c        **** //	OCR0A = 6;
4182:main.c        **** //	timer_setWGM(0, WGM_CLR_ON_COMPARE);
4183:main.c        **** //	timer_selectDivisor(0, CLKDIV1);
4184:main.c        **** 
4185:main.c        **** /*
4186:main.c        **** 	segPosition=0;
4187:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4188:main.c        **** 	newSeg(16, 0x00, (4<<4) | 0);
4189:main.c        **** 	newSeg(8, 0x06, (4<<4) | 0);
4190:main.c        **** 	newSeg(32, 0x00, (4<<4) | 3);
4191:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4192:main.c        **** 	segTerminate();
4193:main.c        **** */
4194:main.c        **** 
4195:main.c        **** /* I Think these were LONG AGO when Green and Red weren't implemented
4196:main.c        **** 	//For Green...
4197:main.c        **** 	// Possibly later to be reimplemented on PWM, but deadTime might inhibit
4198:main.c        **** 	setoutPORT(PA0, PORTA);
4199:main.c        **** 	setoutPORT(PA1, PORTA);
4200:main.c        **** 	//Red:
4201:main.c        **** 	setoutPORT(PA2, PORTA);
4202:main.c        **** 	setoutPORT(PA3, PORTA);
4203:main.c        **** */
4204:main.c        **** 
4205:main.c        **** 
4206:main.c        **** 	// MUCH Of this is outside the screen...
4207:main.c        **** 
4208:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
4209:main.c        **** /*	uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH] = 
4210:main.c        **** 	{ {
4211:main.c        **** 		(0<<2), 
4212:main.c        **** 			(0<<2) | (1<<RED_BLUEVAL_BIT), (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4213:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4214:main.c        **** 		(4<<2), 
4215:main.c        **** 			(4<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4216:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4217:main.c        **** 	   (12<<2), 
4218:main.c        **** 			(12<<2) | (1<<RED_BLUEVAL_BIT), (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4219:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4220:main.c        **** 		(32<<2), 
4221:main.c        **** 			(32<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4222:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4223:main.c        **** 		(36<<2), 
4224:main.c        **** 			(36<<2) | (1<<RED_BLUEVAL_BIT), (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4225:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4226:main.c        **** 		(44<<2), 
4227:main.c        **** 			(44<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4228:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4229:main.c        **** 		(60<<2),
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 97


4230:main.c        **** 	  		(60<<2) | (1<<RED_BLUEVAL_BIT), (60<<2) | (1<<GREEN_BLUEVAL_BIT),
4231:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (60<<2) | (1<<GREEN_BLUEVAL_BIT)
4232:main.c        **** 	  },
4233:main.c        **** 	  {
4234:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<RED_BLUEVAL_BIT),
4235:main.c        **** 	  	(12<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<RED_BLUEVAL_BIT),
4236:main.c        **** 	  	(36<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<RED_BLUEVAL_BIT),
4237:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT),
4238:main.c        **** 		
4239:main.c        **** 		(0<<2) | (1<<GREEN_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT), 
4240:main.c        **** 		(12<<2) | (1<<GREEN_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT), 
4241:main.c        **** 		(36<<2)| (1<<GREEN_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4242:main.c        **** 		(60<<2) | (1<<GREEN_BLUEVAL_BIT), 
4243:main.c        **** 		
4244:main.c        **** 		(0<<2), (4<<2), (12<<2),(32<<2), (36<<2), (44<<2), (60<<2),
4245:main.c        **** 
4246:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4247:main.c        **** 	  	(4<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4248:main.c        **** 		(12<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4249:main.c        **** 	  	(32<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4250:main.c        **** 		(36<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4251:main.c        **** 	  	(44<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4252:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT)
4253:main.c        **** 
4254:main.c        ****   	  }
4255:main.c        **** 	};
4256:main.c        **** */
4257:main.c        **** 
4258:main.c        **** 
4259:main.c        **** 	//Init:
4260:main.c        **** 	uint8_t i;
4261:main.c        **** 	for(i=0; i<FB_WIDTH; i++)
4262:main.c        **** 	{
4263:main.c        **** 		uint8_t j=FB_WIDTH-1-i;
4264:main.c        **** 		setColor((i&0x03), (i&0x0C)>>2, (i&0x30)>>4, 0, i);
4265:main.c        **** 		setColor((i&0x30)>>4, (i&0x0C)>>2, (i&0x03), 1, i);
4266:main.c        **** //		setBlue(frameBuffer[0][i], 0, i);
4267:main.c        **** //		setBlue(frameBuffer[1][i], 1, i);
4268:main.c        **** 	}
4269:main.c        **** #else	//NOT COLOR_BAR_SCROLL
4270:main.c        **** 	//uint8_t frameBuffer[16][16];
4271:main.c        **** 
4272:main.c        **** 	uint8_t row,col;
4273:main.c        **** /*	for(r=0; r<FB_HEIGHT; r++)
4274:main.c        **** 	{
4275:main.c        **** 		for(c=0; c<FB_WIDTH; c++)
4276:main.c        **** 		{
4277:main.c        **** 			uint8_t imagePixel=pgm_readImageByte(pgm_image1, r, c);
4278:main.c        **** 
4279:main.c        **** 			setColor(
4280:main.c        **** 				(getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4281:main.c        **** 				(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4282:main.c        **** 				(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
4283:main.c        **** 				r, c);
4284:main.c        **** //			setBlue(
4285:main.c        **** //					(
4286:main.c        **** //	(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? (60<<2) : 0) |
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 98


4287:main.c        **** //	(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? (1<<GREEN_BLUEVAL_BIT) : 0) |
4288:main.c        **** //	(getbit(RED_IMAGEVAL_BIT, imagePixel) ? (1<<RED_BLUEVAL_BIT) : 0)
4289:main.c        **** //					), r, c);
4290:main.c        **** 		}
4291:main.c        **** 	}
4292:main.c        **** */
4293:main.c        ****  #if (defined(IMAGE_CHANGE) && IMAGE_CHANGE)
4294:main.c        **** 	uint32_t counter=0;
4295:main.c        **** 	uint8_t imageNum = 0;
4296:main.c        **** 	uint8_t colorShift = 0;
4297:main.c        **** 	while(1)
4298:main.c        **** 	{
4299:main.c        ****  #if (defined(FRAME_SYNC) && FRAME_SYNC)
4300:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
4301:main.c        ****  #else
4302:main.c        **** 		if(counter==0)
4303:main.c        ****  #endif
4304:main.c        **** 		{
4305:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4306:main.c        **** 			uint8_t *pimage;
4307:main.c        ****  #endif
4308:main.c        **** 
4309:main.c        **** 	#if 0
4310:main.c        **** 			tetUpdate();
4311:main.c        **** 
4312:main.c        **** 			if(imageNum == 0)
4313:main.c        **** 			{
4314:main.c        **** 				imageNum = 1;
4315:main.c        **** 				pimage = pgm_image1;
4316:main.c        **** 				tetColorScheme = 1;
4317:main.c        **** 			}
4318:main.c        **** 			else
4319:main.c        **** 			{
4320:main.c        **** 				hexColor++;
4321:main.c        **** 				hexColor&=0x3f;
4322:main.c        **** 				imageNum = 0;
4323:main.c        **** 				pimage = pgm_image2;
4324:main.c        **** 				tetColorScheme = 0;
4325:main.c        **** 			}
4326:main.c        **** 	#endif //0
4327:main.c        **** 
4328:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4329:main.c        **** 			for(row=0; row<FB_HEIGHT; row++)
4330:main.c        **** 	      for(col=0; col<FB_WIDTH; col++)
4331:main.c        **** 	      {
4332:main.c        **** 	         uint8_t imagePixel=pgm_readImageByte(pimage, row, col);
4333:main.c        **** 
4334:main.c        **** 
4335:main.c        **** 				if(imagePixel == Tr)
4336:main.c        **** 					frameBuffer[row][col] = colorShift+row+col;
4337:main.c        **** 				else
4338:main.c        **** 					frameBuffer[row][col] = imagePixel;	
4339:main.c        **** 			/*
4340:main.c        **** 	         setColor(
4341:main.c        **** 		         (getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4342:main.c        **** 	            (getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4343:main.c        **** 	            (getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 99


4344:main.c        **** 	            r, c);
4345:main.c        **** 			*/
4346:main.c        **** 			}
4347:main.c        **** 			colorShift++;
4348:main.c        ****  #endif
4349:main.c        ****  #if (defined(LIFE) && LIFE)
4350:main.c        **** 			lifeRound();
4351:main.c        ****  #endif //LIFE
4352:main.c        ****  
4353:main.c        ****  #if (FRAME_COUNT_TO_DELAY != 0)
4354:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
4355:main.c        ****  #endif //FRAME_COUNT_TO_DELAY
4356:main.c        **** 		}
4357:main.c        ****  #if (!defined(FRAME_SYNC) && !FRAME_SYNC)
4358:main.c        **** 		counter+=16384;
4359:main.c        ****  #else
4360:main.c        **** 		//for LIFE testing...
4361:main.c        **** 		counter++;
4362:main.c        **** #endif
4363:main.c        **** 		heartUpdate();
4364:main.c        **** 	}
4365:main.c        ****  #else
4366:main.c        ****   #error "IMAGE_CHANGE is now required for drawPix with image..."
4367:main.c        ****  #endif
4368:main.c        **** #endif
4369:main.c        **** 
4370:main.c        **** #if (defined(PIXEL_SCROLL) && PIXEL_SCROLL)
4371:main.c        **** 	uint32_t counter=0;
4372:main.c        **** 
4373:main.c        **** 	while(1)
4374:main.c        **** 	{
4375:main.c        **** 		if(counter==0)
4376:main.c        **** 		{
4377:main.c        **** 			uint8_t firstCol[2];
4378:main.c        **** 			firstCol[0] = frameBuffer[0][0];
4379:main.c        **** 			firstCol[1] = frameBuffer[1][0];
4380:main.c        **** 
4381:main.c        **** 			uint8_t i;
4382:main.c        **** 			for(i=0; i<FB_WIDTH-1; i++)
4383:main.c        **** 			{
4384:main.c        **** 				frameBuffer[0][i] = frameBuffer[0][i+1];
4385:main.c        **** 				frameBuffer[1][i] = frameBuffer[1][i+1];
4386:main.c        **** //				setBlue(frameBuffer[0][i], 0, i);
4387:main.c        **** //				setBlue(frameBuffer[1][i], 1, i);
4388:main.c        **** 			}
4389:main.c        **** 
4390:main.c        **** 			frameBuffer[0][i] = firstCol[0];
4391:main.c        **** 			frameBuffer[1][i] = firstCol[1];
4392:main.c        **** //			setBlue(frameBuffer[0][i], 0, i);
4393:main.c        **** //			setBlue(frameBuffer[1][i], 1, i);
4394:main.c        **** 		}
4395:main.c        **** 		counter+=16384;
4396:main.c        **** 		heartUpdate();
4397:main.c        **** 	}
4398:main.c        **** #else
4399:main.c        **** 	while(1)
4400:main.c        **** 	{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 100


4401:main.c        **** 		heartUpdate();
4402:main.c        **** 	}
4403:main.c        **** #endif
4404:main.c        **** 
4405:main.c        **** }
 771               		.stabn	68,0,4405,.LM62-.LFBB5
 772               	.LM62:
 773 034e 8730      		cpi r24,lo8(7)
 774 0350 00F4      		brsh .L55
 775 0352 E82F      		mov r30,r24
 776 0354 F0E0      		ldi r31,lo8(0)
 777 0356 E050      		subi r30,lo8(-(CSWTCH.58))
 778 0358 F040      		sbci r31,hi8(-(CSWTCH.58))
 779 035a 00C0      		rjmp .L57
 780               	.L53:
 781 035c 8730      		cpi r24,lo8(7)
 782 035e 00F4      		brsh .L55
 783 0360 E82F      		mov r30,r24
 784 0362 F0E0      		ldi r31,lo8(0)
 785 0364 E050      		subi r30,lo8(-(CSWTCH.61))
 786 0366 F040      		sbci r31,hi8(-(CSWTCH.61))
 787               	.L57:
 788 0368 8081      		ld r24,Z
 789 036a 0895      		ret
 790               	.L55:
 791 036c 8FE3      		ldi r24,lo8(63)
 792               	.L52:
 793               		.stabs	"tetStuff.c",132,0,0,.Ltext3
 794               	.Ltext3:
 422:tetStuff.c    **** 	{
 423:tetStuff.c    **** 		case 0:
 424:tetStuff.c    **** 		case 1:
 425:tetStuff.c    **** 			switch(tetBrick)
 426:tetStuff.c    **** 			{
 427:tetStuff.c    **** 				case 1:
 428:tetStuff.c    **** 					return _R;
 429:tetStuff.c    **** 				case 2:
 430:tetStuff.c    **** 					return _O;
 431:tetStuff.c    **** 				case 3:
 432:tetStuff.c    **** 					return _Y;
 433:tetStuff.c    **** 				case 4:
 434:tetStuff.c    **** 					return _G;
 435:tetStuff.c    **** 				case 5:
 436:tetStuff.c    **** 					return _C;
 437:tetStuff.c    **** 				case 6:
 438:tetStuff.c    **** 					return _B;
 439:tetStuff.c    **** 				case 7:
 440:tetStuff.c    **** 					return _M;
 441:tetStuff.c    **** 				default:	//WTF???
 442:tetStuff.c    **** 					return _W;
 443:tetStuff.c    **** 			}
 444:tetStuff.c    **** 			break;
 445:tetStuff.c    **** 		default: //Shouldn't happen...
 446:tetStuff.c    **** 			// was case1 but these colors are ugly
 447:tetStuff.c    **** 			// and cause syncing problems...
 448:tetStuff.c    **** 			switch(tetBrick)
 449:tetStuff.c    **** 			{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 101


 450:tetStuff.c    **** 				case 1:
 451:tetStuff.c    **** 					return _r;
 452:tetStuff.c    **** 				case 2:
 453:tetStuff.c    **** 					return _g;
 454:tetStuff.c    **** 				case 3:
 455:tetStuff.c    **** 					return _b;
 456:tetStuff.c    **** 				case 4:
 457:tetStuff.c    **** 					return _c;
 458:tetStuff.c    **** 				case 5:
 459:tetStuff.c    **** 					return _m;
 460:tetStuff.c    **** 				case 6:
 461:tetStuff.c    **** 					return _y;
 462:tetStuff.c    **** 				case 7:
 463:tetStuff.c    **** 					return _k;
 464:tetStuff.c    **** 				default:	//WTF
 465:tetStuff.c    **** 					return _W;
 466:tetStuff.c    **** 			}
 467:tetStuff.c    **** //		default:
 468:tetStuff.c    **** //			return 0;
 469:tetStuff.c    **** 	}
 470:tetStuff.c    **** 
 471:tetStuff.c    **** }
 795               		.stabn	68,0,471,.LM63-.LFBB5
 796               	.LM63:
 797 036e 0895      		ret
 798               		.size	tetBrick_to_fb, .-tetBrick_to_fb
 799               	.Lscope5:
 800               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 801               		.stabd	78,0,0
 802               		.stabs	"segClear:F(0,15)",36,0,159,segClear
 803               	.global	segClear
 804               		.type	segClear, @function
 805               	segClear:
 806               		.stabd	46,0,0
 807               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext4
 808               	.Ltext4:
   1:rowSegBuffer.c **** 
   2:rowSegBuffer.c **** 
   3:rowSegBuffer.c **** #ifndef NUM_SEGMENTS
   4:rowSegBuffer.c ****  #define NUM_SEGMENTS	68//128 //68 //128//68
   5:rowSegBuffer.c **** #endif
   6:rowSegBuffer.c **** 
   7:rowSegBuffer.c **** //Green and blue are in the same byte...
   8:rowSegBuffer.c **** // I don't think the code will compile anymore without this.
   9:rowSegBuffer.c **** // It increases the pixel calculation from 18 cycles to 20 cycles
  10:rowSegBuffer.c **** #define GB_COMBINED TRUE
  11:rowSegBuffer.c **** 
  12:rowSegBuffer.c **** // SQUARE_SEGMENTS inserts nops in the counter-loop
  13:rowSegBuffer.c **** // such that each loop takes the equivalent time as the first load/write
  14:rowSegBuffer.c **** //  of the values...
  15:rowSegBuffer.c **** // Then, each incremet of length is equivalent to one drawable-pixel
  16:rowSegBuffer.c **** // (Later, maybe, setting this FALSE would allow for LCD pixel-resolution
  17:rowSegBuffer.c **** //  down to a single pixel, with LVDS_PRESCALER, etc. BUT, the minimum 
  18:rowSegBuffer.c **** //  width of a segment would be longer, due to higher calculation time
  19:rowSegBuffer.c **** //  at the beginning)
  20:rowSegBuffer.c **** // Another benefit of SQUARE_SEGMENTS is that more distance can be
  21:rowSegBuffer.c **** //  covered in the same count... (fewer segments necessary in memory for a
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 102


  22:rowSegBuffer.c **** //  long color-segment)
  23:rowSegBuffer.c **** // Another "benefit" is that all count values can be used,
  24:rowSegBuffer.c **** //  (less testing is necessary to make sure a pixel can be added)
  25:rowSegBuffer.c **** //  (meh...)
  26:rowSegBuffer.c **** #define SQUARE_SEGMENTS TRUE
  27:rowSegBuffer.c **** 
  28:rowSegBuffer.c **** //Segments have four values:
  29:rowSegBuffer.c **** // segment length
  30:rowSegBuffer.c **** // red	(OCR)
  31:rowSegBuffer.c **** // green	(DT)
  32:rowSegBuffer.c **** // blue	(OCR)
  33:rowSegBuffer.c **** //
  34:rowSegBuffer.c **** // To save space, and no additional instruction cycles are needed,
  35:rowSegBuffer.c **** //  combine red and length
  36:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  37:rowSegBuffer.c **** //                   \__ __/ \__ __/
  38:rowSegBuffer.c **** //								V       V
  39:rowSegBuffer.c **** //                      |       Red OCR value
  40:rowSegBuffer.c **** //                      segLength
  41:rowSegBuffer.c **** 
  42:rowSegBuffer.c **** // NOW:
  43:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  44:rowSegBuffer.c **** //                   \___ ___/ \_ _/
  45:rowSegBuffer.c **** //                       V       V
  46:rowSegBuffer.c **** //                       |       Red OCR value
  47:rowSegBuffer.c **** //                       segLength
  48:rowSegBuffer.c **** // RISK:
  49:rowSegBuffer.c **** //  At one point I was considering doubling OCR/DT values
  50:rowSegBuffer.c **** //   in able to get higher resolution...
  51:rowSegBuffer.c **** //   (more CPU cycles per pixel clock)
  52:rowSegBuffer.c **** //  That would require a significant overhaul
  53:rowSegBuffer.c **** //   and LVDS_PRESCALER has already helped...
  54:rowSegBuffer.c **** #define SEG_LENGTH_BITS 5
  55:rowSegBuffer.c **** 
  56:rowSegBuffer.c **** //#if (defined(SEG_LENGTH_BITS))
  57:rowSegBuffer.c ****  #define SEG_LENGTH_MASK 	((UPPER_BIT_MASK8(SEG_LENGTH_BITS)))
  58:rowSegBuffer.c **** //&0xff is necessary for an assembly operand to be 8-bits
  59:rowSegBuffer.c ****  #define RED_MASK 			(((~(SEG_LENGTH_MASK))&0xff))
  60:rowSegBuffer.c ****  #define SEG_COUNT_1			((UPPER_BIT_MASK8__COUNT_1(SEG_LENGTH_BITS)))
  61:rowSegBuffer.c ****  #define SEG_LENGTH_SHIFT	((8-(SEG_LENGTH_BITS)))
  62:rowSegBuffer.c **** //#else
  63:rowSegBuffer.c **** // #define SEG_LENGTH_MASK (0xf0)
  64:rowSegBuffer.c **** // #define RED_MASK (~(SEG_LENGTH_MASK))
  65:rowSegBuffer.c **** //#endif
  66:rowSegBuffer.c **** 
  67:rowSegBuffer.c **** 
  68:rowSegBuffer.c **** //This seems backwards, but it's not. See SQUARE_SEGMENTS notes, above
  69:rowSegBuffer.c **** #if (defined(SQUARE_SEGMENTS) && SQUARE_SEGMENTS)
  70:rowSegBuffer.c ****  #define COUNT_INCREMENT SEG_COUNT_1 //0x10
  71:rowSegBuffer.c ****  //This is the actual length, not as shifted for storage
  72:rowSegBuffer.c ****  #define SEG_MAXLENGTH	(SEG_LENGTH_MASK >> SEG_LENGTH_SHIFT)
  73:rowSegBuffer.c **** #else
  74:rowSegBuffer.c **** #error "This probably isn't implemented anymore..."
  75:rowSegBuffer.c ****  #if (defined(GB_COMBINED) && GB_COMBINED)
  76:rowSegBuffer.c ****   #define COUNT_INCREMENT (5*SEG_COUNT_1) //0x50
  77:rowSegBuffer.c ****  #else
  78:rowSegBuffer.c ****   #define COUNT_INCREMENT (4*SEG_COUNT_1) //0x40
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 103


  79:rowSegBuffer.c ****  #endif
  80:rowSegBuffer.c **** #endif
  81:rowSegBuffer.c **** 
  82:rowSegBuffer.c **** 
  83:rowSegBuffer.c **** // Similar *might* be possible with green and blue
  84:rowSegBuffer.c **** // IF we can switch DE/Blue to /OC1A
  85:rowSegBuffer.c **** //           switch Green to OC1B
  86:rowSegBuffer.c **** //           use DTH for green -> mov, andi, andi
  87:rowSegBuffer.c **** // Not sure if this is possible
  88:rowSegBuffer.c **** // Otherwise, sharing a byte for green/blue introduces
  89:rowSegBuffer.c **** //            mov, andi, and four lsrs
  90:rowSegBuffer.c **** //            mov, andi, swap, andi... maybe not so bad...?
  91:rowSegBuffer.c **** //                       only two additional cycles (since ld is two)
  92:rowSegBuffer.c **** // the benefit with red_length is killing two birds with one stone
  93:rowSegBuffer.c **** //   andi both &='s AND tests for 0...
  94:rowSegBuffer.c **** typedef struct _NONAME_
  95:rowSegBuffer.c **** {
  96:rowSegBuffer.c **** 	uint8_t red_length;	// segLength<<3 | OCR1D
  97:rowSegBuffer.c **** #if (defined(GB_COMBINED) && GB_COMBINED)
  98:rowSegBuffer.c **** 	uint8_t green_blue;	// blue<<4 | green
  99:rowSegBuffer.c **** #else
 100:rowSegBuffer.c **** 	uint8_t green;			//DT1(Low nibble)
 101:rowSegBuffer.c **** 	uint8_t blue;			//OCR1A
 102:rowSegBuffer.c **** #endif
 103:rowSegBuffer.c **** } seg_t;
 104:rowSegBuffer.c **** 
 105:rowSegBuffer.c **** 
 106:rowSegBuffer.c **** // Was thinking about loading the last segment as black, but that doesn't
 107:rowSegBuffer.c **** // work if the last segment isn't read, due to length=0...
 108:rowSegBuffer.c **** seg_t rowSegBuffer[NUM_SEGMENTS+1];/*=
 109:rowSegBuffer.c **** {
 110:rowSegBuffer.c **** 	{(4<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3},  //White
 111:rowSegBuffer.c ****    {(8<<SEG_LENGTH_SHIFT) | 0x00, (4<<4) | 0},  //Black
 112:rowSegBuffer.c **** 	{(16<<SEG_LENGTH_SHIFT)| 0x06, (4<<4) | 0},  //Red
 113:rowSegBuffer.c **** 	{(32<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3}, //White
 114:rowSegBuffer.c **** 	{0,(4<<4)}                                   //Terminate
 115:rowSegBuffer.c **** };
 116:rowSegBuffer.c **** */
 117:rowSegBuffer.c **** /*=
 118:rowSegBuffer.c **** {
 119:rowSegBuffer.c **** 	{0x10,4,6},
 120:rowSegBuffer.c **** 	{0x32,4,8},
 121:rowSegBuffer.c **** 	{0x03,5,2},
 122:rowSegBuffer.c **** 	{0x00,0,0}
 123:rowSegBuffer.c **** };
 124:rowSegBuffer.c **** */
 125:rowSegBuffer.c **** 
 126:rowSegBuffer.c **** 
 127:rowSegBuffer.c **** 
 128:rowSegBuffer.c **** //See rowBuffer.c for an explanation...
 129:rowSegBuffer.c **** // The first three will probably seldom be used
 130:rowSegBuffer.c **** // The last....
 131:rowSegBuffer.c **** #define fbBlue_to_seg(fbColor) \
 132:rowSegBuffer.c **** 		((((fbColor & 0x30) | 0x40)))
 133:rowSegBuffer.c **** 		//((((fbColor & 0x30) >> 4) | 0x04)<<4) //fixed
 134:rowSegBuffer.c **** //	   (((fbColor & 0x30) << 1) | 0x40)
 135:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 104


 136:rowSegBuffer.c **** #define fbGreen_to_seg(fbColor) \
 137:rowSegBuffer.c **** 	   ((fbColor & 0x0C) >> 2)
 138:rowSegBuffer.c **** 
 139:rowSegBuffer.c **** #define fbRed_to_seg(fbColor) \
 140:rowSegBuffer.c **** 	   (((fbColor & 0x03) << 1) | (fbColor & 0x01))
 141:rowSegBuffer.c **** 
 142:rowSegBuffer.c **** //This gives 'red, green_blue' pairs for arguments to newSeg, etc.
 143:rowSegBuffer.c **** // It's kinda hokey to call a three-argument function with *apparently*
 144:rowSegBuffer.c **** // only two arguments, but this'll be used probably more often than
 145:rowSegBuffer.c **** // the actual function-call...
 146:rowSegBuffer.c **** // use newSegfb(length, fbColor) 
 147:rowSegBuffer.c **** //    instead of newSeg(length, fb_to_seg(fbColor))
 148:rowSegBuffer.c **** // it's just a macro, but it makes more sense
 149:rowSegBuffer.c **** #define fb_to_seg(fbColor) \
 150:rowSegBuffer.c ****   fbRed_to_seg(fbColor), (fbBlue_to_seg(fbColor) | fbGreen_to_seg(fbColor))
 151:rowSegBuffer.c **** 
 152:rowSegBuffer.c **** //Outside of rbpix_to_seg, this corresponds with the last-written segment
 153:rowSegBuffer.c **** uint8_t segPosition = 0;
 154:rowSegBuffer.c **** 
 155:rowSegBuffer.c **** 
 156:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue);
 157:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength);
 158:rowSegBuffer.c **** 
 159:rowSegBuffer.c **** void segClear(void)
 160:rowSegBuffer.c **** {
 809               		.stabn	68,0,160,.LM64-.LFBB6
 810               	.LM64:
 811               	.LFBB6:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 161:rowSegBuffer.c **** 	segPosition = 0;
 814               		.stabn	68,0,161,.LM65-.LFBB6
 815               	.LM65:
 816 0370 1092 0000 		sts segPosition,__zero_reg__
 162:rowSegBuffer.c **** 	//The important part is the null-length
 163:rowSegBuffer.c **** 	// but let's load white just in case
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 817               		.stabn	68,0,164,.LM66-.LFBB6
 818               	.LM66:
 819 0374 86E0      		ldi r24,lo8(6)
 820 0376 8093 0000 		sts rowSegBuffer,r24
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 821               		.stabn	68,0,165,.LM67-.LFBB6
 822               	.LM67:
 823 037a 83E6      		ldi r24,lo8(99)
 824 037c 8093 0000 		sts rowSegBuffer+1,r24
 825               	/* epilogue start */
 166:rowSegBuffer.c **** }
 826               		.stabn	68,0,166,.LM68-.LFBB6
 827               	.LM68:
 828 0380 0895      		ret
 829               		.size	segClear, .-segClear
 830               	.Lscope6:
 831               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 832               		.stabd	78,0,0
 833               		.stabs	"segTerminate:F(0,15)",36,0,170,segTerminate
 834               	.global	segTerminate
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 105


 835               		.type	segTerminate, @function
 836               	segTerminate:
 837               		.stabd	46,0,0
 167:rowSegBuffer.c **** 
 168:rowSegBuffer.c **** #define rbpix_to_segTerminate segTerminate
 169:rowSegBuffer.c **** 
 170:rowSegBuffer.c **** void segTerminate(void)
 171:rowSegBuffer.c **** {
 838               		.stabn	68,0,171,.LM69-.LFBB7
 839               	.LM69:
 840               	.LFBB7:
 841               	/* prologue: function */
 842               	/* frame size = 0 */
 172:rowSegBuffer.c **** 
 173:rowSegBuffer.c **** 	//Add a new NULL-SEGMENT
 174:rowSegBuffer.c **** 	//This might appear as a stretched last pixel/segment...
 175:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 843               		.stabn	68,0,175,.LM70-.LFBB7
 844               	.LM70:
 845 0382 8091 0000 		lds r24,segPosition
 846 0386 8334      		cpi r24,lo8(67)
 847 0388 00F4      		brsh .L61
 848 038a E82F      		mov r30,r24
 849 038c F0E0      		ldi r31,lo8(0)
 850 038e EE0F      		lsl r30
 851 0390 FF1F      		rol r31
 852 0392 E050      		subi r30,lo8(-(rowSegBuffer))
 853 0394 F040      		sbci r31,hi8(-(rowSegBuffer))
 854 0396 9081      		ld r25,Z
 855 0398 987F      		andi r25,lo8(-8)
 856 039a 01F0      		breq .L63
 176:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK))
 177:rowSegBuffer.c **** 	{
 178:rowSegBuffer.c **** 		segPosition++;
 857               		.stabn	68,0,178,.LM71-.LFBB7
 858               	.LM71:
 859 039c 8F5F      		subi r24,lo8(-(1))
 860 039e 8093 0000 		sts segPosition,r24
 179:rowSegBuffer.c **** 
 180:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 181:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].red_length & RED_MASK;
 861               		.stabn	68,0,181,.LM72-.LFBB7
 862               	.LM72:
 863 03a2 A82F      		mov r26,r24
 864 03a4 B0E0      		ldi r27,lo8(0)
 180:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 865               		.stabn	68,0,180,.LM73-.LFBB7
 866               	.LM73:
 867 03a6 FD01      		movw r30,r26
 868 03a8 EE0F      		lsl r30
 869 03aa FF1F      		rol r31
 870 03ac E050      		subi r30,lo8(-(rowSegBuffer))
 871 03ae F040      		sbci r31,hi8(-(rowSegBuffer))
 872 03b0 AA0F      		lsl r26
 873 03b2 BB1F      		rol r27
 874 03b4 A050      		subi r26,lo8(-(rowSegBuffer-2))
 875 03b6 B040      		sbci r27,hi8(-(rowSegBuffer-2))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 106


 876 03b8 8C91      		ld r24,X
 877 03ba 8770      		andi r24,lo8(7)
 878 03bc 8083      		st Z,r24
 182:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue
 879               		.stabn	68,0,182,.LM74-.LFBB7
 880               	.LM74:
 881 03be 1196      		adiw r26,1
 882 03c0 8C91      		ld r24,X
 883 03c2 1197      		sbiw r26,1
 884 03c4 8183      		std Z+1,r24
 175:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 885               		.stabn	68,0,175,.LM75-.LFBB7
 886               	.LM75:
 887 03c6 0895      		ret
 888               	.L61:
 183:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].green_blue;
 184:rowSegBuffer.c **** 	}
 185:rowSegBuffer.c **** 	//We're already at the last segment, so we have to nullify it
 186:rowSegBuffer.c **** 	//This might terminate the last pixel early, but is necessary.
 187:rowSegBuffer.c **** 	else if(segPosition == NUM_SEGMENTS-1)
 889               		.stabn	68,0,187,.LM76-.LFBB7
 890               	.LM76:
 891 03c8 8334      		cpi r24,lo8(67)
 892 03ca 01F4      		brne .L63
 188:rowSegBuffer.c **** 	{
 189:rowSegBuffer.c **** 		//Apparently white doesn't cause sync problems... so load it white
 190:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = fbRed_to_seg(_W);
 893               		.stabn	68,0,190,.LM77-.LFBB7
 894               	.LM77:
 895 03cc 87E0      		ldi r24,lo8(7)
 896 03ce 8093 0000 		sts rowSegBuffer+134,r24
 191:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = 
 897               		.stabn	68,0,191,.LM78-.LFBB7
 898               	.LM78:
 899 03d2 83E7      		ldi r24,lo8(115)
 900 03d4 8093 0000 		sts rowSegBuffer+135,r24
 901               	.L63:
 902 03d8 0895      		ret
 903               		.size	segTerminate, .-segTerminate
 904               	.Lscope7:
 905               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 906               		.stabd	78,0,0
 907               		.stabs	"newSeg:F(3,2)",36,0,334,newSeg
 908               		.stabs	"length:P(3,4)",64,0,334,24
 909               		.stabs	"red:P(3,2)",64,0,334,22
 910               		.stabs	"green_blue:P(3,2)",64,0,334,20
 911               	.global	newSeg
 912               		.type	newSeg, @function
 913               	newSeg:
 914               		.stabd	46,0,0
 192:rowSegBuffer.c **** 										fbBlue_to_seg(_W) | fbGreen_to_seg(_W);
 193:rowSegBuffer.c **** 	}
 194:rowSegBuffer.c **** 
 195:rowSegBuffer.c **** 	//If we got here, it's already been terminated...
 196:rowSegBuffer.c **** 	//else...
 197:rowSegBuffer.c **** }
 198:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 107


 199:rowSegBuffer.c **** 
 200:rowSegBuffer.c **** #define newSegfb(length, fbColor) newSeg((length), fb_to_seg(fbColor))
 201:rowSegBuffer.c **** #define addSegfb(length, fbColor) addSeg((length), fb_to_seg(fbColor))
 202:rowSegBuffer.c **** 
 203:rowSegBuffer.c **** //This is just an intermediate test, for now...
 204:rowSegBuffer.c **** // for reloading the rowbuffer to a seg-buffer.
 205:rowSegBuffer.c **** //This could easily be revised (and generalized) to be...
 206:rowSegBuffer.c **** // addSegment or addPixel
 207:rowSegBuffer.c **** void rbpix_to_seg(uint8_t rbValue, uint8_t col, uint8_t length)
 208:rowSegBuffer.c **** {
 209:rowSegBuffer.c **** 	static uint8_t last_rbValue = 0;
 210:rowSegBuffer.c **** 	//uint8_t length = 1;
 211:rowSegBuffer.c **** 
 212:rowSegBuffer.c **** 	if(col == 0)
 213:rowSegBuffer.c **** 	{
 214:rowSegBuffer.c **** 		last_rbValue = 0;
 215:rowSegBuffer.c **** 		segClear();
 216:rowSegBuffer.c **** 	}
 217:rowSegBuffer.c **** 	//Same color as last pixel...
 218:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 219:rowSegBuffer.c **** 	{
 220:rowSegBuffer.c **** 		stretchSeg(length);
 221:rowSegBuffer.c **** 		return;
 222:rowSegBuffer.c **** 	}
 223:rowSegBuffer.c **** 
 224:rowSegBuffer.c **** 	uint8_t green = rbValue & 0x03;
 225:rowSegBuffer.c **** 	uint8_t red = (rbValue & 0x1C) >> 2;
 226:rowSegBuffer.c **** 	uint8_t blue = rbValue >> 5;
 227:rowSegBuffer.c **** 
 228:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 229:rowSegBuffer.c **** 
 230:rowSegBuffer.c **** 	last_rbValue = rbValue;
 231:rowSegBuffer.c **** }
 232:rowSegBuffer.c **** 
 233:rowSegBuffer.c **** //Call this when we already know the color in the last segment is the same
 234:rowSegBuffer.c **** // so we wish to stretch the segment by additionalLength
 235:rowSegBuffer.c **** // these values are real-lengths, not as shifted for storage...
 236:rowSegBuffer.c **** // Return TRUE if the stretch was truncated...
 237:rowSegBuffer.c **** // THIS DOES NOT TEST DISPLAY_WIDTH!
 238:rowSegBuffer.c **** // DON'T FORGET to make additionalLength square before the call
 239:rowSegBuffer.c **** // if necesary....
 240:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength)
 241:rowSegBuffer.c **** {
 242:rowSegBuffer.c **** 		uint8_t oldLength=
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 244:rowSegBuffer.c **** 
 245:rowSegBuffer.c **** 		if(!additionalLength)
 246:rowSegBuffer.c **** 			return FALSE;
 247:rowSegBuffer.c **** 
 248:rowSegBuffer.c **** 		//We can stretch the current segment
 249:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 250:rowSegBuffer.c **** 		{
 251:rowSegBuffer.c **** 			uint8_t maxStretch = SEG_MAXLENGTH - oldLength;
 252:rowSegBuffer.c **** 
 253:rowSegBuffer.c **** 			// Will the entire addition fit in the previous segment?
 254:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 255:rowSegBuffer.c **** 			{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 108


 256:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 257:rowSegBuffer.c **** 					(additionalLength << SEG_LENGTH_SHIFT);
 258:rowSegBuffer.c **** 
 259:rowSegBuffer.c **** 				//Then we're done.
 260:rowSegBuffer.c **** 			//	additionalLength = 0;
 261:rowSegBuffer.c **** 			//	break;
 262:rowSegBuffer.c **** 				return FALSE;
 263:rowSegBuffer.c **** 			}
 264:rowSegBuffer.c **** 			// Nope... stretch it all the way, then later we'll make another
 265:rowSegBuffer.c **** 			else
 266:rowSegBuffer.c **** 			{
 267:rowSegBuffer.c **** 				uint8_t red = 
 268:rowSegBuffer.c **** 					rowSegBuffer[segPosition].red_length & RED_MASK;
 269:rowSegBuffer.c **** 
 270:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 271:rowSegBuffer.c **** 					red | (SEG_MAXLENGTH << SEG_LENGTH_SHIFT);
 272:rowSegBuffer.c **** 
 273:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 274:rowSegBuffer.c **** 			}
 275:rowSegBuffer.c **** 		}
 276:rowSegBuffer.c **** 
 277:rowSegBuffer.c **** 		//The current segment has been stretched and there's more remaining
 278:rowSegBuffer.c **** 		// or it was already maxed-out...
 279:rowSegBuffer.c **** 
 280:rowSegBuffer.c **** 		// We shouldn't ever get here if additionalLength = 0...
 281:rowSegBuffer.c **** 
 282:rowSegBuffer.c **** 		//But we should test to make sure there's still lenth after
 283:rowSegBuffer.c **** 		// the stretch...
 284:rowSegBuffer.c **** 		if(additionalLength)
 285:rowSegBuffer.c **** 		{
 286:rowSegBuffer.c **** 			uint8_t red =
 287:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length & RED_MASK;
 288:rowSegBuffer.c **** 
 289:rowSegBuffer.c **** 			uint8_t green_blue =
 290:rowSegBuffer.c **** 				rowSegBuffer[segPosition].green_blue;
 291:rowSegBuffer.c **** 
 292:rowSegBuffer.c **** 			uint8_t retVal;
 293:rowSegBuffer.c **** 
 294:rowSegBuffer.c **** 			//Create new segment(s) with the remaining length
 295:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 296:rowSegBuffer.c **** 
 297:rowSegBuffer.c **** 			//Then we're done...
 298:rowSegBuffer.c **** 			//additionalLength = 0;
 299:rowSegBuffer.c **** 			//break;
 300:rowSegBuffer.c **** 
 301:rowSegBuffer.c **** 			return retVal;
 302:rowSegBuffer.c **** 		}	
 303:rowSegBuffer.c **** 
 304:rowSegBuffer.c **** 		//We shouldn't ever get here...
 305:rowSegBuffer.c **** 		// Well, maybe... if additionalLength == maxStretch...?
 306:rowSegBuffer.c **** 		return FALSE;
 307:rowSegBuffer.c **** }
 308:rowSegBuffer.c **** 
 309:rowSegBuffer.c **** //This should be like newSeg, but also checks whether it can stretch
 310:rowSegBuffer.c **** // the last segment...
 311:rowSegBuffer.c **** uint8_t addSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 312:rowSegBuffer.c **** {
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 109


 313:rowSegBuffer.c **** 
 314:rowSegBuffer.c **** 	//Currently not smart enough to stretch the first segment...
 315:rowSegBuffer.c **** 	if(segPosition == 0)
 316:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 317:rowSegBuffer.c **** 
 318:rowSegBuffer.c **** 	//Can we stretch?
 319:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 320:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].green_blue == green_blue))
 321:rowSegBuffer.c **** 			return stretchSeg(length);
 322:rowSegBuffer.c **** 	else
 323:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 324:rowSegBuffer.c **** 
 325:rowSegBuffer.c **** }
 326:rowSegBuffer.c **** 
 327:rowSegBuffer.c **** //This assumes you intend to create a new segment
 328:rowSegBuffer.c **** // it does *not* check whether the previous segment could be stretched
 329:rowSegBuffer.c **** // (it in fact, is called by stretchSeg as necessary)
 330:rowSegBuffer.c **** // Returns TRUE if it had to be truncated
 331:rowSegBuffer.c **** //  (out of segment memory, past the display edge...)
 332:rowSegBuffer.c **** // length is the real length, not shifted for storage...
 333:rowSegBuffer.c **** // THIS DOES NOT squarify, so adjust length as necessary before calling
 334:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 335:rowSegBuffer.c **** {
 915               		.stabn	68,0,335,.LM79-.LFBB8
 916               	.LM79:
 917               	.LFBB8:
 918               	/* prologue: function */
 919               	/* frame size = 0 */
 920               		.stabn	68,0,335,.LM80-.LFBB8
 921               	.LM80:
 922 03da 2091 0000 		lds r18,segPosition
 336:rowSegBuffer.c **** 
 337:rowSegBuffer.c **** 	//Recursion would be simpler, but we've got a limited stack.
 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 339:rowSegBuffer.c **** 	{
 340:rowSegBuffer.c **** 		// No more segments available...	
 341:rowSegBuffer.c **** 		// The last segment must have a length of 0
 342:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 343:rowSegBuffer.c **** 		{
 344:rowSegBuffer.c **** 			segTerminate();
 345:rowSegBuffer.c **** 			return TRUE;
 346:rowSegBuffer.c **** 		}
 347:rowSegBuffer.c **** 
 348:rowSegBuffer.c **** 		// Not yet sure how to handle display-width...
 349:rowSegBuffer.c **** 		//if(segTotal > DISPLAY_WIDTH)
 350:rowSegBuffer.c **** 		//  at least draw as much of the segment as possible...
 351:rowSegBuffer.c **** 		//  then segTerminate();
 352:rowSegBuffer.c **** 		//  and return TRUE
 353:rowSegBuffer.c **** 
 354:rowSegBuffer.c **** 		// If we've gotten this far, then we can add the segment
 355:rowSegBuffer.c **** 	
 356:rowSegBuffer.c **** 		//Check if the segment buffer is cleared...
 357:rowSegBuffer.c **** 		// then DON'T increment segPosition...
 358:rowSegBuffer.c **** 		//if(!((segPosition == 0) && 
 359:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 360:rowSegBuffer.c **** 		if(segPosition || 
 361:rowSegBuffer.c **** 			((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 110


 362:rowSegBuffer.c **** 				segPosition++;
 363:rowSegBuffer.c **** 
 364:rowSegBuffer.c **** 
 365:rowSegBuffer.c **** 		//Create a maxlength segment
 366:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length =
 923               		.stabn	68,0,366,.LM81-.LFBB8
 924               	.LM81:
 925 03de 562F      		mov r21,r22
 926 03e0 586F      		ori r21,lo8(-8)
 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 927               		.stabn	68,0,338,.LM82-.LFBB8
 928               	.LM82:
 929 03e2 00C0      		rjmp .L65
 930               	.L70:
 342:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 931               		.stabn	68,0,342,.LM83-.LFBB8
 932               	.LM83:
 933 03e4 2334      		cpi r18,lo8(67)
 934 03e6 01F4      		brne .L66
 935 03e8 2093 0000 		sts segPosition,r18
 936 03ec 00C0      		rjmp .L76
 937               	.L66:
 360:rowSegBuffer.c **** 		if(segPosition || 
 938               		.stabn	68,0,360,.LM84-.LFBB8
 939               	.LM84:
 940 03ee 2223      		tst r18
 941 03f0 01F4      		brne .L68
 942 03f2 3091 0000 		lds r19,rowSegBuffer
 943 03f6 387F      		andi r19,lo8(-8)
 944 03f8 01F0      		breq .L69
 945               	.L68:
 362:rowSegBuffer.c **** 				segPosition++;
 946               		.stabn	68,0,362,.LM85-.LFBB8
 947               	.LM85:
 948 03fa 2F5F      		subi r18,lo8(-(1))
 949               	.L69:
 950               		.stabn	68,0,366,.LM86-.LFBB8
 951               	.LM86:
 952 03fc E22F      		mov r30,r18
 953 03fe F0E0      		ldi r31,lo8(0)
 954 0400 EE0F      		lsl r30
 955 0402 FF1F      		rol r31
 956 0404 E050      		subi r30,lo8(-(rowSegBuffer))
 957 0406 F040      		sbci r31,hi8(-(rowSegBuffer))
 958 0408 5083      		st Z,r21
 367:rowSegBuffer.c **** 			red | (SEG_MAXLENGTH<<SEG_LENGTH_SHIFT);
 368:rowSegBuffer.c **** 
 369:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 959               		.stabn	68,0,369,.LM87-.LFBB8
 960               	.LM87:
 961 040a 4183      		std Z+1,r20
 370:rowSegBuffer.c **** 
 371:rowSegBuffer.c **** 		length -= SEG_MAXLENGTH;
 962               		.stabn	68,0,371,.LM88-.LFBB8
 963               	.LM88:
 964 040c 4F97      		sbiw r24,31
 965               	.L65:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 111


 338:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 966               		.stabn	68,0,338,.LM89-.LFBB8
 967               	.LM89:
 968 040e 8F31      		cpi r24,31
 969 0410 9105      		cpc r25,__zero_reg__
 970 0412 00F4      		brsh .L70
 971 0414 2093 0000 		sts segPosition,r18
 372:rowSegBuffer.c **** 
 373:rowSegBuffer.c **** 	}
 374:rowSegBuffer.c **** 
 375:rowSegBuffer.c **** 	//We can fit whatever's left (or the whole thing) into a single segment
 376:rowSegBuffer.c **** 	// Unless, of course, there's nothing left...
 377:rowSegBuffer.c **** 	if(length > 0) //< SEG_MAXLENGTH)//Guaranteed now...
 972               		.stabn	68,0,377,.LM90-.LFBB8
 973               	.LM90:
 974 0418 0097      		sbiw r24,0
 975 041a 01F4      		brne .L71
 976 041c 80E0      		ldi r24,lo8(0)
 977 041e 0895      		ret
 978               	.L71:
 378:rowSegBuffer.c **** 	{
 379:rowSegBuffer.c **** 		//Make sure there's another segment to write to!
 380:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 979               		.stabn	68,0,380,.LM91-.LFBB8
 980               	.LM91:
 981 0420 2334      		cpi r18,lo8(67)
 982 0422 01F4      		brne .L72
 983               	.L76:
 381:rowSegBuffer.c **** 		{
 382:rowSegBuffer.c **** 			segTerminate();
 984               		.stabn	68,0,382,.LM92-.LFBB8
 985               	.LM92:
 986 0424 00D0      		rcall segTerminate
 987 0426 81E0      		ldi r24,lo8(1)
 383:rowSegBuffer.c **** 			return TRUE;
 988               		.stabn	68,0,383,.LM93-.LFBB8
 989               	.LM93:
 990 0428 0895      		ret
 991               	.L72:
 384:rowSegBuffer.c **** 		}
 385:rowSegBuffer.c **** 
 386:rowSegBuffer.c **** 		//if(!((segPosition == 0) &&
 387:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 388:rowSegBuffer.c **** 		if(segPosition || 
 992               		.stabn	68,0,388,.LM94-.LFBB8
 993               	.LM94:
 994 042a 2223      		tst r18
 995 042c 01F4      		brne .L73
 996 042e 3091 0000 		lds r19,rowSegBuffer
 997 0432 387F      		andi r19,lo8(-8)
 998 0434 01F0      		breq .L74
 999               	.L73:
 389:rowSegBuffer.c **** 	     ((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
 390:rowSegBuffer.c ****   				segPosition++;
 1000               		.stabn	68,0,390,.LM95-.LFBB8
 1001               	.LM95:
 1002 0436 2F5F      		subi r18,lo8(-(1))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 112


 1003 0438 2093 0000 		sts segPosition,r18
 1004               	.L74:
 391:rowSegBuffer.c **** 
 392:rowSegBuffer.c **** 
 393:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = 
 1005               		.stabn	68,0,393,.LM96-.LFBB8
 1006               	.LM96:
 1007 043c E091 0000 		lds r30,segPosition
 1008 0440 F0E0      		ldi r31,lo8(0)
 1009 0442 EE0F      		lsl r30
 1010 0444 FF1F      		rol r31
 1011 0446 E050      		subi r30,lo8(-(rowSegBuffer))
 1012 0448 F040      		sbci r31,hi8(-(rowSegBuffer))
 1013 044a 880F      		lsl r24
 1014 044c 880F      		lsl r24
 1015 044e 880F      		lsl r24
 1016 0450 862B      		or r24,r22
 1017 0452 8083      		st Z,r24
 394:rowSegBuffer.c **** 			red | (length<<SEG_LENGTH_SHIFT);
 395:rowSegBuffer.c **** 
 396:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 1018               		.stabn	68,0,396,.LM97-.LFBB8
 1019               	.LM97:
 1020 0454 4183      		std Z+1,r20
 1021 0456 80E0      		ldi r24,lo8(0)
 397:rowSegBuffer.c **** 	}
 398:rowSegBuffer.c **** 
 399:rowSegBuffer.c **** 	return FALSE;
 400:rowSegBuffer.c **** 
 401:rowSegBuffer.c **** }
 1022               		.stabn	68,0,401,.LM98-.LFBB8
 1023               	.LM98:
 1024 0458 0895      		ret
 1025               		.size	newSeg, .-newSeg
 1026               	.Lscope8:
 1027               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 1028               		.stabd	78,0,0
 1029               		.stabs	"stretchSeg:F(3,2)",36,0,240,stretchSeg
 1030               		.stabs	"additionalLength:P(3,4)",64,0,240,24
 1031               	.global	stretchSeg
 1032               		.type	stretchSeg, @function
 1033               	stretchSeg:
 1034               		.stabd	46,0,0
 241:rowSegBuffer.c **** {
 1035               		.stabn	68,0,241,.LM99-.LFBB9
 1036               	.LM99:
 1037               	.LFBB9:
 1038               	/* prologue: function */
 1039               	/* frame size = 0 */
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1040               		.stabn	68,0,243,.LM100-.LFBB9
 1041               	.LM100:
 1042 045a E091 0000 		lds r30,segPosition
 1043 045e F0E0      		ldi r31,lo8(0)
 1044 0460 DF01      		movw r26,r30
 1045 0462 AA0F      		lsl r26
 1046 0464 BB1F      		rol r27
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 113


 1047 0466 A050      		subi r26,lo8(-(rowSegBuffer))
 1048 0468 B040      		sbci r27,hi8(-(rowSegBuffer))
 1049 046a 2C91      		ld r18,X
 245:rowSegBuffer.c **** 		if(!additionalLength)
 1050               		.stabn	68,0,245,.LM101-.LFBB9
 1051               	.LM101:
 1052 046c 0097      		sbiw r24,0
 1053 046e 01F0      		breq .L78
 243:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1054               		.stabn	68,0,243,.LM102-.LFBB9
 1055               	.LM102:
 1056 0470 422F      		mov r20,r18
 1057 0472 4695      		lsr r20
 1058 0474 4695      		lsr r20
 1059 0476 4695      		lsr r20
 249:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 1060               		.stabn	68,0,249,.LM103-.LFBB9
 1061               	.LM103:
 1062 0478 4F31      		cpi r20,lo8(31)
 1063 047a 00F4      		brsh .L79
 1064               	.LBB113:
 254:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 1065               		.stabn	68,0,254,.LM104-.LFBB9
 1066               	.LM104:
 1067 047c 3FE1      		ldi r19,lo8(31)
 1068 047e 341B      		sub r19,r20
 1069 0480 432F      		mov r20,r19
 1070 0482 50E0      		ldi r21,lo8(0)
 1071 0484 4817      		cp r20,r24
 1072 0486 5907      		cpc r21,r25
 1073 0488 00F0      		brlo .L80
 256:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 1074               		.stabn	68,0,256,.LM105-.LFBB9
 1075               	.LM105:
 1076 048a 880F      		lsl r24
 1077 048c 880F      		lsl r24
 1078 048e 880F      		lsl r24
 1079 0490 820F      		add r24,r18
 1080 0492 8C93      		st X,r24
 1081 0494 80E0      		ldi r24,lo8(0)
 262:rowSegBuffer.c **** 				return FALSE;
 1082               		.stabn	68,0,262,.LM106-.LFBB9
 1083               	.LM106:
 1084 0496 0895      		ret
 1085               	.L80:
 1086               	.LBB114:
 270:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 1087               		.stabn	68,0,270,.LM107-.LFBB9
 1088               	.LM107:
 1089 0498 286F      		ori r18,lo8(-8)
 1090 049a 2C93      		st X,r18
 273:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 1091               		.stabn	68,0,273,.LM108-.LFBB9
 1092               	.LM108:
 1093 049c 841B      		sub r24,r20
 1094 049e 950B      		sbc r25,r21
 1095               	.LBE114:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 114


 1096               	.LBE113:
 284:rowSegBuffer.c **** 		if(additionalLength)
 1097               		.stabn	68,0,284,.LM109-.LFBB9
 1098               	.LM109:
 1099 04a0 01F0      		breq .L78
 1100               	.L79:
 1101               	.LBB115:
 295:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 1102               		.stabn	68,0,295,.LM110-.LFBB9
 1103               	.LM110:
 1104 04a2 EE0F      		lsl r30
 1105 04a4 FF1F      		rol r31
 1106 04a6 E050      		subi r30,lo8(-(rowSegBuffer))
 1107 04a8 F040      		sbci r31,hi8(-(rowSegBuffer))
 1108 04aa 6081      		ld r22,Z
 1109 04ac 6770      		andi r22,lo8(7)
 1110 04ae 4181      		ldd r20,Z+1
 1111 04b0 00D0      		rcall newSeg
 301:rowSegBuffer.c **** 			return retVal;
 1112               		.stabn	68,0,301,.LM111-.LFBB9
 1113               	.LM111:
 1114 04b2 0895      		ret
 1115               	.L78:
 1116 04b4 80E0      		ldi r24,lo8(0)
 1117               	.LBE115:
 307:rowSegBuffer.c **** }
 1118               		.stabn	68,0,307,.LM112-.LFBB9
 1119               	.LM112:
 1120 04b6 0895      		ret
 1121               		.size	stretchSeg, .-stretchSeg
 1122               		.stabs	"oldLength:r(3,2)",64,0,242,20
 1123               		.stabn	192,0,0,.LFBB9-.LFBB9
 1124               		.stabs	"retVal:r(3,2)",64,0,292,24
 1125               		.stabn	192,0,0,.LBB115-.LFBB9
 1126               		.stabn	224,0,0,.LBE115-.LFBB9
 1127               		.stabn	224,0,0,.Lscope9-.LFBB9
 1128               	.Lscope9:
 1129               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 1130               		.stabd	78,0,0
 1131               		.stabs	"addSeg:F(3,2)",36,0,311,addSeg
 1132               		.stabs	"length:P(3,4)",64,0,311,24
 1133               		.stabs	"red:P(3,2)",64,0,311,22
 1134               		.stabs	"green_blue:P(3,2)",64,0,311,20
 1135               	.global	addSeg
 1136               		.type	addSeg, @function
 1137               	addSeg:
 1138               		.stabd	46,0,0
 312:rowSegBuffer.c **** {
 1139               		.stabn	68,0,312,.LM113-.LFBB10
 1140               	.LM113:
 1141               	.LFBB10:
 1142               	/* prologue: function */
 1143               	/* frame size = 0 */
 315:rowSegBuffer.c **** 	if(segPosition == 0)
 1144               		.stabn	68,0,315,.LM114-.LFBB10
 1145               	.LM114:
 1146 04b8 E091 0000 		lds r30,segPosition
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 115


 1147 04bc EE23      		tst r30
 1148 04be 01F4      		brne .L84
 316:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1149               		.stabn	68,0,316,.LM115-.LFBB10
 1150               	.LM115:
 1151 04c0 00D0      		rcall newSeg
 1152 04c2 0895      		ret
 1153               	.L84:
 319:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 1154               		.stabn	68,0,319,.LM116-.LFBB10
 1155               	.LM116:
 1156 04c4 F0E0      		ldi r31,lo8(0)
 1157 04c6 EE0F      		lsl r30
 1158 04c8 FF1F      		rol r31
 1159 04ca E050      		subi r30,lo8(-(rowSegBuffer))
 1160 04cc F040      		sbci r31,hi8(-(rowSegBuffer))
 1161 04ce 2081      		ld r18,Z
 1162 04d0 30E0      		ldi r19,lo8(0)
 1163 04d2 2770      		andi r18,lo8(7)
 1164 04d4 3070      		andi r19,hi8(7)
 1165 04d6 A62F      		mov r26,r22
 1166 04d8 B0E0      		ldi r27,lo8(0)
 1167 04da 2A17      		cp r18,r26
 1168 04dc 3B07      		cpc r19,r27
 1169 04de 01F4      		brne .L86
 1170 04e0 2181      		ldd r18,Z+1
 1171 04e2 2417      		cp r18,r20
 1172 04e4 01F4      		brne .L86
 321:rowSegBuffer.c **** 			return stretchSeg(length);
 1173               		.stabn	68,0,321,.LM117-.LFBB10
 1174               	.LM117:
 1175 04e6 00D0      		rcall stretchSeg
 1176 04e8 0895      		ret
 1177               	.L86:
 323:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1178               		.stabn	68,0,323,.LM118-.LFBB10
 1179               	.LM118:
 1180 04ea 00D0      		rcall newSeg
 325:rowSegBuffer.c **** }
 1181               		.stabn	68,0,325,.LM119-.LFBB10
 1182               	.LM119:
 1183 04ec 0895      		ret
 1184               		.size	addSeg, .-addSeg
 1185               	.Lscope10:
 1186               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 1187               		.stabd	78,0,0
 1188               		.stabs	"rbpix_to_seg:F(0,15)",36,0,207,rbpix_to_seg
 1189               		.stabs	"rbValue:P(3,2)",64,0,207,17
 1190               		.stabs	"col:P(3,2)",64,0,207,22
 1191               		.stabs	"length:P(3,2)",64,0,207,24
 1192               	.global	rbpix_to_seg
 1193               		.type	rbpix_to_seg, @function
 1194               	rbpix_to_seg:
 1195               		.stabd	46,0,0
 208:rowSegBuffer.c **** {
 1196               		.stabn	68,0,208,.LM120-.LFBB11
 1197               	.LM120:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 116


 1198               	.LFBB11:
 1199 04ee 1F93      		push r17
 1200               	/* prologue: function */
 1201               	/* frame size = 0 */
 1202 04f0 182F      		mov r17,r24
 1203 04f2 842F      		mov r24,r20
 212:rowSegBuffer.c **** 	if(col == 0)
 1204               		.stabn	68,0,212,.LM121-.LFBB11
 1205               	.LM121:
 1206 04f4 6623      		tst r22
 1207 04f6 01F4      		brne .L89
 214:rowSegBuffer.c **** 		last_rbValue = 0;
 1208               		.stabn	68,0,214,.LM122-.LFBB11
 1209               	.LM122:
 1210 04f8 1092 0000 		sts last_rbValue.2025,__zero_reg__
 1211               	.LBB116:
 1212               	.LBB117:
 161:rowSegBuffer.c **** 	segPosition = 0;
 1213               		.stabn	68,0,161,.LM123-.LFBB11
 1214               	.LM123:
 1215 04fc 1092 0000 		sts segPosition,__zero_reg__
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 1216               		.stabn	68,0,164,.LM124-.LFBB11
 1217               	.LM124:
 1218 0500 96E0      		ldi r25,lo8(6)
 1219 0502 9093 0000 		sts rowSegBuffer,r25
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 1220               		.stabn	68,0,165,.LM125-.LFBB11
 1221               	.LM125:
 1222 0506 93E6      		ldi r25,lo8(99)
 1223 0508 9093 0000 		sts rowSegBuffer+1,r25
 1224 050c 00C0      		rjmp .L90
 1225               	.L89:
 1226               	.LBE117:
 1227               	.LBE116:
 218:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 1228               		.stabn	68,0,218,.LM126-.LFBB11
 1229               	.LM126:
 1230 050e 9091 0000 		lds r25,segPosition
 1231 0512 9923      		tst r25
 1232 0514 01F0      		breq .L90
 1233 0516 9091 0000 		lds r25,last_rbValue.2025
 1234 051a 1917      		cp r17,r25
 1235 051c 01F4      		brne .L90
 220:rowSegBuffer.c **** 		stretchSeg(length);
 1236               		.stabn	68,0,220,.LM127-.LFBB11
 1237               	.LM127:
 1238 051e 90E0      		ldi r25,lo8(0)
 1239 0520 00D0      		rcall stretchSeg
 221:rowSegBuffer.c **** 		return;
 1240               		.stabn	68,0,221,.LM128-.LFBB11
 1241               	.LM128:
 1242 0522 00C0      		rjmp .L92
 1243               	.L90:
 228:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 1244               		.stabn	68,0,228,.LM129-.LFBB11
 1245               	.LM129:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 117


 1246 0524 612F      		mov r22,r17
 1247 0526 70E0      		ldi r23,lo8(0)
 1248 0528 6C71      		andi r22,lo8(28)
 1249 052a 7070      		andi r23,hi8(28)
 1250 052c 7595      		asr r23
 1251 052e 6795      		ror r22
 1252 0530 7595      		asr r23
 1253 0532 6795      		ror r22
 1254 0534 212F      		mov r18,r17
 1255 0536 2295      		swap r18
 1256 0538 2695      		lsr r18
 1257 053a 2770      		andi r18,lo8(7)
 1258 053c 2295      		swap r18
 1259 053e 207F      		andi r18,lo8(-16)
 1260 0540 912F      		mov r25,r17
 1261 0542 9370      		andi r25,lo8(3)
 1262 0544 292B      		or r18,r25
 1263 0546 90E0      		ldi r25,lo8(0)
 1264 0548 422F      		mov r20,r18
 1265 054a 00D0      		rcall newSeg
 230:rowSegBuffer.c **** 	last_rbValue = rbValue;
 1266               		.stabn	68,0,230,.LM130-.LFBB11
 1267               	.LM130:
 1268 054c 1093 0000 		sts last_rbValue.2025,r17
 1269               	.L92:
 1270               	/* epilogue start */
 231:rowSegBuffer.c **** }
 1271               		.stabn	68,0,231,.LM131-.LFBB11
 1272               	.LM131:
 1273 0550 1F91      		pop r17
 1274 0552 0895      		ret
 1275               		.size	rbpix_to_seg, .-rbpix_to_seg
 1276               		.stabs	"last_rbValue:V(3,2)",38,0,209,last_rbValue.2025
 1277               		.stabn	192,0,0,.LFBB11-.LFBB11
 1278               		.stabn	224,0,0,.Lscope11-.LFBB11
 1279               	.Lscope11:
 1280               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 1281               		.stabd	78,0,0
 1282               		.stabs	"fb_to_rb:F(3,2)",36,0,85,fb_to_rb
 1283               		.stabs	"fbColor:P(3,2)",64,0,85,24
 1284               	.global	fb_to_rb
 1285               		.type	fb_to_rb, @function
 1286               	fb_to_rb:
 1287               		.stabd	46,0,0
 1288               		.stabs	"rowBuffer.c",132,0,0,.Ltext5
 1289               	.Ltext5:
   1:rowBuffer.c   **** // RowBuffer
   2:rowBuffer.c   **** //    An entire row is calculated and stored in the rowbuffer
   3:rowBuffer.c   **** //    before each line is displayed.
   4:rowBuffer.c   **** //    (There is not nearly enough memory for an entire frameBuffer)
   5:rowBuffer.c   **** //
   6:rowBuffer.c   **** //    A single byte is used for each drawable pixel in the row
   7:rowBuffer.c   **** //    this byte is actually a bit-mask of the OCR/DT values
   8:rowBuffer.c   **** //    so it's more of a settings-buffer
   9:rowBuffer.c   **** //    
  10:rowBuffer.c   **** //    Processing each byte and writing registers takes 14 clock cycles
  11:rowBuffer.c   **** //     so at full-speed LVDS (1 pixel per 7/8ths clock cycle)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 118


  12:rowBuffer.c   **** //     then each drawable pixel is 16 LCD pixels wide
  13:rowBuffer.c   **** //     for a maximum resolution of 64 drawable pixels across
  14:rowBuffer.c   **** //     (thus, the row-settings-buffer is 64Bytes)
  15:rowBuffer.c   **** //    (Were the bytes not packed, and we used three bytes per drawable
  16:rowBuffer.c   **** //     pixel, each readFromSRAM*3+loadToRegister*3 pixel would be 
  17:rowBuffer.c   **** //     9 cycles... for ~100 pixels and ~300Bytes. Would it really be worth
  18:rowBuffer.c   **** //     3 times the memory for 1/3 more pixels? Probably not...
  19:rowBuffer.c   **** //     See RowSegmentBuffer for higher resolution...)
  20:rowBuffer.c   **** //
  21:rowBuffer.c   **** //   Red: (+OC1D => RX0+)
  22:rowBuffer.c   **** //    Off (0/63): OCR1D = 0
  23:rowBuffer.c   **** //    35/63:      OCR1D = 3
  24:rowBuffer.c   **** //    51/63:      OCR1D = 4   (FOUR_SHADES only)
  25:rowBuffer.c   **** //    63/63:      OCR1D >= 6
  26:rowBuffer.c   **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
  27:rowBuffer.c   **** //    Off (6/63): DTL1 = 0
  28:rowBuffer.c   **** //    38-39/63:      DTL1 = 1
  29:rowBuffer.c   **** //    54-55/63:      DTL1 = 2 (FOUR_SHADES only)
  30:rowBuffer.c   **** //    62-63/63:      DTL1 = 3
  31:rowBuffer.c   **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
  32:rowBuffer.c   **** //    Off (15/63):  OCR1A=4
  33:rowBuffer.c   **** //    47/63:        OCR1A=5
  34:rowBuffer.c   **** //    63/63:        OCR1A=6
  35:rowBuffer.c   **** //
  36:rowBuffer.c   **** //  For faster pixels: these values could be stored in a settingsBuffer
  37:rowBuffer.c   **** //  (instead of a frame-buffer based on color values)
  38:rowBuffer.c   **** //  we have: 
  39:rowBuffer.c   **** //                             0    1    2    3
  40:rowBuffer.c   **** //                 ColorVal:  00   01   10   11
  41:rowBuffer.c   **** //     Red (OCR1D): 0,3,4,6  000, 011, 100, 110
  42:rowBuffer.c   **** //   Green (DTL1):  0,1,2,3  000, 001, 010, 011
  43:rowBuffer.c   **** //    Blue (OCR1A): 4,5,6    100, 101, 110, 110
  44:rowBuffer.c   **** //           (I guess it could be noted that Blue's bit2 is always 1)
  45:rowBuffer.c   **** //           (also: OCR1A = 7 is totally acceptable, 
  46:rowBuffer.c   **** //                  so blueOCR=0x4|blueColor)
  47:rowBuffer.c   **** //           ( Similar can be said for Red... 7 is acceptable)
  48:rowBuffer.c   **** //  For memory space, we could fit these values directly in a single byte
  49:rowBuffer.c   **** //    Red Mask: 0x07
  50:rowBuffer.c   **** //  Green Mask: 0x14
  51:rowBuffer.c   **** //   Blue Mask: 0x60
  52:rowBuffer.c   **** //
  53:rowBuffer.c   **** //  Options: mask and shift, no extra memory
  54:rowBuffer.c   **** //           andi for red
  55:rowBuffer.c   **** //           andi for green + 3 shifts
  56:rowBuffer.c   **** //           5 shifts for blue
  57:rowBuffer.c   **** //           ... 10 cycles (12 pixels)
  58:rowBuffer.c   **** //           If green is the low two bits:
  59:rowBuffer.c   **** //           andi for green
  60:rowBuffer.c   **** //           andi for red + 2 shifts
  61:rowBuffer.c   **** //           5 shifts for blue
  62:rowBuffer.c   **** //           ... 9 cycles (11 pixels)
  63:rowBuffer.c   **** //          + 3 register writes (3 cycles) = 12cycles
  64:rowBuffer.c   **** //          + 1 SRAM read (2 cycles) = 14 cycles (16 pixels)
  65:rowBuffer.c   **** //           ALSO: 5 shifts TOTAL, usable?
  66:rowBuffer.c   **** //         (This may be outdated... and doesn't take into account
  67:rowBuffer.c   **** //          mov instructions... so see the code instead of believing this)
  68:rowBuffer.c   **** //         BUT:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 119


  69:rowBuffer.c   **** //          64 pixels across * 64 pixels down is 4096 bytes
  70:rowBuffer.c   **** //          WAY more than my RAM
  71:rowBuffer.c   **** //          So either way we need to precalculate each row before
  72:rowBuffer.c   **** //          displaying it
  73:rowBuffer.c   **** //          Could be as simple as loading direct from program memory
  74:rowBuffer.c   **** 
  75:rowBuffer.c   **** 
  76:rowBuffer.c   **** 
  77:rowBuffer.c   **** #define LOADROW	TRUE
  78:rowBuffer.c   **** 
  79:rowBuffer.c   **** #define RB_WIDTH 64 //100
  80:rowBuffer.c   **** #define RB_HEIGHT 48
  81:rowBuffer.c   **** uint8_t rowBuffer[RB_WIDTH];
  82:rowBuffer.c   **** 
  83:rowBuffer.c   **** 
  84:rowBuffer.c   **** //Convert from a frameBuffer color to a rowBuffer setting value...
  85:rowBuffer.c   **** uint8_t fb_to_rb(uint8_t fbColor)
  86:rowBuffer.c   **** {
 1290               		.stabn	68,0,86,.LM132-.LFBB12
 1291               	.LM132:
 1292               	.LFBB12:
 1293               	/* prologue: function */
 1294               	/* frame size = 0 */
  87:rowBuffer.c   ****    uint8_t rb = 0;
  88:rowBuffer.c   **** 
  89:rowBuffer.c   ****    //rb bit: 7 6 5 4 3 2 1 0
  90:rowBuffer.c   ****    //        \_ _/ \_ _/ \ /
  91:rowBuffer.c   ****    //          V     V    V
  92:rowBuffer.c   ****    //          |     |    Green Setting
  93:rowBuffer.c   ****    //          |     Red Setting
  94:rowBuffer.c   ****    //          Blue Setting
  95:rowBuffer.c   **** 
  96:rowBuffer.c   ****    // Frame Buffer color/shade values:
  97:rowBuffer.c   ****    //fb bit: 7 6 5 4 3 2 1 0
  98:rowBuffer.c   ****    //        \ / \ / \ / \ /
  99:rowBuffer.c   ****    //         V   V   V   V
 100:rowBuffer.c   ****    //         |   |   |   Red Value (0-3)
 101:rowBuffer.c   ****    //         |   |   Green Value (0-3)
 102:rowBuffer.c   ****    //         |   Blue Value (0-3)
 103:rowBuffer.c   ****    //         Alpha... only partially implemented
 104:rowBuffer.c   **** 
 105:rowBuffer.c   **** #warning "This isn't at all optimized..."
 106:rowBuffer.c   ****    // Blue setting = Blue Value | 0x04
 107:rowBuffer.c   ****    uint8_t blueValue = (fbColor & 0x30) >> 4;
 1295               		.stabn	68,0,107,.LM133-.LFBB12
 1296               	.LM133:
 1297 0554 682F      		mov r22,r24
 1298 0556 70E0      		ldi r23,lo8(0)
 108:rowBuffer.c   ****    rb = (blueValue << 5) | 0x80;
 109:rowBuffer.c   **** 
 110:rowBuffer.c   ****    // Red setting = redVal << 1 | redVal & 0x01
 111:rowBuffer.c   ****    uint8_t redValue = (fbColor & 0x03);
 112:rowBuffer.c   ****    rb |= ((redValue << 1) | (redValue & 0x01)) << 2;
 1299               		.stabn	68,0,112,.LM134-.LFBB12
 1300               	.LM134:
 1301 0558 8370      		andi r24,lo8(3)
 1302 055a 90E0      		ldi r25,lo8(0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 120


 1303 055c 9C01      		movw r18,r24
 1304 055e 2170      		andi r18,lo8(1)
 1305 0560 3070      		andi r19,hi8(1)
 1306 0562 880F      		lsl r24
 1307 0564 991F      		rol r25
 1308 0566 282B      		or r18,r24
 1309 0568 392B      		or r19,r25
 1310 056a 220F      		lsl r18
 1311 056c 331F      		rol r19
 1312 056e 220F      		lsl r18
 1313 0570 331F      		rol r19
 1314 0572 2068      		ori r18,lo8(-128)
 1315 0574 AB01      		movw r20,r22
 1316 0576 4073      		andi r20,lo8(48)
 1317 0578 5070      		andi r21,hi8(48)
 1318 057a 440F      		lsl r20
 1319 057c 551F      		rol r21
 1320 057e 242B      		or r18,r20
 1321 0580 CB01      		movw r24,r22
 1322 0582 8C70      		andi r24,lo8(12)
 1323 0584 9070      		andi r25,hi8(12)
 1324 0586 9595      		asr r25
 1325 0588 8795      		ror r24
 1326 058a 9595      		asr r25
 1327 058c 8795      		ror r24
 113:rowBuffer.c   **** 
 114:rowBuffer.c   ****    // Green Setting = Green Value...
 115:rowBuffer.c   ****    uint8_t greenValue = (fbColor & 0x0C) >> 2;
 116:rowBuffer.c   ****    rb |= greenValue;
 117:rowBuffer.c   **** 
 118:rowBuffer.c   ****    return rb;
 119:rowBuffer.c   **** }
 1328               		.stabn	68,0,119,.LM135-.LFBB12
 1329               	.LM135:
 1330 058e 822B      		or r24,r18
 1331               	/* epilogue start */
 1332 0590 0895      		ret
 1333               		.size	fb_to_rb, .-fb_to_rb
 1334               		.stabs	"rb:r(3,2)",64,0,87,18
 1335               		.stabn	192,0,0,.LFBB12-.LFBB12
 1336               		.stabn	224,0,0,.Lscope12-.LFBB12
 1337               	.Lscope12:
 1338               		.stabs	"",36,0,0,.Lscope12-.LFBB12
 1339               		.stabd	78,0,0
 1340               		.stabs	"pll_enable:F(0,15)",36,0,1295,pll_enable
 1341               	.global	pll_enable
 1342               		.type	pll_enable, @function
 1343               	pll_enable:
 1344               		.stabd	46,0,0
 1345               		.stabs	"main.c",132,0,0,.Ltext6
 1346               	.Ltext6:
1296:main.c        **** {
 1347               		.stabn	68,0,1296,.LM136-.LFBB13
 1348               	.LM136:
 1349               	.LFBB13:
 1350               	/* prologue: function */
 1351               	/* frame size = 0 */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 121


1306:main.c        ****    setbit(PLLE, PLLCSR);
 1352               		.stabn	68,0,1306,.LM137-.LFBB13
 1353               	.LM137:
 1354 0592 89B5      		in r24,73-0x20
 1355 0594 8260      		ori r24,lo8(2)
 1356 0596 89BD      		out 73-0x20,r24
 1357               	.LBB118:
 1358               	.LBB119:
 1359               	.LBB120:
 1360               	.LBB121:
 1361               	.LBB122:
 1362               	.LBB123:
 1363               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext7
 1364               	.Ltext7:
   1:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 122


  44:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 123


 101:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 1365               		.stabn	68,0,105,.LM138-.LFBB13
 1366               	.LM138:
 1367 0598 88EC      		ldi r24,lo8(200)
 1368 059a 90E0      		ldi r25,hi8(200)
 1369               	/* #APP */
 1370               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1371 059c 0197      		1: sbiw r24,1
 1372 059e 01F4      		brne 1b
 1373               	 ;  0 "" 2
 1374               	/* #NOAPP */
 1375 05a0 00C0      		rjmp .L96
 1376               	.L97:
 1377               	.LBE123:
 1378               	.LBE122:
 1379               	.LBE121:
 1380               	.LBE120:
 1381               	.LBE119:
 1382               	.LBE118:
 1383               		.stabs	"main.c",132,0,0,.Ltext8
 1384               	.Ltext8:
1314:main.c        ****       asm("nop");
 1385               		.stabn	68,0,1314,.LM139-.LFBB13
 1386               	.LM139:
 1387               	/* #APP */
 1388               	 ;  1314 "main.c" 1
 1389 05a2 0000      		nop
 1390               	 ;  0 "" 2
 1391               	/* #NOAPP */
 1392               	.L96:
1312:main.c        ****    while(!getbit(PLOCK, PLLCSR))
 1393               		.stabn	68,0,1312,.LM140-.LFBB13
 1394               	.LM140:
 1395 05a4 09B4      		in __tmp_reg__,73-0x20
 1396 05a6 00FE      		sbrs __tmp_reg__,0
 1397 05a8 00C0      		rjmp .L97
1317:main.c        ****    setbit(PCKE, PLLCSR);
 1398               		.stabn	68,0,1317,.LM141-.LFBB13
 1399               	.LM141:
 1400 05aa 89B5      		in r24,73-0x20
 1401 05ac 8460      		ori r24,lo8(4)
 1402 05ae 89BD      		out 73-0x20,r24
 1403               	/* epilogue start */
1319:main.c        **** }
 1404               		.stabn	68,0,1319,.LM142-.LFBB13
 1405               	.LM142:
 1406 05b0 0895      		ret
 1407               		.size	pll_enable, .-pll_enable
 1408               		.stabs	"__count:r(3,4)",64,0,138,24
 1409               		.stabn	192,0,0,.LBB122-.LFBB13
 1410               		.stabn	224,0,0,.LBE122-.LFBB13
 1411               	.Lscope13:
 1412               		.stabs	"",36,0,0,.Lscope13-.LFBB13
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 124


 1413               		.stabd	78,0,0
 1414               		.stabs	"lvds_timerInit:F(0,15)",36,0,1321,lvds_timerInit
 1415               	.global	lvds_timerInit
 1416               		.type	lvds_timerInit, @function
 1417               	lvds_timerInit:
 1418               		.stabd	46,0,0
1322:main.c        **** {
 1419               		.stabn	68,0,1322,.LM143-.LFBB14
 1420               	.LM143:
 1421               	.LFBB14:
 1422               	/* prologue: function */
 1423               	/* frame size = 0 */
1328:main.c        ****    OCR1C = 6;
 1424               		.stabn	68,0,1328,.LM144-.LFBB14
 1425               	.LM144:
 1426 05b2 86E0      		ldi r24,lo8(6)
 1427 05b4 8BBD      		out 75-0x20,r24
1331:main.c        **** 	CLOCK_OCR = 3; //2; //3;
 1428               		.stabn	68,0,1331,.LM145-.LFBB14
 1429               	.LM145:
 1430 05b6 83E0      		ldi r24,lo8(3)
 1431 05b8 8CBD      		out 76-0x20,r24
1363:main.c        ****    OSCCAL = OSCCAL_VAL;
 1432               		.stabn	68,0,1363,.LM146-.LFBB14
 1433               	.LM146:
 1434 05ba 8FEF      		ldi r24,lo8(-1)
 1435 05bc 81BF      		out 81-0x20,r24
1430:main.c        **** 	pll_enable();
 1436               		.stabn	68,0,1430,.LM147-.LFBB14
 1437               	.LM147:
 1438 05be 00D0      		rcall pll_enable
1442:main.c        **** 	writeMasked(CSBITS, 
 1439               		.stabn	68,0,1442,.LM148-.LFBB14
 1440               	.LM148:
 1441 05c0 8FB5      		in r24,79-0x20
 1442 05c2 807F      		andi r24,lo8(-16)
 1443 05c4 8460      		ori r24,lo8(4)
 1444 05c6 8FBD      		out 79-0x20,r24
1449:main.c        **** 	writeMasked(DTPSBITS,
 1445               		.stabn	68,0,1449,.LM149-.LFBB14
 1446               	.LM149:
 1447 05c8 8FB5      		in r24,79-0x20
 1448 05ca 8063      		ori r24,lo8(48)
 1449 05cc 8FBD      		out 79-0x20,r24
1461:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
 1450               		.stabn	68,0,1461,.LM150-.LFBB14
 1451               	.LM150:
 1452 05ce 80B7      		in r24,80-0x20
 1453 05d0 8260      		ori r24,lo8(2)
 1454 05d2 80BF      		out 80-0x20,r24
1464:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
 1455               		.stabn	68,0,1464,.LM151-.LFBB14
 1456               	.LM151:
 1457 05d4 80B7      		in r24,80-0x20
 1458 05d6 8160      		ori r24,lo8(1)
 1459 05d8 80BF      		out 80-0x20,r24
1466:main.c        **** 	setbit(PWM1D, TCCR1C);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 125


 1460               		.stabn	68,0,1466,.LM152-.LFBB14
 1461               	.LM152:
 1462 05da 87B5      		in r24,71-0x20
 1463 05dc 8160      		ori r24,lo8(1)
 1464 05de 87BD      		out 71-0x20,r24
1470:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
 1465               		.stabn	68,0,1470,.LM153-.LFBB14
 1466               	.LM153:
 1467 05e0 B99A      		sbi 55-0x20,1
1472:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
 1468               		.stabn	68,0,1472,.LM154-.LFBB14
 1469               	.LM154:
 1470 05e2 BA9A      		sbi 55-0x20,2
1473:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
 1471               		.stabn	68,0,1473,.LM155-.LFBB14
 1472               	.LM155:
 1473 05e4 BB9A      		sbi 55-0x20,3
1474:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
 1474               		.stabn	68,0,1474,.LM156-.LFBB14
 1475               	.LM156:
 1476 05e6 BD9A      		sbi 55-0x20,5
1477:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
 1477               		.stabn	68,0,1477,.LM157-.LFBB14
 1478               	.LM157:
 1479 05e8 86B5      		in r24,70-0x20
 1480 05ea 8C7F      		andi r24,lo8(-4)
 1481 05ec 86BD      		out 70-0x20,r24
1544:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
 1482               		.stabn	68,0,1544,.LM158-.LFBB14
 1483               	.LM158:
 1484 05ee 89E0      		ldi r24,lo8(9)
 1485 05f0 87BD      		out 71-0x20,r24
1547:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
 1486               		.stabn	68,0,1547,.LM159-.LFBB14
 1487               	.LM159:
 1488 05f2 83E6      		ldi r24,lo8(99)
 1489 05f4 80BF      		out 80-0x20,r24
1578:main.c        ****  	Nada_init();
 1490               		.stabn	68,0,1578,.LM160-.LFBB14
 1491               	.LM160:
 1492 05f6 80E3      		ldi r24,lo8(48)
 1493 05f8 84BD      		out 68-0x20,r24
 1494 05fa 84E0      		ldi r24,lo8(4)
 1495 05fc 8DBD      		out 77-0x20,r24
 1496               	/* epilogue start */
1579:main.c        **** }
 1497               		.stabn	68,0,1579,.LM161-.LFBB14
 1498               	.LM161:
 1499 05fe 0895      		ret
 1500               		.size	lvds_timerInit, .-lvds_timerInit
 1501               	.Lscope14:
 1502               		.stabs	"",36,0,0,.Lscope14-.LFBB14
 1503               		.stabd	78,0,0
 1504               		.stabs	"lcd_Init:F(0,15)",36,0,870,lcd_Init
 1505               	.global	lcd_Init
 1506               		.type	lcd_Init, @function
 1507               	lcd_Init:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 126


 1508               		.stabd	46,0,0
 1509               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext9
 1510               	.Ltext9:
   1:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //lcdStuff 0.51ncf-git
   2:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
   3:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.51ncf-git first attempt at using git for uploading to googleCode...
   4:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        this version isn't yet used by any projects
   5:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.50ncf cleanup, colorOverride is unused...
   6:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				SMILEY -> LCD_SMILEY
   7:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf-1 loadRow unused... removal untested...
   8:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf drawPix...
   9:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-6 HSYNC_INACTIVE, etc. definable elsewhere
  10:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-5 Adding BLUE_VERT_BAR_REVERSED
  11:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-4 Adding NOTES: DON'T START WITH BLUE_DIAG_BAR
  12:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-3 T_DV and T_Vlow overrideable
  13:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-2 Not sure if I've modified it between... but here: 
  14:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        FRAME_COUNT_TO_DELAY wasn't defined, giving warnings
  15:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-1 updateLCD() has return-values for state-switches
  16:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (VFP, VSync, VBP, DE)
  17:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        ACTUALLY, that's unnecessary... state-transitions can be
  18:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        determined by vSync and dataEnable...
  19:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf Haven't been keeping these backed up regularly...
  20:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        More toward realtime adjustable timing values
  21:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        V Front Porch now occurs at the beginning of the frame, instead
  22:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        of at the end...
  23:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  24:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.20ncf More Timing Value experiment preparation... 
  25:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-3ish looking into reloading methods for e.g. experimenting with
  26:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          timing values: sdramThing2.0-7
  27:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          How to "move" timing-values around data which needn't be
  28:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          changed...
  29:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-andsomemore
  30:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Added MAKELONG to fix integer overflow warnings
  31:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Revised it from "... + MAKELONG" to "MAKELONG(...)"
  32:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (The +MAKELONG version is lost in the ether... if you *really*
  33:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //           want it, there's a localized version in sdramThing2.0-6)
  34:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-1ish - Adding HSYNC_COUNT_FRAME_COMPLETE
  35:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               Removal of LVDS_PRESCALER stuff...
  36:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf - Stolen from LCDdirectLVDS/54-moreColorStuff/main.c
  37:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Removal of LCDdirectLVDS-specific stuff...
  38:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				A little bit of rewriting of notes to be more generalized
  39:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          All delay_cyc references replaced with delay_Dots,
  40:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //					math changed accordingly...
  41:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  42:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  43:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I hereby declare this FPD-Link simulation technique to forever be called
  44:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  PW-BANGing
  45:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  46:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o 0.10ncf-4: (sdramThing2.0v8-28)
  47:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DON'T START WITH BLUE_DIAG_BAR
  48:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Unless you want to be depressed
  49:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Good Starting Point DE_BLUE
  50:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  51:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  52:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  53:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //new notes a/o 0.10ncf-3ish:
  54:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The basic idea is that timing is something that needs to be experimented
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 127


  55:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // with, often... so, for cases where LCD timing/drawing data is loaded
  56:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // beforehand (e.g. sdramThing2.0-7), it would be nice not to have to
  57:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // reload *all* the data, only to change the necessary timing data
  58:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  59:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Neglecting the SDRAM for a second, we have essentially:
  60:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (The exact placement is not necessarily in order... e.g. DH_DOTS could
  61:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  be at the end of a row, or at the beginning... VSYNC rows could be at
  62:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  the top, or at the bottom.....)
  63:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (See also notes "Here's how it worked pre-lvds:", which actually are a
  64:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   bit off, e.g. I don't think VSYNC L->H was delayed by DE_TIME after
  65:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Hsync)
  66:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  67:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS + HD_DOTS + DH_DOTS = "Horizontal Blank Time"
  68:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (This "front/back" thing always confused me...
  69:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DH_DOTS is *in front of* Hsync as far as *time* is concerned...
  70:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  i.e. looking at a 'scope trace... But something about reading left-to-
  71:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  right causes me to feel like "front" is the furthest to the right
  72:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  which would be *later* in time... weird.
  73:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
  74:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  75:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |--|<--H_LOW_DOTS                       "Horiz Front Porch"
  76:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  |--|<--HD_DOTS="Horiz Back Porch"    |<---->|<--DH_DOTS
  77:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .      |
  78:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<............................................./
  79:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .    
  80:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        v  v  .                                 .      
  81:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V _______________________________________________  \ VSYNC Rows
  82:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  83:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_Vlow times)
  84:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .
  85:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .      "Vsync Back Porch"
  86:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  87:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  88:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_VD times)
  89:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .         "Vbp should be
  90:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              v                                 v          static"
  91:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************
  92:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  93:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  94:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  95:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
  96:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  97:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *<------ DE_ACTIVE_DOTS --------->*        (Repeat V_COUNT
  98:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *         =1024 times)
  99:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     .   Displayed Pixels
 100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *
 101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
 104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
 106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************      
 108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                      "Vsync Front Porch"
 109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
 110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_DV times)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 128


 112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #warning "TODO Maybe: LCDdirectLVDS (which so far is the only version which synced with such low re
 115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Front vs. Back porches....
 117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   If I were to draw a car driving down a street... 
 118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I would draw it with its front to the right, driving to the right...
 119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       _____/\________     \O/
 121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ...|__   _________   __\     |
 122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...\_/         \_/       / \							//
 123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person is *in front of* the car... which means the car has not yet
 125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   arrived at the person, but will soon... 
 126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (later in time, not *before* in time)
 127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This is my logic...
 128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So The "Horizontal Front Porch", to me, should be to the RIGHT of the
 129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Horizontal Sync Pulse...
 130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But that ain't how it is (unless I've confused myself into a circle
 131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   where my logic is actually right, and I just think it's wrong?)
 132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   
 133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  By the logic that the front porch occurs *before* the sync pulse,
 134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ... I suppose we could think of a person in front of a house... it
 135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   makes more sense, anyhow, since it's a porch in front of a house, 
 136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   not person in front of a car.
 137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person's walking into the house, crosses the *front*-porch 
 138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   *before* enterring the doorway. If he continues walking all the way
 139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   through the house and out the back-door, he'll be crossing the *back*
 140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   porch later in time...
 141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Right, so the logic makes sense... but for some reason I have to run 
 143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  through this whole diatribe every time I see the terms.
 144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Heh, and even after going through it, the damned thing seems backwards.
 145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Probably because I drew it with the front-porch to the right side...)
 146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (AND THEN there's the issue that it seems to me like the front-porch
 147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the left of the drawing-area whereas the back-porch
 148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the right of it... rather than to the HSYNC pulse)
 149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Anyways, all that drawing was to figure out where to position this
 152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in memory, such that it would be the least processing-effort to modify
 153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // timing values for testing... (because loading the SDRAM's free-running 
 154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // data takes ~20minutes!)
 155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Options LTN, IDT, or TESTVALS
 159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
 160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DISPLAY
 161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //oldNote:
 165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it seems the speed (at least for the LTN) isn't so important after all
 167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This could be used to my advantage...
 168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 129


 169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Thus, pixels could be skinnier, thus higher-resolution.
 170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Or more instructions could be used for the same resolution
 171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   allowing, e.g. sprites from program-memory, without necessitating a
 172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   large (or any?) frame-buffer...
 173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This would normally be 0 for the highest-speed frame-refresh possible
 176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // However, increasing this value can slow the frame-refresh rate
 177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if desired
 178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. 50000 causes it to refresh ~ every few seconds
 179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (durn-near the limit for how long the LCD will retain an image)
 180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The benefit being that it doesn't flicker at annoying rates for
 181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  stationary images
 182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  worth exploring...
 183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This may be highly dependent on the screen capabilities...
 184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   of course, this sorta thing is undocumented
 185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   it just has to be experimented with
 186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   likely be driven DC... not sure what the long term effects are.
 188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This could be a hell of a lot more sophisticated...
 189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. refresh after a frameBuffer change
 190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      refresh based on a seconds-timer
 191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...
 192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AS-IS: Does refreshes completely independent of the frame-buffer
 193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      if it's too slow, some images may be missed completely.
 194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      This is not true for FRAME_SYNC TRUE (below)
 195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (and it's not really useful anymore with FRAME_SYNC)
 196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o sdramThing2.0, this is not really relevent...
 197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	if the frame needs updating, just stop free-running, right?
 198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	well, doing-so might cause issues, since the LVDS clock will not be
 199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    running... this is a TBD
 200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //New Idea:
 204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Disable the Hsync timer interrupt after the frame completes
 205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and reenable elsewhere...
 206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (It seems pixels changing from one shade to another take an
 207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate step halfway between)
 208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Thus, two updates then a pause might clear that up)
 209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   is the same...)
 211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (but it is an interesting effect)
 212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Reworded: Having several frame refreshes before a pause helps to
 214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  "solidify" the color changes... especially the sharp changes 
 215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (e.g. yellow<->black)
 216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
 217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   in LCDdirect that was only connected such that R, G, and B were each
 218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   either full-off or full-on, i.e. all Red bits were connected to a
 219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   single output pin (full on when 1, full off when 0).
 220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I hadn't attributed it to improper refresh synchronization
 221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   as the refresh rate was too fast to see... That's a handy way to get
 222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  connected with each color 
 224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  If you WANT this effect (for intermediate shades?) 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 130


 226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   set FRAME_COUNT_TO_DELAY to 1
 227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Then, each change of color will (apparently) result in a value halfway
 228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between the old color and the new color
 229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Not sure whether it's an electrical problem, but these half-shades 
 230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   depends on the goal...
 232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FRAME_COUNT_TO_DELAY 2//7//1//5//2//3
 233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN appears to be content with my pseudo-LVDS scheme.
 237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IAXG has never unblanked
 238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Even though suitable timings were found with SwitchResX
 239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Maybe due to psuedo-LVDS
 240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            slight timing issues // It probably doesn't work with all cases...
 241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Definitely with drawPix/Images...(RC oscillator variances?)
 242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            glitches when switching LVDS states 
 243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 (thought I had that figured out, originally)
 244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      The fact the LTN appears to recognize the signalling suggests the
 245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG would be worth further exploration...
 246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         Unfortunately, the CCFT blew out my inverter
 247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        And I must have put it back together incorrectly
 248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (backlight filters out of order or flipped?)
 249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (which actually makes for some very interesting
 250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         visuals, but hard to develop with)
 251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG: uses DE, V, and H
 252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             At low pixel-clock DE is active for fewer pixels...
 253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              Last Tested: 680 was full-screen
 254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             Nice because it increases the frame-rate!
 255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      LTN:  uses DE only
 256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
 259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Though I am currently running with OSCAL set to the highest frequency
 261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   and the PLL seems to be syncing at about 128MHz)
 262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (New Note, a/o sdramThing2.0v5... it's kinda ironic that I was able to
 263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   run it at 128MHz with nothing more than an AVR and some gates...
 264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   seeing as how sdramThing has been fidgetty just running at 8MHz
 265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Anyways, an eventual goal is to run at 133MHz+, using basically
 266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   nothing more than the SDRAM itself for timing and refreshes...
 267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   would allow for full resolution and full color-depth)
 268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Wiring:
 273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   simplest of all:
 275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's spec'd to run from 4.5-5.5V, and its propagation delays and slew
 279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     yet it's working...
 281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, the output voltages are right in the LVDS range,
 282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 131


 283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (Don't forget the LCD has a 100ohm resistor between
 284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         RXinN/clk+ and RXinN/clk-)
 285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's probably best to use two XORs from the same chip for a single
 287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    LVDS channel, since different chips may have slightly different
 288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    characteristics. 
 289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The entire circuit, thus, requires TWO 74LS86's 
 291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (four XORs apiece, two per LVDS channel, 8-total)
 292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              VCC3V3   VCC3V3
 295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                           ______________
 296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---\ \-_                        |  LCD (1 channel
 297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |       of 4)
 298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk-  | ----.
 299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   AVR, etc.         | |    _-                      |     |
 300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3.3V TTL >---+---/ /___-                        |     \ 100
 301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   output       |                                   |     /
 302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     \ ohms
 303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     /
 304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                `---\ \-_                        |     |
 305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |     |
 306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk+  | ----'
 307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    _-                      |
 308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---/ /___-                        |
 309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                          |
 310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               GND      GND
 311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Also used: The TTL 74AHC series...
 314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
 316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (with a 100ohm load in the LCD)
 318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     channels, I had to implement Red and Green with the LS 
 321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     before switching all channels to the LS... Using different chips
 322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (specifically, different TYPES of chips) for different channels
 323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     signals are synchronized, but the red and green signals were shifted
 325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     a bit or two (resulting in "Black" appearing green)
 326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  For other circuits attempted, see oldNotes.txt
 328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (and boy there were many, involving voltage dividers, AC coupling,
 329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      reference voltages, BJT differential amplifiers... I doubt I 
 330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      documented them all, or even most. Whoda thunk the simplest, 
 331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      especially under- AND over-spec'd--timing, supply voltage, and
 332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      output voltage--would be the one...?)
 333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LVDS/FPD-Link timing:
 335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
 338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____               |____.____.____.____
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 132


 340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |            |         |
 342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^  ^ | 
 347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<--Not Blue-->|         |
 348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^ ^  |  
 352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<------->|-Not Green    |
 353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^^     
 357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<-->|-Not Red
 358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Of course: The "Not Green/Red" bits above are least-significant-bits
 360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              and basically have little/no visible effect
 361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Implementations/prospects:
 364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowBuffer.c (more like row-settings-buffer)
 365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     calculate a row's worth of pixels before drawing that row
 366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (uses packed color settings in a single byte per drawable pixel)
 367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     64 drawable pixels across, regardless of LVDS speed
 368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * For faster pixels: these settings values could be stored 
 369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (not implemented)
 371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowSegBuffer.c
 372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     also calculates an entire row before drawing it
 373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     instead of storing pixels, store "segments"
 374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     i.e. each segment is defined by a color value and a length
 375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Number of segments is limited only by memory...
 376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      e.g. 64 segments per row (max) is 64*3Bytes
 377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Three bytes for color, and *really simple* packing for seg-length
 378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       as high as one LCD pixel.
 380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (with packing)
 382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      only adds two clock cycles to each "pixel", so probably worth it
 384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   In Any Case: There's not enough RAM for a full frame
 386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          64 pixels across * 64 pixels down is 4096 bytes
 387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          So whatever method, we need to precalculate each row before
 388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          displaying it
 389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Could be as simple as loading direct from program memory
 390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Since low-bits are barely visible, their effect is neglected.
 393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE/V/H Timing (LCDdirectLVDS):
 396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 133


 397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |  0   1    2    3    4    5    6       All: set @ 0
 399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____                         OCR1C = 6 
 400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Clock:    /                   \    .    .    /         Complementary-
 401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                             Output Mode
 402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                          required for DT
 403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____ ____ ____ ____ ____ ____|____    
 405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state2                      |    
 407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_BLUE: >|    DT=X, OCR=0
 408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         Watch the transition!! -------^
 409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DC_DISABLED:
 411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   maxBlue: >\____|		DT=0, OCR=5
 412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             See below for more blue settings...
 413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____      ____ ____|____ 
 415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state1              | 
 417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\______________|    DT=3, OCR=3
 418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DC_DISABLED:
 419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Not much can be done...
 420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____           ____ ____ ____|____ 
 422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state3              |
 424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\____|		DT=4, OCR=5
 427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____                ____ ____|____ 
 429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state4          | 
 431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >__________________________________|    DT=X, OCR=0
 432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             TransitionWatch!!! -------^
 433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             Shouldn't matter... DT from no-edge
 434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >\________________________|		DT=0, OCR=1
 436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____ ____ ____ ____|____ 
 438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state0                  |     
 440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\____|		DT=3, OCR=5
 443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //So far this is the only case I've seen:
 445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Vsync
 446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_ACTIVE
 447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_ACTIVE		0
 448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_INACTIVE
 450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_INACTIVE	1
 451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Hsync
 453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_ACTIVE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 134


 454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_ACTIVE		0
 455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_INACTIVE
 457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_INACTIVE	1
 458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE (active high)
 460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_ACTIVE
 461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_ACTIVE			1
 462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_INACTIVE
 464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_INACTIVE		0
 465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HERE!
 468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Transitions: OLD!!!!! WRONG!!!!
 473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (are they? There're several additional transitions, now, for one.)
 474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The idea is to reduce the number of instructions between each
 475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS "state."
 476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  These are implemented below in the case:
 477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    "#else //NOT FULL_INIT_TESTS"
 478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Since each instruction takes *longer than* a single pixel
 479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    two instructions would *at best* occur on two consecutive pixels
 480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Thus, there's likely to be a transition-glitch
 481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (e.g. old OCR value with new DT value)
 482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Note that the new DT values are implemented at the next corresponding
 483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    edge after the DT-write instruction completes
 484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    New OCR values are delayed until the next TCNT reset to 0
 487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Initial:
 489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	H			OCR=2
 492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H		->	Nada		OCR=NADA_OCR
 493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	V			DT=3
 495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	V+H		OCR=0
 496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V+H	->	V			OCR=NADA_OCR
 497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	Nada		DT=2
 498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	DE			DT=1
 500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DE	->	Nada		DT=2
 501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(REMOVE_DC) && REMOVE_DC)
 504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Unused, normally...
 507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
 509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 135


 511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else //!REMOVE_DC
 514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Nada init
 515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Unused, normally...
 518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
 523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //REMOVE_DC
 527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FULL_INIT_TESTS TRUE
 530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Display is DE-Only (doesn't use H/Vsync)
 532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Shouldn't be necessary to select this if it is,
 533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since DE timing is the same either way
 534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // but I want to test whether a single-bit is being detected
 535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  single bit, which might explain why the other display didn't work)
 537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //These are just examples... the project should define them:
 538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
 540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()      Nada_init()
 541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()    Nada_init()
 542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()    Nada_init()
 543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()      Nada_init()
 544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()      Nada_init()
 545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()      Nada_init()
 546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()     DE_init()
 547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DE_init()
 548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if(DE_BLUE)
 550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "...The display should be blank"
 552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
 553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Use full initialization of each LVDS state
 554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (might not be good during transitions, but should guarantee
 555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  steady-state, in case my transitions aren't correct...)
 556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()		Vsync_init()
 558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()		VplusH_init()
 559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()		Vsync_init()
 560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()		Nada_init()
 561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()		Hsync_init()
 562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()		Nada_init()
 563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()		DEonly_init()
 564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DEblue_init()
 565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()		Nada_init()
 566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 136


 568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else	//NOT FULL_INIT_TESTS
 570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 																	 //for easy-scoping
 573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync() { OCR1A=0; }
 575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromVplusH() { OCR1A=4; }
 576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
 577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()   { OCR1A=3; }
 580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()   { OCR1A=4; }
 581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //End Of FULL_INIT_TESTS
 589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The typical patterns look like this (not at all to scale):
 594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ----______------------------------------------------______-- V
 595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
 597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      __________-__-__-__-__-__-__-__-__-__-__________________  DE
 599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 
 600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ^^^^\														//blah
 601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             1234 5?
 602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Pixels are sent during DE High (basically all the CPU will be used here)
 603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Ideally, 
 604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  there won't be any glitches when changing from one state to another
 605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Init (pre 1):
 607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DeadTimerRising=1
 608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The states are:
 610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Not necessarily accurate, just looking into necessary changes)
 611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (from Vsync L->H)
 612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1  NothingActive (long, No DE, VporchFrontTimes)
 614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2  Hsync
 616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3  NothingActive (short)
 618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4  DE
 620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5  NothingActive(?)
 622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7  Repeat 2-5 for each row
 624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 137


 625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8  NothingActive (long, No DE, VporchBackTimes)
 626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9  V w/o H
 628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   10 V w/  H
 630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   11 Repeat 9-10 for Vsync time...
 632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Here's how it worked pre-lvds:
 635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HSYNC, VSYNC, and DE refer to the actual pins
 636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In the LVDS setup, there're modes corresponding to each pin-combination
 637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Timer Interrupt:
 639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  loadData:
 640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC active
 641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC Low delay
 642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC inactive
 643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if(dataEnable)
 644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE active
 645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Send row data
 646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE inactive
 647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  //Prep for next interrupt
 648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  switch(hsyncCount++)
 649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync H->L (active)
 650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    1:
 651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC active
 653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync L->H (inactive)
 654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_Vlow:
 655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC inactive
 656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Start of frame
 657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_VD +(T_Vlow):
 658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=TRUE
 659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //All rows have been displayed
 660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    V_COUNT +(T_VD+T_Vlow):
 661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Frame Complete
 663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
 664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          hsyncCount=0
 665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(dataEnable)
 666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Use the remaining time to load the next row to memory
 667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  So:
 669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC active
 679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE (not necessary?)
 680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 138


 682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC inactive
 691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
 694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=TRUE
 703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 708:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 709:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 710:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 711:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 712:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 713:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE
 714:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 715:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 716:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's basically just:
 717:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
 718:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 719:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 720:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 721:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 722:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 723:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 724:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 725:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 726:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 727:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||  .   |        |                      .
 728:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|  .   ^--------^                      .
 729:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |  .                                   .
 730:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 hsyncCount=0 (repeat from Interrupt0)  .
 731:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 732:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 733:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 734:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 735:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 736:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE
 737:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ESPECIALLY THIS FIRST STATE.
 738:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V Front Porch originally (and in these drawings) occurred at the end
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 139


 739:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // of the frame...
 740:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // More logically, it now starts at the beginning of the frame
 741:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (Also removing this initial "glitch" of a single interrupt with
 742:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NothingActive)
 743:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 744:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE (a/o 0.30, for certain)
 745:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOW to compare with LVDS states:
 746:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 747:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 748:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 749:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 750:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 751:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 752:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 753:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 754:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 755:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- V w/o H  \ These two toggle until
 756:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- V w/ H   / next LCD state...
 757:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 758:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- V w/o H > Intermediate change of state
 759:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 760:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From Previous State (?)
 761:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         /
 762:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 763:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 764:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
 765:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 766:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 767:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 768:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 769:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 770:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 771:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 772:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- NothingActive  \ These two toggle until
 773:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- H_Only         / next LCD state...
 774:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 775:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- NothingActive > Intermediate change of state
 776:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 777:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- V w/o H   \ From previous state
 778:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- V w/ H    /
 779:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 780:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 781:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
 782:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 783:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 784:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 785:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 786:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 787:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^              ^ ^^        ^ 
 788:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        |
 789:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        +--- NothingActive  \  These four
 790:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | |+------------ DE              | cycle until
 791:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | +------------- NothingActive   | next LCD state...
 792:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              +--------------- H_Only  ^      /
 793:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |                                       |
 794:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From previous   |
 795:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         / state           +-This intermediate state
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 140


 796:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                may not be necessary
 797:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                (IAXG01 shows 160 dots!)
 798:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 799:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 800:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 801:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 802:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 803:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 804:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 805:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 806:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 807:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^^        ^    ^ ^
 808:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | |
 809:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | +--- NothingActive \  These two toggle
 810:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    +----- H_Only        /  until next LCD state
 811:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |
 812:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        +---- NothingActive \ 								//blah
 813:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |+------------- DE             |  From previous state
 814:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +-------------- NothingActive  |
 815:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +---------------- H_Only        /
 816:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 817:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's essentially just:
 818:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
 819:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 820:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 821:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 822:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 823:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 824:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 825:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 826:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 827:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 828:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^             .                                   .
 829:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |             .....................................
 830:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +--- NothingActive \											//blah
 831:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +----- H_Only        / From previous state...
 832:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 833:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 834:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 835:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS State transitions:
 836:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1 H_Only
 837:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2 NothingActive
 838:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 839:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3 V w/o H
 840:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4 V w/ H
 841:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    
 842:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 3,4)
 843:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 844:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5 V w/o H
 845:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 846:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   6 NothingActive
 847:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7 H_Only
 848:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 849:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 6,7)
 850:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 851:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8 NothingActive
 852:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 141


 853:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9 H_Only
 854:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  10 NothingActive
 855:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  11 DE
 856:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  12 NothingActive
 857:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 858:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 9-12)
 859:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 860:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  13 H_Only
 861:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  14 NothingActive
 862:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 863:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 13-14)
 864:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 865:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   These should be reviewed to determine which changes are necessary
 866:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between each state...
 867:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (the fewer changes, the less likely we'll glitch...?)
 868:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 869:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 870:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void lcd_Init(void)
 871:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1511               		.stabn	68,0,871,.LM162-.LFBB15
 1512               	.LM162:
 1513               	.LFBB15:
 1514               	/* prologue: function */
 1515               	/* frame size = 0 */
 872:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  	Nada_init();
 1516               		.stabn	68,0,872,.LM163-.LFBB15
 1517               	.LM163:
 1518 0600 80E3      		ldi r24,lo8(48)
 1519 0602 84BD      		out 68-0x20,r24
 1520 0604 84E0      		ldi r24,lo8(4)
 1521 0606 8DBD      		out 77-0x20,r24
 1522               	/* epilogue start */
 873:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 1523               		.stabn	68,0,873,.LM164-.LFBB15
 1524               	.LM164:
 1525 0608 0895      		ret
 1526               		.size	lcd_Init, .-lcd_Init
 1527               	.Lscope15:
 1528               		.stabs	"",36,0,0,.Lscope15-.LFBB15
 1529               		.stabd	78,0,0
 1530               		.stabs	"updateLCD:F(3,2)",36,0,1165,updateLCD
 1531               	.global	updateLCD
 1532               		.type	updateLCD, @function
 1533               	updateLCD:
 1534               		.stabd	46,0,0
 874:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 875:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 876:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TESTVALS	0
 877:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define LTN 1
 878:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define IDT 2
 879:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 880:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 881:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //TIMING:
 882:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Measurements below (in microseconds) are referring to preLVDS
 883:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  There may be other such old-notes...
 884:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 885:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 142


 886:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<--T_Hhigh-->| |<-T_Hlow
 887:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    __   _____________   ____________  3.6V
 888:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H    |_|             |_|           _  0V
 889:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 890:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Data Enable
 891:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Only active when there's valid pixel data
 892:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       (For a dual-pixel 1024x768 display:
 893:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         for 512 of the 717 clocks in HSYNC-active)
 894:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Low during Vsync... (~720us)
 895:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 896:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 897:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech display: 136 dots
 898:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //2-136+
 899:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech, last used: 40
 900:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Last used 8
 901:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN: 1072<=1344<=1500 clocks per line, 1024DE... Hsync unused
 902:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // SEE Hlow_Delay() notes if this value is large!
 903:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 904:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef H_LOW_DOTS
 905:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 906:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	8
 907:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 908:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS   40//8//1//40 //30 //2//136
 909:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 910:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
 911:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 							  // And having a value here increases codesize
 912:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 913:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 914:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 915:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //H is set low immediately upon entry of the timer interrupt
 916:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // its low-time is controlled via nops
 917:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (so if HLow is long for a particular display, this might need revising)
 918:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 919:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if((!defined(HLOW_DELAY_OVERRIDE) || !HLOW_DELAY_OVERRIDE) \
 920:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		                                         && !defined(Hlow_Delay))
 921:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hlow_Delay() \
 922:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	delay_Dots(H_LOW_DOTS)
 923:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 924:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 925:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 926:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 927:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 928:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This was found expermentally with SwitchResX
 929:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 680
 930:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (IDTech had some oddities regarding slow pixel-clocks, where pixels
 931:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  would be repeated, regardless of the pixel-clock, thus, for slow clocks
 932:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it has the effect of *stretching* the image, thus 680 "pixels" across
 933:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  instead of its 1024 *physical* pixels)
 934:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 1024
 935:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
 936:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        it does, however, affect the vertical(!)
 937:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // If I recall Correctly, this is used only for setting the timer interrupt
 938:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  rate...
 939:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 940:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
 941:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 942:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 143


 943:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 944:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
 945:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 946:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 947:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 948:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
 949:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  90-320+
 950:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Total Time: 1206<=1344<=2047
 951:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
 952:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Excess waits should be thrown in DH (since that's between interrupts)
 953:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //T_HD is the time from H inactivated to DE activated
 954:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka H back-porch: 1-160+
 955:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 50
 956:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 5
 957:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 958:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_DOTS
 959:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 960:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 5
 961:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 962:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
 963:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 964:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 50//5
 965:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 966:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 967:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 968:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_Delay
 969:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_Delay()	delay_Dots(HD_DOTS)
 970:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 971:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 972:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think this was just a mistake. This change to delay_Dots a/o 0.10ncf
 973:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (untested in LCDdirectLVDS)
 974:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //delay_cyc(HD_DOTS)
 975:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 976:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 977:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is the number of CPU cycles between DE->L and Horiz->L
 978:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is just used in calculating the OCR value...
 979:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // aka H Front Porch: 0-24+
 980:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 24
 981:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 46
 982:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 1072-1024-1-1 = 46
 983:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DH_DOTS
 984:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 985:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	46
 986:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 987:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
 988:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 989:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	0//1000//100//46
 990:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 991:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 992:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 993:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |
 994:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       v
 995:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      T_DH
 996:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
 997:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H   __.  ____________  .___________
 998:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      .|_|  .        .|_|  .
 999:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _.     .________.     .___________
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 144


1000:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |_____| 512clk |_____|
1001:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ^              ^
1002:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       \___________   \                        (just avoiding \ warning)
1003:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                   \  |     768 Hsyncs
1004:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    v v
1005:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _             _ _ _ _ _ _ _ _ _ _ 
1006:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |___________| | | | | | | | | | |______
1007:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1008:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1009:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1010:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1011:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 29
1012:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1013:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Frame: 772<=806<=1000 lines...
1014:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1015:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_VD
1016:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1017:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1018:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1019:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define  T_VD 29 //3//29 //7 //29
1020:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1021:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1022:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1023:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1024:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1025:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync front porch: 1-3+
1026:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 3
1027:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1028:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_DV
1029:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1030:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1031:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1032:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3//3 //1 //3
1033:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1034:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1035:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1036:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1037:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1038:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //1-6+ (1 is used by the first switch-case...)
1039:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 6
1040:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN Last used 16
1041:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 772 - 768 - 1 - 1 = 2
1042:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_Vlow
1043:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1044:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 16
1045:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1046:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow	6 //16//6 //2 //6
1047:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1048:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 32
1049:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1050:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1051:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1052:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 768
1053:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef V_COUNT
1054:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1055:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1056:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 145


1057:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1058:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1059:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #if (LVDS_PRESCALER == 8)
1060:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define V_COUNT 768
1061:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #else
1062:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  #define V_COUNT	(768*2/3)
1063:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #endif
1064:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1065:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1066:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1067:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                       
1068:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      |           
1069:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      V           
1070:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              |<-T_DV>|           |<-T_VD-->|
1071:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .       .           .         .
1072:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _____________||__.   124us   .____||___________________
1073:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V           .   ||  |___________|    ||   .
1074:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
1075:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
1076:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .   ||                   ||   .
1077:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
1078:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   | | | | |___||___________________||___| | | | | | | | |
1079:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                  ||                   ||
1080:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1081:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        1
1082:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        |
1083:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        v               
1084:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _________________   ___________________   _____________
1085:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V                   |_|                   |_|
1086:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
1087:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
1088:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          ^
1089:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          |
1090:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          2
1091:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1092:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1093:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1094:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_COUNT_FRAME_COMPLETE  \
1095:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY)
1096:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_DV = 3
1097:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V_COUNT = 768 
1098:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_VD = 3
1099:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_Vlow = 32
1100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // FRAME_UPDATE_DELAY = 0
1101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 806
1102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(FRAME_UPDATE_DELAY != 0)
1104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "FRAME_UPDATE_DELAY is no longer implemented..."
1105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#if(HSYNC_COUNT_FRAME_COMPLETE & 0x01)
1109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #warning "Total vertical lines might need to be even!"
1110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //This should be fixed...
1111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#endif
1112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 146


1114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_HSYNC \
1115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS = 100
1117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HD_DOTS = 50 
1118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE_ACTIVE_DOTS = 1024
1119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DH_DOTS = 0
1120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 1174
1121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define MAKELONG (0L)
1124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_FRAME \
1126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  ((MAKELONG(HSYNC_COUNT_FRAME_COMPLETE)) * (MAKELONG(DOT_COUNT_PER_HSYNC)))
1127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 946,244
1128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Hlow_Delay 		H_LOW_DOTS
1130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //HD_Delay			HD_DOTS	
1131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DE_ACTIVE_DOTS
1132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DH_DOTS
1133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
1138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t dataEnable = 0;
1142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t vSync = 0;
1143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint16_t hsyncCount = 0;
1144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //frameCount=0 can be used in main to detect whether we've completed a 
1146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  a frame AND its FRAME_UPDATE_DELAY
1147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(FRAME_COUNT_TO_DELAY) && (FRAME_COUNT_TO_DELAY != 0))
1148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t frameCount = 0;
1149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*
1152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum) \
1154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	__attribute__((__always_inline__));
1155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
1156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Returns TRUE when the frame is complete
1158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Should send nada (and maybe hsyncs?) thereafter(?)
1159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In sdramThing2.0, when this returns TRUE, the SDRAM loading is complete
1160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // EXCEPT: the final HD_Dots' FR_READ/ACTIVATE commands will point to a
1161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  non-existent "next" Hsync... these commands need to be rewritten to
1162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  point to the "first" Hsync. This is handled in sdramThing2.0's code
1163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Used to be:
1164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //SIGNAL(TIMER0_COMPA_vect)
1165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t updateLCD(void)
1166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1535               		.stabn	68,0,1166,.LM165-.LFBB16
 1536               	.LM165:
 1537               	.LFBB16:
 1538               	/* prologue: function */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 147


 1539               	/* frame size = 0 */
1167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	uint8_t frameComplete = FALSE;
1168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//static uint8_t frameCount = 0;
1170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	while(TCNT0L != 7){};
1173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This won't work... who knows how many cycles interrupt-entry will be
1174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Above should fix that...
1175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//I think this was just an indicator for scope triggering...
1176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// not relevent for 
1177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	setpinPORT(PB2, PORTB);
1178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	clrpinPORT(PB2, PORTB);
1179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Hsync and Actually draw the pixels... (when DE is active)
1182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This takes a LONG time and will occupy most of the CPU...
1183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... IN THIS INTERRUPT
1184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
1185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
 1540               		.stabn	68,0,1185,.LM166-.LFBB16
 1541               	.LM166:
 1542 060a 2091 0000 		lds r18,dataEnable
 1543               	.LBB124:
 1544               	.LBB125:
1186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
1188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
1190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//V Front Porch, begins with initLCD
1192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync H->L (Begin V-Sync)
1194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_DV:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
1196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
1199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync L->H (Begin V Back Porch)
1201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_Vlow + T_DV:
1202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	if(hfm_nextOutput(&modulator))
1203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 0xff;
1204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	else
1205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 7;
1206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
1209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Start of frame (DE active)
1211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_VD +(T_Vlow + T_DV):
1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// All rows have been displayed
1215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Return to V Front Porch
1216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case V_COUNT +(T_VD + T_Vlow + T_DV):
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 148


1218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	break;
1219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Frame complete
1220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//case HSYNC_COUNT_FRAME_COMPLETE:
1221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
1223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(FRAME_COUNT_TO_DELAY != 0)
1224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//static uint8_t frameCount = 0;
1225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameCount++;
1226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
1227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				frameCount = 0;
1229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
1230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
1231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			
1234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
1235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Yeah, guess that makes sense... Must be Nada...
1236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameComplete = TRUE;
1237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		default:
1239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(LOADROW) && LOADROW)
1244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Load the next row into the row(seg)buffer
1245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//data is enabled after T_VD+T_Vlow...
1246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
1247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
1248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This note was written long before the above was commented-out...
1251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//So...?
1252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// Here is where loadRow used to be called
1253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// it has been moved to oldNotes.txt, but it would make more sense
1254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to look at LCDdirectLVDS <25 or LCDdirect
1255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// loadRow used the time between DE inactive and the next Hsync
1256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
1257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus, DE could gain more pixels because there would be fewer
1258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// calculations to determine the memory location to write from
1259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This effect has since been minimized
1260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// BUT loadRow might be necessary for program-memory-based images...
1261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	return frameComplete;
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //See LCDdirectLVDS for an example...
1267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // basically it loads a single row into a buffer for the next dateEnable
1268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (either the row-buffer or the row-segment-buffer) 
1269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This has been *greatly* reduced, is not at all functional, just
1270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // to give an idea of loadRow's purpose.
1271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(LOADROW) && LOADROW)
1272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum)
1273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//e.g....
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 149


1275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	tet_drawRow(rbRowNum, rowBuffer);
1276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...	
1278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	rowBuffer[i] = fb_to_rb(colorVal);
1279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...
1281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
1282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
1283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			for(i=0; i<FB_WIDTH; i++)
1285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
1287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				if(!(temp & 0xC0))
1288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
1289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
1293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//HORIZONTAL_COLOR_BARS
1295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	for(i=0; i<RB_WIDTH; i++)
1296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowBuffer[i] = fb_to_rb(rowNum);
1297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Good for syncing to have white on both borders...
1299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	newSeg(1, 0x06, (6<<4) | 3);
1300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //LOAD_ROW
1303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Including inactive pixel-clocks (timing)
1306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DotCount per row...
1307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TOTAL_CYC_COUNT was used for the timer-interrupt in LCDdirectLVDS
1308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This was DOTS_TO_CYC(DISPLAY_DOT_COUNT) + ROW_CALCULATION_CYCS
1309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  ROW_CALCULATION_CYCS was 50,000 (!!!)
1310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DOTS_TO_CYC(dots), last-used, was dots*7 (LVDS_PRESCALER nullified /8)
1311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So, the overall dot-count per row was... 
1312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DISPLAY_DOT_COUNT + ROW_CALCULATION_DOTS
1313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     where ROW_CALCULATION_DOTS = 50,000cyc/7 = 7142 dots
1314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     So... the overall dot-count per row was *MUCH* longer than usual
1315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Pretty certain there's not nearly enough memory to simulate that
1316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (in sdramThing2.0)
1317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But It does suggest that it would be worthwhile to try to stretch
1318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   the rows as much as possible...
1319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   During this time, NADA is sent normally, (V=H, H=H, DE=L)
1320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Or Vsync (V=L, H=H, DE=L)
1321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Maybe something could be simulated with PWM again, if necessary...
1322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Certainly not at full-speed)
1323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_DOT_COUNT \
1324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
1330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 150


1332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void init_timer0Hsync(void)
1343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//T_HD + T_DH + T_low + T_DE
1345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// For the original system, 19.865us = 695 dot-clocks
1346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// We'd need to take advantage of the 16-bit timer
1347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  OCR1A may not be written properly (with a temporary high-byte)
1348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... not sure.
1349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
1350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is a hack, for testing syncability with long row-calculations
1352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // before actually drawing it... e.g. loading from program memory
1353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This value needs to be larger than the calculation time
1354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // otherwise, it seems, syncing isn't stable
1355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
1356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
1357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_CYC_COUNT	(DOTS_TO_CYC(DISPLAY_DOT_COUNT))
1359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
1360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
1362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // apparently an effect of the display, definitely not a code-thing
1363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in which case the vertical resolution decreases
1364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // though, this could be used to advantage... 
1365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. more processing time outside the drawing interrupts?)
1366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOTE that if the value is too small and calculations take longer in some
1367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // lines than others (?), those lines may repeat, or syncing could be off
1368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (LVDS_PRESCALER == 8)
1369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 1//20
1370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
1371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
1373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
1374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TOTAL_CYC_COUNT \
1377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
1378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
1379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define TOTAL_CYC_COUNT 2000
1380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TOTAL_CYC_COUNT > 255)
1381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Adding +7 causes it to round up (hopefully)
1382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
1383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV	CLKDIV8
1384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
1385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS > 255)
1386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
1387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
1388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_CLKDIV CLKDIV64
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 151


1389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #if (TIMER0_TCNTS > 255)
1390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
1391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
1392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_CLKDIV CLKDIV256
1393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #if (TIMER0_TCNTS > 255)
1394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
1395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
1396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_CLKDIV	CLKDIV1024
1397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #endif
1398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #endif
1399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS == 0)
1401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "TIMER0_OCRVAL == 0"
1402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
1405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV CLKDIV1
1406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //For testing, I want to see the pulses with the 'scope
1410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Unless the timer is divisible by 7 the pulses will not align with the
1411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // timer overflow...
1412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
1413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
1414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // and we'll only start visualizing *after* the extra TCNTs...
1415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Since the timer counts from 0 to (and including) OCR1A
1416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Add one to this test...
1417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
1418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
1419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
1420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
1421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
1423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
1424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
1425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
1426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
1428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
1429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
1430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
1431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
1433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
1434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
1435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
1436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
1438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
1439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
1440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
1441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
1443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
1444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
1445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 152


1446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS) % 7) == 0)
1448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS) % 7 == 0"
1449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
1450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
1451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else
1453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "WTF?"
1454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
1457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TIMER0_OCRVAL > 255)
1460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
1461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
1464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
1465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
1466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
1467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define fullBlue()	DEblue_init()
1470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Either use one of the ones here, or define your own...
1474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is the drawable row number on the LCD...
1475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //static __inline__ void drawPix(uint16_t rowNum);
1476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum) \
1480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
1483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //drawPix loads each pixel individually... It doesn't use a for-loop
1484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since that would take away from actual pixel-drawing time...
1485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think it's been removed... but here's a (non-functional) example...
1486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+1));	 
1489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+2));	 
1490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+3)); 
1491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+61));
1493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+62));
1494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+63));
1495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// WriteColor writes the pixel *after* the calculations...
1496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus the pixel appears basically after writeColor completes
1497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// These nops assure the 64th pixel is fully-displayed before exitting
1498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
1499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
1501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*		reg[17] = colorBuffer[rowNum][17];                         
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 153


1503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[17]);                         
1504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[20] = colorBuffer[rowNum][20];                         
1506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[20]);  
1507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		
1508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
1509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[0] = colorBuffer[rowNum][0];
1510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[0]);
1511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[10] = colorBuffer[rowNum][10];
1513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[10]);
1514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
1515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Display the rest as black...
1516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(0);
1517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else		//ROW_SEG_BUFFER
1519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (0<<COM1B1) | (1<<COM1B0)
1523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (1<<PWM1A) | (1<<PWM1B) );
1524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		drawSegs();
1526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DE->Nada transition expects fullBlue...
1529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Also helps to show the edge of the DE timing...
1530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          
1535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Among the things that don't make sense...
1536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// This appears to go into affect BEFORE delay_cyc (?)
1537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// as, without a pull-up resistor on the /OC1B output, 
1538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// green seems to be floating between the last pixel and the
1539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// delay_cyc (!)
1540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Disable complementary-output for Green 
1541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
1543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<COM1B1) | (0<<COM1B0)
1545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<PWM1A) | (1<<PWM1B) );
1546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		fullBlue();
1548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //0
1550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          G) groovy little spiral...
1554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
1559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 154


1560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				   | (0<<COM1B1) | (1<<COM1B0)
1561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					| (1<<PWM1A) | (1<<PWM1B) );
1562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8 early... appears to be syncing on Blue signal
1565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // thus we get diagonal data including Hsync (colored in red) along the
1566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // as a diagonal stripe at the right
1567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
1568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t blueCyc = DOTS_TO_CYC(rowNum);
1571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
1572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t blueDots = rowNum;
1573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t notBlueDots = DE_ACTIVE_DOTS - blueDots;
1574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(notBlueCyc);
1577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(notBlueDots);
1578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(notBlueDots);
1579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(blueCyc);
1581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(blueDots);
1582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(blueDots);
1583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-31ish: LooksPromising, but delayed
1588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // also LVDS bit-shifts causing vertical striping
1589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
1590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-32 nogo... syncs at end of blue instead of Hsync
1605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR_REVERSED) && BLUE_VERT_BAR_REVERSED)
1606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 155


1617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(DE_BLUE) && DE_BLUE)
1622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
1626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS);
1627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS);
1628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_BORDER) && (BLUE_BORDER!=0))
1633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - BLUE_BORDER*2);
1639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
1647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
1648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		if(rowNum <= 256)
1649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=0;
1650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		else
1651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=1;
1652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
1653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//#warning "see 'shouldBe' here..."
1654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Should be:
1655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
1656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//rowNum = rowNum / (768/FB_HEIGHT);
1657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DEonly_fromNada();
1660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       drawPix(rowNum);
1661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Nada_init();
1662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "THIS ISN'T SAFE"
1663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
1664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Drawing Methods...
1665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       //Disable complementary-output for Green 
1672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 156


1674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<COM1B1) | (0<<COM1B0)
1676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<PWM1A) | (1<<PWM1B) );
1677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//colorOverride removed in LVDS, revisit LCDdirect50
1680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AND HERE!!!
1685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is only used when DE is active...
1687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and should be 0 at *drawn row* 0
1688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable)
1689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//H Active pulse...
1691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(vSync)
 1545               		.stabn	68,0,1691,.LM167-.LFBB16
 1546               	.LM167:
 1547 060e 8091 0000 		lds r24,vSync
 1548 0612 8823      		tst r24
 1549 0614 01F0      		breq .L104
1692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync_fromNada() is called at the end of the last interupt
1694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       VplusH_fromVsync();
 1550               		.stabn	68,0,1694,.LM168-.LFBB16
 1551               	.LM168:
 1552 0616 1DBC      		out 77-0x20,__zero_reg__
 1553               	.LBB126:
 1554               	.LBB127:
 1555               	.LBB128:
 1556               	.LBB129:
 1557               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext10
 1558               	.Ltext10:
 1559               		.stabn	68,0,105,.LM169-.LFBB16
 1560               	.LM169:
 1561 0618 8FEA      		ldi r24,lo8(175)
 1562 061a 90E0      		ldi r25,hi8(175)
 1563               	/* #APP */
 1564               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1565 061c 0197      		1: sbiw r24,1
 1566 061e 01F4      		brne 1b
 1567               	 ;  0 "" 2
 1568               	/* #NOAPP */
 1569               	.LBE129:
 1570               	.LBE128:
 1571               	.LBE127:
 1572               	.LBE126:
 1573               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext11
 1574               	.Ltext11:
1695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Vsync_fromVplusH();
 1575               		.stabn	68,0,1696,.LM170-.LFBB16
 1576               	.LM170:
 1577 0620 85E0      		ldi r24,lo8(5)
 1578 0622 00C0      		rjmp .L115
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 157


 1579               	.L104:
1697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    else
1700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hsync_fromNada();
 1580               		.stabn	68,0,1701,.LM171-.LFBB16
 1581               	.LM171:
 1582 0624 83E0      		ldi r24,lo8(3)
 1583 0626 8DBD      		out 77-0x20,r24
 1584               	.LBB130:
 1585               	.LBB131:
 1586               	.LBB132:
 1587               	.LBB133:
 1588               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext12
 1589               	.Ltext12:
 1590               		.stabn	68,0,105,.LM172-.LFBB16
 1591               	.LM172:
 1592 0628 8FEA      		ldi r24,lo8(175)
 1593 062a 90E0      		ldi r25,hi8(175)
 1594               	/* #APP */
 1595               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1596 062c 0197      		1: sbiw r24,1
 1597 062e 01F4      		brne 1b
 1598               	 ;  0 "" 2
 1599               	/* #NOAPP */
 1600               	.LBE133:
 1601               	.LBE132:
 1602               	.LBE131:
 1603               	.LBE130:
 1604               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext13
 1605               	.Ltext13:
1702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Nada_fromHsync();
 1606               		.stabn	68,0,1703,.LM173-.LFBB16
 1607               	.LM173:
 1608 0630 84E0      		ldi r24,lo8(4)
 1609               	.L115:
 1610 0632 8DBD      		out 77-0x20,r24
 1611               	.LBB134:
 1612               	.LBB135:
 1613               	.LBB136:
 1614               	.LBB137:
 1615               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext14
 1616               	.Ltext14:
 1617               		.stabn	68,0,105,.LM174-.LFBB16
 1618               	.LM174:
 1619 0634 88E5      		ldi r24,lo8(88)
 1620 0636 90E0      		ldi r25,hi8(88)
 1621               	/* #APP */
 1622               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1623 0638 0197      		1: sbiw r24,1
 1624 063a 01F4      		brne 1b
 1625               	 ;  0 "" 2
 1626               	/* #NOAPP */
 1627               	.LBE137:
 1628               	.LBE136:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 158


 1629               	.LBE135:
 1630               	.LBE134:
 1631               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext15
 1632               	.Ltext15:
1704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(dataEnable)
 1633               		.stabn	68,0,1707,.LM175-.LFBB16
 1634               	.LM175:
 1635 063c 2223      		tst r18
 1636 063e 01F4      		brne .+2
 1637 0640 00C0      		rjmp .L106
 1638               	.LBB138:
 1639               	.LBB139:
 1640               		.stabs	"main.c",132,0,0,.Ltext16
 1641               	.Ltext16:
3841:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 1642               		.stabn	68,0,3841,.LM176-.LFBB16
 1643               	.LM176:
 1644 0642 83E5      		ldi r24,lo8(83)
 1645 0644 80BF      		out 80-0x20,r24
 1646               	.LBB140:
 1647               	.LBB141:
 1648               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext17
 1649               	.Ltext17:
 402:rowSegBuffer.c **** 
 403:rowSegBuffer.c **** 
 404:rowSegBuffer.c **** static __inline__ \
 405:rowSegBuffer.c **** void drawSegs(void) \
 406:rowSegBuffer.c **** 	__attribute__((__always_inline__));
 407:rowSegBuffer.c **** 
 408:rowSegBuffer.c **** 
 409:rowSegBuffer.c **** void drawSegs(void)
 410:rowSegBuffer.c **** {
 411:rowSegBuffer.c **** #warning "This might need to be modified such that DE is active *with* the first pixel... and compl
 412:rowSegBuffer.c **** 	//Declared volatile *just in case* I decide to use it after the asm...
 413:rowSegBuffer.c **** 	// (as modified by the asm)
 414:rowSegBuffer.c **** 	volatile uint8_t *byteptr = &(rowSegBuffer[0].red_length);
 415:rowSegBuffer.c **** 
 416:rowSegBuffer.c **** 	//These should only be used in the asm...
 417:rowSegBuffer.c **** 	// declaring them here, instead of using specific registers in asm
 418:rowSegBuffer.c **** 	// should help assure that those registers aren't clobbered
 419:rowSegBuffer.c **** 	// if used elsewhere
 420:rowSegBuffer.c **** 	//volatile uint8_t r=0, rl=0, g=0, b=0;
 421:rowSegBuffer.c **** 
 422:rowSegBuffer.c **** 	//uint8_t r, rl, g, b;
 423:rowSegBuffer.c **** 
 424:rowSegBuffer.c **** 	//Basic idea:
 425:rowSegBuffer.c **** 
 426:rowSegBuffer.c **** 	//do{
 427:rowSegBuffer.c **** 	//  red_length = rowSegBuffer[n].red_length;
 428:rowSegBuffer.c **** 	//  green      = rowSegBuffer[n].green;
 429:rowSegBuffer.c **** 	//  blue       = rowSegBuffer[n].blue;
 430:rowSegBuffer.c **** 	//  
 431:rowSegBuffer.c **** 	//  OCR1D = red_length&0x0f;
 432:rowSegBuffer.c **** 	//  DT1   = green;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 159


 433:rowSegBuffer.c **** 	//  OCR1A = blue;
 434:rowSegBuffer.c **** 	//
 435:rowSegBuffer.c **** 	//  red_length &= 0xf0;
 436:rowSegBuffer.c **** 	//  if(!red_length)
 437:rowSegBuffer.c **** 	//     break;
 438:rowSegBuffer.c **** 	//
 439:rowSegBuffer.c **** 	//  while(red_length)
 440:rowSegBuffer.c **** 	//		red_length -= 0x10;
 441:rowSegBuffer.c **** 	// } while(1);
 442:rowSegBuffer.c **** 
 443:rowSegBuffer.c **** 	//This looks like it should work...
 444:rowSegBuffer.c **** 	// but there are some oddities
 445:rowSegBuffer.c **** 	// in this case, registers are loaded such that andi can't be used
 446:rowSegBuffer.c **** 	// but and can... thus it's a few instructions larger...
 447:rowSegBuffer.c **** 	/*
 448:rowSegBuffer.c **** 	do
 449:rowSegBuffer.c **** 	{
 450:rowSegBuffer.c **** 		rl = *(byteptr++);
 451:rowSegBuffer.c **** 		r = rl;
 452:rowSegBuffer.c **** 		r &= 0x0f;
 453:rowSegBuffer.c **** 		g = *(byteptr++);
 454:rowSegBuffer.c **** 		b = *(byteptr++);
 455:rowSegBuffer.c **** 
 456:rowSegBuffer.c **** 		//just testing pushes and pops...
 457:rowSegBuffer.c **** 		// apparently the optimizer realizes which registers are in use
 458:rowSegBuffer.c **** 		// in the (only) call to drawSegs() and doesn't bother to push the
 459:rowSegBuffer.c **** 		// the rest...
 460:rowSegBuffer.c **** //		drawSegs();
 461:rowSegBuffer.c **** 		OCR1D = r;
 462:rowSegBuffer.c **** 		DT1 = g;
 463:rowSegBuffer.c **** 		OCR1A = b;
 464:rowSegBuffer.c **** 
 465:rowSegBuffer.c **** 		rl &= 0xf0;
 466:rowSegBuffer.c **** 
 467:rowSegBuffer.c **** 		if(!rl)
 468:rowSegBuffer.c **** 			break;
 469:rowSegBuffer.c **** 
 470:rowSegBuffer.c **** 		while(rl)
 471:rowSegBuffer.c **** 			rl -= 0x10;
 472:rowSegBuffer.c **** 	} while(1);
 473:rowSegBuffer.c **** */
 474:rowSegBuffer.c **** 
 475:rowSegBuffer.c **** 	//LoadNext:
 476:rowSegBuffer.c **** 	//  ld   Rredlength, Z+	(Red|length)								2
 477:rowSegBuffer.c **** 	//  ld   Rgreen, Z+	(Green)											2
 478:rowSegBuffer.c **** 	//  ld   Rblue, Z+	(Blue)											2
 479:rowSegBuffer.c **** 	//	 mov  Rred, Rredlength												1
 480:rowSegBuffer.c **** 	//  andi Rred, 0x0f				//Remove length from Rred		1
 481:rowSegBuffer.c **** 	//  out  OCR1D, Rred														1
 482:rowSegBuffer.c **** 	//  out  DT1, Rgreen														1
 483:rowSegBuffer.c **** 	//  out  OCR1A, Rblue													1
 484:rowSegBuffer.c **** 
 485:rowSegBuffer.c **** 	//  andi Rredlength, 0xf0		//Remove red from length		1
 486:rowSegBuffer.c **** 	//  breq Done						// if length==0, we're done	1 2
 487:rowSegBuffer.c **** 
 488:rowSegBuffer.c **** 	//Counter:
 489:rowSegBuffer.c **** 	//  subi Rlength, 0x10			//Subtract 0x10 each time...	1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 160


 490:rowSegBuffer.c **** 	//  breq LoadNext					// if length==0, next segment	1 2
 491:rowSegBuffer.c **** 	//  rjmp Counter					// else, next counter loop    2
 492:rowSegBuffer.c **** 
 493:rowSegBuffer.c **** 	//Done:
 494:rowSegBuffer.c **** 
 495:rowSegBuffer.c **** 	// Thus, minimum inter-pixel time is 16 clock cycles
 496:rowSegBuffer.c **** 	// (14 for the last one)
 497:rowSegBuffer.c **** 	// This cannot be reuced by using a separate byte for red and length
 498:rowSegBuffer.c **** 	// because the mov and andi in LoadNext would be replaced by a ld
 499:rowSegBuffer.c **** 
 500:rowSegBuffer.c **** 	// To make the counter take longer between each count,
 501:rowSegBuffer.c **** 	// decrement it by a smaller number...
 502:rowSegBuffer.c **** 
 503:rowSegBuffer.c **** //	drawSegs();
 504:rowSegBuffer.c **** /*
 505:rowSegBuffer.c **** __asm__ __volatile__
 506:rowSegBuffer.c **** 	(
 507:rowSegBuffer.c **** 	"LoadNext_%=: \n\t"
 508:rowSegBuffer.c **** 	 	"ld %1, %a0+ ; \n\t"		//%a1 refers to XYZ whichever is selected
 509:rowSegBuffer.c **** 		"mov %2, %1 ; \n\t"		// Load R (+length)
 510:rowSegBuffer.c **** 		"andi %2, 0x0f ; \n\t"	//Remove length from Rred
 511:rowSegBuffer.c **** 		"ld %3, %a0+ ; \n\t"		//Load G	
 512:rowSegBuffer.c **** 		"ld %4, %a0+ ; \n\t"		//Load B
 513:rowSegBuffer.c **** 		"out %5, %2 ; \n\t"	// Write OCR1D (Red)
 514:rowSegBuffer.c **** 		"out %6, %3 ; \n\t"		// Write DT1 (Green)
 515:rowSegBuffer.c **** 		"out %7, %4 ; \n\t"	// Write OCR1A (Blue)
 516:rowSegBuffer.c **** 
 517:rowSegBuffer.c **** 		"andi %1, 0xf0 ; \n\t"	// Remove red from length
 518:rowSegBuffer.c **** 		"breq Done_%= ; \n\t"		// if length==0 from the start, we're done
 519:rowSegBuffer.c **** 
 520:rowSegBuffer.c **** 	"Counter_%=: \n\t"
 521:rowSegBuffer.c **** 		"subi %1, 0x10 ; \n\t"	//Decrement the counter by 0x10
 522:rowSegBuffer.c **** 		"breq LoadNext_%= ; \n\t"	// if we've decremented to 0, next segment
 523:rowSegBuffer.c **** 
 524:rowSegBuffer.c **** 	"Done_%=: \n\t"
 525:rowSegBuffer.c **** 		:								//No output register...
 526:rowSegBuffer.c **** 		: "e" (byteptr),			//byteptr: %0, r/w and assigned to X,Y,orZ
 527:rowSegBuffer.c **** 		  "d"  (rl),				//rl: %1, andi and subi will be used
 528:rowSegBuffer.c **** 		  "d"  (r),					//r: %2, andi will be used
 529:rowSegBuffer.c **** 		  "r"  (g),					//g: %3
 530:rowSegBuffer.c **** 		  "r"  (b),					//b: %4
 531:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1D)), //OCR1D: %5
 532:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(DT1)),	//DT1: %6
 533:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1A))	//OCR1A %7
 534:rowSegBuffer.c **** 	);
 535:rowSegBuffer.c **** */
 536:rowSegBuffer.c **** 
 537:rowSegBuffer.c **** __asm__ __volatile__
 1650               		.stabn	68,0,537,.LM177-.LFBB16
 1651               	.LM177:
 1652 0646 E0E0      		ldi r30,lo8(rowSegBuffer)
 1653 0648 F0E0      		ldi r31,hi8(rowSegBuffer)
 1654               	/* #APP */
 1655               	 ;  537 "rowSegBuffer.c" 1
 1656               		LoadNext_974: 
 1657 064a 4191      		ld r20, Z+ ; 
 1658 064c 542F      		mov r21, r20 ; 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 161


 1659 064e 5770      		andi r21, 7 ; 
 1660 0650 6191      		ld r22, Z+ ; 
 1661 0652 762F      		mov r23, r22 ; 
 1662 0654 6F70      		andi r22, 0x0f ; 
 1663 0656 7295      		swap r23 ; 
 1664 0658 7F70      		andi r23, 0x0f 
 1665 065a 5ABD      		out 42, r21 ; 
 1666 065c 64BD      		out 36, r22 ; 
 1667 065e 7DBD      		out 45, r23 ; 
 1668 0660 487F      		andi r20, 248 ; 
 1669 0662 01F0      		breq Done_974 ; 
 1670 0664 0000      		nop ; 
 1671 0666 0000      		nop ; 
 1672               		Counter_974: 
 1673 0668 4850      		subi r20, 8 ; 
 1674 066a 01F0      		breq LoadNext_974 ; 
 1675 066c 0000      		nop ; 
 1676 066e 0000      		nop ; 
 1677 0670 0000      		nop ; 
 1678 0672 0000      		nop ; 
 1679 0674 0000      		nop ; 
 1680 0676 0000      		nop ; 
 1681 0678 0000      		nop ; 
 1682 067a 0000      		nop ; 
 1683 067c 0000      		nop ; 
 1684 067e 0000      		nop ; 
 1685 0680 0000      		nop ; 
 1686 0682 0000      		nop ; 
 1687 0684 0000      		nop ; 
 1688 0686 0000      		nop ; 
 1689 0688 0000      		nop ; 
 1690 068a 0000      		nop ; 
 1691 068c 00C0      		rjmp Counter_974 ; 
 1692               		Done_974: 
 1693               		
 1694               	 ;  0 "" 2
 1695               	/* #NOAPP */
 1696               	.LBE141:
 1697               	.LBE140:
 1698               		.stabs	"main.c",132,0,0,.Ltext18
 1699               	.Ltext18:
3885:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 1700               		.stabn	68,0,3885,.LM178-.LFBB16
 1701               	.LM178:
 1702 068e 83E6      		ldi r24,lo8(99)
 1703 0690 80BF      		out 80-0x20,r24
3889:main.c        **** 		fullBlue();
 1704               		.stabn	68,0,3889,.LM179-.LFBB16
 1705               	.LM179:
 1706 0692 14BC      		out 68-0x20,__zero_reg__
 1707 0694 86E0      		ldi r24,lo8(6)
 1708 0696 8DBD      		out 77-0x20,r24
3890:main.c        **** 		Nada_fromDEonly();
 1709               		.stabn	68,0,3890,.LM180-.LFBB16
 1710               	.LM180:
 1711 0698 80E3      		ldi r24,lo8(48)
 1712 069a 84BD      		out 68-0x20,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 162


 1713               	.L106:
 1714               	.LBE139:
 1715               	.LBE138:
 1716               	.LBE125:
 1717               	.LBE124:
 1718               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext19
 1719               	.Ltext19:
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
 1720               		.stabn	68,0,1187,.LM181-.LFBB16
 1721               	.LM181:
 1722 069c 8091 0000 		lds r24,hsyncCount
 1723 06a0 9091 0000 		lds r25,(hsyncCount)+1
 1724 06a4 0196      		adiw r24,1
 1725 06a6 9093 0000 		sts (hsyncCount)+1,r25
 1726 06aa 8093 0000 		sts hsyncCount,r24
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
 1727               		.stabn	68,0,1189,.LM182-.LFBB16
 1728               	.LM182:
 1729 06ae 8332      		cpi r24,35
 1730 06b0 9105      		cpc r25,__zero_reg__
 1731 06b2 01F0      		breq .L109
 1732 06b4 8432      		cpi r24,36
 1733 06b6 9105      		cpc r25,__zero_reg__
 1734 06b8 00F4      		brsh .L112
 1735 06ba 8330      		cpi r24,3
 1736 06bc 9105      		cpc r25,__zero_reg__
 1737 06be 01F4      		brne .L116
 1738 06c0 00C0      		rjmp .L119
 1739               	.L112:
 1740 06c2 8632      		cpi r24,38
 1741 06c4 9105      		cpc r25,__zero_reg__
 1742 06c6 01F0      		breq .L110
 1743 06c8 23E0      		ldi r18,hi8(806)
 1744 06ca 8632      		cpi r24,lo8(806)
 1745 06cc 9207      		cpc r25,r18
 1746 06ce 01F4      		brne .L116
 1747 06d0 00C0      		rjmp .L120
 1748               	.L119:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 1749               		.stabn	68,0,1195,.LM183-.LFBB16
 1750               	.LM183:
 1751 06d2 1092 0000 		sts dataEnable,__zero_reg__
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
 1752               		.stabn	68,0,1197,.LM184-.LFBB16
 1753               	.LM184:
 1754 06d6 81E0      		ldi r24,lo8(1)
 1755 06d8 8093 0000 		sts vSync,r24
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
 1756               		.stabn	68,0,1198,.LM185-.LFBB16
 1757               	.LM185:
 1758 06dc 80E4      		ldi r24,lo8(64)
 1759 06de 84BD      		out 68-0x20,r24
 1760 06e0 85E0      		ldi r24,lo8(5)
 1761 06e2 00C0      		rjmp .L117
 1762               	.L109:
1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
 1763               		.stabn	68,0,1207,.LM186-.LFBB16
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 163


 1764               	.LM186:
 1765 06e4 1092 0000 		sts vSync,__zero_reg__
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
 1766               		.stabn	68,0,1208,.LM187-.LFBB16
 1767               	.LM187:
 1768 06e8 80E3      		ldi r24,lo8(48)
 1769 06ea 84BD      		out 68-0x20,r24
 1770 06ec 84E0      		ldi r24,lo8(4)
 1771               	.L117:
 1772 06ee 8DBD      		out 77-0x20,r24
 1773 06f0 00C0      		rjmp .L116
 1774               	.L110:
1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
 1775               		.stabn	68,0,1212,.LM188-.LFBB16
 1776               	.LM188:
 1777 06f2 81E0      		ldi r24,lo8(1)
 1778 06f4 8093 0000 		sts dataEnable,r24
 1779               	.L116:
 1780 06f8 80E0      		ldi r24,lo8(0)
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
 1781               		.stabn	68,0,1213,.LM189-.LFBB16
 1782               	.LM189:
 1783 06fa 0895      		ret
 1784               	.L120:
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 1785               		.stabn	68,0,1217,.LM190-.LFBB16
 1786               	.LM190:
 1787 06fc 1092 0000 		sts dataEnable,__zero_reg__
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
 1788               		.stabn	68,0,1222,.LM191-.LFBB16
 1789               	.LM191:
 1790 0700 1092 0000 		sts (hsyncCount)+1,__zero_reg__
 1791 0704 1092 0000 		sts hsyncCount,__zero_reg__
 1792 0708 81E0      		ldi r24,lo8(1)
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 1793               		.stabn	68,0,1263,.LM192-.LFBB16
 1794               	.LM192:
 1795 070a 0895      		ret
 1796               		.size	updateLCD, .-updateLCD
 1797               		.stabs	"frameComplete:r(3,2)",64,0,1167,24
 1798               		.stabn	192,0,0,.LFBB16-.LFBB16
 1799               		.stabs	"__count:r(3,4)",64,0,1643,24
 1800               		.stabn	192,0,0,.LBB128-.LFBB16
 1801               		.stabn	224,0,0,.LBE128-.LFBB16
 1802               		.stabs	"__count:r(3,4)",64,0,1643,24
 1803               		.stabn	192,0,0,.LBB132-.LFBB16
 1804               		.stabn	224,0,0,.LBE132-.LFBB16
 1805               		.stabs	"__count:r(3,4)",64,0,1643,24
 1806               		.stabn	192,0,0,.LBB136-.LFBB16
 1807               		.stabn	224,0,0,.LBE136-.LFBB16
 1808               		.stabn	224,0,0,.Lscope16-.LFBB16
 1809               	.Lscope16:
 1810               		.stabs	"",36,0,0,.Lscope16-.LFBB16
 1811               		.stabd	78,0,0
 1812               		.stabs	"init_timer0Hsync:F(0,15)",36,0,3051,init_timer0Hsync
 1813               	.global	init_timer0Hsync
 1814               		.type	init_timer0Hsync, @function
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 164


 1815               	init_timer0Hsync:
 1816               		.stabd	46,0,0
 1817               		.stabs	"main.c",132,0,0,.Ltext20
 1818               	.Ltext20:
3052:main.c        **** {
 1819               		.stabn	68,0,3052,.LM193-.LFBB17
 1820               	.LM193:
 1821               	.LFBB17:
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
3172:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
 1824               		.stabn	68,0,3172,.LM194-.LFBB17
 1825               	.LM194:
 1826 070c 83EE      		ldi r24,lo8(-29)
 1827 070e 83BB      		out 51-0x20,r24
3173:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
 1828               		.stabn	68,0,3173,.LM195-.LFBB17
 1829               	.LM195:
 1830 0710 80E0      		ldi r24,lo8(0)
 1831 0712 62E0      		ldi r22,lo8(2)
 1832 0714 00D0      		rcall timer_setWGM
3174:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
 1833               		.stabn	68,0,3174,.LM196-.LFBB17
 1834               	.LM196:
 1835 0716 80E0      		ldi r24,lo8(0)
 1836 0718 68E0      		ldi r22,lo8(8)
 1837 071a 00D0      		rcall timer_selectDivisor
3175:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
 1838               		.stabn	68,0,3175,.LM197-.LFBB17
 1839               	.LM197:
 1840 071c 80E0      		ldi r24,lo8(0)
 1841 071e 60E0      		ldi r22,lo8(0)
 1842 0720 41E0      		ldi r20,lo8(1)
 1843 0722 00D0      		rcall timer_compareMatchIntSetup
 1844               	/* epilogue start */
3176:main.c        **** }
 1845               		.stabn	68,0,3176,.LM198-.LFBB17
 1846               	.LM198:
 1847 0724 0895      		ret
 1848               		.size	init_timer0Hsync, .-init_timer0Hsync
 1849               	.Lscope17:
 1850               		.stabs	"",36,0,0,.Lscope17-.LFBB17
 1851               		.stabd	78,0,0
 1852               		.stabs	"main:F(0,1)",36,0,4156,main
 1853               	.global	main
 1854               		.type	main, @function
 1855               	main:
 1856               		.stabd	46,0,0
4157:main.c        **** {
 1857               		.stabn	68,0,4157,.LM199-.LFBB18
 1858               	.LM199:
 1859               	.LFBB18:
 1860               	/* prologue: function */
 1861               	/* frame size = 0 */
4165:main.c        **** 	tetInit(7);
 1862               		.stabn	68,0,4165,.LM200-.LFBB18
 1863               	.LM200:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 165


 1864 0726 87E0      		ldi r24,lo8(7)
 1865 0728 00D0      		rcall tetInit
4167:main.c        **** 	init_timer0Hsync();
 1866               		.stabn	68,0,4167,.LM201-.LFBB18
 1867               	.LM201:
 1868 072a 00D0      		rcall init_timer0Hsync
4174:main.c        **** 	lvds_timerInit();
 1869               		.stabn	68,0,4174,.LM202-.LFBB18
 1870               	.LM202:
 1871 072c 00D0      		rcall lvds_timerInit
 1872               	.L126:
4300:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
 1873               		.stabn	68,0,4300,.LM203-.LFBB18
 1874               	.LM203:
 1875 072e 8091 0000 		lds r24,frameCount
 1876 0732 8823      		tst r24
 1877 0734 01F4      		brne .L124
 1878               	.L129:
 1879 0736 89B7      		in r24,89-0x20
 1880 0738 8071      		andi r24,lo8(16)
 1881 073a 01F4      		brne .L129
4354:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
 1882               		.stabn	68,0,4354,.LM204-.LFBB18
 1883               	.LM204:
 1884 073c 60E0      		ldi r22,lo8(0)
 1885 073e 41E0      		ldi r20,lo8(1)
 1886 0740 00D0      		rcall timer_compareMatchIntSetup
 1887 0742 00C0      		rjmp .L126
 1888               	.L124:
 1889               	.L131:
 1890 0744 00C0      		rjmp .L131
 1891               		.size	main, .-main
 1892               	.Lscope18:
 1893               		.stabs	"",36,0,0,.Lscope18-.LFBB18
 1894               		.stabd	78,0,0
 1895               		.stabs	"__vector_14:F(0,15)",36,0,2060,__vector_14
 1896               	.global	__vector_14
 1897               		.type	__vector_14, @function
 1898               	__vector_14:
 1899               		.stabd	46,0,0
2061:main.c        **** {
 1900               		.stabn	68,0,2061,.LM205-.LFBB19
 1901               	.LM205:
 1902               	.LFBB19:
 1903 0746 1F92      		push __zero_reg__
 1904 0748 0F92      		push r0
 1905 074a 0FB6      		in r0,__SREG__
 1906 074c 0F92      		push r0
 1907 074e 1124      		clr __zero_reg__
 1908 0750 9F92      		push r9
 1909 0752 AF92      		push r10
 1910 0754 BF92      		push r11
 1911 0756 CF92      		push r12
 1912 0758 DF92      		push r13
 1913 075a EF92      		push r14
 1914 075c FF92      		push r15
 1915 075e 0F93      		push r16
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 166


 1916 0760 1F93      		push r17
 1917 0762 2F93      		push r18
 1918 0764 3F93      		push r19
 1919 0766 4F93      		push r20
 1920 0768 5F93      		push r21
 1921 076a 6F93      		push r22
 1922 076c 7F93      		push r23
 1923 076e 8F93      		push r24
 1924 0770 9F93      		push r25
 1925 0772 AF93      		push r26
 1926 0774 BF93      		push r27
 1927 0776 EF93      		push r30
 1928 0778 FF93      		push r31
 1929 077a DF93      		push r29
 1930 077c CF93      		push r28
 1931 077e 00D0      		rcall .
 1932 0780 CDB7      		in r28,__SP_L__
 1933 0782 DEB7      		in r29,__SP_H__
 1934               	/* prologue: Signal */
 1935               	/* frame size = 2 */
2076:main.c        **** 	if(updateLCD())
 1936               		.stabn	68,0,2076,.LM206-.LFBB19
 1937               	.LM206:
 1938 0784 00D0      		rcall updateLCD
 1939 0786 8823      		tst r24
 1940 0788 01F0      		breq .L133
2080:main.c        **** 			frameCount++;
 1941               		.stabn	68,0,2080,.LM207-.LFBB19
 1942               	.LM207:
 1943 078a 8091 0000 		lds r24,frameCount.2275
 1944 078e 8F5F      		subi r24,lo8(-(1))
 1945 0790 8093 0000 		sts frameCount.2275,r24
2081:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
 1946               		.stabn	68,0,2081,.LM208-.LFBB19
 1947               	.LM208:
 1948 0794 8230      		cpi r24,lo8(2)
 1949 0796 01F4      		brne .L133
2083:main.c        **** 				frameCount = 0;
 1950               		.stabn	68,0,2083,.LM209-.LFBB19
 1951               	.LM209:
 1952 0798 1092 0000 		sts frameCount.2275,__zero_reg__
2084:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
 1953               		.stabn	68,0,2084,.LM210-.LFBB19
 1954               	.LM210:
 1955 079c 80E0      		ldi r24,lo8(0)
 1956 079e 60E0      		ldi r22,lo8(0)
 1957 07a0 40E0      		ldi r20,lo8(0)
 1958 07a2 00D0      		rcall timer_compareMatchIntSetup
 1959               	.L133:
2093:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
 1960               		.stabn	68,0,2093,.LM211-.LFBB19
 1961               	.LM211:
 1962 07a4 0091 0000 		lds r16,hsyncCount
 1963 07a8 1091 0000 		lds r17,(hsyncCount)+1
 1964 07ac 0352      		subi r16,lo8(-(-35))
 1965 07ae 1040      		sbci r17,hi8(-(-35))
 1966 07b0 23E0      		ldi r18,hi8(768)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 167


 1967 07b2 0030      		cpi r16,lo8(768)
 1968 07b4 1207      		cpc r17,r18
 1969 07b6 00F0      		brlo .+2
 1970 07b8 00C0      		rjmp .L175
 1971               	.LBB159:
 1972               	.LBB160:
2901:main.c        **** 	if(rowNum == 0)
 1973               		.stabn	68,0,2901,.LM212-.LFBB19
 1974               	.LM212:
 1975 07ba 0115      		cp r16,__zero_reg__
 1976 07bc 1105      		cpc r17,__zero_reg__
 1977 07be 01F4      		brne .L135
2903:main.c        **** 		lastThetaOffset+=16;
 1978               		.stabn	68,0,2903,.LM213-.LFBB19
 1979               	.LM213:
 1980 07c0 8091 0000 		lds r24,lastThetaOffset.2290
 1981 07c4 9091 0000 		lds r25,(lastThetaOffset.2290)+1
 1982 07c8 4096      		adiw r24,16
 1983 07ca 9093 0000 		sts (lastThetaOffset.2290)+1,r25
 1984 07ce 8093 0000 		sts lastThetaOffset.2290,r24
2904:main.c        **** 		frameCount++;
 1985               		.stabn	68,0,2904,.LM214-.LFBB19
 1986               	.LM214:
 1987 07d2 8091 0000 		lds r24,frameCount.2291
 1988 07d6 8F5F      		subi r24,lo8(-(1))
 1989 07d8 8093 0000 		sts frameCount.2291,r24
 1990               	.L135:
 1991               	.LBB161:
 1992               	.LBB162:
 1993               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext21
 1994               	.Ltext21:
 161:rowSegBuffer.c **** 	segPosition = 0;
 1995               		.stabn	68,0,161,.LM215-.LFBB19
 1996               	.LM215:
 1997 07dc 1092 0000 		sts segPosition,__zero_reg__
 164:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 1998               		.stabn	68,0,164,.LM216-.LFBB19
 1999               	.LM216:
 2000 07e0 86E0      		ldi r24,lo8(6)
 2001 07e2 8093 0000 		sts rowSegBuffer,r24
 165:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 2002               		.stabn	68,0,165,.LM217-.LFBB19
 2003               	.LM217:
 2004 07e6 83E6      		ldi r24,lo8(99)
 2005 07e8 8093 0000 		sts rowSegBuffer+1,r24
 2006               	.LBE162:
 2007               	.LBE161:
 2008               		.stabs	"main.c",132,0,0,.Ltext22
 2009               	.Ltext22:
2910:main.c        **** 	addSegfb(3, _W);
 2010               		.stabn	68,0,2910,.LM218-.LFBB19
 2011               	.LM218:
 2012 07ec 83E0      		ldi r24,lo8(3)
 2013 07ee 90E0      		ldi r25,hi8(3)
 2014 07f0 67E0      		ldi r22,lo8(7)
 2015 07f2 43E7      		ldi r20,lo8(115)
 2016 07f4 00D0      		rcall addSeg
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 168


2912:main.c        **** 	uint8_t sineVal = (uint8_t)((int8_t)128 + 
 2017               		.stabn	68,0,2912,.LM219-.LFBB19
 2018               	.LM219:
 2019 07f6 8091 0000 		lds r24,lastThetaOffset.2290
 2020 07fa 9091 0000 		lds r25,(lastThetaOffset.2290)+1
 2021 07fe 800F      		add r24,r16
 2022 0800 911F      		adc r25,r17
 2023 0802 00D0      		rcall sineRaw8
2913:main.c        **** 			sineRaw8(rowNum+lastThetaOffset));
 2024               		.stabn	68,0,2913,.LM220-.LFBB19
 2025               	.LM220:
 2026 0804 70E8      		ldi r23,lo8(-128)
 2027 0806 F72E      		mov r15,r23
 2028 0808 F80E      		add r15,r24
2915:main.c        **** 	uint8_t nextSineVal = (uint8_t)((int8_t)128 +
 2029               		.stabn	68,0,2915,.LM221-.LFBB19
 2030               	.LM221:
 2031 080a 8091 0000 		lds r24,lastThetaOffset.2290
 2032 080e 9091 0000 		lds r25,(lastThetaOffset.2290)+1
 2033 0812 0196      		adiw r24,1
 2034 0814 800F      		add r24,r16
 2035 0816 911F      		adc r25,r17
 2036 0818 00D0      		rcall sineRaw8
2916:main.c        **** 			sineRaw8(rowNum+1+lastThetaOffset));
 2037               		.stabn	68,0,2916,.LM222-.LFBB19
 2038               	.LM222:
 2039 081a 8058      		subi r24,lo8(-(-128))
2922:main.c        **** 	if(nextSineVal < sineVal)
 2040               		.stabn	68,0,2922,.LM223-.LFBB19
 2041               	.LM223:
 2042 081c 8F15      		cp r24,r15
 2043 081e 00F4      		brsh .L136
2924:main.c        **** 		length = (sineVal - nextSineVal);
 2044               		.stabn	68,0,2924,.LM224-.LFBB19
 2045               	.LM224:
 2046 0820 EF2C      		mov r14,r15
 2047 0822 E81A      		sub r14,r24
2927:main.c        **** 		sineVal-=length;//*4;
 2048               		.stabn	68,0,2927,.LM225-.LFBB19
 2049               	.LM225:
 2050 0824 FE18      		sub r15,r14
 2051 0826 00C0      		rjmp .L137
 2052               	.L136:
2929:main.c        **** 	else if(nextSineVal > sineVal)
 2053               		.stabn	68,0,2929,.LM226-.LFBB19
 2054               	.LM226:
 2055 0828 F816      		cp r15,r24
 2056 082a 00F4      		brsh .L138
2930:main.c        **** 		length = (nextSineVal - sineVal);
 2057               		.stabn	68,0,2930,.LM227-.LFBB19
 2058               	.LM227:
 2059 082c E82E      		mov r14,r24
 2060 082e EF18      		sub r14,r15
 2061               	.L137:
2934:main.c        **** 	if(length == 0)
 2062               		.stabn	68,0,2934,.LM228-.LFBB19
 2063               	.LM228:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 169


 2064 0830 EE20      		tst r14
 2065 0832 01F4      		brne .L139
 2066               	.L138:
 2067 0834 EE24      		clr r14
 2068 0836 E394      		inc r14
 2069               	.L139:
2939:main.c        **** 	uint8_t j = frameCount;
 2070               		.stabn	68,0,2939,.LM229-.LFBB19
 2071               	.LM229:
 2072 0838 9090 0000 		lds r9,frameCount.2291
 2073 083c E0E0      		ldi r30,lo8(0)
 2074               	.LBB163:
 2075               	.LBB164:
 2076               		.stabs	"fbColors.h",132,0,0,.Ltext23
 2077               	.Ltext23:
   1:fbColors.h    **** // 7 6 5 4 3 2 1 0
   2:fbColors.h    **** // a a b b g g r r
   3:fbColors.h    **** //             0 0 = 0x00
   4:fbColors.h    **** //             0 1 = 0x01
   5:fbColors.h    **** //             1 0 = 0x02
   6:fbColors.h    **** //             1 1 = 0x03
   7:fbColors.h    **** //         0 0     = 0x00
   8:fbColors.h    **** //         0 1     = 0x04
   9:fbColors.h    **** //         1 0     = 0x08
  10:fbColors.h    **** //         1 1     = 0x0C
  11:fbColors.h    **** //     0 0         = 0x00
  12:fbColors.h    **** //     0 1         = 0x10
  13:fbColors.h    **** //     1 0         = 0x20
  14:fbColors.h    **** //     1 1         = 0x30
  15:fbColors.h    **** 
  16:fbColors.h    **** 
  17:fbColors.h    **** //Takes three values, from 0-3 each...
  18:fbColors.h    **** #define rgb(r,g,b) (((r)&0x03) | (((g)&0x03)<<2) | (((b)&0x03)<<4))
  19:fbColors.h    **** 
  20:fbColors.h    **** 
  21:fbColors.h    **** #define _R  0x03	//0x03						00 00 11
  22:fbColors.h    **** #define _O  0x07	//0x03 | 0x10				00 01 11
  23:fbColors.h    **** #define _Y  0x0F  //0x03 | 0x0C           00 11 11
  24:fbColors.h    **** #define _G 0x0C	//       0x0C				00 11 00
  25:fbColors.h    **** #define _C 0x3C   //       0x0C | 0x30    11 11 00
  26:fbColors.h    **** #define _B 0x30	//              0x30		11 00 00
  27:fbColors.h    **** #define _V 0x13   //0x03 |        0x10		01 00 11
  28:fbColors.h    **** #define _M  0x33	//0x03 |			 0x30		11 00 11
  29:fbColors.h    **** #define _K  0x00	//								00 00 00
  30:fbColors.h    **** #define _W 0x3F	//0x03 | 0x0C | 0x30		11 11 11
  31:fbColors.h    **** #define _r 0x01	//0x01						00 00 01
  32:fbColors.h    **** #define _g 0x04	//			0x04				00 01 00
  33:fbColors.h    **** #define _b 0x10	//					 0x10		01 00 00
  34:fbColors.h    **** #define _c 0x14	//			0x04	 0x10		01 01 00
  35:fbColors.h    **** #define _m 0x11	//0x01 |			 0x10		01 00 01
  36:fbColors.h    **** #define _y 0x05	//0x01 | 0x04				00 01 01
  37:fbColors.h    **** #define _k 0x15	//0x01 | 0x04 | 0x10		01 01 01
  38:fbColors.h    **** #define Tr 0xC0   //Transparent
  39:fbColors.h    **** 
  40:fbColors.h    **** 
  41:fbColors.h    **** //Creates a "gradient" effect, where no color-change is greater than 1
  42:fbColors.h    **** // for each change in value
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 170


  43:fbColors.h    **** // except at the crossover from full-blue back to 0... (0x30)
  44:fbColors.h    **** static __inline__ \
  45:fbColors.h    **** uint8_t rgbGradient(uint8_t value) \
  46:fbColors.h    **** 	__attribute__((__always_inline__));
  47:fbColors.h    **** 
  48:fbColors.h    **** uint8_t rgbGradient(uint8_t value)
  49:fbColors.h    **** {
  50:fbColors.h    **** 	while(value > 0x2f)
  51:fbColors.h    **** 		value -= 0x30;
  52:fbColors.h    **** 
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2078               		.stabn	68,0,54,.LM230-.LFBB19
 2079               	.LM230:
 2080 083e 63E0      		ldi r22,lo8(3)
 2081 0840 D62E      		mov r13,r22
 2082               	.LBE164:
 2083               	.LBE163:
 2084               		.stabs	"main.c",132,0,0,.Ltext24
 2085               	.Ltext24:
2949:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
 2086               		.stabn	68,0,2949,.LM231-.LFBB19
 2087               	.LM231:
 2088 0842 AF2C      		mov r10,r15
 2089 0844 BB24      		clr r11
 2090               	.L146:
2944:main.c        **** 		J++;
 2091               		.stabn	68,0,2944,.LM232-.LFBB19
 2092               	.LM232:
 2093 0846 CE2E      		mov r12,r30
 2094 0848 C394      		inc r12
 2095 084a 6C2D      		mov r22,r12
 2096 084c 690D      		add r22,r9
 2097 084e 00C0      		rjmp .L140
 2098               	.L141:
 2099               	.LBB166:
 2100               	.LBB165:
 2101               		.stabs	"fbColors.h",132,0,0,.Ltext25
 2102               	.Ltext25:
  51:fbColors.h    **** 		value -= 0x30;
 2103               		.stabn	68,0,51,.LM233-.LFBB19
 2104               	.LM233:
 2105 0850 6053      		subi r22,lo8(-(-48))
 2106               	.L140:
  50:fbColors.h    **** 	while(value > 0x2f)
 2107               		.stabn	68,0,50,.LM234-.LFBB19
 2108               	.LM234:
 2109 0852 6033      		cpi r22,lo8(48)
 2110 0854 00F4      		brsh .L141
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2111               		.stabn	68,0,53,.LM235-.LFBB19
 2112               	.LM235:
 2113 0856 462F      		mov r20,r22
 2114 0858 4370      		andi r20,lo8(3)
 2115               		.stabn	68,0,54,.LM236-.LFBB19
 2116               	.LM236:
 2117 085a 70E0      		ldi r23,lo8(0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 171


 2118 085c 62FF      		sbrs r22,2
 2119 085e 00C0      		rjmp .L142
 2120 0860 3D2D      		mov r19,r13
 2121 0862 341B      		sub r19,r20
 2122 0864 432F      		mov r20,r19
 2123               	.L142:
  55:fbColors.h    **** 	uint8_t G = ((value)&0x0C)>>2; 
 2124               		.stabn	68,0,55,.LM237-.LFBB19
 2125               	.LM237:
 2126 0866 9B01      		movw r18,r22
 2127 0868 2C70      		andi r18,lo8(12)
 2128 086a 3070      		andi r19,hi8(12)
 2129 086c 3595      		asr r19
 2130 086e 2795      		ror r18
 2131 0870 3595      		asr r19
 2132 0872 2795      		ror r18
  56:fbColors.h    **** 	uint8_t g = ((value)&0x10) ? (3-G) : G ; 
 2133               		.stabn	68,0,56,.LM238-.LFBB19
 2134               	.LM238:
 2135 0874 64FF      		sbrs r22,4
 2136 0876 00C0      		rjmp .L143
 2137 0878 8D2D      		mov r24,r13
 2138 087a 821B      		sub r24,r18
 2139 087c 282F      		mov r18,r24
 2140               	.L143:
  57:fbColors.h    **** 	uint8_t B = ((value)&0x30) >> 4; 
 2141               		.stabn	68,0,57,.LM239-.LFBB19
 2142               	.LM239:
 2143 087e CB01      		movw r24,r22
 2144 0880 8073      		andi r24,lo8(48)
 2145 0882 9070      		andi r25,hi8(48)
 2146 0884 34E0      		ldi r19,4
 2147 0886 9595      	1:	asr r25
 2148 0888 8795      		ror r24
 2149 088a 3A95      		dec r19
 2150 088c 01F4      		brne 1b
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2151               		.stabn	68,0,58,.LM240-.LFBB19
 2152               	.LM240:
 2153 088e 66FF      		sbrs r22,6
 2154 0890 00C0      		rjmp .L144
 2155 0892 9D2D      		mov r25,r13
 2156 0894 981B      		sub r25,r24
 2157 0896 892F      		mov r24,r25
 2158               	.L144:
  59:fbColors.h    **** 
  60:fbColors.h    **** 	return rgb(r,g,b);
 2159               		.stabn	68,0,60,.LM241-.LFBB19
 2160               	.LM241:
 2161 0898 30E0      		ldi r19,lo8(0)
 2162 089a 2370      		andi r18,lo8(3)
 2163 089c 3070      		andi r19,hi8(3)
 2164 089e 220F      		lsl r18
 2165 08a0 331F      		rol r19
 2166 08a2 220F      		lsl r18
 2167 08a4 331F      		rol r19
 2168 08a6 4370      		andi r20,lo8(3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 172


 2169 08a8 422B      		or r20,r18
 2170 08aa 90E0      		ldi r25,lo8(0)
 2171 08ac 8370      		andi r24,lo8(3)
 2172 08ae 9070      		andi r25,hi8(3)
 2173 08b0 B4E0      		ldi r27,4
 2174 08b2 880F      	1:	lsl r24
 2175 08b4 991F      		rol r25
 2176 08b6 BA95      		dec r27
 2177 08b8 01F4      		brne 1b
 2178 08ba 482B      		or r20,r24
 2179               	.LBE165:
 2180               	.LBE166:
 2181               		.stabs	"main.c",132,0,0,.Ltext26
 2182               	.Ltext26:
2949:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
 2183               		.stabn	68,0,2949,.LM242-.LFBB19
 2184               	.LM242:
 2185 08bc 8C2D      		mov r24,r12
 2186 08be 90E0      		ldi r25,lo8(0)
 2187 08c0 65E0      		ldi r22,lo8(5)
 2188 08c2 70E0      		ldi r23,hi8(5)
 2189 08c4 00D0      		rcall __mulhi3
 2190 08c6 242F      		mov r18,r20
 2191 08c8 30E0      		ldi r19,lo8(0)
 2192 08ca F42F      		mov r31,r20
 2193 08cc F170      		andi r31,lo8(1)
 2194 08ce 4073      		andi r20,lo8(48)
 2195 08d0 8A15      		cp r24,r10
 2196 08d2 9B05      		cpc r25,r11
 2197 08d4 00F4      		brsh .L145
2952:main.c        **** 		addSegfb(WIDTH, rgbVal);
 2198               		.stabn	68,0,2952,.LM243-.LFBB19
 2199               	.LM243:
 2200 08d6 B901      		movw r22,r18
 2201 08d8 6370      		andi r22,lo8(3)
 2202 08da 7070      		andi r23,hi8(3)
 2203 08dc 660F      		lsl r22
 2204 08de 771F      		rol r23
 2205 08e0 6F2B      		or r22,r31
 2206 08e2 4064      		ori r20,lo8(64)
 2207 08e4 2C70      		andi r18,lo8(12)
 2208 08e6 3070      		andi r19,hi8(12)
 2209 08e8 3595      		asr r19
 2210 08ea 2795      		ror r18
 2211 08ec 3595      		asr r19
 2212 08ee 2795      		ror r18
 2213 08f0 422B      		or r20,r18
 2214 08f2 85E0      		ldi r24,lo8(5)
 2215 08f4 90E0      		ldi r25,hi8(5)
 2216 08f6 00D0      		rcall addSeg
 2217 08f8 EC2D      		mov r30,r12
 2218 08fa 00C0      		rjmp .L146
 2219               	.L145:
2957:main.c        **** 	addSegfb(sineVal-(uint16_t)J*(uint16_t)WIDTH, rgbVal); 
 2220               		.stabn	68,0,2957,.LM244-.LFBB19
 2221               	.LM244:
 2222 08fc 8E2F      		mov r24,r30
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 173


 2223 08fe 90E0      		ldi r25,lo8(0)
 2224 0900 65E0      		ldi r22,lo8(5)
 2225 0902 70E0      		ldi r23,hi8(5)
 2226 0904 00D0      		rcall __mulhi3
 2227 0906 B901      		movw r22,r18
 2228 0908 6370      		andi r22,lo8(3)
 2229 090a 7070      		andi r23,hi8(3)
 2230 090c 660F      		lsl r22
 2231 090e 771F      		rol r23
 2232 0910 6F2B      		or r22,r31
 2233 0912 4064      		ori r20,lo8(64)
 2234 0914 2C70      		andi r18,lo8(12)
 2235 0916 3070      		andi r19,hi8(12)
 2236 0918 3595      		asr r19
 2237 091a 2795      		ror r18
 2238 091c 3595      		asr r19
 2239 091e 2795      		ror r18
 2240 0920 422B      		or r20,r18
 2241 0922 9501      		movw r18,r10
 2242 0924 281B      		sub r18,r24
 2243 0926 390B      		sbc r19,r25
 2244 0928 C901      		movw r24,r18
 2245 092a 00D0      		rcall addSeg
2959:main.c        **** 	addSegfb(length, _W); 
 2246               		.stabn	68,0,2959,.LM245-.LFBB19
 2247               	.LM245:
 2248 092c 8E2D      		mov r24,r14
 2249 092e 90E0      		ldi r25,lo8(0)
 2250 0930 67E0      		ldi r22,lo8(7)
 2251 0932 43E7      		ldi r20,lo8(115)
 2252 0934 00D0      		rcall addSeg
2960:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
 2253               		.stabn	68,0,2960,.LM246-.LFBB19
 2254               	.LM246:
 2255 0936 6801      		movw r12,r16
 2256 0938 83E0      		ldi r24,3
 2257 093a D694      	1:	lsr r13
 2258 093c C794      		ror r12
 2259 093e 8A95      		dec r24
 2260 0940 01F4      		brne 1b
 2261 0942 8C2D      		mov r24,r12
 2262 0944 9C2D      		mov r25,r12
 2263 0946 00C0      		rjmp .L147
 2264               	.L148:
 2265               	.LBB167:
 2266               	.LBB168:
 2267               		.stabs	"fbColors.h",132,0,0,.Ltext27
 2268               	.Ltext27:
  51:fbColors.h    **** 		value -= 0x30;
 2269               		.stabn	68,0,51,.LM247-.LFBB19
 2270               	.LM247:
 2271 0948 9053      		subi r25,lo8(-(-48))
 2272               	.L147:
  50:fbColors.h    **** 	while(value > 0x2f)
 2273               		.stabn	68,0,50,.LM248-.LFBB19
 2274               	.LM248:
 2275 094a 9033      		cpi r25,lo8(48)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 174


 2276 094c 00F4      		brsh .L148
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2277               		.stabn	68,0,53,.LM249-.LFBB19
 2278               	.LM249:
 2279 094e 692F      		mov r22,r25
 2280 0950 6370      		andi r22,lo8(3)
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2281               		.stabn	68,0,54,.LM250-.LFBB19
 2282               	.LM250:
 2283 0952 92FF      		sbrs r25,2
 2284 0954 00C0      		rjmp .L149
 2285 0956 23E0      		ldi r18,lo8(3)
 2286 0958 261B      		sub r18,r22
 2287 095a 622F      		mov r22,r18
 2288               	.L149:
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2289               		.stabn	68,0,58,.LM251-.LFBB19
 2290               	.LM251:
 2291 095c 982F      		mov r25,r24
 2292 095e 00C0      		rjmp .L152
 2293               	.L153:
 2294               	.LBE168:
 2295               	.LBE167:
 2296               	.LBB169:
 2297               	.LBB170:
  51:fbColors.h    **** 		value -= 0x30;
 2298               		.stabn	68,0,51,.LM252-.LFBB19
 2299               	.LM252:
 2300 0960 9053      		subi r25,lo8(-(-48))
 2301               	.L152:
  50:fbColors.h    **** 	while(value > 0x2f)
 2302               		.stabn	68,0,50,.LM253-.LFBB19
 2303               	.LM253:
 2304 0962 9033      		cpi r25,lo8(48)
 2305 0964 00F4      		brsh .L153
  53:fbColors.h    **** 	uint8_t R = ((value)&0x03); 
 2306               		.stabn	68,0,53,.LM254-.LFBB19
 2307               	.LM254:
 2308 0966 792F      		mov r23,r25
 2309 0968 7370      		andi r23,lo8(3)
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2310               		.stabn	68,0,54,.LM255-.LFBB19
 2311               	.LM255:
 2312 096a 92FF      		sbrs r25,2
 2313 096c 00C0      		rjmp .L154
 2314 096e 23E0      		ldi r18,lo8(3)
 2315 0970 271B      		sub r18,r23
 2316 0972 722F      		mov r23,r18
 2317               	.L154:
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2318               		.stabn	68,0,58,.LM256-.LFBB19
 2319               	.LM256:
 2320 0974 282F      		mov r18,r24
 2321 0976 00C0      		rjmp .L157
 2322               	.L158:
 2323               	.LBE170:
 2324               	.LBE169:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 175


 2325               	.LBB171:
 2326               	.LBB172:
  51:fbColors.h    **** 		value -= 0x30;
 2327               		.stabn	68,0,51,.LM257-.LFBB19
 2328               	.LM257:
 2329 0978 2053      		subi r18,lo8(-(-48))
 2330               	.L157:
  50:fbColors.h    **** 	while(value > 0x2f)
 2331               		.stabn	68,0,50,.LM258-.LFBB19
 2332               	.LM258:
 2333 097a 2033      		cpi r18,lo8(48)
 2334 097c 00F4      		brsh .L158
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2335               		.stabn	68,0,54,.LM259-.LFBB19
 2336               	.LM259:
 2337 097e 30E0      		ldi r19,lo8(0)
  57:fbColors.h    **** 	uint8_t B = ((value)&0x30) >> 4; 
 2338               		.stabn	68,0,57,.LM260-.LFBB19
 2339               	.LM260:
 2340 0980 A901      		movw r20,r18
 2341 0982 4073      		andi r20,lo8(48)
 2342 0984 5070      		andi r21,hi8(48)
 2343 0986 B4E0      		ldi r27,4
 2344 0988 5595      	1:	asr r21
 2345 098a 4795      		ror r20
 2346 098c BA95      		dec r27
 2347 098e 01F4      		brne 1b
 2348 0990 542F      		mov r21,r20
  58:fbColors.h    **** 	uint8_t b = ((value)&0x40) ? (3-B) : B ;
 2349               		.stabn	68,0,58,.LM261-.LFBB19
 2350               	.LM261:
 2351 0992 26FF      		sbrs r18,6
 2352 0994 00C0      		rjmp .L179
 2353 0996 93E0      		ldi r25,lo8(3)
 2354 0998 941B      		sub r25,r20
 2355 099a 592F      		mov r21,r25
 2356 099c 00C0      		rjmp .L179
 2357               	.L162:
 2358               	.LBE172:
 2359               	.LBE171:
 2360               	.LBB173:
 2361               	.LBB174:
  51:fbColors.h    **** 		value -= 0x30;
 2362               		.stabn	68,0,51,.LM262-.LFBB19
 2363               	.LM262:
 2364 099e 8053      		subi r24,lo8(-(-48))
 2365               	.L179:
  50:fbColors.h    **** 	while(value > 0x2f)
 2366               		.stabn	68,0,50,.LM263-.LFBB19
 2367               	.LM263:
 2368 09a0 8033      		cpi r24,lo8(48)
 2369 09a2 00F4      		brsh .L162
  54:fbColors.h    **** 	uint8_t r = ((value)&0x04) ? (3-R) : R ; 
 2370               		.stabn	68,0,54,.LM264-.LFBB19
 2371               	.LM264:
 2372 09a4 90E0      		ldi r25,lo8(0)
  55:fbColors.h    **** 	uint8_t G = ((value)&0x0C)>>2; 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 176


 2373               		.stabn	68,0,55,.LM265-.LFBB19
 2374               	.LM265:
 2375 09a6 9C01      		movw r18,r24
 2376 09a8 2C70      		andi r18,lo8(12)
 2377 09aa 3070      		andi r19,hi8(12)
 2378 09ac 3595      		asr r19
 2379 09ae 2795      		ror r18
 2380 09b0 3595      		asr r19
 2381 09b2 2795      		ror r18
 2382 09b4 422F      		mov r20,r18
  56:fbColors.h    **** 	uint8_t g = ((value)&0x10) ? (3-G) : G ; 
 2383               		.stabn	68,0,56,.LM266-.LFBB19
 2384               	.LM266:
 2385 09b6 84FF      		sbrs r24,4
 2386 09b8 00C0      		rjmp .L164
 2387 09ba 23E0      		ldi r18,lo8(3)
 2388 09bc 241B      		sub r18,r20
 2389 09be 422F      		mov r20,r18
 2390               	.L164:
 2391               	.LBE174:
 2392               	.LBE173:
 2393               		.stabs	"main.c",132,0,0,.Ltext28
 2394               	.Ltext28:
2960:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
 2395               		.stabn	68,0,2960,.LM267-.LFBB19
 2396               	.LM267:
 2397 09c0 21E0      		ldi r18,lo8(257)
 2398 09c2 31E0      		ldi r19,hi8(257)
 2399 09c4 2F19      		sub r18,r15
 2400 09c6 3109      		sbc r19,__zero_reg__
 2401 09c8 7170      		andi r23,lo8(1)
 2402 09ca 6370      		andi r22,lo8(3)
 2403 09cc 660F      		lsl r22
 2404 09ce 672B      		or r22,r23
 2405 09d0 952F      		mov r25,r21
 2406 09d2 9295      		swap r25
 2407 09d4 9073      		andi r25,lo8(48)
 2408 09d6 9064      		ori r25,lo8(64)
 2409 09d8 4370      		andi r20,lo8(3)
 2410 09da 492B      		or r20,r25
 2411 09dc C901      		movw r24,r18
 2412 09de 8E19      		sub r24,r14
 2413 09e0 9109      		sbc r25,__zero_reg__
 2414 09e2 00D0      		rcall addSeg
2962:main.c        **** 	addSegfb(3, _W);
 2415               		.stabn	68,0,2962,.LM268-.LFBB19
 2416               	.LM268:
 2417 09e4 83E0      		ldi r24,lo8(3)
 2418 09e6 90E0      		ldi r25,hi8(3)
 2419 09e8 67E0      		ldi r22,lo8(7)
 2420 09ea 43E7      		ldi r20,lo8(115)
 2421 09ec 00D0      		rcall addSeg
 2422               	.LBB175:
2966:main.c        **** 		addSegfb(3, _R);
 2423               		.stabn	68,0,2966,.LM269-.LFBB19
 2424               	.LM269:
 2425 09ee 83E0      		ldi r24,lo8(3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 177


 2426 09f0 90E0      		ldi r25,hi8(3)
 2427 09f2 67E0      		ldi r22,lo8(7)
 2428 09f4 40E4      		ldi r20,lo8(64)
 2429 09f6 00D0      		rcall addSeg
2976:main.c        **** 		char thisChar = (rowNum/8)%('~'-' '+1) + ' '; //pgm_read_byte(&(string[rowNum/8])); 
 2430               		.stabn	68,0,2976,.LM270-.LFBB19
 2431               	.LM270:
 2432 09f8 C601      		movw r24,r12
 2433 09fa 6FE5      		ldi r22,lo8(95)
 2434 09fc 70E0      		ldi r23,hi8(95)
 2435 09fe 00D0      		rcall __udivmodhi4
 2436 0a00 805E      		subi r24,lo8(-(32))
 2437 0a02 8983      		std Y+1,r24
 2438 0a04 C801      		movw r24,r16
 2439 0a06 8770      		andi r24,lo8(7)
 2440 0a08 9070      		andi r25,hi8(7)
 2441 0a0a F1E0      		ldi r31,lo8(1)
 2442 0a0c EF2E      		mov r14,r31
 2443 0a0e F12C      		mov r15,__zero_reg__
 2444 0a10 00C0      		rjmp 2f
 2445 0a12 EE0C      	1:	lsl r14
 2446 0a14 FF1C      		rol r15
 2447 0a16 8A95      	2:	dec r24
 2448 0a18 02F4      		brpl 1b
 2449 0a1a E9E9      		ldi r30,lo8(665)
 2450 0a1c AE2E      		mov r10,r30
 2451 0a1e E2E0      		ldi r30,hi8(665)
 2452 0a20 BE2E      		mov r11,r30
 2453               	.L168:
 2454               	.LBB176:
2983:main.c        **** 			if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
 2455               		.stabn	68,0,2983,.LM271-.LFBB19
 2456               	.LM271:
 2457 0a22 E981      		ldd r30,Y+1
 2458 0a24 C501      		movw r24,r10
 2459 0a26 8E0F      		add r24,r30
 2460 0a28 911D      		adc r25,__zero_reg__
 2461 0a2a FC01      		movw r30,r24
 2462 0a2c E050      		subi r30,lo8(-(characters-32))
 2463 0a2e F040      		sbci r31,hi8(-(characters-32))
 2464               	/* #APP */
 2465               	 ;  2983 "main.c" 1
 2466 0a30 8491      		lpm r24, Z
 2467               		
 2468               	 ;  0 "" 2
 2469               	/* #NOAPP */
 2470               	.LBE176:
 2471 0a32 90E0      		ldi r25,lo8(0)
 2472 0a34 8E21      		and r24,r14
 2473 0a36 9F21      		and r25,r15
 2474 0a38 0097      		sbiw r24,0
 2475 0a3a 01F0      		breq .L166
2984:main.c        **** 				addSegfb(1, _Y); //0x06, (4<<4) | 3);
 2476               		.stabn	68,0,2984,.LM272-.LFBB19
 2477               	.LM272:
 2478 0a3c 81E0      		ldi r24,lo8(1)
 2479 0a3e 90E0      		ldi r25,hi8(1)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 178


 2480 0a40 67E0      		ldi r22,lo8(7)
 2481 0a42 43E4      		ldi r20,lo8(67)
 2482 0a44 00C0      		rjmp .L180
 2483               	.L166:
2986:main.c        **** 				addSegfb(1, _R); //0x06, (4<<4) | 0);
 2484               		.stabn	68,0,2986,.LM273-.LFBB19
 2485               	.LM273:
 2486 0a46 81E0      		ldi r24,lo8(1)
 2487 0a48 90E0      		ldi r25,hi8(1)
 2488 0a4a 67E0      		ldi r22,lo8(7)
 2489 0a4c 40E4      		ldi r20,lo8(64)
 2490               	.L180:
 2491 0a4e 00D0      		rcall addSeg
 2492 0a50 21EA      		ldi r18,lo8(-95)
 2493 0a52 3FEF      		ldi r19,hi8(-95)
 2494 0a54 A20E      		add r10,r18
 2495 0a56 B31E      		adc r11,r19
2981:main.c        **** 		for(i=8; i>0; i--)
 2496               		.stabn	68,0,2981,.LM274-.LFBB19
 2497               	.LM274:
 2498 0a58 31EA      		ldi r19,lo8(-95)
 2499 0a5a A316      		cp r10,r19
 2500 0a5c 3FEF      		ldi r19,hi8(-95)
 2501 0a5e B306      		cpc r11,r19
 2502 0a60 01F4      		brne .L168
2989:main.c        **** 		addSegfb(3, _R); //0x06, (4<<4) | 0);
 2503               		.stabn	68,0,2989,.LM275-.LFBB19
 2504               	.LM275:
 2505 0a62 83E0      		ldi r24,lo8(3)
 2506 0a64 90E0      		ldi r25,hi8(3)
 2507 0a66 67E0      		ldi r22,lo8(7)
 2508 0a68 40E4      		ldi r20,lo8(64)
 2509 0a6a 00D0      		rcall addSeg
2991:main.c        **** 		addSegfb(1, _W); //0x04, (6<<4) | 3);
 2510               		.stabn	68,0,2991,.LM276-.LFBB19
 2511               	.LM276:
 2512 0a6c 81E0      		ldi r24,lo8(1)
 2513 0a6e 90E0      		ldi r25,hi8(1)
 2514 0a70 67E0      		ldi r22,lo8(7)
 2515 0a72 43E7      		ldi r20,lo8(115)
 2516 0a74 00D0      		rcall addSeg
2997:main.c        **** 		strncpy_P(&thisChar, tqbf+(rowNum/8), 1);
 2517               		.stabn	68,0,2997,.LM277-.LFBB19
 2518               	.LM277:
 2519 0a76 B601      		movw r22,r12
 2520 0a78 6050      		subi r22,lo8(-(__c.2309))
 2521 0a7a 7040      		sbci r23,hi8(-(__c.2309))
 2522 0a7c CE01      		movw r24,r28
 2523 0a7e 0196      		adiw r24,1
 2524 0a80 41E0      		ldi r20,lo8(1)
 2525 0a82 50E0      		ldi r21,hi8(1)
 2526 0a84 00D0      		rcall strncpy_P
2999:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0, (6<<4) | 0);
 2527               		.stabn	68,0,2999,.LM278-.LFBB19
 2528               	.LM278:
 2529 0a86 83E0      		ldi r24,lo8(3)
 2530 0a88 90E0      		ldi r25,hi8(3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 179


 2531 0a8a 60E0      		ldi r22,lo8(0)
 2532 0a8c 40E5      		ldi r20,lo8(80)
 2533 0a8e 00D0      		rcall addSeg
3001:main.c        **** 		if(rowNum/8 < strlen_P(tqbf))
 2534               		.stabn	68,0,3001,.LM279-.LFBB19
 2535               	.LM279:
 2536 0a90 80E0      		ldi r24,lo8(__c.2309)
 2537 0a92 90E0      		ldi r25,hi8(__c.2309)
 2538 0a94 00D0      		rcall strlen_P
 2539 0a96 C816      		cp r12,r24
 2540 0a98 D906      		cpc r13,r25
 2541 0a9a 00F4      		brsh .L169
 2542 0a9c 79E9      		ldi r23,lo8(665)
 2543 0a9e C72E      		mov r12,r23
 2544 0aa0 72E0      		ldi r23,hi8(665)
 2545 0aa2 D72E      		mov r13,r23
 2546               	.L172:
 2547               	.LBB177:
3005:main.c        **** 				if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
 2548               		.stabn	68,0,3005,.LM280-.LFBB19
 2549               	.LM280:
 2550 0aa4 E981      		ldd r30,Y+1
 2551 0aa6 C601      		movw r24,r12
 2552 0aa8 8E0F      		add r24,r30
 2553 0aaa 911D      		adc r25,__zero_reg__
 2554 0aac FC01      		movw r30,r24
 2555 0aae E050      		subi r30,lo8(-(characters-32))
 2556 0ab0 F040      		sbci r31,hi8(-(characters-32))
 2557               	/* #APP */
 2558               	 ;  3005 "main.c" 1
 2559 0ab2 8491      		lpm r24, Z
 2560               		
 2561               	 ;  0 "" 2
 2562               	/* #NOAPP */
 2563               	.LBE177:
 2564 0ab4 90E0      		ldi r25,lo8(0)
 2565 0ab6 8E21      		and r24,r14
 2566 0ab8 9F21      		and r25,r15
 2567 0aba 0097      		sbiw r24,0
 2568 0abc 01F0      		breq .L170
3006:main.c        **** 					addSegfb(1, rgb(3,0,1));//_C); //0, (6<<4) | 3);
 2569               		.stabn	68,0,3006,.LM281-.LFBB19
 2570               	.LM281:
 2571 0abe 81E0      		ldi r24,lo8(1)
 2572 0ac0 90E0      		ldi r25,hi8(1)
 2573 0ac2 67E0      		ldi r22,lo8(7)
 2574 0ac4 00C0      		rjmp .L181
 2575               	.L170:
3008:main.c        **** 					addSegfb(1, rgb(0,0,1));//_B); //0, (6<<4) | 0);
 2576               		.stabn	68,0,3008,.LM282-.LFBB19
 2577               	.LM282:
 2578 0ac6 81E0      		ldi r24,lo8(1)
 2579 0ac8 90E0      		ldi r25,hi8(1)
 2580 0aca 60E0      		ldi r22,lo8(0)
 2581               	.L181:
 2582 0acc 40E5      		ldi r20,lo8(80)
 2583 0ace 00D0      		rcall addSeg
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 180


 2584 0ad0 21EA      		ldi r18,lo8(-95)
 2585 0ad2 3FEF      		ldi r19,hi8(-95)
 2586 0ad4 C20E      		add r12,r18
 2587 0ad6 D31E      		adc r13,r19
3003:main.c        **** 			for(i=8; i>0; i--)
 2588               		.stabn	68,0,3003,.LM283-.LFBB19
 2589               	.LM283:
 2590 0ad8 31EA      		ldi r19,lo8(-95)
 2591 0ada C316      		cp r12,r19
 2592 0adc 3FEF      		ldi r19,hi8(-95)
 2593 0ade D306      		cpc r13,r19
 2594 0ae0 01F4      		brne .L172
 2595 0ae2 00C0      		rjmp .L173
 2596               	.L169:
3012:main.c        **** 			addSegfb(8, rgb(0,0,1));//_B); //0,(6<<4) | 0);
 2597               		.stabn	68,0,3012,.LM284-.LFBB19
 2598               	.LM284:
 2599 0ae4 88E0      		ldi r24,lo8(8)
 2600 0ae6 90E0      		ldi r25,hi8(8)
 2601 0ae8 60E0      		ldi r22,lo8(0)
 2602 0aea 40E5      		ldi r20,lo8(80)
 2603 0aec 00D0      		rcall addSeg
 2604               	.L173:
3014:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0,(6<<4)|0);
 2605               		.stabn	68,0,3014,.LM285-.LFBB19
 2606               	.LM285:
 2607 0aee 83E0      		ldi r24,lo8(3)
 2608 0af0 90E0      		ldi r25,hi8(3)
 2609 0af2 60E0      		ldi r22,lo8(0)
 2610 0af4 40E5      		ldi r20,lo8(80)
 2611 0af6 00D0      		rcall addSeg
 2612               	.LBE175:
3022:main.c        **** 		addSegfb(1, (i+rowNum/4)&0x3f);
 2613               		.stabn	68,0,3022,.LM286-.LFBB19
 2614               	.LM286:
 2615 0af8 1695      		lsr r17
 2616 0afa 0795      		ror r16
 2617 0afc 1695      		lsr r17
 2618 0afe 0795      		ror r16
 2619 0b00 20E0      		ldi r18,lo8(0)
 2620               	.L174:
 2621 0b02 402F      		mov r20,r16
 2622 0b04 602F      		mov r22,r16
 2623 0b06 6370      		andi r22,lo8(3)
 2624 0b08 660F      		lsl r22
 2625 0b0a 802F      		mov r24,r16
 2626 0b0c 8170      		andi r24,lo8(1)
 2627 0b0e 682B      		or r22,r24
 2628 0b10 4073      		andi r20,lo8(48)
 2629 0b12 4064      		ori r20,lo8(64)
 2630 0b14 C801      		movw r24,r16
 2631 0b16 8C70      		andi r24,lo8(12)
 2632 0b18 9070      		andi r25,hi8(12)
 2633 0b1a 9695      		lsr r25
 2634 0b1c 8795      		ror r24
 2635 0b1e 9695      		lsr r25
 2636 0b20 8795      		ror r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 181


 2637 0b22 482B      		or r20,r24
 2638 0b24 81E0      		ldi r24,lo8(1)
 2639 0b26 90E0      		ldi r25,hi8(1)
 2640 0b28 2A83      		std Y+2,r18
 2641 0b2a 00D0      		rcall addSeg
3021:main.c        **** 	for(i=0; i<64; i++)
 2642               		.stabn	68,0,3021,.LM287-.LFBB19
 2643               	.LM287:
 2644 0b2c 2A81      		ldd r18,Y+2
 2645 0b2e 2F5F      		subi r18,lo8(-(1))
 2646 0b30 0F5F      		subi r16,lo8(-(1))
 2647 0b32 1F4F      		sbci r17,hi8(-(1))
 2648 0b34 2034      		cpi r18,lo8(64)
 2649 0b36 01F4      		brne .L174
3024:main.c        **** 	addSegfb(3, _W); //0x06, (6<<4) | 3);
 2650               		.stabn	68,0,3024,.LM288-.LFBB19
 2651               	.LM288:
 2652 0b38 83E0      		ldi r24,lo8(3)
 2653 0b3a 90E0      		ldi r25,hi8(3)
 2654 0b3c 67E0      		ldi r22,lo8(7)
 2655 0b3e 43E7      		ldi r20,lo8(115)
 2656 0b40 00D0      		rcall addSeg
3026:main.c        **** 	segTerminate();
 2657               		.stabn	68,0,3026,.LM289-.LFBB19
 2658               	.LM289:
 2659 0b42 00D0      		rcall segTerminate
 2660               	.L175:
 2661               	/* epilogue start */
 2662               	.LBE160:
 2663               	.LBE159:
2105:main.c        **** }
 2664               		.stabn	68,0,2105,.LM290-.LFBB19
 2665               	.LM290:
 2666 0b44 0F90      		pop __tmp_reg__
 2667 0b46 0F90      		pop __tmp_reg__
 2668 0b48 CF91      		pop r28
 2669 0b4a DF91      		pop r29
 2670 0b4c FF91      		pop r31
 2671 0b4e EF91      		pop r30
 2672 0b50 BF91      		pop r27
 2673 0b52 AF91      		pop r26
 2674 0b54 9F91      		pop r25
 2675 0b56 8F91      		pop r24
 2676 0b58 7F91      		pop r23
 2677 0b5a 6F91      		pop r22
 2678 0b5c 5F91      		pop r21
 2679 0b5e 4F91      		pop r20
 2680 0b60 3F91      		pop r19
 2681 0b62 2F91      		pop r18
 2682 0b64 1F91      		pop r17
 2683 0b66 0F91      		pop r16
 2684 0b68 FF90      		pop r15
 2685 0b6a EF90      		pop r14
 2686 0b6c DF90      		pop r13
 2687 0b6e CF90      		pop r12
 2688 0b70 BF90      		pop r11
 2689 0b72 AF90      		pop r10
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 182


 2690 0b74 9F90      		pop r9
 2691 0b76 0F90      		pop r0
 2692 0b78 0FBE      		out __SREG__,r0
 2693 0b7a 0F90      		pop r0
 2694 0b7c 1F90      		pop __zero_reg__
 2695 0b7e 1895      		reti
 2696               		.size	__vector_14, .-__vector_14
 2697               		.stabs	"frameCount:V(3,2)",38,0,2062,frameCount.2275
 2698               		.stabn	192,0,0,.LFBB19-.LFBB19
 2699               		.stabs	"sineVal:r(3,2)",64,0,2912,15
 2700               		.stabs	"nextSineVal:r(3,2)",64,0,2915,24
 2701               		.stabs	"length:r(3,2)",64,0,2918,14
 2702               		.stabs	"J:r(3,2)",64,0,2938,30
 2703               		.stabs	"j:r(3,2)",64,0,2939,9
 2704               		.stabs	"i:r(3,2)",64,0,3020,18
 2705               		.stabn	192,0,0,.LBB160-.LFBB19
 2706               		.stabs	"r:r(3,2)",64,0,54,20
 2707               		.stabs	"g:r(3,2)",64,0,56,18
 2708               		.stabs	"b:r(3,2)",64,0,58,24
 2709               		.stabn	192,0,0,.LBB164-.LFBB19
 2710               		.stabn	224,0,0,.LBE164-.LFBB19
 2711               		.stabs	"r:r(3,2)",64,0,54,20
 2712               		.stabs	"g:r(3,2)",64,0,56,18
 2713               		.stabs	"b:r(3,2)",64,0,58,24
 2714               		.stabn	192,0,0,.LBB165-.LFBB19
 2715               		.stabn	224,0,0,.LBE165-.LFBB19
 2716               		.stabs	"r:r(3,2)",64,0,54,22
 2717               		.stabn	192,0,0,.LBB168-.LFBB19
 2718               		.stabn	224,0,0,.LBE168-.LFBB19
 2719               		.stabs	"r:r(3,2)",64,0,54,23
 2720               		.stabn	192,0,0,.LBB170-.LFBB19
 2721               		.stabn	224,0,0,.LBE170-.LFBB19
 2722               		.stabs	"b:r(3,2)",64,0,58,21
 2723               		.stabn	192,0,0,.LBB172-.LFBB19
 2724               		.stabn	224,0,0,.LBE172-.LFBB19
 2725               		.stabs	"value:r(3,2)",64,0,2960,24
 2726               		.stabn	192,0,0,.LBB173-.LFBB19
 2727               		.stabs	"g:r(3,2)",64,0,56,20
 2728               		.stabn	192,0,0,.LBB174-.LFBB19
 2729               		.stabn	224,0,0,.LBE174-.LFBB19
 2730               		.stabn	224,0,0,.LBE173-.LFBB19
 2731               		.stabs	"thisChar:(0,2)",128,0,2976,1
 2732               		.stabn	192,0,0,.LBB175-.LFBB19
 2733               		.stabs	"__result:r(3,2)",64,0,2983,24
 2734               		.stabn	192,0,0,.LBB176-.LFBB19
 2735               		.stabn	224,0,0,.LBE176-.LFBB19
 2736               		.stabs	"__result:r(3,2)",64,0,3005,24
 2737               		.stabn	192,0,0,.LBB177-.LFBB19
 2738               		.stabn	224,0,0,.LBE177-.LFBB19
 2739               		.stabn	224,0,0,.LBE175-.LFBB19
 2740               		.stabn	224,0,0,.LBE160-.LFBB19
 2741               		.stabn	224,0,0,.Lscope19-.LFBB19
 2742               	.Lscope19:
 2743               		.stabs	"",36,0,0,.Lscope19-.LFBB19
 2744               		.stabd	78,0,0
 2745               	.global	header
 2746               		.section	.progmem.data,"a",@progbits
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 183


 2747               		.type	header, @object
 2748               		.size	header, 36
 2749               	header:
 2750 0000 4C43 4464 		.string	"LCDdirectLVDS59 2013-12-12 10:00:40"
 2750      6972 6563 
 2750      744C 5644 
 2750      5335 3920 
 2750      3230 3133 
 2751               	.global	characters
 2752               		.type	characters, @object
 2753               		.size	characters, 760
 2754               	characters:
 2755 0024 00        		.byte	0
 2756 0025 0C        		.byte	12
 2757 0026 36        		.byte	54
 2758 0027 36        		.byte	54
 2759 0028 0C        		.byte	12
 2760 0029 00        		.byte	0
 2761 002a 1C        		.byte	28
 2762 002b 06        		.byte	6
 2763 002c 18        		.byte	24
 2764 002d 06        		.byte	6
 2765 002e 00        		.byte	0
 2766 002f 00        		.byte	0
 2767 0030 00        		.byte	0
 2768 0031 00        		.byte	0
 2769 0032 00        		.byte	0
 2770 0033 60        		.byte	96
 2771 0034 1E        		.byte	30
 2772 0035 0C        		.byte	12
 2773 0036 1E        		.byte	30
 2774 0037 1E        		.byte	30
 2775 0038 38        		.byte	56
 2776 0039 3F        		.byte	63
 2777 003a 1C        		.byte	28
 2778 003b 3F        		.byte	63
 2779 003c 1E        		.byte	30
 2780 003d 1E        		.byte	30
 2781 003e 00        		.byte	0
 2782 003f 00        		.byte	0
 2783 0040 18        		.byte	24
 2784 0041 00        		.byte	0
 2785 0042 06        		.byte	6
 2786 0043 1E        		.byte	30
 2787 0044 3E        		.byte	62
 2788 0045 0C        		.byte	12
 2789 0046 3F        		.byte	63
 2790 0047 3C        		.byte	60
 2791 0048 3F        		.byte	63
 2792 0049 7F        		.byte	127
 2793 004a 7F        		.byte	127
 2794 004b 3C        		.byte	60
 2795 004c 33        		.byte	51
 2796 004d 1E        		.byte	30
 2797 004e 78        		.byte	120
 2798 004f 67        		.byte	103
 2799 0050 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 184


 2800 0051 63        		.byte	99
 2801 0052 63        		.byte	99
 2802 0053 1C        		.byte	28
 2803 0054 3F        		.byte	63
 2804 0055 1E        		.byte	30
 2805 0056 3F        		.byte	63
 2806 0057 1E        		.byte	30
 2807 0058 3F        		.byte	63
 2808 0059 33        		.byte	51
 2809 005a 33        		.byte	51
 2810 005b 63        		.byte	99
 2811 005c 63        		.byte	99
 2812 005d 33        		.byte	51
 2813 005e 7F        		.byte	127
 2814 005f 1E        		.byte	30
 2815 0060 03        		.byte	3
 2816 0061 1E        		.byte	30
 2817 0062 08        		.byte	8
 2818 0063 00        		.byte	0
 2819 0064 0C        		.byte	12
 2820 0065 00        		.byte	0
 2821 0066 07        		.byte	7
 2822 0067 00        		.byte	0
 2823 0068 38        		.byte	56
 2824 0069 00        		.byte	0
 2825 006a 1C        		.byte	28
 2826 006b 00        		.byte	0
 2827 006c 07        		.byte	7
 2828 006d 0C        		.byte	12
 2829 006e 18        		.byte	24
 2830 006f 07        		.byte	7
 2831 0070 0E        		.byte	14
 2832 0071 00        		.byte	0
 2833 0072 00        		.byte	0
 2834 0073 00        		.byte	0
 2835 0074 00        		.byte	0
 2836 0075 00        		.byte	0
 2837 0076 00        		.byte	0
 2838 0077 00        		.byte	0
 2839 0078 08        		.byte	8
 2840 0079 00        		.byte	0
 2841 007a 00        		.byte	0
 2842 007b 00        		.byte	0
 2843 007c 00        		.byte	0
 2844 007d 00        		.byte	0
 2845 007e 00        		.byte	0
 2846 007f 38        		.byte	56
 2847 0080 18        		.byte	24
 2848 0081 07        		.byte	7
 2849 0082 6E        		.byte	110
 2850 0083 00        		.byte	0
 2851 0084 1E        		.byte	30
 2852 0085 36        		.byte	54
 2853 0086 36        		.byte	54
 2854 0087 3E        		.byte	62
 2855 0088 63        		.byte	99
 2856 0089 36        		.byte	54
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 185


 2857 008a 06        		.byte	6
 2858 008b 0C        		.byte	12
 2859 008c 0C        		.byte	12
 2860 008d 66        		.byte	102
 2861 008e 0C        		.byte	12
 2862 008f 00        		.byte	0
 2863 0090 00        		.byte	0
 2864 0091 00        		.byte	0
 2865 0092 30        		.byte	48
 2866 0093 33        		.byte	51
 2867 0094 0F        		.byte	15
 2868 0095 33        		.byte	51
 2869 0096 33        		.byte	51
 2870 0097 3C        		.byte	60
 2871 0098 03        		.byte	3
 2872 0099 06        		.byte	6
 2873 009a 33        		.byte	51
 2874 009b 33        		.byte	51
 2875 009c 33        		.byte	51
 2876 009d 00        		.byte	0
 2877 009e 00        		.byte	0
 2878 009f 0C        		.byte	12
 2879 00a0 00        		.byte	0
 2880 00a1 0C        		.byte	12
 2881 00a2 33        		.byte	51
 2882 00a3 63        		.byte	99
 2883 00a4 1E        		.byte	30
 2884 00a5 66        		.byte	102
 2885 00a6 66        		.byte	102
 2886 00a7 36        		.byte	54
 2887 00a8 46        		.byte	70
 2888 00a9 46        		.byte	70
 2889 00aa 66        		.byte	102
 2890 00ab 33        		.byte	51
 2891 00ac 0C        		.byte	12
 2892 00ad 30        		.byte	48
 2893 00ae 66        		.byte	102
 2894 00af 06        		.byte	6
 2895 00b0 77        		.byte	119
 2896 00b1 67        		.byte	103
 2897 00b2 36        		.byte	54
 2898 00b3 66        		.byte	102
 2899 00b4 33        		.byte	51
 2900 00b5 66        		.byte	102
 2901 00b6 33        		.byte	51
 2902 00b7 2D        		.byte	45
 2903 00b8 33        		.byte	51
 2904 00b9 33        		.byte	51
 2905 00ba 63        		.byte	99
 2906 00bb 63        		.byte	99
 2907 00bc 33        		.byte	51
 2908 00bd 33        		.byte	51
 2909 00be 06        		.byte	6
 2910 00bf 06        		.byte	6
 2911 00c0 18        		.byte	24
 2912 00c1 1C        		.byte	28
 2913 00c2 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 186


 2914 00c3 0C        		.byte	12
 2915 00c4 00        		.byte	0
 2916 00c5 06        		.byte	6
 2917 00c6 00        		.byte	0
 2918 00c7 30        		.byte	48
 2919 00c8 00        		.byte	0
 2920 00c9 36        		.byte	54
 2921 00ca 00        		.byte	0
 2922 00cb 06        		.byte	6
 2923 00cc 00        		.byte	0
 2924 00cd 00        		.byte	0
 2925 00ce 06        		.byte	6
 2926 00cf 0C        		.byte	12
 2927 00d0 00        		.byte	0
 2928 00d1 00        		.byte	0
 2929 00d2 00        		.byte	0
 2930 00d3 00        		.byte	0
 2931 00d4 00        		.byte	0
 2932 00d5 00        		.byte	0
 2933 00d6 00        		.byte	0
 2934 00d7 0C        		.byte	12
 2935 00d8 00        		.byte	0
 2936 00d9 00        		.byte	0
 2937 00da 00        		.byte	0
 2938 00db 00        		.byte	0
 2939 00dc 00        		.byte	0
 2940 00dd 00        		.byte	0
 2941 00de 0C        		.byte	12
 2942 00df 18        		.byte	24
 2943 00e0 0C        		.byte	12
 2944 00e1 3B        		.byte	59
 2945 00e2 00        		.byte	0
 2946 00e3 1E        		.byte	30
 2947 00e4 36        		.byte	54
 2948 00e5 7F        		.byte	127
 2949 00e6 03        		.byte	3
 2950 00e7 33        		.byte	51
 2951 00e8 1C        		.byte	28
 2952 00e9 03        		.byte	3
 2953 00ea 06        		.byte	6
 2954 00eb 18        		.byte	24
 2955 00ec 3C        		.byte	60
 2956 00ed 0C        		.byte	12
 2957 00ee 00        		.byte	0
 2958 00ef 00        		.byte	0
 2959 00f0 00        		.byte	0
 2960 00f1 18        		.byte	24
 2961 00f2 3B        		.byte	59
 2962 00f3 0C        		.byte	12
 2963 00f4 30        		.byte	48
 2964 00f5 30        		.byte	48
 2965 00f6 36        		.byte	54
 2966 00f7 1F        		.byte	31
 2967 00f8 03        		.byte	3
 2968 00f9 30        		.byte	48
 2969 00fa 33        		.byte	51
 2970 00fb 33        		.byte	51
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 187


 2971 00fc 0C        		.byte	12
 2972 00fd 0C        		.byte	12
 2973 00fe 06        		.byte	6
 2974 00ff 3F        		.byte	63
 2975 0100 18        		.byte	24
 2976 0101 30        		.byte	48
 2977 0102 7B        		.byte	123
 2978 0103 33        		.byte	51
 2979 0104 66        		.byte	102
 2980 0105 03        		.byte	3
 2981 0106 66        		.byte	102
 2982 0107 16        		.byte	22
 2983 0108 16        		.byte	22
 2984 0109 03        		.byte	3
 2985 010a 33        		.byte	51
 2986 010b 0C        		.byte	12
 2987 010c 30        		.byte	48
 2988 010d 36        		.byte	54
 2989 010e 06        		.byte	6
 2990 010f 7F        		.byte	127
 2991 0110 6F        		.byte	111
 2992 0111 63        		.byte	99
 2993 0112 66        		.byte	102
 2994 0113 33        		.byte	51
 2995 0114 66        		.byte	102
 2996 0115 07        		.byte	7
 2997 0116 0C        		.byte	12
 2998 0117 33        		.byte	51
 2999 0118 33        		.byte	51
 3000 0119 63        		.byte	99
 3001 011a 36        		.byte	54
 3002 011b 33        		.byte	51
 3003 011c 19        		.byte	25
 3004 011d 06        		.byte	6
 3005 011e 0C        		.byte	12
 3006 011f 18        		.byte	24
 3007 0120 36        		.byte	54
 3008 0121 00        		.byte	0
 3009 0122 18        		.byte	24
 3010 0123 1E        		.byte	30
 3011 0124 3E        		.byte	62
 3012 0125 1E        		.byte	30
 3013 0126 30        		.byte	48
 3014 0127 1E        		.byte	30
 3015 0128 06        		.byte	6
 3016 0129 6E        		.byte	110
 3017 012a 36        		.byte	54
 3018 012b 0E        		.byte	14
 3019 012c 1E        		.byte	30
 3020 012d 66        		.byte	102
 3021 012e 0C        		.byte	12
 3022 012f 37        		.byte	55
 3023 0130 1F        		.byte	31
 3024 0131 1E        		.byte	30
 3025 0132 3B        		.byte	59
 3026 0133 6E        		.byte	110
 3027 0134 1B        		.byte	27
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 188


 3028 0135 3E        		.byte	62
 3029 0136 3E        		.byte	62
 3030 0137 33        		.byte	51
 3031 0138 33        		.byte	51
 3032 0139 63        		.byte	99
 3033 013a 63        		.byte	99
 3034 013b 33        		.byte	51
 3035 013c 3F        		.byte	63
 3036 013d 0C        		.byte	12
 3037 013e 18        		.byte	24
 3038 013f 0C        		.byte	12
 3039 0140 00        		.byte	0
 3040 0141 00        		.byte	0
 3041 0142 0C        		.byte	12
 3042 0143 00        		.byte	0
 3043 0144 36        		.byte	54
 3044 0145 1E        		.byte	30
 3045 0146 18        		.byte	24
 3046 0147 6E        		.byte	110
 3047 0148 00        		.byte	0
 3048 0149 06        		.byte	6
 3049 014a 18        		.byte	24
 3050 014b FF        		.byte	-1
 3051 014c 3F        		.byte	63
 3052 014d 00        		.byte	0
 3053 014e 3F        		.byte	63
 3054 014f 00        		.byte	0
 3055 0150 0C        		.byte	12
 3056 0151 3F        		.byte	63
 3057 0152 0C        		.byte	12
 3058 0153 1C        		.byte	28
 3059 0154 1C        		.byte	28
 3060 0155 33        		.byte	51
 3061 0156 30        		.byte	48
 3062 0157 1F        		.byte	31
 3063 0158 18        		.byte	24
 3064 0159 1E        		.byte	30
 3065 015a 3E        		.byte	62
 3066 015b 0C        		.byte	12
 3067 015c 0C        		.byte	12
 3068 015d 03        		.byte	3
 3069 015e 00        		.byte	0
 3070 015f 30        		.byte	48
 3071 0160 18        		.byte	24
 3072 0161 7B        		.byte	123
 3073 0162 33        		.byte	51
 3074 0163 3E        		.byte	62
 3075 0164 03        		.byte	3
 3076 0165 66        		.byte	102
 3077 0166 1E        		.byte	30
 3078 0167 1E        		.byte	30
 3079 0168 03        		.byte	3
 3080 0169 3F        		.byte	63
 3081 016a 0C        		.byte	12
 3082 016b 30        		.byte	48
 3083 016c 1E        		.byte	30
 3084 016d 06        		.byte	6
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 189


 3085 016e 6B        		.byte	107
 3086 016f 7B        		.byte	123
 3087 0170 63        		.byte	99
 3088 0171 3E        		.byte	62
 3089 0172 33        		.byte	51
 3090 0173 3E        		.byte	62
 3091 0174 1C        		.byte	28
 3092 0175 0C        		.byte	12
 3093 0176 33        		.byte	51
 3094 0177 33        		.byte	51
 3095 0178 6B        		.byte	107
 3096 0179 1C        		.byte	28
 3097 017a 1E        		.byte	30
 3098 017b 0C        		.byte	12
 3099 017c 06        		.byte	6
 3100 017d 18        		.byte	24
 3101 017e 18        		.byte	24
 3102 017f 63        		.byte	99
 3103 0180 00        		.byte	0
 3104 0181 00        		.byte	0
 3105 0182 30        		.byte	48
 3106 0183 66        		.byte	102
 3107 0184 33        		.byte	51
 3108 0185 3E        		.byte	62
 3109 0186 33        		.byte	51
 3110 0187 0F        		.byte	15
 3111 0188 33        		.byte	51
 3112 0189 6E        		.byte	110
 3113 018a 0C        		.byte	12
 3114 018b 18        		.byte	24
 3115 018c 36        		.byte	54
 3116 018d 0C        		.byte	12
 3117 018e 7F        		.byte	127
 3118 018f 33        		.byte	51
 3119 0190 33        		.byte	51
 3120 0191 66        		.byte	102
 3121 0192 33        		.byte	51
 3122 0193 36        		.byte	54
 3123 0194 03        		.byte	3
 3124 0195 0C        		.byte	12
 3125 0196 33        		.byte	51
 3126 0197 33        		.byte	51
 3127 0198 63        		.byte	99
 3128 0199 36        		.byte	54
 3129 019a 33        		.byte	51
 3130 019b 19        		.byte	25
 3131 019c 07        		.byte	7
 3132 019d 00        		.byte	0
 3133 019e 38        		.byte	56
 3134 019f 00        		.byte	0
 3135 01a0 00        		.byte	0
 3136 01a1 0C        		.byte	12
 3137 01a2 00        		.byte	0
 3138 01a3 7F        		.byte	127
 3139 01a4 30        		.byte	48
 3140 01a5 0C        		.byte	12
 3141 01a6 3B        		.byte	59
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 190


 3142 01a7 00        		.byte	0
 3143 01a8 06        		.byte	6
 3144 01a9 18        		.byte	24
 3145 01aa 3C        		.byte	60
 3146 01ab 0C        		.byte	12
 3147 01ac 00        		.byte	0
 3148 01ad 00        		.byte	0
 3149 01ae 00        		.byte	0
 3150 01af 06        		.byte	6
 3151 01b0 37        		.byte	55
 3152 01b1 0C        		.byte	12
 3153 01b2 06        		.byte	6
 3154 01b3 30        		.byte	48
 3155 01b4 7F        		.byte	127
 3156 01b5 30        		.byte	48
 3157 01b6 33        		.byte	51
 3158 01b7 0C        		.byte	12
 3159 01b8 33        		.byte	51
 3160 01b9 30        		.byte	48
 3161 01ba 00        		.byte	0
 3162 01bb 00        		.byte	0
 3163 01bc 06        		.byte	6
 3164 01bd 3F        		.byte	63
 3165 01be 18        		.byte	24
 3166 01bf 0C        		.byte	12
 3167 01c0 7B        		.byte	123
 3168 01c1 3F        		.byte	63
 3169 01c2 66        		.byte	102
 3170 01c3 03        		.byte	3
 3171 01c4 66        		.byte	102
 3172 01c5 16        		.byte	22
 3173 01c6 16        		.byte	22
 3174 01c7 73        		.byte	115
 3175 01c8 33        		.byte	51
 3176 01c9 0C        		.byte	12
 3177 01ca 33        		.byte	51
 3178 01cb 36        		.byte	54
 3179 01cc 46        		.byte	70
 3180 01cd 63        		.byte	99
 3181 01ce 73        		.byte	115
 3182 01cf 63        		.byte	99
 3183 01d0 06        		.byte	6
 3184 01d1 3B        		.byte	59
 3185 01d2 1E        		.byte	30
 3186 01d3 38        		.byte	56
 3187 01d4 0C        		.byte	12
 3188 01d5 33        		.byte	51
 3189 01d6 33        		.byte	51
 3190 01d7 7F        		.byte	127
 3191 01d8 36        		.byte	54
 3192 01d9 0C        		.byte	12
 3193 01da 46        		.byte	70
 3194 01db 06        		.byte	6
 3195 01dc 30        		.byte	48
 3196 01dd 18        		.byte	24
 3197 01de 00        		.byte	0
 3198 01df 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 191


 3199 01e0 00        		.byte	0
 3200 01e1 3E        		.byte	62
 3201 01e2 66        		.byte	102
 3202 01e3 03        		.byte	3
 3203 01e4 33        		.byte	51
 3204 01e5 3F        		.byte	63
 3205 01e6 06        		.byte	6
 3206 01e7 33        		.byte	51
 3207 01e8 66        		.byte	102
 3208 01e9 0C        		.byte	12
 3209 01ea 18        		.byte	24
 3210 01eb 1E        		.byte	30
 3211 01ec 0C        		.byte	12
 3212 01ed 6B        		.byte	107
 3213 01ee 33        		.byte	51
 3214 01ef 33        		.byte	51
 3215 01f0 66        		.byte	102
 3216 01f1 33        		.byte	51
 3217 01f2 36        		.byte	54
 3218 01f3 1E        		.byte	30
 3219 01f4 0C        		.byte	12
 3220 01f5 33        		.byte	51
 3221 01f6 33        		.byte	51
 3222 01f7 6B        		.byte	107
 3223 01f8 1C        		.byte	28
 3224 01f9 33        		.byte	51
 3225 01fa 0C        		.byte	12
 3226 01fb 0C        		.byte	12
 3227 01fc 18        		.byte	24
 3228 01fd 0C        		.byte	12
 3229 01fe 00        		.byte	0
 3230 01ff 00        		.byte	0
 3231 0200 00        		.byte	0
 3232 0201 00        		.byte	0
 3233 0202 36        		.byte	54
 3234 0203 1F        		.byte	31
 3235 0204 66        		.byte	102
 3236 0205 33        		.byte	51
 3237 0206 00        		.byte	0
 3238 0207 0C        		.byte	12
 3239 0208 0C        		.byte	12
 3240 0209 66        		.byte	102
 3241 020a 0C        		.byte	12
 3242 020b 0E        		.byte	14
 3243 020c 00        		.byte	0
 3244 020d 0C        		.byte	12
 3245 020e 03        		.byte	3
 3246 020f 33        		.byte	51
 3247 0210 0C        		.byte	12
 3248 0211 33        		.byte	51
 3249 0212 33        		.byte	51
 3250 0213 30        		.byte	48
 3251 0214 33        		.byte	51
 3252 0215 33        		.byte	51
 3253 0216 06        		.byte	6
 3254 0217 33        		.byte	51
 3255 0218 18        		.byte	24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 192


 3256 0219 0C        		.byte	12
 3257 021a 0E        		.byte	14
 3258 021b 0C        		.byte	12
 3259 021c 00        		.byte	0
 3260 021d 0C        		.byte	12
 3261 021e 00        		.byte	0
 3262 021f 03        		.byte	3
 3263 0220 33        		.byte	51
 3264 0221 66        		.byte	102
 3265 0222 66        		.byte	102
 3266 0223 36        		.byte	54
 3267 0224 46        		.byte	70
 3268 0225 06        		.byte	6
 3269 0226 66        		.byte	102
 3270 0227 33        		.byte	51
 3271 0228 0C        		.byte	12
 3272 0229 33        		.byte	51
 3273 022a 66        		.byte	102
 3274 022b 66        		.byte	102
 3275 022c 63        		.byte	99
 3276 022d 63        		.byte	99
 3277 022e 36        		.byte	54
 3278 022f 06        		.byte	6
 3279 0230 1E        		.byte	30
 3280 0231 36        		.byte	54
 3281 0232 33        		.byte	51
 3282 0233 0C        		.byte	12
 3283 0234 33        		.byte	51
 3284 0235 1E        		.byte	30
 3285 0236 77        		.byte	119
 3286 0237 63        		.byte	99
 3287 0238 0C        		.byte	12
 3288 0239 63        		.byte	99
 3289 023a 06        		.byte	6
 3290 023b 60        		.byte	96
 3291 023c 18        		.byte	24
 3292 023d 00        		.byte	0
 3293 023e 00        		.byte	0
 3294 023f 00        		.byte	0
 3295 0240 33        		.byte	51
 3296 0241 66        		.byte	102
 3297 0242 33        		.byte	51
 3298 0243 33        		.byte	51
 3299 0244 03        		.byte	3
 3300 0245 06        		.byte	6
 3301 0246 3E        		.byte	62
 3302 0247 66        		.byte	102
 3303 0248 0C        		.byte	12
 3304 0249 18        		.byte	24
 3305 024a 36        		.byte	54
 3306 024b 0C        		.byte	12
 3307 024c 63        		.byte	99
 3308 024d 33        		.byte	51
 3309 024e 33        		.byte	51
 3310 024f 3E        		.byte	62
 3311 0250 3E        		.byte	62
 3312 0251 06        		.byte	6
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 193


 3313 0252 30        		.byte	48
 3314 0253 2C        		.byte	44
 3315 0254 33        		.byte	51
 3316 0255 1E        		.byte	30
 3317 0256 7F        		.byte	127
 3318 0257 36        		.byte	54
 3319 0258 3E        		.byte	62
 3320 0259 26        		.byte	38
 3321 025a 0C        		.byte	12
 3322 025b 18        		.byte	24
 3323 025c 0C        		.byte	12
 3324 025d 00        		.byte	0
 3325 025e 00        		.byte	0
 3326 025f 0C        		.byte	12
 3327 0260 00        		.byte	0
 3328 0261 36        		.byte	54
 3329 0262 0C        		.byte	12
 3330 0263 63        		.byte	99
 3331 0264 6E        		.byte	110
 3332 0265 00        		.byte	0
 3333 0266 18        		.byte	24
 3334 0267 06        		.byte	6
 3335 0268 00        		.byte	0
 3336 0269 00        		.byte	0
 3337 026a 0C        		.byte	12
 3338 026b 00        		.byte	0
 3339 026c 0C        		.byte	12
 3340 026d 01        		.byte	1
 3341 026e 1E        		.byte	30
 3342 026f 3F        		.byte	63
 3343 0270 3F        		.byte	63
 3344 0271 1E        		.byte	30
 3345 0272 30        		.byte	48
 3346 0273 1E        		.byte	30
 3347 0274 1E        		.byte	30
 3348 0275 06        		.byte	6
 3349 0276 1E        		.byte	30
 3350 0277 0E        		.byte	14
 3351 0278 0C        		.byte	12
 3352 0279 0C        		.byte	12
 3353 027a 18        		.byte	24
 3354 027b 00        		.byte	0
 3355 027c 06        		.byte	6
 3356 027d 0C        		.byte	12
 3357 027e 1E        		.byte	30
 3358 027f 33        		.byte	51
 3359 0280 3F        		.byte	63
 3360 0281 3C        		.byte	60
 3361 0282 3F        		.byte	63
 3362 0283 7F        		.byte	127
 3363 0284 0F        		.byte	15
 3364 0285 7C        		.byte	124
 3365 0286 33        		.byte	51
 3366 0287 1E        		.byte	30
 3367 0288 1E        		.byte	30
 3368 0289 67        		.byte	103
 3369 028a 7F        		.byte	127
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 194


 3370 028b 63        		.byte	99
 3371 028c 63        		.byte	99
 3372 028d 1C        		.byte	28
 3373 028e 0F        		.byte	15
 3374 028f 38        		.byte	56
 3375 0290 67        		.byte	103
 3376 0291 1E        		.byte	30
 3377 0292 1E        		.byte	30
 3378 0293 3F        		.byte	63
 3379 0294 0C        		.byte	12
 3380 0295 63        		.byte	99
 3381 0296 63        		.byte	99
 3382 0297 1E        		.byte	30
 3383 0298 7F        		.byte	127
 3384 0299 1E        		.byte	30
 3385 029a 40        		.byte	64
 3386 029b 1E        		.byte	30
 3387 029c 00        		.byte	0
 3388 029d 00        		.byte	0
 3389 029e 00        		.byte	0
 3390 029f 6E        		.byte	110
 3391 02a0 3D        		.byte	61
 3392 02a1 1E        		.byte	30
 3393 02a2 6E        		.byte	110
 3394 02a3 1E        		.byte	30
 3395 02a4 0F        		.byte	15
 3396 02a5 30        		.byte	48
 3397 02a6 67        		.byte	103
 3398 02a7 1E        		.byte	30
 3399 02a8 1B        		.byte	27
 3400 02a9 67        		.byte	103
 3401 02aa 1E        		.byte	30
 3402 02ab 63        		.byte	99
 3403 02ac 33        		.byte	51
 3404 02ad 1E        		.byte	30
 3405 02ae 06        		.byte	6
 3406 02af 30        		.byte	48
 3407 02b0 0F        		.byte	15
 3408 02b1 1F        		.byte	31
 3409 02b2 18        		.byte	24
 3410 02b3 6E        		.byte	110
 3411 02b4 0C        		.byte	12
 3412 02b5 36        		.byte	54
 3413 02b6 63        		.byte	99
 3414 02b7 30        		.byte	48
 3415 02b8 3F        		.byte	63
 3416 02b9 38        		.byte	56
 3417 02ba 18        		.byte	24
 3418 02bb 07        		.byte	7
 3419 02bc 00        		.byte	0
 3420 02bd 00        		.byte	0
 3421 02be 00        		.byte	0
 3422 02bf 00        		.byte	0
 3423 02c0 00        		.byte	0
 3424 02c1 00        		.byte	0
 3425 02c2 00        		.byte	0
 3426 02c3 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 195


 3427 02c4 00        		.byte	0
 3428 02c5 00        		.byte	0
 3429 02c6 00        		.byte	0
 3430 02c7 00        		.byte	0
 3431 02c8 00        		.byte	0
 3432 02c9 06        		.byte	6
 3433 02ca 00        		.byte	0
 3434 02cb 00        		.byte	0
 3435 02cc 00        		.byte	0
 3436 02cd 00        		.byte	0
 3437 02ce 00        		.byte	0
 3438 02cf 00        		.byte	0
 3439 02d0 00        		.byte	0
 3440 02d1 00        		.byte	0
 3441 02d2 00        		.byte	0
 3442 02d3 00        		.byte	0
 3443 02d4 00        		.byte	0
 3444 02d5 00        		.byte	0
 3445 02d6 00        		.byte	0
 3446 02d7 00        		.byte	0
 3447 02d8 06        		.byte	6
 3448 02d9 00        		.byte	0
 3449 02da 00        		.byte	0
 3450 02db 00        		.byte	0
 3451 02dc 00        		.byte	0
 3452 02dd 00        		.byte	0
 3453 02de 00        		.byte	0
 3454 02df 00        		.byte	0
 3455 02e0 00        		.byte	0
 3456 02e1 00        		.byte	0
 3457 02e2 00        		.byte	0
 3458 02e3 00        		.byte	0
 3459 02e4 00        		.byte	0
 3460 02e5 00        		.byte	0
 3461 02e6 00        		.byte	0
 3462 02e7 00        		.byte	0
 3463 02e8 00        		.byte	0
 3464 02e9 00        		.byte	0
 3465 02ea 00        		.byte	0
 3466 02eb 00        		.byte	0
 3467 02ec 00        		.byte	0
 3468 02ed 00        		.byte	0
 3469 02ee 00        		.byte	0
 3470 02ef 00        		.byte	0
 3471 02f0 00        		.byte	0
 3472 02f1 00        		.byte	0
 3473 02f2 00        		.byte	0
 3474 02f3 00        		.byte	0
 3475 02f4 00        		.byte	0
 3476 02f5 00        		.byte	0
 3477 02f6 00        		.byte	0
 3478 02f7 00        		.byte	0
 3479 02f8 00        		.byte	0
 3480 02f9 00        		.byte	0
 3481 02fa 00        		.byte	0
 3482 02fb 00        		.byte	0
 3483 02fc FF        		.byte	-1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 196


 3484 02fd 00        		.byte	0
 3485 02fe 00        		.byte	0
 3486 02ff 00        		.byte	0
 3487 0300 00        		.byte	0
 3488 0301 00        		.byte	0
 3489 0302 00        		.byte	0
 3490 0303 00        		.byte	0
 3491 0304 1F        		.byte	31
 3492 0305 00        		.byte	0
 3493 0306 00        		.byte	0
 3494 0307 0E        		.byte	14
 3495 0308 00        		.byte	0
 3496 0309 00        		.byte	0
 3497 030a 00        		.byte	0
 3498 030b 00        		.byte	0
 3499 030c 00        		.byte	0
 3500 030d 0F        		.byte	15
 3501 030e 78        		.byte	120
 3502 030f 00        		.byte	0
 3503 0310 00        		.byte	0
 3504 0311 00        		.byte	0
 3505 0312 00        		.byte	0
 3506 0313 00        		.byte	0
 3507 0314 00        		.byte	0
 3508 0315 00        		.byte	0
 3509 0316 1F        		.byte	31
 3510 0317 00        		.byte	0
 3511 0318 00        		.byte	0
 3512 0319 00        		.byte	0
 3513 031a 00        		.byte	0
 3514 031b 00        		.byte	0
 3515               	.global	pieceNum
 3516               	.global	pieceNum
 3517               		.section .bss
 3518               		.type	pieceNum, @object
 3519               		.size	pieceNum, 1
 3520               	pieceNum:
 3521 0000 00        		.skip 1,0
 3522               	.global	pieceOrientation
 3523               	.global	pieceOrientation
 3524               		.type	pieceOrientation, @object
 3525               		.size	pieceOrientation, 1
 3526               	pieceOrientation:
 3527 0001 00        		.skip 1,0
 3528               	.global	pieceTopRow
 3529               	.global	pieceTopRow
 3530               		.type	pieceTopRow, @object
 3531               		.size	pieceTopRow, 1
 3532               	pieceTopRow:
 3533 0002 00        		.skip 1,0
 3534               	.global	pieceLeftCol
 3535               	.global	pieceLeftCol
 3536               		.type	pieceLeftCol, @object
 3537               		.size	pieceLeftCol, 1
 3538               	pieceLeftCol:
 3539 0003 00        		.skip 1,0
 3540               	.global	tetColorScheme
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 197


 3541               	.global	tetColorScheme
 3542               		.type	tetColorScheme, @object
 3543               		.size	tetColorScheme, 1
 3544               	tetColorScheme:
 3545 0004 00        		.skip 1,0
 3546               	.global	pgm_tetPiece
 3547               		.section	.progmem.data
 3548               		.type	pgm_tetPiece, @object
 3549               		.size	pgm_tetPiece, 56
 3550               	pgm_tetPiece:
 3551 031c F000      		.word	240
 3552 031e 2222      		.word	8738
 3553 0320 F000      		.word	240
 3554 0322 2222      		.word	8738
 3555 0324 600C      		.word	3168
 3556 0326 6402      		.word	612
 3557 0328 600C      		.word	3168
 3558 032a 6402      		.word	612
 3559 032c C006      		.word	1728
 3560 032e 408C      		.word	-29632
 3561 0330 C006      		.word	1728
 3562 0332 408C      		.word	-29632
 3563 0334 E004      		.word	1248
 3564 0336 C404      		.word	1220
 3565 0338 E400      		.word	228
 3566 033a 6404      		.word	1124
 3567 033c E008      		.word	2272
 3568 033e 4C04      		.word	1100
 3569 0340 E200      		.word	226
 3570 0342 4406      		.word	1604
 3571 0344 E002      		.word	736
 3572 0346 440C      		.word	3140
 3573 0348 E800      		.word	232
 3574 034a 4604      		.word	1094
 3575 034c 6006      		.word	1632
 3576 034e 6006      		.word	1632
 3577 0350 6006      		.word	1632
 3578 0352 6006      		.word	1632
 3579               	.global	segPosition
 3580               	.global	segPosition
 3581               		.section .bss
 3582               		.type	segPosition, @object
 3583               		.size	segPosition, 1
 3584               	segPosition:
 3585 0005 00        		.skip 1,0
 3586               	.global	dataEnable
 3587               	.global	dataEnable
 3588               		.type	dataEnable, @object
 3589               		.size	dataEnable, 1
 3590               	dataEnable:
 3591 0006 00        		.skip 1,0
 3592               	.global	vSync
 3593               	.global	vSync
 3594               		.type	vSync, @object
 3595               		.size	vSync, 1
 3596               	vSync:
 3597 0007 00        		.skip 1,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 198


 3598               	.global	hsyncCount
 3599               	.global	hsyncCount
 3600               		.type	hsyncCount, @object
 3601               		.size	hsyncCount, 2
 3602               	hsyncCount:
 3603 0008 0000      		.skip 2,0
 3604               	.global	frameCount
 3605               	.global	frameCount
 3606               		.type	frameCount, @object
 3607               		.size	frameCount, 1
 3608               	frameCount:
 3609 000a 00        		.skip 1,0
 3610               	.global	pgm_image1
 3611               		.section	.progmem.data
 3612               		.type	pgm_image1, @object
 3613               		.size	pgm_image1, 256
 3614               	pgm_image1:
 3615 0354 C0        		.byte	-64
 3616 0355 C0        		.byte	-64
 3617 0356 C0        		.byte	-64
 3618 0357 C0        		.byte	-64
 3619 0358 C0        		.byte	-64
 3620 0359 00        		.byte	0
 3621 035a 00        		.byte	0
 3622 035b 00        		.byte	0
 3623 035c 00        		.byte	0
 3624 035d 00        		.byte	0
 3625 035e 00        		.byte	0
 3626 035f C0        		.byte	-64
 3627 0360 C0        		.byte	-64
 3628 0361 C0        		.byte	-64
 3629 0362 C0        		.byte	-64
 3630 0363 C0        		.byte	-64
 3631 0364 C0        		.byte	-64
 3632 0365 C0        		.byte	-64
 3633 0366 C0        		.byte	-64
 3634 0367 00        		.byte	0
 3635 0368 00        		.byte	0
 3636 0369 0F        		.byte	15
 3637 036a 0F        		.byte	15
 3638 036b 0F        		.byte	15
 3639 036c 0F        		.byte	15
 3640 036d 0F        		.byte	15
 3641 036e 0F        		.byte	15
 3642 036f 00        		.byte	0
 3643 0370 00        		.byte	0
 3644 0371 C0        		.byte	-64
 3645 0372 C0        		.byte	-64
 3646 0373 C0        		.byte	-64
 3647 0374 C0        		.byte	-64
 3648 0375 C0        		.byte	-64
 3649 0376 00        		.byte	0
 3650 0377 00        		.byte	0
 3651 0378 0F        		.byte	15
 3652 0379 0F        		.byte	15
 3653 037a 0F        		.byte	15
 3654 037b 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 199


 3655 037c 0F        		.byte	15
 3656 037d 0F        		.byte	15
 3657 037e 0F        		.byte	15
 3658 037f 0F        		.byte	15
 3659 0380 00        		.byte	0
 3660 0381 00        		.byte	0
 3661 0382 C0        		.byte	-64
 3662 0383 C0        		.byte	-64
 3663 0384 C0        		.byte	-64
 3664 0385 00        		.byte	0
 3665 0386 00        		.byte	0
 3666 0387 0F        		.byte	15
 3667 0388 0F        		.byte	15
 3668 0389 0F        		.byte	15
 3669 038a 0F        		.byte	15
 3670 038b 0F        		.byte	15
 3671 038c 0F        		.byte	15
 3672 038d 0F        		.byte	15
 3673 038e 0F        		.byte	15
 3674 038f 0F        		.byte	15
 3675 0390 0F        		.byte	15
 3676 0391 00        		.byte	0
 3677 0392 00        		.byte	0
 3678 0393 C0        		.byte	-64
 3679 0394 C0        		.byte	-64
 3680 0395 00        		.byte	0
 3681 0396 0F        		.byte	15
 3682 0397 0F        		.byte	15
 3683 0398 0F        		.byte	15
 3684 0399 00        		.byte	0
 3685 039a 0F        		.byte	15
 3686 039b 0F        		.byte	15
 3687 039c 0F        		.byte	15
 3688 039d 0F        		.byte	15
 3689 039e 00        		.byte	0
 3690 039f 0F        		.byte	15
 3691 03a0 0F        		.byte	15
 3692 03a1 0F        		.byte	15
 3693 03a2 00        		.byte	0
 3694 03a3 C0        		.byte	-64
 3695 03a4 00        		.byte	0
 3696 03a5 0F        		.byte	15
 3697 03a6 0F        		.byte	15
 3698 03a7 0F        		.byte	15
 3699 03a8 00        		.byte	0
 3700 03a9 00        		.byte	0
 3701 03aa 00        		.byte	0
 3702 03ab 0F        		.byte	15
 3703 03ac 0F        		.byte	15
 3704 03ad 00        		.byte	0
 3705 03ae 00        		.byte	0
 3706 03af 00        		.byte	0
 3707 03b0 0F        		.byte	15
 3708 03b1 0F        		.byte	15
 3709 03b2 0F        		.byte	15
 3710 03b3 00        		.byte	0
 3711 03b4 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 200


 3712 03b5 0F        		.byte	15
 3713 03b6 0F        		.byte	15
 3714 03b7 0F        		.byte	15
 3715 03b8 0F        		.byte	15
 3716 03b9 00        		.byte	0
 3717 03ba 0F        		.byte	15
 3718 03bb 0F        		.byte	15
 3719 03bc 0F        		.byte	15
 3720 03bd 0F        		.byte	15
 3721 03be 00        		.byte	0
 3722 03bf 0F        		.byte	15
 3723 03c0 0F        		.byte	15
 3724 03c1 0F        		.byte	15
 3725 03c2 0F        		.byte	15
 3726 03c3 00        		.byte	0
 3727 03c4 00        		.byte	0
 3728 03c5 0F        		.byte	15
 3729 03c6 0F        		.byte	15
 3730 03c7 0F        		.byte	15
 3731 03c8 0F        		.byte	15
 3732 03c9 0F        		.byte	15
 3733 03ca 0F        		.byte	15
 3734 03cb 0F        		.byte	15
 3735 03cc 0F        		.byte	15
 3736 03cd 0F        		.byte	15
 3737 03ce 0F        		.byte	15
 3738 03cf 0F        		.byte	15
 3739 03d0 0F        		.byte	15
 3740 03d1 0F        		.byte	15
 3741 03d2 0F        		.byte	15
 3742 03d3 00        		.byte	0
 3743 03d4 00        		.byte	0
 3744 03d5 0F        		.byte	15
 3745 03d6 0F        		.byte	15
 3746 03d7 0F        		.byte	15
 3747 03d8 0F        		.byte	15
 3748 03d9 0F        		.byte	15
 3749 03da 0F        		.byte	15
 3750 03db 0F        		.byte	15
 3751 03dc 0F        		.byte	15
 3752 03dd 0F        		.byte	15
 3753 03de 0F        		.byte	15
 3754 03df 0F        		.byte	15
 3755 03e0 0F        		.byte	15
 3756 03e1 0F        		.byte	15
 3757 03e2 0F        		.byte	15
 3758 03e3 00        		.byte	0
 3759 03e4 00        		.byte	0
 3760 03e5 0F        		.byte	15
 3761 03e6 0F        		.byte	15
 3762 03e7 00        		.byte	0
 3763 03e8 00        		.byte	0
 3764 03e9 0F        		.byte	15
 3765 03ea 0F        		.byte	15
 3766 03eb 0F        		.byte	15
 3767 03ec 0F        		.byte	15
 3768 03ed 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 201


 3769 03ee 0F        		.byte	15
 3770 03ef 00        		.byte	0
 3771 03f0 00        		.byte	0
 3772 03f1 0F        		.byte	15
 3773 03f2 0F        		.byte	15
 3774 03f3 00        		.byte	0
 3775 03f4 00        		.byte	0
 3776 03f5 0F        		.byte	15
 3777 03f6 0F        		.byte	15
 3778 03f7 0F        		.byte	15
 3779 03f8 00        		.byte	0
 3780 03f9 00        		.byte	0
 3781 03fa 0F        		.byte	15
 3782 03fb 0F        		.byte	15
 3783 03fc 0F        		.byte	15
 3784 03fd 0F        		.byte	15
 3785 03fe 00        		.byte	0
 3786 03ff 00        		.byte	0
 3787 0400 0F        		.byte	15
 3788 0401 0F        		.byte	15
 3789 0402 0F        		.byte	15
 3790 0403 00        		.byte	0
 3791 0404 C0        		.byte	-64
 3792 0405 00        		.byte	0
 3793 0406 0F        		.byte	15
 3794 0407 0F        		.byte	15
 3795 0408 0F        		.byte	15
 3796 0409 00        		.byte	0
 3797 040a 00        		.byte	0
 3798 040b 00        		.byte	0
 3799 040c 00        		.byte	0
 3800 040d 00        		.byte	0
 3801 040e 00        		.byte	0
 3802 040f 0F        		.byte	15
 3803 0410 0F        		.byte	15
 3804 0411 0F        		.byte	15
 3805 0412 00        		.byte	0
 3806 0413 C0        		.byte	-64
 3807 0414 C0        		.byte	-64
 3808 0415 00        		.byte	0
 3809 0416 00        		.byte	0
 3810 0417 0F        		.byte	15
 3811 0418 0F        		.byte	15
 3812 0419 0F        		.byte	15
 3813 041a 0F        		.byte	15
 3814 041b 0F        		.byte	15
 3815 041c 0F        		.byte	15
 3816 041d 0F        		.byte	15
 3817 041e 0F        		.byte	15
 3818 041f 0F        		.byte	15
 3819 0420 0F        		.byte	15
 3820 0421 00        		.byte	0
 3821 0422 00        		.byte	0
 3822 0423 C0        		.byte	-64
 3823 0424 C0        		.byte	-64
 3824 0425 C0        		.byte	-64
 3825 0426 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 202


 3826 0427 00        		.byte	0
 3827 0428 0F        		.byte	15
 3828 0429 0F        		.byte	15
 3829 042a 0F        		.byte	15
 3830 042b 0F        		.byte	15
 3831 042c 0F        		.byte	15
 3832 042d 0F        		.byte	15
 3833 042e 0F        		.byte	15
 3834 042f 0F        		.byte	15
 3835 0430 00        		.byte	0
 3836 0431 00        		.byte	0
 3837 0432 C0        		.byte	-64
 3838 0433 C0        		.byte	-64
 3839 0434 C0        		.byte	-64
 3840 0435 C0        		.byte	-64
 3841 0436 C0        		.byte	-64
 3842 0437 00        		.byte	0
 3843 0438 00        		.byte	0
 3844 0439 0F        		.byte	15
 3845 043a 0F        		.byte	15
 3846 043b 0F        		.byte	15
 3847 043c 0F        		.byte	15
 3848 043d 0F        		.byte	15
 3849 043e 0F        		.byte	15
 3850 043f 00        		.byte	0
 3851 0440 00        		.byte	0
 3852 0441 C0        		.byte	-64
 3853 0442 C0        		.byte	-64
 3854 0443 C0        		.byte	-64
 3855 0444 C0        		.byte	-64
 3856 0445 C0        		.byte	-64
 3857 0446 C0        		.byte	-64
 3858 0447 C0        		.byte	-64
 3859 0448 C0        		.byte	-64
 3860 0449 00        		.byte	0
 3861 044a 00        		.byte	0
 3862 044b 00        		.byte	0
 3863 044c 00        		.byte	0
 3864 044d 00        		.byte	0
 3865 044e 00        		.byte	0
 3866 044f C0        		.byte	-64
 3867 0450 C0        		.byte	-64
 3868 0451 C0        		.byte	-64
 3869 0452 C0        		.byte	-64
 3870 0453 C0        		.byte	-64
 3871               	.global	pgm_image2
 3872               		.type	pgm_image2, @object
 3873               		.size	pgm_image2, 256
 3874               	pgm_image2:
 3875 0454 C0        		.byte	-64
 3876 0455 C0        		.byte	-64
 3877 0456 C0        		.byte	-64
 3878 0457 C0        		.byte	-64
 3879 0458 C0        		.byte	-64
 3880 0459 00        		.byte	0
 3881 045a 00        		.byte	0
 3882 045b 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 203


 3883 045c 00        		.byte	0
 3884 045d 00        		.byte	0
 3885 045e 00        		.byte	0
 3886 045f C0        		.byte	-64
 3887 0460 C0        		.byte	-64
 3888 0461 C0        		.byte	-64
 3889 0462 C0        		.byte	-64
 3890 0463 C0        		.byte	-64
 3891 0464 C0        		.byte	-64
 3892 0465 C0        		.byte	-64
 3893 0466 C0        		.byte	-64
 3894 0467 00        		.byte	0
 3895 0468 00        		.byte	0
 3896 0469 0F        		.byte	15
 3897 046a 0F        		.byte	15
 3898 046b 0F        		.byte	15
 3899 046c 0F        		.byte	15
 3900 046d 0F        		.byte	15
 3901 046e 0F        		.byte	15
 3902 046f 00        		.byte	0
 3903 0470 00        		.byte	0
 3904 0471 C0        		.byte	-64
 3905 0472 C0        		.byte	-64
 3906 0473 C0        		.byte	-64
 3907 0474 C0        		.byte	-64
 3908 0475 C0        		.byte	-64
 3909 0476 00        		.byte	0
 3910 0477 00        		.byte	0
 3911 0478 0F        		.byte	15
 3912 0479 0F        		.byte	15
 3913 047a 0F        		.byte	15
 3914 047b 0F        		.byte	15
 3915 047c 0F        		.byte	15
 3916 047d 0F        		.byte	15
 3917 047e 0F        		.byte	15
 3918 047f 0F        		.byte	15
 3919 0480 00        		.byte	0
 3920 0481 00        		.byte	0
 3921 0482 C0        		.byte	-64
 3922 0483 C0        		.byte	-64
 3923 0484 C0        		.byte	-64
 3924 0485 00        		.byte	0
 3925 0486 00        		.byte	0
 3926 0487 0F        		.byte	15
 3927 0488 0F        		.byte	15
 3928 0489 0F        		.byte	15
 3929 048a 0F        		.byte	15
 3930 048b 0F        		.byte	15
 3931 048c 0F        		.byte	15
 3932 048d 0F        		.byte	15
 3933 048e 0F        		.byte	15
 3934 048f 0F        		.byte	15
 3935 0490 0F        		.byte	15
 3936 0491 00        		.byte	0
 3937 0492 00        		.byte	0
 3938 0493 C0        		.byte	-64
 3939 0494 C0        		.byte	-64
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 204


 3940 0495 00        		.byte	0
 3941 0496 0F        		.byte	15
 3942 0497 0F        		.byte	15
 3943 0498 0F        		.byte	15
 3944 0499 00        		.byte	0
 3945 049a 0F        		.byte	15
 3946 049b 0F        		.byte	15
 3947 049c 0F        		.byte	15
 3948 049d 0F        		.byte	15
 3949 049e 0F        		.byte	15
 3950 049f 0F        		.byte	15
 3951 04a0 0F        		.byte	15
 3952 04a1 0F        		.byte	15
 3953 04a2 00        		.byte	0
 3954 04a3 C0        		.byte	-64
 3955 04a4 00        		.byte	0
 3956 04a5 0F        		.byte	15
 3957 04a6 0F        		.byte	15
 3958 04a7 0F        		.byte	15
 3959 04a8 00        		.byte	0
 3960 04a9 00        		.byte	0
 3961 04aa 00        		.byte	0
 3962 04ab 0F        		.byte	15
 3963 04ac 0F        		.byte	15
 3964 04ad 00        		.byte	0
 3965 04ae 0F        		.byte	15
 3966 04af 0F        		.byte	15
 3967 04b0 0F        		.byte	15
 3968 04b1 0F        		.byte	15
 3969 04b2 0F        		.byte	15
 3970 04b3 00        		.byte	0
 3971 04b4 00        		.byte	0
 3972 04b5 0F        		.byte	15
 3973 04b6 0F        		.byte	15
 3974 04b7 0F        		.byte	15
 3975 04b8 0F        		.byte	15
 3976 04b9 00        		.byte	0
 3977 04ba 0F        		.byte	15
 3978 04bb 0F        		.byte	15
 3979 04bc 0F        		.byte	15
 3980 04bd 0F        		.byte	15
 3981 04be 00        		.byte	0
 3982 04bf 00        		.byte	0
 3983 04c0 0F        		.byte	15
 3984 04c1 0F        		.byte	15
 3985 04c2 0F        		.byte	15
 3986 04c3 00        		.byte	0
 3987 04c4 00        		.byte	0
 3988 04c5 0F        		.byte	15
 3989 04c6 0F        		.byte	15
 3990 04c7 0F        		.byte	15
 3991 04c8 0F        		.byte	15
 3992 04c9 0F        		.byte	15
 3993 04ca 0F        		.byte	15
 3994 04cb 0F        		.byte	15
 3995 04cc 0F        		.byte	15
 3996 04cd 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 205


 3997 04ce 0F        		.byte	15
 3998 04cf 0F        		.byte	15
 3999 04d0 0F        		.byte	15
 4000 04d1 0F        		.byte	15
 4001 04d2 0F        		.byte	15
 4002 04d3 00        		.byte	0
 4003 04d4 00        		.byte	0
 4004 04d5 0F        		.byte	15
 4005 04d6 0F        		.byte	15
 4006 04d7 0F        		.byte	15
 4007 04d8 0F        		.byte	15
 4008 04d9 0F        		.byte	15
 4009 04da 0F        		.byte	15
 4010 04db 0F        		.byte	15
 4011 04dc 0F        		.byte	15
 4012 04dd 0F        		.byte	15
 4013 04de 0F        		.byte	15
 4014 04df 0F        		.byte	15
 4015 04e0 0F        		.byte	15
 4016 04e1 0F        		.byte	15
 4017 04e2 0F        		.byte	15
 4018 04e3 00        		.byte	0
 4019 04e4 00        		.byte	0
 4020 04e5 0F        		.byte	15
 4021 04e6 0F        		.byte	15
 4022 04e7 00        		.byte	0
 4023 04e8 00        		.byte	0
 4024 04e9 0F        		.byte	15
 4025 04ea 0F        		.byte	15
 4026 04eb 0F        		.byte	15
 4027 04ec 0F        		.byte	15
 4028 04ed 0F        		.byte	15
 4029 04ee 0F        		.byte	15
 4030 04ef 00        		.byte	0
 4031 04f0 00        		.byte	0
 4032 04f1 0F        		.byte	15
 4033 04f2 0F        		.byte	15
 4034 04f3 00        		.byte	0
 4035 04f4 00        		.byte	0
 4036 04f5 0F        		.byte	15
 4037 04f6 0F        		.byte	15
 4038 04f7 0F        		.byte	15
 4039 04f8 00        		.byte	0
 4040 04f9 00        		.byte	0
 4041 04fa 0F        		.byte	15
 4042 04fb 0F        		.byte	15
 4043 04fc 0F        		.byte	15
 4044 04fd 0F        		.byte	15
 4045 04fe 00        		.byte	0
 4046 04ff 00        		.byte	0
 4047 0500 0F        		.byte	15
 4048 0501 0F        		.byte	15
 4049 0502 0F        		.byte	15
 4050 0503 00        		.byte	0
 4051 0504 C0        		.byte	-64
 4052 0505 00        		.byte	0
 4053 0506 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 206


 4054 0507 0F        		.byte	15
 4055 0508 0F        		.byte	15
 4056 0509 00        		.byte	0
 4057 050a 00        		.byte	0
 4058 050b 00        		.byte	0
 4059 050c 00        		.byte	0
 4060 050d 00        		.byte	0
 4061 050e 00        		.byte	0
 4062 050f 0F        		.byte	15
 4063 0510 0F        		.byte	15
 4064 0511 0F        		.byte	15
 4065 0512 00        		.byte	0
 4066 0513 C0        		.byte	-64
 4067 0514 C0        		.byte	-64
 4068 0515 00        		.byte	0
 4069 0516 00        		.byte	0
 4070 0517 0F        		.byte	15
 4071 0518 0F        		.byte	15
 4072 0519 0F        		.byte	15
 4073 051a 00        		.byte	0
 4074 051b 03        		.byte	3
 4075 051c 00        		.byte	0
 4076 051d 03        		.byte	3
 4077 051e 00        		.byte	0
 4078 051f 0F        		.byte	15
 4079 0520 0F        		.byte	15
 4080 0521 00        		.byte	0
 4081 0522 00        		.byte	0
 4082 0523 C0        		.byte	-64
 4083 0524 C0        		.byte	-64
 4084 0525 C0        		.byte	-64
 4085 0526 00        		.byte	0
 4086 0527 00        		.byte	0
 4087 0528 0F        		.byte	15
 4088 0529 0F        		.byte	15
 4089 052a 00        		.byte	0
 4090 052b 03        		.byte	3
 4091 052c 03        		.byte	3
 4092 052d 03        		.byte	3
 4093 052e 00        		.byte	0
 4094 052f 0F        		.byte	15
 4095 0530 00        		.byte	0
 4096 0531 00        		.byte	0
 4097 0532 C0        		.byte	-64
 4098 0533 C0        		.byte	-64
 4099 0534 C0        		.byte	-64
 4100 0535 C0        		.byte	-64
 4101 0536 C0        		.byte	-64
 4102 0537 00        		.byte	0
 4103 0538 00        		.byte	0
 4104 0539 0F        		.byte	15
 4105 053a 0F        		.byte	15
 4106 053b 00        		.byte	0
 4107 053c 00        		.byte	0
 4108 053d 00        		.byte	0
 4109 053e 0F        		.byte	15
 4110 053f 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 207


 4111 0540 00        		.byte	0
 4112 0541 C0        		.byte	-64
 4113 0542 C0        		.byte	-64
 4114 0543 C0        		.byte	-64
 4115 0544 C0        		.byte	-64
 4116 0545 C0        		.byte	-64
 4117 0546 C0        		.byte	-64
 4118 0547 C0        		.byte	-64
 4119 0548 C0        		.byte	-64
 4120 0549 00        		.byte	0
 4121 054a 00        		.byte	0
 4122 054b 00        		.byte	0
 4123 054c 00        		.byte	0
 4124 054d 00        		.byte	0
 4125 054e 00        		.byte	0
 4126 054f C0        		.byte	-64
 4127 0550 C0        		.byte	-64
 4128 0551 C0        		.byte	-64
 4129 0552 C0        		.byte	-64
 4130 0553 C0        		.byte	-64
 4131               		.lcomm frameCount.2275,1
 4132               		.type	__c.2309, @object
 4133               		.size	__c.2309, 47
 4134               	__c.2309:
 4135 0554 2054 6865 		.string	" The Quick Brown Fox Jumped Over The Lazy Dog!"
 4135      2051 7569 
 4135      636B 2042 
 4135      726F 776E 
 4135      2046 6F78 
 4136               		.lcomm frameCount.2291,1
 4137               		.lcomm lastThetaOffset.2290,2
 4138               		.lcomm last_rbValue.2025,1
 4139               		.lcomm newPieceHitCount.1823,1
 4140               		.lcomm callCount.1822,1
 4141               		.comm tetRow,72,1
 4142               		.comm rowSegBuffer,138,1
 4143               		.comm rowBuffer,64,1
 4144               		.comm pimage,2,1
 4145               		.data
 4146               		.type	CSWTCH.58, @object
 4147               		.size	CSWTCH.58, 7
 4148               	CSWTCH.58:
 4149 0000 03        		.byte	3
 4150 0001 07        		.byte	7
 4151 0002 0F        		.byte	15
 4152 0003 0C        		.byte	12
 4153 0004 3C        		.byte	60
 4154 0005 30        		.byte	48
 4155 0006 33        		.byte	51
 4156               		.type	CSWTCH.61, @object
 4157               		.size	CSWTCH.61, 7
 4158               	CSWTCH.61:
 4159 0007 01        		.byte	1
 4160 0008 04        		.byte	4
 4161 0009 10        		.byte	16
 4162 000a 14        		.byte	20
 4163 000b 11        		.byte	17
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 208


 4164 000c 05        		.byte	5
 4165 000d 15        		.byte	21
 4166               		.stabs	"header:G(0,16)=ar(0,17)=r(0,17);0;0177777;;0;35;(3,2)",32,0,16,0
 4167               		.stabs	"characters:G(0,18)=ar(0,17);0;7;(0,19)=ar(0,17);0;94;(3,2)",32,0,30,0
 4168               		.stabs	"pgm_tetPiece:G(0,20)=ar(0,17);0;6;(0,21)=ar(0,17);0;3;(3,4)",32,0,488,0
 4169               		.stabs	"tetRow:G(0,22)=ar(0,17);0;17;(3,6)",32,0,52,0
 4170               		.stabs	"pieceNum:G(3,2)",32,0,91,0
 4171               		.stabs	"pieceOrientation:G(3,2)",32,0,92,0
 4172               		.stabs	"pieceTopRow:G(3,2)",32,0,94,0
 4173               		.stabs	"pieceLeftCol:G(3,2)",32,0,95,0
 4174               		.stabs	"tetColorScheme:G(3,2)",32,0,414,0
 4175               		.stabs	"rowSegBuffer:G(0,23)=ar(0,17);0;68;(13,2)",32,0,108,0
 4176               		.stabs	"segPosition:G(3,2)",32,0,153,0
 4177               		.stabs	"rowBuffer:G(0,24)=ar(0,17);0;63;(3,2)",32,0,81,0
 4178               		.stabs	"pimage:G(0,25)=*(3,2)",32,0,2033,0
 4179               		.stabs	"dataEnable:G(3,2)",32,0,1141,0
 4180               		.stabs	"vSync:G(3,2)",32,0,1142,0
 4181               		.stabs	"hsyncCount:G(3,4)",32,0,1143,0
 4182               		.stabs	"frameCount:G(3,2)",32,0,1148,0
 4183               		.stabs	"pgm_image1:G(0,26)=ar(0,17);0;255;(3,2)",32,0,4006,0
 4184               		.stabs	"pgm_image2:G(0,26)",32,0,4072,0
 4185               		.text
 4186               		.stabs	"",100,0,0,.Letext0
 4187               	.Letext0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 209


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:2      *ABS*:0000003f __SREG__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3      *ABS*:0000003e __SP_H__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4      *ABS*:0000003d __SP_L__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:6      *ABS*:00000001 __zero_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:114    .text:00000000 getTetBrick
                            *COM*:00000048 tetRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:165    .text:00000036 setTetBrick
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:249    .text:000000b2 tetInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:319    .text:000000f0 tetUpdate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4138   .bss:00000010 newPieceHitCount.1823
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3526   .bss:00000001 pieceOrientation
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3538   .bss:00000003 pieceLeftCol
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3532   .bss:00000002 pieceTopRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4139   .bss:00000011 callCount.1822
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3520   .bss:00000000 pieceNum
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3550   .progmem.data:0000031c pgm_tetPiece
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:752    .text:00000340 tetBrick_to_fb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3544   .bss:00000004 tetColorScheme
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4148   .data:00000000 CSWTCH.58
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4158   .data:00000007 CSWTCH.61
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:805    .text:00000370 segClear
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3584   .bss:00000005 segPosition
                            *COM*:0000008a rowSegBuffer
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:836    .text:00000382 segTerminate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:913    .text:000003da newSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1033   .text:0000045a stretchSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1137   .text:000004b8 addSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1194   .text:000004ee rbpix_to_seg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4137   .bss:0000000f last_rbValue.2025
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1286   .text:00000554 fb_to_rb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1343   .text:00000592 pll_enable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1417   .text:000005b2 lvds_timerInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1507   .text:00000600 lcd_Init
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1533   .text:0000060a updateLCD
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3590   .bss:00000006 dataEnable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3596   .bss:00000007 vSync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1656   .text:0000064a LoadNext_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1692   .text:0000068e Done_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1672   .text:00000668 Counter_974
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3602   .bss:00000008 hsyncCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1815   .text:0000070c init_timer0Hsync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1855   .text:00000726 main
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3608   .bss:0000000a frameCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:1898   .text:00000746 __vector_14
                             .bss:0000000b frameCount.2275
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4136   .bss:0000000d lastThetaOffset.2290
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4131   .bss:0000000c frameCount.2291
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:2754   .progmem.data:00000024 characters
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:4134   .progmem.data:00000554 __c.2309
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:2749   .progmem.data:00000000 header
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3614   .progmem.data:00000354 pgm_image1
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s:3874   .progmem.data:00000454 pgm_image2
                            *COM*:00000040 rowBuffer
                            *COM*:00000002 pimage
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//ccgvqafA.s 			page 210



UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulhi3
timer_setWGM
timer_selectDivisor
timer_compareMatchIntSetup
sineRaw8
__udivmodhi4
strncpy_P
strlen_P
