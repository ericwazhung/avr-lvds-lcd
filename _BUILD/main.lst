GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 1


   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.stabs	"/Users/meh/_avrProjects/LCDdirectLVDS/59-reallyCommon2/",100,0,2,.Ltext0
  10               		.stabs	"main.c",100,0,2,.Ltext0
  11               		.text
  12               	.Ltext0:
  13               		.stabs	"gcc2_compiled.",60,0,0,0
  14               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  15               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  16               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  17               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  18               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  19               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  20               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  21               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  22               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  23               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  24               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  25               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  26               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  29               		.stabs	"projInfo.h",130,0,0,0
  30               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdint.h",130,0,0,0
  32               		.stabs	"int8_t:t(3,1)=(0,10)",128,0,121,0
  33               		.stabs	"uint8_t:t(3,2)=(0,11)",128,0,122,0
  34               		.stabs	"int16_t:t(3,3)=(0,1)",128,0,123,0
  35               		.stabs	"uint16_t:t(3,4)=(0,4)",128,0,124,0
  36               		.stabs	"int32_t:t(3,5)=(0,3)",128,0,125,0
  37               		.stabs	"uint32_t:t(3,6)=(0,5)",128,0,126,0
  38               		.stabs	"int64_t:t(3,7)=(0,6)",128,0,128,0
  39               		.stabs	"uint64_t:t(3,8)=(0,7)",128,0,129,0
  40               		.stabs	"intptr_t:t(3,9)=(3,3)",128,0,142,0
  41               		.stabs	"uintptr_t:t(3,10)=(3,4)",128,0,147,0
  42               		.stabs	"int_least8_t:t(3,11)=(3,1)",128,0,159,0
  43               		.stabs	"uint_least8_t:t(3,12)=(3,2)",128,0,164,0
  44               		.stabs	"int_least16_t:t(3,13)=(3,3)",128,0,169,0
  45               		.stabs	"uint_least16_t:t(3,14)=(3,4)",128,0,174,0
  46               		.stabs	"int_least32_t:t(3,15)=(3,5)",128,0,179,0
  47               		.stabs	"uint_least32_t:t(3,16)=(3,6)",128,0,184,0
  48               		.stabs	"int_least64_t:t(3,17)=(3,7)",128,0,192,0
  49               		.stabs	"uint_least64_t:t(3,18)=(3,8)",128,0,199,0
  50               		.stabs	"int_fast8_t:t(3,19)=(3,1)",128,0,213,0
  51               		.stabs	"uint_fast8_t:t(3,20)=(3,2)",128,0,218,0
  52               		.stabs	"int_fast16_t:t(3,21)=(3,3)",128,0,223,0
  53               		.stabs	"uint_fast16_t:t(3,22)=(3,4)",128,0,228,0
  54               		.stabs	"int_fast32_t:t(3,23)=(3,5)",128,0,233,0
  55               		.stabs	"uint_fast32_t:t(3,24)=(3,6)",128,0,238,0
  56               		.stabs	"int_fast64_t:t(3,25)=(3,7)",128,0,246,0
  57               		.stabs	"uint_fast64_t:t(3,26)=(3,8)",128,0,253,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 2


  58               		.stabs	"intmax_t:t(3,27)=(3,7)",128,0,273,0
  59               		.stabs	"uintmax_t:t(3,28)=(3,8)",128,0,278,0
  60               		.stabn	162,0,0,0
  61               		.stabs	"int_farptr_t:t(2,1)=(3,5)",128,0,77,0
  62               		.stabs	"uint_farptr_t:t(2,2)=(3,6)",128,0,81,0
  63               		.stabn	162,0,0,0
  64               		.stabn	162,0,0,0
  65               		.stabs	"main.h",130,0,0,0
  66               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/io.h",130,0,0,0
  67               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdlib.h",130,0,0,0
  72               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/include/stddef.h",130,0,0,0
  73               		.stabs	"size_t:t(8,1)=(0,4)",128,0,211,0
  74               		.stabs	"wchar_t:t(8,2)=(0,1)",128,0,323,0
  75               		.stabn	162,0,0,0
  76               		.stabs	"div_t:t(7,1)=(7,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,71,0
  77               		.stabs	"ldiv_t:t(7,3)=(7,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,77,0
  78               		.stabs	"__compar_fn_t:t(7,5)=(7,6)=*(7,7)=f(0,1)",128,0,80,0
  79               		.stabn	162,0,0,0
  80               		.stabs	"_commonCode_localized/heartbeat/1.21/heartbeat.h",130,0,0,0
  81               		.stabs	"./_commonCode_localized/hfModulation/0.93/hfModulation.h",130,0,0,0
  82               		.stabs	"hfm_t:t(10,1)=(10,2)=B(10,3)=s6runningSum:(3,4),0,16;desiredSum:(3,4),16,16;maxPower:(3,2)
  83               		.stabn	162,0,0,0
  84               		.stabn	162,0,0,0
  85               		.stabn	162,0,0,0
  86               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  87               		.stabs	"prog_void:t(11,1)=(11,2)=(11,2)",128,0,217,0
  88               		.stabs	"prog_char:t(11,3)=(11,4)=@s8;r(11,4);0;255;",128,0,218,0
  89               		.stabs	"prog_uchar:t(11,5)=(11,6)=@s8;r(11,6);0;255;",128,0,219,0
  90               		.stabs	"prog_int8_t:t(11,7)=(11,8)=(0,10)",128,0,221,0
  91               		.stabs	"prog_uint8_t:t(11,9)=(11,10)=(0,11)",128,0,222,0
  92               		.stabs	"prog_int16_t:t(11,11)=(11,12)=(0,1)",128,0,223,0
  93               		.stabs	"prog_uint16_t:t(11,13)=(11,14)=(0,4)",128,0,224,0
  94               		.stabs	"prog_int32_t:t(11,15)=(11,16)=(0,3)",128,0,225,0
  95               		.stabs	"prog_uint32_t:t(11,17)=(11,18)=(0,5)",128,0,226,0
  96               		.stabs	"prog_int64_t:t(11,19)=(11,20)=(0,6)",128,0,228,0
  97               		.stabs	"prog_uint64_t:t(11,21)=(11,22)=(0,7)",128,0,229,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"_commonCode_localized/sineTable/0.99/sineTable.h",130,0,0,0
 100               		.stabs	"theta_t:t(12,1)=(3,3)",128,0,69,0
 101               		.stabs	"sine_t:t(12,2)=(3,3)",128,0,96,0
 102               		.stabs	"mult_t:t(12,3)=(3,5)",128,0,99,0
 103               		.stabs	"axis_t:t(12,4)=(3,5)",128,0,114,0
 104               		.stabn	162,0,0,0
 105               		.stabs	"rowSegBuffer.c",130,0,0,0
 106               		.stabs	"_NONAME_:T(13,1)=s2red_length:(3,2),0,8;green_blue:(3,2),8,8;;",128,0,0,0
 107               		.stabs	"seg_t:t(13,2)=(13,1)",128,0,101,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"_IST_BLAH_:T(0,16)=s3length:(3,4),0,16;color:(3,2),16,8;;",128,0,0,0
 110               		.stabs	"intermediateSeg_t:t(0,17)=(0,16)",128,0,2272,0
 111               		.stabs	"getTetBrick:F(3,2)",36,0,378,getTetBrick
 112               		.stabs	"row:P(3,2)",64,0,378,24
 113               		.stabs	"col:P(3,2)",64,0,378,22
 114               	.global	getTetBrick
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 3


 115               		.type	getTetBrick, @function
 116               	getTetBrick:
 117               		.stabd	46,0,0
 118               		.stabs	"tetStuff.c",132,0,0,.Ltext1
 119               	.Ltext1:
   1:tetStuff.c    **** #if (TRUE)
   2:tetStuff.c    **** 
   3:tetStuff.c    **** //in main...
   4:tetStuff.c    **** uint8_t fb_to_rb(uint8_t fbColor);
   5:tetStuff.c    **** 
   6:tetStuff.c    **** // Tetris:
   7:tetStuff.c    **** // 10 across
   8:tetStuff.c    **** // 18 up
   9:tetStuff.c    **** // 7 pieces (colors = 3 bits each)
  10:tetStuff.c    **** // Using 4 bits, for easy-access: 90 bytes
  11:tetStuff.c    **** // Using 3 bits: 67.5 bytes
  12:tetStuff.c    **** // How about a happy-medium... use 32-bits for a row...
  13:tetStuff.c    **** #define TET_HEIGHT	18
  14:tetStuff.c    **** #define TET_WIDTH		10
  15:tetStuff.c    **** #define TET_TOP_ROW  (0)
  16:tetStuff.c    **** 
  17:tetStuff.c    **** extern uint16_t pgm_tetPiece[7][4];
  18:tetStuff.c    **** #define bin4x4(b15,b14,b13,b12,\
  19:tetStuff.c    **** 		         b11,b10, b9, b8,\
  20:tetStuff.c    **** 		          b7, b6, b5, b4,\
  21:tetStuff.c    ****                 b3, b2, b1, b0)\
  22:tetStuff.c    ****          ((bin(b15,b14,b13,b12,b11,b10, b9, b8) << 8) | \
  23:tetStuff.c    **** 			          (bin( b7, b6, b5, b4, b3, b2, b1, b0)))
  24:tetStuff.c    **** 
  25:tetStuff.c    **** #define getTetPieceBrick(piece, orientation, row, col) \
  26:tetStuff.c    **** 	   getbit((row*4+col), pgm_getTetPiece(piece,orientation))
  27:tetStuff.c    **** 
  28:tetStuff.c    **** #define pgm_getTetPiece(piece,orientation) \
  29:tetStuff.c    **** 	   ((uint16_t)pgm_read_word(&(pgm_tetPiece[piece][orientation])))
  30:tetStuff.c    **** 
  31:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col);
  32:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val);
  33:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick);
  34:tetStuff.c    **** 	
  35:tetStuff.c    **** //For now, let's just test that it works...
  36:tetStuff.c    **** // (This could be implemented with bitfields?)
  37:tetStuff.c    **** uint32_t tetRow[TET_HEIGHT];
  38:tetStuff.c    **** 
  39:tetStuff.c    **** void tetInit(uint8_t filledRows)
  40:tetStuff.c    **** {
  41:tetStuff.c    **** 	uint8_t row;
  42:tetStuff.c    **** 
  43:tetStuff.c    **** 	//Clear the board...
  44:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
  45:tetStuff.c    **** 		tetRow[row]=0;
  46:tetStuff.c    **** #if (TRUE) //Load random-ish "bricks" for testing...
  47:tetStuff.c    **** 	uint8_t col;
  48:tetStuff.c    **** 	//Now, leaving the first several rows blank for piece-testing...
  49:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
  50:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
  51:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
  52:tetStuff.c    **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 4


  53:tetStuff.c    **** #endif
  54:tetStuff.c    **** #if (FALSE) //Just throw some random pieces in for testing... Dun Woik
  55:tetStuff.c    **** 	row = 0;
  56:tetStuff.c    **** 	uint8_t col;
  57:tetStuff.c    **** 	uint8_t piece = 0;
  58:tetStuff.c    **** 	uint8_t pieceRow;
  59:tetStuff.c    **** 
  60:tetStuff.c    **** 	for(col=0; col<TET_WIDTH; col++)
  61:tetStuff.c    **** 	{
  62:tetStuff.c    **** 		piece = col/4;
  63:tetStuff.c    **** 
  64:tetStuff.c    **** 		for(pieceRow=0; pieceRow<4; pieceRow++)
  65:tetStuff.c    **** 			setTetBrick(pieceRow + row, col, (row+col) & 0x07);
  66:tetStuff.c    **** 				  	//(getTetPieceBrick(piece,0,pieceRow,col)) ? piece : 0);
  67:tetStuff.c    **** 
  68:tetStuff.c    **** 		row+=4;
  69:tetStuff.c    **** 
  70:tetStuff.c    **** 	}
  71:tetStuff.c    **** #endif
  72:tetStuff.c    **** }
  73:tetStuff.c    **** 
  74:tetStuff.c    **** 
  75:tetStuff.c    **** //Also determines color (pieceNum+1)...
  76:tetStuff.c    **** uint8_t pieceNum = 0;
  77:tetStuff.c    **** uint8_t pieceOrientation = 0;
  78:tetStuff.c    **** //Upper-Left corner
  79:tetStuff.c    **** uint8_t pieceTopRow = 0;
  80:tetStuff.c    **** uint8_t pieceLeftCol = 0;
  81:tetStuff.c    **** #define PIECE_HEIGHT 4
  82:tetStuff.c    **** #define PIECE_WIDTH	4
  83:tetStuff.c    **** #define NUM_PIECES	7
  84:tetStuff.c    **** #define PIECE_STARTCOL 3
  85:tetStuff.c    **** #define PIECE_STARTROW 0
  86:tetStuff.c    **** 
  87:tetStuff.c    **** 
  88:tetStuff.c    **** static __inline__ \
  89:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[]) \
  90:tetStuff.c    **** 	  __attribute__((__always_inline__));
  91:tetStuff.c    **** //This assumes rowBuffer[] points to the first column we should draw
  92:tetStuff.c    **** // it could be called as, e.g. tet_drawRow(rbRowNum, &RealRowBuffer[5])
  93:tetStuff.c    **** // to shift it right five pixels...
  94:tetStuff.c    **** // rowNum corresponds to the row in drawable pixels
  95:tetStuff.c    **** // (though this may change later... for, e.g. high vertical resolution)
  96:tetStuff.c    **** // (e.g. for brick separators...)
  97:tetStuff.c    **** void tet_drawRow(uint8_t rowNum, uint8_t rowBuffer[])
  98:tetStuff.c    **** {
  99:tetStuff.c    **** 	uint8_t i; 
 100:tetStuff.c    **** 
 101:tetStuff.c    **** 	if( (rowNum >= TET_TOP_ROW) &&
 102:tetStuff.c    **** 		 (rowNum < TET_TOP_ROW+TET_HEIGHT) )
 103:tetStuff.c    **** 	{
 104:tetStuff.c    **** 		//left border:
 105:tetStuff.c    **** 		rowBuffer[0]=fb_to_rb(_W);
 106:tetStuff.c    **** 
 107:tetStuff.c    **** 		//Draw active (and inactive) bricks
 108:tetStuff.c    **** 		for(i=1; i<=TET_WIDTH; i++)
 109:tetStuff.c    **** 		{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 5


 110:tetStuff.c    **** 			rowBuffer[i]=
 111:tetStuff.c    **** 				fb_to_rb(tetBrick_to_fb(
 112:tetStuff.c    **** 							getTetBrick(rowNum-TET_TOP_ROW,i-1)));
 113:tetStuff.c    **** 		}
 114:tetStuff.c    **** 
 115:tetStuff.c    **** 		//right border:
 116:tetStuff.c    **** 		rowBuffer[i]=fb_to_rb(_W);
 117:tetStuff.c    **** 
 118:tetStuff.c    **** 		//SEE NOTE in main.c re: _b and _c -> _W syncing...
 119:tetStuff.c    **** 	}
 120:tetStuff.c    **** 	//bottom border:
 121:tetStuff.c    **** 	else if(rowNum == TET_TOP_ROW+TET_HEIGHT)
 122:tetStuff.c    **** 		for(i=0; i<=TET_WIDTH+1; i++)
 123:tetStuff.c    **** 			rowBuffer[i]=fb_to_rb(_W);
 124:tetStuff.c    **** //	else
 125:tetStuff.c    **** //		return;
 126:tetStuff.c    **** 
 127:tetStuff.c    **** 
 128:tetStuff.c    **** 	//Active (falling) piece:
 129:tetStuff.c    **** 
 130:tetStuff.c    **** 	if((rowNum >= pieceTopRow) &&
 131:tetStuff.c    **** 		(rowNum < pieceTopRow+PIECE_HEIGHT) )
 132:tetStuff.c    **** 	{
 133:tetStuff.c    **** 		uint8_t pieceRowNum = rowNum - pieceTopRow;
 134:tetStuff.c    **** 
 135:tetStuff.c    **** 		for(i=0; i<PIECE_WIDTH; i++)
 136:tetStuff.c    **** 		{
 137:tetStuff.c    **** 			uint8_t pieceBrick = 
 138:tetStuff.c    **** 					getTetPieceBrick(pieceNum, pieceOrientation, 
 139:tetStuff.c    **** 										  pieceRowNum, i);
 140:tetStuff.c    **** 
 141:tetStuff.c    **** 			//Only draw piece pixels (not black/empty pixels)
 142:tetStuff.c    **** 			// (we don't want to overwrite nearby bricks)
 143:tetStuff.c    **** 			if(pieceBrick)
 144:tetStuff.c    **** 			//+1 for the left border...
 145:tetStuff.c    **** 				rowBuffer[i+1+pieceLeftCol] =
 146:tetStuff.c    **** 						fb_to_rb(tetBrick_to_fb(pieceNum+1));
 147:tetStuff.c    **** 		}
 148:tetStuff.c    **** 	}
 149:tetStuff.c    **** 
 150:tetStuff.c    **** 
 151:tetStuff.c    **** 
 152:tetStuff.c    **** 
 153:tetStuff.c    **** 	//Draw "TETRIS" vertically...
 154:tetStuff.c    **** #define CHARACTER_START_COL   14 //FB_WIDTH
 155:tetStuff.c    ****    //i=FB_WIDTH;
 156:tetStuff.c    ****    i=CHARACTER_START_COL;
 157:tetStuff.c    **** 
 158:tetStuff.c    ****    uint8_t charRow;
 159:tetStuff.c    ****    uint8_t color;
 160:tetStuff.c    ****    char character;
 161:tetStuff.c    ****    switch(rowNum/8)
 162:tetStuff.c    ****    {
 163:tetStuff.c    ****          case 0:
 164:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 165:tetStuff.c    ****             character = 'T';
 166:tetStuff.c    ****             color = _R;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 6


 167:tetStuff.c    ****             break;
 168:tetStuff.c    ****          case 1:
 169:tetStuff.c    ****             //charRow = getCharRow('E', rowNum%8);
 170:tetStuff.c    ****             character = 'E';
 171:tetStuff.c    ****             color = _O;
 172:tetStuff.c    ****             break;
 173:tetStuff.c    ****          case 2:
 174:tetStuff.c    ****             //charRow = getCharRow('T', rowNum%8);
 175:tetStuff.c    ****             character = 'T';
 176:tetStuff.c    ****             color = _Y;
 177:tetStuff.c    ****             break;
 178:tetStuff.c    ****          case 3:
 179:tetStuff.c    ****             { 
 180:tetStuff.c    ****                uint8_t z, temp;
 181:tetStuff.c    ****                
 182:tetStuff.c    ****                //Reverse the "R" to make it look Russian
 183:tetStuff.c    ****                // And shift it one left...
 184:tetStuff.c    ****                temp = getCharRow('R', rowNum%8);
 185:tetStuff.c    ****                
 186:tetStuff.c    ****                for(z=0; z<8; z++)
 187:tetStuff.c    ****                {
 188:tetStuff.c    ****                   writebit(7-z, charRow, getbit(z,temp));
 189:tetStuff.c    ****                }  
 190:tetStuff.c    ****                //Characters are reversed... bit 0 is far-left
 191:tetStuff.c    ****                //So to shift a character left, I must shift its bits right
 192:tetStuff.c    ****                // (right?)
 193:tetStuff.c    ****                charRow >>= 1;
 194:tetStuff.c    ****                color = _G; 
 195:tetStuff.c    ****             }  
 196:tetStuff.c    ****             break;
 197:tetStuff.c    ****          case 4:
 198:tetStuff.c    ****             //charRow = getCharRow('I', rowNum%8);
 199:tetStuff.c    ****             character = 'I';
 200:tetStuff.c    ****             color = _C; 
 201:tetStuff.c    ****             break;
 202:tetStuff.c    ****          case 5:
 203:tetStuff.c    ****             //charRow = getCharRow('S', rowNum%8);
 204:tetStuff.c    ****             character = 'S';
 205:tetStuff.c    ****             color = _B; 
 206:tetStuff.c    ****             break;
 207:tetStuff.c    ****          default:
 208:tetStuff.c    ****             character = ' ';
 209:tetStuff.c    ****             //charRow = 0;
 210:tetStuff.c    ****             break;
 211:tetStuff.c    ****    }     
 212:tetStuff.c    **** 
 213:tetStuff.c    **** 	//Load charRow for all cases except the backwards "R"
 214:tetStuff.c    **** 	// which is handled above...      
 215:tetStuff.c    ****    if(rowNum/8 != 3)
 216:tetStuff.c    ****          charRow = getCharRow(character, rowNum%8);
 217:tetStuff.c    **** 
 218:tetStuff.c    ****    i++;
 219:tetStuff.c    **** 
 220:tetStuff.c    ****    uint8_t j;
 221:tetStuff.c    ****    for(j=0; j<8; j++)
 222:tetStuff.c    ****          if(getbit(j, charRow))
 223:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x25;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 7


 224:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(color); //0x25);
 225:tetStuff.c    ****          else
 226:tetStuff.c    ****             //frameBuffer[rowNum][j+i+1] = 0x01;
 227:tetStuff.c    ****             rowBuffer[j+i] = fb_to_rb(0x00);
 228:tetStuff.c    **** 
 229:tetStuff.c    **** 
 230:tetStuff.c    **** }
 231:tetStuff.c    **** 
 232:tetStuff.c    **** void tetUpdate(void)
 233:tetStuff.c    **** {
 234:tetStuff.c    **** 	//For now, we're just experimenting with the different pieces/
 235:tetStuff.c    **** 	// orientations/positions...	
 236:tetStuff.c    **** 	static uint8_t callCount = 0;
 237:tetStuff.c    **** 	static uint8_t newPieceHitCount=0;
 238:tetStuff.c    **** 
 239:tetStuff.c    **** 	uint8_t new_pieceOrientation;
 240:tetStuff.c    **** 	uint8_t new_pieceTopRow;
 241:tetStuff.c    **** 	uint8_t new_pieceLeftCol;
 242:tetStuff.c    **** //	uint8_t new_pieceNum;
 243:tetStuff.c    **** 
 244:tetStuff.c    **** 	uint8_t pieceRow;
 245:tetStuff.c    **** 	uint8_t pieceCol;
 246:tetStuff.c    **** 
 247:tetStuff.c    **** 	uint8_t noChange = FALSE;
 248:tetStuff.c    **** 	uint8_t settle = FALSE;
 249:tetStuff.c    **** 
 250:tetStuff.c    **** 	if(newPieceHitCount == 5)
 251:tetStuff.c    **** 	{
 252:tetStuff.c    **** 		newPieceHitCount = 0;
 253:tetStuff.c    **** 		tetInit(0);
 254:tetStuff.c    **** 	}
 255:tetStuff.c    **** 
 256:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 257:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 258:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 259:tetStuff.c    **** 
 260:tetStuff.c    **** 	if(callCount%4 == 2)
 261:tetStuff.c    ****    {
 262:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 263:tetStuff.c    ****       if (new_pieceOrientation==4)
 264:tetStuff.c    **** 			new_pieceOrientation=0;
 265:tetStuff.c    **** 	}
 266:tetStuff.c    **** 
 267:tetStuff.c    ****       if(callCount%4==0)
 268:tetStuff.c    ****       {  
 269:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 270:tetStuff.c    **** 		}
 271:tetStuff.c    **** 
 272:tetStuff.c    **** 		if(callCount%4==3)
 273:tetStuff.c    **** 		{
 274:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 275:tetStuff.c    ****       }
 276:tetStuff.c    **** 
 277:tetStuff.c    **** 	callCount++;
 278:tetStuff.c    **** 
 279:tetStuff.c    **** 
 280:tetStuff.c    **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 8


 281:tetStuff.c    **** 
 282:tetStuff.c    **** 
 283:tetStuff.c    **** 	//Check for collision in the new piece position/orientation...
 284:tetStuff.c    **** 	//Starting from the bottom... (intentional wraparound)
 285:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 286:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 287:tetStuff.c    **** 		{
 288:tetStuff.c    **** 			//This isn't particularly efficient...
 289:tetStuff.c    **** 			// rereading each time...
 290:tetStuff.c    **** 			uint8_t pieceBrick =
 291:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 292:tetStuff.c    **** 											  pieceRow, pieceCol);
 293:tetStuff.c    **** 
 294:tetStuff.c    **** 			uint8_t boardRow = new_pieceTopRow + pieceRow;
 295:tetStuff.c    **** 
 296:tetStuff.c    **** 			uint8_t boardCol = new_pieceLeftCol + pieceCol;
 297:tetStuff.c    **** 
 298:tetStuff.c    **** 			uint8_t boardBrick = getTetBrick(boardRow, boardCol);
 299:tetStuff.c    **** 
 300:tetStuff.c    **** 
 301:tetStuff.c    **** 			if(pieceBrick)
 302:tetStuff.c    **** 			{
 303:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 304:tetStuff.c    **** 				{
 305:tetStuff.c    **** 					noChange = TRUE;
 306:tetStuff.c    **** 					settle = TRUE;
 307:tetStuff.c    **** 					break;
 308:tetStuff.c    **** 				}
 309:tetStuff.c    **** 
 310:tetStuff.c    **** 				//There's some plausibility for some oddities here...
 311:tetStuff.c    **** 				// revisit 41-15.zip
 312:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 313:tetStuff.c    **** 				{
 314:tetStuff.c    **** 				   noChange = TRUE;
 315:tetStuff.c    **** 				   break;
 316:tetStuff.c    **** 				}
 317:tetStuff.c    **** 
 318:tetStuff.c    **** 
 319:tetStuff.c    **** 				if(boardBrick)
 320:tetStuff.c    **** 				{
 321:tetStuff.c    **** 					//Must be a settle...
 322:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 323:tetStuff.c    **** 						(new_pieceLeftCol == pieceLeftCol))
 324:tetStuff.c    **** 						settle = TRUE;
 325:tetStuff.c    **** 
 326:tetStuff.c    **** 					noChange = TRUE;
 327:tetStuff.c    **** 					break;
 328:tetStuff.c    **** 				}
 329:tetStuff.c    **** 			}
 330:tetStuff.c    **** 		}
 331:tetStuff.c    **** 
 332:tetStuff.c    **** 
 333:tetStuff.c    **** 
 334:tetStuff.c    **** 
 335:tetStuff.c    **** 
 336:tetStuff.c    **** 	if(!noChange)
 337:tetStuff.c    **** 	{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 9


 338:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 339:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 340:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 341:tetStuff.c    **** 	}
 342:tetStuff.c    **** 
 343:tetStuff.c    **** 	if(settle)
 344:tetStuff.c    **** 	{
 345:tetStuff.c    **** 		// Check if we've hit on a new piece...
 346:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 347:tetStuff.c    **** 		   (pieceLeftCol == PIECE_STARTCOL) &&
 348:tetStuff.c    **** 		   (pieceOrientation == 0))
 349:tetStuff.c    **** 		   newPieceHitCount++;
 350:tetStuff.c    **** 
 351:tetStuff.c    **** 
 352:tetStuff.c    **** 		//Load the piece into the board...
 353:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 354:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 355:tetStuff.c    **** 			{
 356:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 357:tetStuff.c    **** 										  pieceRow, pieceCol))
 358:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 359:tetStuff.c    **** 								pieceLeftCol+pieceCol,
 360:tetStuff.c    **** 								pieceNum+1);
 361:tetStuff.c    **** 			}
 362:tetStuff.c    **** 
 363:tetStuff.c    **** 
 364:tetStuff.c    **** 		//Load a new piece...
 365:tetStuff.c    **** 		pieceNum++;
 366:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 367:tetStuff.c    **** 			pieceNum = 0;
 368:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 369:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 370:tetStuff.c    **** 		pieceOrientation = 0;
 371:tetStuff.c    **** 	}
 372:tetStuff.c    **** 
 373:tetStuff.c    **** }
 374:tetStuff.c    **** 
 375:tetStuff.c    **** //returns a 3-bit value
 376:tetStuff.c    **** // 0 corresponds to no brick
 377:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 378:tetStuff.c    **** uint8_t getTetBrick(uint8_t row, uint8_t col)
 379:tetStuff.c    **** {
 120               		.stabn	68,0,379,.LM0-.LFBB1
 121               	.LM0:
 122               	.LFBB1:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               		.stabn	68,0,379,.LM1-.LFBB1
 126               	.LM1:
 127 0000 E82F      		mov r30,r24
 128 0002 F0E0      		ldi r31,lo8(0)
 129 0004 EE0F      		lsl r30
 130 0006 FF1F      		rol r31
 131 0008 EE0F      		lsl r30
 132 000a FF1F      		rol r31
 133 000c E050      		subi r30,lo8(-(tetRow))
 134 000e F040      		sbci r31,hi8(-(tetRow))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 10


 135 0010 862F      		mov r24,r22
 136 0012 90E0      		ldi r25,lo8(0)
 137 0014 63E0      		ldi r22,lo8(3)
 138 0016 70E0      		ldi r23,hi8(3)
 139 0018 00D0      		rcall __mulhi3
 140 001a 2081      		ld r18,Z
 141 001c 3181      		ldd r19,Z+1
 142 001e 4281      		ldd r20,Z+2
 143 0020 5381      		ldd r21,Z+3
 144 0022 00C0      		rjmp 2f
 145 0024 5695      	1:	lsr r21
 146 0026 4795      		ror r20
 147 0028 3795      		ror r19
 148 002a 2795      		ror r18
 149 002c 8A95      	2:	dec r24
 150 002e 02F4      		brpl 1b
 380:tetStuff.c    **** 	//uint8_t tetCol = col*3;
 381:tetStuff.c    **** //	uint8_t tetMask = '\007';
 382:tetStuff.c    **** 	
 383:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
 384:tetStuff.c    **** 
 385:tetStuff.c    **** }
 151               		.stabn	68,0,385,.LM2-.LFBB1
 152               	.LM2:
 153 0030 822F      		mov r24,r18
 154 0032 8770      		andi r24,lo8(7)
 155               	/* epilogue start */
 156 0034 0895      		ret
 157               		.size	getTetBrick, .-getTetBrick
 158               	.Lscope1:
 159               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 160               		.stabd	78,0,0
 161               		.stabs	"setTetBrick:F(0,15)",36,0,391,setTetBrick
 162               		.stabs	"row:P(3,2)",64,0,391,24
 163               		.stabs	"col:P(3,2)",64,0,391,22
 164               		.stabs	"val:P(3,2)",64,0,391,20
 165               	.global	setTetBrick
 166               		.type	setTetBrick, @function
 167               	setTetBrick:
 168               		.stabd	46,0,0
 386:tetStuff.c    **** 
 387:tetStuff.c    **** 
 388:tetStuff.c    **** //val should only be 0-7
 389:tetStuff.c    **** // 0 corresponds to no brick
 390:tetStuff.c    **** // 1-7 corresponds to the type of piece the brick came from...
 391:tetStuff.c    **** void setTetBrick(uint8_t row, uint8_t col, uint8_t val)
 392:tetStuff.c    **** {
 169               		.stabn	68,0,392,.LM3-.LFBB2
 170               	.LM3:
 171               	.LFBB2:
 172 0036 0F93      		push r16
 173 0038 1F93      		push r17
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 393:tetStuff.c    **** 	//Clear the old value...
 394:tetStuff.c    **** 	tetRow[row] &= ~(((uint32_t)'\007')<<(3*col));
 176               		.stabn	68,0,394,.LM4-.LFBB2
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 11


 177               	.LM4:
 178 003a E82F      		mov r30,r24
 179 003c F0E0      		ldi r31,lo8(0)
 180 003e 862F      		mov r24,r22
 181 0040 90E0      		ldi r25,lo8(0)
 182 0042 63E0      		ldi r22,lo8(3)
 183 0044 70E0      		ldi r23,hi8(3)
 184 0046 00D0      		rcall __mulhi3
 185 0048 A82F      		mov r26,r24
 395:tetStuff.c    **** 	//Write the new value...
 396:tetStuff.c    **** 	tetRow[row] |= (((uint32_t)val)<<(3*col));
 186               		.stabn	68,0,396,.LM5-.LFBB2
 187               	.LM5:
 188 004a EE0F      		lsl r30
 189 004c FF1F      		rol r31
 190 004e EE0F      		lsl r30
 191 0050 FF1F      		rol r31
 192 0052 E050      		subi r30,lo8(-(tetRow))
 193 0054 F040      		sbci r31,hi8(-(tetRow))
 194 0056 67E0      		ldi r22,lo8(7)
 195 0058 70E0      		ldi r23,hi8(7)
 196 005a 80E0      		ldi r24,hlo8(7)
 197 005c 90E0      		ldi r25,hhi8(7)
 198 005e 0A2E      		mov r0,r26
 199 0060 00C0      		rjmp 2f
 200 0062 660F      	1:	lsl r22
 201 0064 771F      		rol r23
 202 0066 881F      		rol r24
 203 0068 991F      		rol r25
 204 006a 0A94      	2:	dec r0
 205 006c 02F4      		brpl 1b
 206 006e 6095      		com r22
 207 0070 7095      		com r23
 208 0072 8095      		com r24
 209 0074 9095      		com r25
 210 0076 0081      		ld r16,Z
 211 0078 1181      		ldd r17,Z+1
 212 007a 2281      		ldd r18,Z+2
 213 007c 3381      		ldd r19,Z+3
 214 007e 6023      		and r22,r16
 215 0080 7123      		and r23,r17
 216 0082 8223      		and r24,r18
 217 0084 9323      		and r25,r19
 218 0086 242F      		mov r18,r20
 219 0088 30E0      		ldi r19,lo8(0)
 220 008a 40E0      		ldi r20,lo8(0)
 221 008c 50E0      		ldi r21,hi8(0)
 222 008e 00C0      		rjmp 2f
 223 0090 220F      	1:	lsl r18
 224 0092 331F      		rol r19
 225 0094 441F      		rol r20
 226 0096 551F      		rol r21
 227 0098 AA95      	2:	dec r26
 228 009a 02F4      		brpl 1b
 229 009c 622B      		or r22,r18
 230 009e 732B      		or r23,r19
 231 00a0 842B      		or r24,r20
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 12


 232 00a2 952B      		or r25,r21
 233 00a4 6083      		st Z,r22
 234 00a6 7183      		std Z+1,r23
 235 00a8 8283      		std Z+2,r24
 236 00aa 9383      		std Z+3,r25
 237               	/* epilogue start */
 397:tetStuff.c    **** }
 238               		.stabn	68,0,397,.LM6-.LFBB2
 239               	.LM6:
 240 00ac 1F91      		pop r17
 241 00ae 0F91      		pop r16
 242 00b0 0895      		ret
 243               		.size	setTetBrick, .-setTetBrick
 244               	.Lscope2:
 245               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 246               		.stabd	78,0,0
 247               		.stabs	"tetInit:F(0,15)",36,0,39,tetInit
 248               		.stabs	"filledRows:P(3,2)",64,0,39,24
 249               	.global	tetInit
 250               		.type	tetInit, @function
 251               	tetInit:
 252               		.stabd	46,0,0
  40:tetStuff.c    **** {
 253               		.stabn	68,0,40,.LM7-.LFBB3
 254               	.LM7:
 255               	.LFBB3:
 256 00b2 0F93      		push r16
 257 00b4 1F93      		push r17
 258               	/* prologue: function */
 259               	/* frame size = 0 */
  40:tetStuff.c    **** {
 260               		.stabn	68,0,40,.LM8-.LFBB3
 261               	.LM8:
 262 00b6 E0E0      		ldi r30,lo8(tetRow)
 263 00b8 F0E0      		ldi r31,hi8(tetRow)
 264               	.L6:
  45:tetStuff.c    **** 		tetRow[row]=0;
 265               		.stabn	68,0,45,.LM9-.LFBB3
 266               	.LM9:
 267 00ba 1192      		st Z+,__zero_reg__
 268 00bc 1192      		st Z+,__zero_reg__
 269 00be 1192      		st Z+,__zero_reg__
 270 00c0 1192      		st Z+,__zero_reg__
  44:tetStuff.c    **** 	for(row=0; row<TET_HEIGHT; row++)
 271               		.stabn	68,0,44,.LM10-.LFBB3
 272               	.LM10:
 273 00c2 90E0      		ldi r25,hi8(tetRow+72)
 274 00c4 E030      		cpi r30,lo8(tetRow+72)
 275 00c6 F907      		cpc r31,r25
 276 00c8 01F4      		brne .L6
  49:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 277               		.stabn	68,0,49,.LM11-.LFBB3
 278               	.LM11:
 279 00ca 12E1      		ldi r17,lo8(18)
 280 00cc 181B      		sub r17,r24
 281 00ce 00C0      		rjmp .L7
 282               	.L9:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 13


 283 00d0 00E0      		ldi r16,lo8(0)
 284               	.L8:
  51:tetStuff.c    **** 			setTetBrick(row, col, (row+col)&0x07);
 285               		.stabn	68,0,51,.LM12-.LFBB3
 286               	.LM12:
 287 00d2 402F      		mov r20,r16
 288 00d4 410F      		add r20,r17
 289 00d6 4770      		andi r20,lo8(7)
 290 00d8 812F      		mov r24,r17
 291 00da 602F      		mov r22,r16
 292 00dc 00D0      		rcall setTetBrick
  50:tetStuff.c    **** 		for(col=0; col<TET_WIDTH; col++)
 293               		.stabn	68,0,50,.LM13-.LFBB3
 294               	.LM13:
 295 00de 0F5F      		subi r16,lo8(-(1))
 296 00e0 0A30      		cpi r16,lo8(10)
 297 00e2 01F4      		brne .L8
  49:tetStuff.c    **** 	for(row=TET_HEIGHT-filledRows; row<TET_HEIGHT; row++)
 298               		.stabn	68,0,49,.LM14-.LFBB3
 299               	.LM14:
 300 00e4 1F5F      		subi r17,lo8(-(1))
 301               	.L7:
 302 00e6 1231      		cpi r17,lo8(18)
 303 00e8 00F0      		brlo .L9
 304               	/* epilogue start */
  72:tetStuff.c    **** }
 305               		.stabn	68,0,72,.LM15-.LFBB3
 306               	.LM15:
 307 00ea 1F91      		pop r17
 308 00ec 0F91      		pop r16
 309 00ee 0895      		ret
 310               		.size	tetInit, .-tetInit
 311               		.stabs	"row:r(3,2)",64,0,41,17
 312               		.stabs	"col:r(3,2)",64,0,47,16
 313               		.stabn	192,0,0,.LFBB3-.LFBB3
 314               		.stabn	224,0,0,.Lscope3-.LFBB3
 315               	.Lscope3:
 316               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 317               		.stabd	78,0,0
 318               		.stabs	"tetUpdate:F(0,15)",36,0,232,tetUpdate
 319               	.global	tetUpdate
 320               		.type	tetUpdate, @function
 321               	tetUpdate:
 322               		.stabd	46,0,0
 233:tetStuff.c    **** {
 323               		.stabn	68,0,233,.LM16-.LFBB4
 324               	.LM16:
 325               	.LFBB4:
 326 00f0 2F92      		push r2
 327 00f2 3F92      		push r3
 328 00f4 4F92      		push r4
 329 00f6 5F92      		push r5
 330 00f8 6F92      		push r6
 331 00fa 7F92      		push r7
 332 00fc 8F92      		push r8
 333 00fe 9F92      		push r9
 334 0100 AF92      		push r10
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 14


 335 0102 BF92      		push r11
 336 0104 CF92      		push r12
 337 0106 DF92      		push r13
 338 0108 EF92      		push r14
 339 010a FF92      		push r15
 340 010c 0F93      		push r16
 341 010e 1F93      		push r17
 342 0110 DF93      		push r29
 343 0112 CF93      		push r28
 344 0114 00D0      		rcall .
 345 0116 CDB7      		in r28,__SP_L__
 346 0118 DEB7      		in r29,__SP_H__
 347               	/* prologue: function */
 348               	/* frame size = 2 */
 250:tetStuff.c    **** 	if(newPieceHitCount == 5)
 349               		.stabn	68,0,250,.LM17-.LFBB4
 350               	.LM17:
 351 011a 8091 0000 		lds r24,newPieceHitCount.1823
 352 011e 8530      		cpi r24,lo8(5)
 353 0120 01F4      		brne .L15
 252:tetStuff.c    **** 		newPieceHitCount = 0;
 354               		.stabn	68,0,252,.LM18-.LFBB4
 355               	.LM18:
 356 0122 1092 0000 		sts newPieceHitCount.1823,__zero_reg__
 253:tetStuff.c    **** 		tetInit(0);
 357               		.stabn	68,0,253,.LM19-.LFBB4
 358               	.LM19:
 359 0126 80E0      		ldi r24,lo8(0)
 360 0128 00D0      		rcall tetInit
 361               	.L15:
 256:tetStuff.c    **** 	new_pieceOrientation = pieceOrientation;
 362               		.stabn	68,0,256,.LM20-.LFBB4
 363               	.LM20:
 364 012a 3090 0000 		lds r3,pieceOrientation
 257:tetStuff.c    **** 	new_pieceLeftCol = pieceLeftCol;
 365               		.stabn	68,0,257,.LM21-.LFBB4
 366               	.LM21:
 367 012e 4091 0000 		lds r20,pieceLeftCol
 258:tetStuff.c    **** 	new_pieceTopRow = pieceTopRow;
 368               		.stabn	68,0,258,.LM22-.LFBB4
 369               	.LM22:
 370 0132 2090 0000 		lds r2,pieceTopRow
 260:tetStuff.c    **** 	if(callCount%4 == 2)
 371               		.stabn	68,0,260,.LM23-.LFBB4
 372               	.LM23:
 373 0136 5091 0000 		lds r21,callCount.1822
 374 013a 852F      		mov r24,r21
 375 013c 90E0      		ldi r25,lo8(0)
 376 013e 8370      		andi r24,lo8(3)
 377 0140 9070      		andi r25,hi8(3)
 378 0142 8230      		cpi r24,2
 379 0144 9105      		cpc r25,__zero_reg__
 380 0146 01F4      		brne .L16
 262:tetStuff.c    **** 		new_pieceOrientation=pieceOrientation+1;
 381               		.stabn	68,0,262,.LM24-.LFBB4
 382               	.LM24:
 383 0148 232D      		mov r18,r3
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 15


 384 014a 2F5F      		subi r18,lo8(-(1))
 263:tetStuff.c    ****       if (new_pieceOrientation==4)
 385               		.stabn	68,0,263,.LM25-.LFBB4
 386               	.LM25:
 387 014c 2430      		cpi r18,lo8(4)
 388 014e 01F0      		breq .+2
 389 0150 00C0      		rjmp .L18
 390 0152 00C0      		rjmp .L48
 391               	.L16:
 267:tetStuff.c    ****       if(callCount%4==0)
 392               		.stabn	68,0,267,.LM26-.LFBB4
 393               	.LM26:
 394 0154 0097      		sbiw r24,0
 395 0156 01F4      		brne .L19
 269:tetStuff.c    ****          new_pieceLeftCol=pieceLeftCol+1;
 396               		.stabn	68,0,269,.LM27-.LFBB4
 397               	.LM27:
 398 0158 342F      		mov r19,r20
 399 015a 3F5F      		subi r19,lo8(-(1))
 400 015c 00C0      		rjmp .L43
 401               	.L19:
 272:tetStuff.c    **** 		if(callCount%4==3)
 402               		.stabn	68,0,272,.LM28-.LFBB4
 403               	.LM28:
 404 015e 8330      		cpi r24,3
 405 0160 9105      		cpc r25,__zero_reg__
 406 0162 01F4      		brne .L45
 274:tetStuff.c    **** 			new_pieceTopRow=pieceTopRow+1;
 407               		.stabn	68,0,274,.LM29-.LFBB4
 408               	.LM29:
 409 0164 2394      		inc r2
 410               	.L45:
 411 0166 342F      		mov r19,r20
 412               	.L43:
 413 0168 232D      		mov r18,r3
 414               	.L20:
 277:tetStuff.c    **** 	callCount++;
 415               		.stabn	68,0,277,.LM30-.LFBB4
 416               	.LM30:
 417 016a 5F5F      		subi r21,lo8(-(1))
 418 016c 5093 0000 		sts callCount.1822,r21
 419               	.LBB81:
 420               	.LBB82:
 291:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 421               		.stabn	68,0,291,.LM31-.LFBB4
 422               	.LM31:
 423 0170 8091 0000 		lds r24,pieceNum
 424 0174 90E0      		ldi r25,lo8(0)
 425 0176 880F      		lsl r24
 426 0178 991F      		rol r25
 427 017a 880F      		lsl r24
 428 017c 991F      		rol r25
 429 017e 820F      		add r24,r18
 430 0180 911D      		adc r25,__zero_reg__
 431 0182 880F      		lsl r24
 432 0184 991F      		rol r25
 433 0186 8050      		subi r24,lo8(-(pgm_tetPiece))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 16


 434 0188 9040      		sbci r25,hi8(-(pgm_tetPiece))
 435 018a 122D      		mov r17,r2
 436 018c 1D5F      		subi r17,lo8(-(3))
 437 018e A0E0      		ldi r26,lo8(0)
 438 0190 B3E0      		ldi r27,lo8(3)
 439 0192 FC01      		movw r30,r24
 440               	/* #APP */
 441               	 ;  291 "tetStuff.c" 1
 442 0194 C590      		lpm r12, Z+
 443 0196 D490      		lpm r13, Z
 444               		
 445               	 ;  0 "" 2
 446               	/* #NOAPP */
 447 0198 00C0      		rjmp .L22
 448               	.L26:
 449               	.LBE82:
 301:tetStuff.c    **** 			if(pieceBrick)
 450               		.stabn	68,0,301,.LM32-.LFBB4
 451               	.LM32:
 452 019a CF01      		movw r24,r30
 453 019c 8E0D      		add r24,r14
 454 019e 9F1D      		adc r25,r15
 455 01a0 2601      		movw r4,r12
 456 01a2 00C0      		rjmp 2f
 457 01a4 5694      	1:	lsr r5
 458 01a6 4794      		ror r4
 459 01a8 8A95      	2:	dec r24
 460 01aa 02F4      		brpl 1b
 461 01ac 40FE      		sbrs r4,0
 462 01ae 00C0      		rjmp .L23
 303:tetStuff.c    **** 				if(boardRow >= TET_HEIGHT)
 463               		.stabn	68,0,303,.LM33-.LFBB4
 464               	.LM33:
 465 01b0 1231      		cpi r17,lo8(18)
 466 01b2 00F4      		brsh .L24
 312:tetStuff.c    **** 				if(boardCol >= TET_WIDTH)
 467               		.stabn	68,0,312,.LM34-.LFBB4
 468               	.LM34:
 469 01b4 0A30      		cpi r16,lo8(10)
 470 01b6 00F4      		brsh .L25
 319:tetStuff.c    **** 				if(boardBrick)
 471               		.stabn	68,0,319,.LM35-.LFBB4
 472               	.LM35:
 473 01b8 802F      		mov r24,r16
 474 01ba 90E0      		ldi r25,lo8(0)
 475 01bc 63E0      		ldi r22,lo8(3)
 476 01be 70E0      		ldi r23,hi8(3)
 477 01c0 00D0      		rcall __mulhi3
 478 01c2 2401      		movw r4,r8
 479 01c4 3501      		movw r6,r10
 480 01c6 00C0      		rjmp 2f
 481 01c8 7694      	1:	lsr r7
 482 01ca 6794      		ror r6
 483 01cc 5794      		ror r5
 484 01ce 4794      		ror r4
 485 01d0 8A95      	2:	dec r24
 486 01d2 02F4      		brpl 1b
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 17


 487 01d4 842D      		mov r24,r4
 488 01d6 8770      		andi r24,lo8(7)
 489 01d8 01F0      		breq .L23
 322:tetStuff.c    **** 					if((new_pieceOrientation == pieceOrientation) &&
 490               		.stabn	68,0,322,.LM36-.LFBB4
 491               	.LM36:
 492 01da 2315      		cp r18,r3
 493 01dc 01F4      		brne .L25
 494 01de 3417      		cp r19,r20
 495 01e0 01F4      		brne .L25
 496 01e2 00C0      		rjmp .L24
 497               	.L23:
 498 01e4 3196      		adiw r30,1
 499 01e6 0F5F      		subi r16,lo8(-(1))
 500               	.LBE81:
 286:tetStuff.c    **** 		for(pieceCol = 0; pieceCol < 4; pieceCol++)
 501               		.stabn	68,0,286,.LM37-.LFBB4
 502               	.LM37:
 503 01e8 E430      		cpi r30,4
 504 01ea F105      		cpc r31,__zero_reg__
 505 01ec 01F4      		brne .L26
 506 01ee 80E0      		ldi r24,lo8(0)
 507 01f0 00C0      		rjmp .L27
 508               	.L24:
 509 01f2 81E0      		ldi r24,lo8(1)
 510 01f4 00C0      		rjmp .L44
 511               	.L25:
 512 01f6 80E0      		ldi r24,lo8(0)
 513               	.L44:
 514 01f8 A1E0      		ldi r26,lo8(1)
 515               	.L27:
 285:tetStuff.c    **** 	for(pieceRow = 3; (pieceRow < 128) && !settle && !noChange; pieceRow--)
 516               		.stabn	68,0,285,.LM38-.LFBB4
 517               	.LM38:
 518 01fa B150      		subi r27,lo8(-(-1))
 519 01fc 1150      		subi r17,lo8(-(-1))
 520 01fe BF3F      		cpi r27,lo8(-1)
 521 0200 01F0      		breq .L28
 522 0202 8823      		tst r24
 523 0204 01F4      		brne .L28
 524               	.L22:
 525 0206 AA23      		tst r26
 526 0208 01F0      		breq .+2
 527 020a 00C0      		rjmp .L37
 528               	.LBB85:
 291:tetStuff.c    **** 						getTetPieceBrick(pieceNum, new_pieceOrientation,
 529               		.stabn	68,0,291,.LM39-.LFBB4
 530               	.LM39:
 531 020c EB2E      		mov r14,r27
 532 020e FF24      		clr r15
 533 0210 EE0C      		lsl r14
 534 0212 FF1C      		rol r15
 535 0214 EE0C      		lsl r14
 536 0216 FF1C      		rol r15
 537               	.LBB83:
 538               	.LBB84:
 383:tetStuff.c    **** 	return ((uint8_t)(tetRow[row] >> (3*col))) & '\007';
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 18


 539               		.stabn	68,0,383,.LM40-.LFBB4
 540               	.LM40:
 541 0218 E12F      		mov r30,r17
 542 021a F0E0      		ldi r31,lo8(0)
 543 021c EE0F      		lsl r30
 544 021e FF1F      		rol r31
 545 0220 EE0F      		lsl r30
 546 0222 FF1F      		rol r31
 547 0224 E050      		subi r30,lo8(-(tetRow))
 548 0226 F040      		sbci r31,hi8(-(tetRow))
 549 0228 8080      		ld r8,Z
 550 022a 9180      		ldd r9,Z+1
 551 022c A280      		ldd r10,Z+2
 552 022e B380      		ldd r11,Z+3
 553 0230 032F      		mov r16,r19
 554 0232 E0E0      		ldi r30,lo8(0)
 555 0234 F0E0      		ldi r31,hi8(0)
 556 0236 00C0      		rjmp .L26
 557               	.L28:
 558               	.LBE84:
 559               	.LBE83:
 560               	.LBE85:
 336:tetStuff.c    **** 	if(!noChange)
 561               		.stabn	68,0,336,.LM41-.LFBB4
 562               	.LM41:
 563 0238 AA23      		tst r26
 564 023a 01F4      		brne .L30
 338:tetStuff.c    **** 		pieceOrientation = new_pieceOrientation;
 565               		.stabn	68,0,338,.LM42-.LFBB4
 566               	.LM42:
 567 023c 2093 0000 		sts pieceOrientation,r18
 339:tetStuff.c    **** 		pieceLeftCol = new_pieceLeftCol;
 568               		.stabn	68,0,339,.LM43-.LFBB4
 569               	.LM43:
 570 0240 3093 0000 		sts pieceLeftCol,r19
 340:tetStuff.c    **** 		pieceTopRow = new_pieceTopRow;
 571               		.stabn	68,0,340,.LM44-.LFBB4
 572               	.LM44:
 573 0244 2092 0000 		sts pieceTopRow,r2
 574               	.L30:
 343:tetStuff.c    **** 	if(settle)
 575               		.stabn	68,0,343,.LM45-.LFBB4
 576               	.LM45:
 577 0248 8823      		tst r24
 578 024a 01F4      		brne .+2
 579 024c 00C0      		rjmp .L37
 346:tetStuff.c    **** 		if((pieceTopRow == PIECE_STARTROW) &&
 580               		.stabn	68,0,346,.LM46-.LFBB4
 581               	.LM46:
 582 024e 8091 0000 		lds r24,pieceTopRow
 583 0252 8823      		tst r24
 584 0254 01F0      		breq .+2
 585 0256 00C0      		rjmp .L31
 586 0258 8091 0000 		lds r24,pieceLeftCol
 587 025c 8330      		cpi r24,lo8(3)
 588 025e 01F0      		breq .+2
 589 0260 00C0      		rjmp .L31
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 19


 590 0262 8091 0000 		lds r24,pieceOrientation
 591 0266 8823      		tst r24
 592 0268 01F0      		breq .+2
 593 026a 00C0      		rjmp .L31
 349:tetStuff.c    **** 		   newPieceHitCount++;
 594               		.stabn	68,0,349,.LM47-.LFBB4
 595               	.LM47:
 596 026c 8091 0000 		lds r24,newPieceHitCount.1823
 597 0270 8F5F      		subi r24,lo8(-(1))
 598 0272 8093 0000 		sts newPieceHitCount.1823,r24
 599 0276 00C0      		rjmp .L31
 600               	.L34:
 601               	.LBB86:
 356:tetStuff.c    **** 				if(getTetPieceBrick(pieceNum, pieceOrientation,
 602               		.stabn	68,0,356,.LM48-.LFBB4
 603               	.LM48:
 604 0278 4091 0000 		lds r20,pieceNum
 605 027c E42F      		mov r30,r20
 606 027e F0E0      		ldi r31,lo8(0)
 607 0280 EE0F      		lsl r30
 608 0282 FF1F      		rol r31
 609 0284 EE0F      		lsl r30
 610 0286 FF1F      		rol r31
 611 0288 8091 0000 		lds r24,pieceOrientation
 612 028c E80F      		add r30,r24
 613 028e F11D      		adc r31,__zero_reg__
 614 0290 EE0F      		lsl r30
 615 0292 FF1F      		rol r31
 616 0294 E050      		subi r30,lo8(-(pgm_tetPiece))
 617 0296 F040      		sbci r31,hi8(-(pgm_tetPiece))
 618               	/* #APP */
 619               	 ;  356 "tetStuff.c" 1
 620 0298 8591      		lpm r24, Z+
 621 029a 9491      		lpm r25, Z
 622               		
 623               	 ;  0 "" 2
 624               	/* #NOAPP */
 625               	.LBE86:
 626 029c B701      		movw r22,r14
 627 029e 620F      		add r22,r18
 628 02a0 731F      		adc r23,r19
 629 02a2 00C0      		rjmp 2f
 630 02a4 9695      	1:	lsr r25
 631 02a6 8795      		ror r24
 632 02a8 6A95      	2:	dec r22
 633 02aa 02F4      		brpl 1b
 634 02ac 80FF      		sbrs r24,0
 635 02ae 00C0      		rjmp .L33
 358:tetStuff.c    **** 				setTetBrick(pieceTopRow+pieceRow,
 636               		.stabn	68,0,358,.LM49-.LFBB4
 637               	.LM49:
 638 02b0 8091 0000 		lds r24,pieceTopRow
 639 02b4 6091 0000 		lds r22,pieceLeftCol
 640 02b8 6E0D      		add r22,r14
 641 02ba 4F5F      		subi r20,lo8(-(1))
 642 02bc 810F      		add r24,r17
 643 02be 2983      		std Y+1,r18
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 20


 644 02c0 3A83      		std Y+2,r19
 645 02c2 00D0      		rcall setTetBrick
 646 02c4 3A81      		ldd r19,Y+2
 647 02c6 2981      		ldd r18,Y+1
 648               	.L33:
 649 02c8 0894      		sec
 650 02ca E11C      		adc r14,__zero_reg__
 651 02cc F11C      		adc r15,__zero_reg__
 354:tetStuff.c    **** 			for(pieceCol = 0; pieceCol < 4; pieceCol++)
 652               		.stabn	68,0,354,.LM50-.LFBB4
 653               	.LM50:
 654 02ce 64E0      		ldi r22,lo8(4)
 655 02d0 E616      		cp r14,r22
 656 02d2 F104      		cpc r15,__zero_reg__
 657 02d4 01F4      		brne .L34
 353:tetStuff.c    **** 		for(pieceRow = 0; pieceRow < 4; pieceRow++)
 658               		.stabn	68,0,353,.LM51-.LFBB4
 659               	.LM51:
 660 02d6 1F5F      		subi r17,lo8(-(1))
 661 02d8 2C5F      		subi r18,lo8(-(4))
 662 02da 3F4F      		sbci r19,hi8(-(4))
 663 02dc 1430      		cpi r17,lo8(4)
 664 02de 01F4      		brne .L38
 665 02e0 00C0      		rjmp .L49
 666               	.L31:
 667 02e2 20E0      		ldi r18,lo8(0)
 668 02e4 30E0      		ldi r19,hi8(0)
 669 02e6 10E0      		ldi r17,lo8(0)
 670               	.L38:
 671 02e8 EE24      		clr r14
 672 02ea FF24      		clr r15
 673 02ec 00C0      		rjmp .L34
 674               	.L49:
 365:tetStuff.c    **** 		pieceNum++;
 675               		.stabn	68,0,365,.LM52-.LFBB4
 676               	.LM52:
 677 02ee 8091 0000 		lds r24,pieceNum
 678 02f2 8F5F      		subi r24,lo8(-(1))
 679 02f4 8093 0000 		sts pieceNum,r24
 366:tetStuff.c    **** 		if(pieceNum==NUM_PIECES)
 680               		.stabn	68,0,366,.LM53-.LFBB4
 681               	.LM53:
 682 02f8 8730      		cpi r24,lo8(7)
 683 02fa 01F4      		brne .L36
 367:tetStuff.c    **** 			pieceNum = 0;
 684               		.stabn	68,0,367,.LM54-.LFBB4
 685               	.LM54:
 686 02fc 1092 0000 		sts pieceNum,__zero_reg__
 687               	.L36:
 368:tetStuff.c    **** 		pieceLeftCol = PIECE_STARTCOL;
 688               		.stabn	68,0,368,.LM55-.LFBB4
 689               	.LM55:
 690 0300 83E0      		ldi r24,lo8(3)
 691 0302 8093 0000 		sts pieceLeftCol,r24
 369:tetStuff.c    **** 		pieceTopRow = PIECE_STARTROW;
 692               		.stabn	68,0,369,.LM56-.LFBB4
 693               	.LM56:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 21


 694 0306 1092 0000 		sts pieceTopRow,__zero_reg__
 370:tetStuff.c    **** 		pieceOrientation = 0;
 695               		.stabn	68,0,370,.LM57-.LFBB4
 696               	.LM57:
 697 030a 1092 0000 		sts pieceOrientation,__zero_reg__
 698 030e 00C0      		rjmp .L37
 699               	.L48:
 373:tetStuff.c    **** }
 700               		.stabn	68,0,373,.LM58-.LFBB4
 701               	.LM58:
 702 0310 20E0      		ldi r18,lo8(0)
 703               	.L18:
 704 0312 342F      		mov r19,r20
 705 0314 00C0      		rjmp .L20
 706               	.L37:
 707               	/* epilogue start */
 708 0316 0F90      		pop __tmp_reg__
 709 0318 0F90      		pop __tmp_reg__
 710 031a CF91      		pop r28
 711 031c DF91      		pop r29
 712 031e 1F91      		pop r17
 713 0320 0F91      		pop r16
 714 0322 FF90      		pop r15
 715 0324 EF90      		pop r14
 716 0326 DF90      		pop r13
 717 0328 CF90      		pop r12
 718 032a BF90      		pop r11
 719 032c AF90      		pop r10
 720 032e 9F90      		pop r9
 721 0330 8F90      		pop r8
 722 0332 7F90      		pop r7
 723 0334 6F90      		pop r6
 724 0336 5F90      		pop r5
 725 0338 4F90      		pop r4
 726 033a 3F90      		pop r3
 727 033c 2F90      		pop r2
 728 033e 0895      		ret
 729               		.size	tetUpdate, .-tetUpdate
 730               		.stabs	"callCount:V(3,2)",38,0,236,callCount.1822
 731               		.stabs	"newPieceHitCount:V(3,2)",38,0,237,newPieceHitCount.1823
 732               		.stabs	"new_pieceOrientation:r(3,2)",64,0,239,3
 733               		.stabs	"new_pieceTopRow:r(3,2)",64,0,240,2
 734               		.stabs	"new_pieceLeftCol:r(3,2)",64,0,241,20
 735               		.stabs	"pieceRow:r(3,2)",64,0,244,27
 736               		.stabs	"pieceCol:r(3,2)",64,0,245,21
 737               		.stabs	"noChange:r(3,2)",64,0,247,26
 738               		.stabs	"settle:r(3,2)",64,0,248,24
 739               		.stabn	192,0,0,.LFBB4-.LFBB4
 740               		.stabs	"__addr16:r(3,4)",64,0,291,24
 741               		.stabn	192,0,0,.LBB82-.LFBB4
 742               		.stabn	224,0,0,.LBE82-.LFBB4
 743               		.stabs	"__addr16:r(3,4)",64,0,356,30
 744               		.stabn	192,0,0,.LBB86-.LFBB4
 745               		.stabn	224,0,0,.LBE86-.LFBB4
 746               		.stabn	224,0,0,.Lscope4-.LFBB4
 747               	.Lscope4:
 748               		.stabs	"",36,0,0,.Lscope4-.LFBB4
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 22


 749               		.stabd	78,0,0
 750               		.stabs	"tetBrick_to_fb:F(3,2)",36,0,401,tetBrick_to_fb
 751               		.stabs	"tetBrick:P(3,2)",64,0,401,24
 752               	.global	tetBrick_to_fb
 753               		.type	tetBrick_to_fb, @function
 754               	tetBrick_to_fb:
 755               		.stabd	46,0,0
 398:tetStuff.c    **** 
 399:tetStuff.c    **** uint8_t tetColorScheme = 0;
 400:tetStuff.c    **** 
 401:tetStuff.c    **** uint8_t tetBrick_to_fb(uint8_t tetBrick)
 402:tetStuff.c    **** {
 756               		.stabn	68,0,402,.LM59-.LFBB5
 757               	.LM59:
 758               	.LFBB5:
 759               	/* prologue: function */
 760               	/* frame size = 0 */
 403:tetStuff.c    **** 	if(!tetBrick)
 761               		.stabn	68,0,403,.LM60-.LFBB5
 762               	.LM60:
 763 0340 8823      		tst r24
 764 0342 01F0      		breq .L52
 404:tetStuff.c    **** 		return 0;
 405:tetStuff.c    **** 
 406:tetStuff.c    **** 	switch(tetColorScheme)
 765               		.stabn	68,0,406,.LM61-.LFBB5
 766               	.LM61:
 767 0344 9091 0000 		lds r25,tetColorScheme
 768 0348 8150      		subi r24,lo8(-(-1))
 769 034a 9230      		cpi r25,lo8(2)
 770 034c 00F4      		brsh .L53
 771               		.stabs	"main.c",132,0,0,.Ltext2
 772               	.Ltext2:
   1:main.c        **** #include "projInfo.h"   //Don't include in main.h 'cause that's included in other .c's?
   2:main.c        **** #include "main.h"
   3:main.c        **** #include <util/delay.h> //For delay_us in pll_enable
   4:main.c        **** #include <avr/pgmspace.h>
   5:main.c        **** #include _TIMERCOMMON_HEADER_
   6:main.c        **** //#include "../../../_commonCode/charBitmap/0.10/charBitmap.h"
   7:main.c        **** #include _CHARBITMAP_HEADER_
   8:main.c        **** #include "fbColors.h"
   9:main.c        **** 
  10:main.c        **** #include _SINETABLE_HEADER_
  11:main.c        **** #include "tetStuff.c"
  12:main.c        **** 
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** //#define SEG_HFM		TRUE
  20:main.c        **** //#define SEG_QUESTION	TRUE
  21:main.c        **** 
  22:main.c        **** // When this isn't true, remove ADC stuff from the makefile
  23:main.c        **** // to save codespace
  24:main.c        **** #define SEG_RACER 	TRUE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 23


  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** 
  28:main.c        **** 
  29:main.c        **** 
  30:main.c        **** //#warning "This needs to be moved... and conditional"
  31:main.c        **** //#include "rowSegBuffer.c"
  32:main.c        **** 
  33:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
  34:main.c        **** #define pgm_readImageByte(image, row, col)   \
  35:main.c        **** 	   pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** 
  39:main.c        **** // I hereby declare this FPD-Link simulation technique to forever be called
  40:main.c        **** //  PW-BANGing
  41:main.c        **** 
  42:main.c        **** 
  43:main.c        **** //For testing of slower LVDS pixel-rates
  44:main.c        **** // (maybe we can increase the resolution)
  45:main.c        **** // value must be 1, 2, 4, or 8
  46:main.c        **** // This is overridden by 8 when SLOW_LVDS_TEST is true...
  47:main.c        **** // If commented-out the default of 1 is used...
  48:main.c        **** // AFAICT, this only increases codesize in HLow_delay...
  49:main.c        **** // CHANGING THIS MIGHT AFFECT DISPLAYABILITY...
  50:main.c        **** // One place to look is the delay_cyc in drawPix
  51:main.c        **** //  Currently 1, 2, and 8 seem to work.
  52:main.c        **** //  8 no longer works, noticed a/o v46
  53:main.c        **** #define LVDS_PRESCALER 8//2//1//8//2//4//8//2//8//2
  54:main.c        **** //8//2//1//2//2//2//2//2//2//2//2//2//2//2//8//4 //1 //2//4//8//2//4
  55:main.c        **** 
  56:main.c        **** 
  57:main.c        **** //#define LIFE TRUE
  58:main.c        **** #if (defined(LIFE) && LIFE)
  59:main.c        ****  #include "lifeStuff.c"
  60:main.c        **** #endif
  61:main.c        **** 
  62:main.c        **** #define ROW_SEG_BUFFER	TRUE
  63:main.c        **** //now, SEG_STRETCH >= 3 causes weirdness... (repeated rows)
  64:main.c        **** // previously 3 was OK
  65:main.c        **** // This is fixed a/o newSeg, etc.
  66:main.c        **** #define SEG_STRETCH 5//4//3//2//3//4//6//3//4//6	//Stretch pixels using longer segments
  67:main.c        **** 
  68:main.c        **** #if (defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
  69:main.c        ****  #warning "ROW_SEG_BUFFER requires ROW_BUFFER, but this is a hack"
  70:main.c        ****  #if (!defined(LVDS_PRESCALER) || (LVDS_PRESCALER < 2))
  71:main.c        ****   #error "ROW_SEG_BUFFER uses 20cyc/pixel, which isn't compatible with ROW_BUFFER -> width=64, sinc
  72:main.c        ****  #endif
  73:main.c        ****  #define ROW_BUFFER TRUE
  74:main.c        ****  #include "rowSegBuffer.c"
  75:main.c        **** #endif
  76:main.c        **** 
  77:main.c        **** #define ROW_BUFFER TRUE
  78:main.c        **** #if (defined(ROW_BUFFER) && ROW_BUFFER)
  79:main.c        ****  #include "rowBuffer.c"
  80:main.c        **** #endif
  81:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 24


  82:main.c        **** //Only valid with ROW_BUFFER=TRUE above:
  83:main.c        **** //#define HORIZONTAL_COLOR_BARS TRUE
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** 
  87:main.c        **** 
  88:main.c        **** 
  89:main.c        **** 
  90:main.c        **** 
  91:main.c        **** 
  92:main.c        **** 
  93:main.c        **** 
  94:main.c        **** //See its old definition elsewhere
  95:main.c        **** #define NUM_PSEGS (1024/3+16)
  96:main.c        **** 
  97:main.c        **** 
  98:main.c        **** 
  99:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
 100:main.c        **** 	#include _ADC_HEADER_
 101:main.c        **** //	#include <stdio.h>
 102:main.c        **** 
 103:main.c        **** //Returns 0-9 or -1 if we've reached 0...
 104:main.c        **** int8_t grabDecimal_u32(uint32_t value, uint8_t newVal)
 105:main.c        **** {
 106:main.c        ****    static uint32_t divisor = 1000000000;
 107:main.c        **** 
 108:main.c        ****    static uint32_t thisVal;
 109:main.c        **** 
 110:main.c        ****    if(newVal)
 111:main.c        ****    {
 112:main.c        ****       divisor = 1000000000;
 113:main.c        ****       thisVal = value;
 114:main.c        ****    }
 115:main.c        **** 
 116:main.c        ****    uint8_t decimal = 0;
 117:main.c        **** 
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        ****    if(divisor == 0)
 121:main.c        ****       return -1;
 122:main.c        **** 
 123:main.c        ****    while(thisVal >= divisor)
 124:main.c        ****    {
 125:main.c        ****       decimal++;
 126:main.c        ****       thisVal -= divisor;
 127:main.c        **** 
 128:main.c        ****    }
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** 
 132:main.c        **** 
 133:main.c        ****    divisor /= 10;
 134:main.c        **** 
 135:main.c        ****    return decimal;
 136:main.c        **** }
 137:main.c        **** 
 138:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 25


 139:main.c        **** //Including raceWidth, and maybe some buffer...
 140:main.c        **** #define RACE_WIDTH_PSEGS	272
 141:main.c        **** 
 142:main.c        **** 
 143:main.c        **** void showScore(uint16_t rowNum, uint32_t score, uint8_t color)
 144:main.c        **** {
 145:main.c        **** 
 146:main.c        **** 	//The first few rows aren't displaying?
 147:main.c        **** //		rowNum-=6;
 148:main.c        **** 		int8_t decimal;
 149:main.c        **** 		uint8_t scoreFound = FALSE;
 150:main.c        **** 
 151:main.c        **** 		static uint32_t thisScore;
 152:main.c        **** 
 153:main.c        **** 		if(rowNum == 0)
 154:main.c        **** 			thisScore = score; // goodCount;
 155:main.c        **** 
 156:main.c        **** 		decimal = grabDecimal_u32(thisScore, 1);
 157:main.c        **** 
 158:main.c        **** 		uint8_t col;
 159:main.c        **** 
 160:main.c        **** 		uint8_t charRow = 0;
 161:main.c        **** 
 162:main.c        **** 		for(col=0; col<NUM_PSEGS-3-RACE_WIDTH_PSEGS; col++)
 163:main.c        **** 		{
 164:main.c        **** //			uint8_t charRow = 0;
 165:main.c        **** 			
 166:main.c        **** 			if(col%8==0)
 167:main.c        **** 			{
 168:main.c        **** 				if((decimal != 0) && (decimal != -1))
 169:main.c        **** 					scoreFound = TRUE;
 170:main.c        **** 
 171:main.c        **** 				if((decimal == -1) || (!scoreFound))
 172:main.c        **** 					charRow = 0;
 173:main.c        **** 				else
 174:main.c        **** 					charRow = getCharRow(decimal+'0', rowNum/2);
 175:main.c        **** 				decimal = grabDecimal_u32(thisScore, 0);
 176:main.c        **** 			}
 177:main.c        **** 
 178:main.c        **** 			if(getbit(col%8, charRow))
 179:main.c        **** 				addSegfb(1,color);
 180:main.c        **** 			else
 181:main.c        **** 				addSegfb(1,_B);
 182:main.c        **** 		}
 183:main.c        **** }	
 184:main.c        **** 
 185:main.c        **** #endif
 186:main.c        **** 
 187:main.c        **** 
 188:main.c        **** 
 189:main.c        **** 
 190:main.c        **** 
 191:main.c        **** 
 192:main.c        **** 
 193:main.c        **** 
 194:main.c        **** //Options LTN, IDT, or TESTVALS
 195:main.c        **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 26


 196:main.c        **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 197:main.c        **** 
 198:main.c        **** //For Red and Green (NOT Blue) This enables four shades, instead of three
 199:main.c        **** // (including black)
 200:main.c        **** // Doing so increases pixel-processing time, thus the pixel-widths
 201:main.c        **** // (thus decreasing resolution)
 202:main.c        **** // each color takes 9 cycles to process in three-shade mode
 203:main.c        **** // or 12 cycles for red and green, plus 9 for blue in four-shade mode
 204:main.c        **** #define FOUR_SHADES TRUE
 205:main.c        **** 
 206:main.c        **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 207:main.c        **** //  it seems the speed (at least for the LTN) isn't so important after all
 208:main.c        **** //  This could be used to my advantage...
 209:main.c        **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
 210:main.c        **** //  Thus, pixels could be skinnier, thus higher-resolution.
 211:main.c        **** //   Or more instructions could be used for the same resolution
 212:main.c        **** //   allowing, e.g. sprites from program-memory, without necessitating a
 213:main.c        **** //   large (or any?) frame-buffer...
 214:main.c        **** 
 215:main.c        **** 
 216:main.c        **** //This used to be handled by TOOFAST_TEST, but now can be configured here
 217:main.c        **** // 0xff sets the processor to run as fast as possible 
 218:main.c        **** //  (~16MHz? ~128MHz bit-rate)
 219:main.c        **** // 0x00 sets it as slow as possible (~4MHz, ~32MHz bit-rate)
 220:main.c        **** //  good for testing whether odd colors
 221:main.c        **** //  or bad syncing is due to bits being shifted, etc. 
 222:main.c        **** //  Maybe due to slow "LVDS" conversion chips, or whatnot.
 223:main.c        **** //   This seems to be the case right now... 0xff: black is appearing green
 224:main.c        **** //   There should be *some* green in it, but not this much.
 225:main.c        **** //   Likely due to different propagation delays between my under-driven
 226:main.c        **** //    74LS86's (running red and green), from 3.3V!
 227:main.c        **** //    and the happier and newer 74AHC XOR and OR currently driving the
 228:main.c        **** //    clock and DVH/Blue signals
 229:main.c        **** //  Highly dependent on the screen itself, some may not run at all with
 230:main.c        **** //  such slow bitrates... heck, some may not run at all even at the fastest
 231:main.c        **** // If SLOW_EVERYTHING_TEST is true, this value is overridden
 232:main.c        **** // LTN last used 0x20
 233:main.c        **** #define OSCCAL_VAL	0xff//0x20//0xff //0x00
 234:main.c        **** 
 235:main.c        **** //This would normally be 0 for the highest-speed frame-refresh possible
 236:main.c        **** // However, increasing this value can slow the frame-refresh rate
 237:main.c        **** //   if desired
 238:main.c        **** // e.g. 50000 causes it to refresh ~ every few seconds
 239:main.c        **** //   (durn-near the limit for how long the LCD will retain an image)
 240:main.c        **** // The benefit being that it doesn't flicker at annoying rates for
 241:main.c        **** //  stationary images
 242:main.c        **** //  worth exploring...
 243:main.c        **** // This may be highly dependent on the screen capabilities...
 244:main.c        **** //   of course, this sorta thing is undocumented
 245:main.c        **** //   it just has to be experimented with
 246:main.c        **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 247:main.c        **** //   likely be driven DC... not sure what the long term effects are.
 248:main.c        **** // This could be a hell of a lot more sophisticated...
 249:main.c        **** // e.g. refresh after a frameBuffer change
 250:main.c        **** //      refresh based on a seconds-timer
 251:main.c        **** //      ...
 252:main.c        **** // AS-IS: Does refreshes completely independent of the frame-buffer
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 27


 253:main.c        **** //      if it's too slow, some images may be missed completely.
 254:main.c        **** //      This is not true for FRAME_SYNC TRUE (below)
 255:main.c        **** //      (and it's not really useful anymore with FRAME_SYNC)
 256:main.c        **** #define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 257:main.c        **** 
 258:main.c        **** //SHOULD PROBABLY BE REVISITED
 259:main.c        **** // It probably doesn't work with all cases...
 260:main.c        **** // Definitely with drawPix/Images...
 261:main.c        **** //This causes main o update the image *after* FRAME_UPDATE_DELAY
 262:main.c        **** #define FRAME_SYNC TRUE
 263:main.c        **** 
 264:main.c        **** //New Idea:
 265:main.c        **** // Disable the Hsync timer interrupt after the frame completes
 266:main.c        **** //  and reenable elsewhere...
 267:main.c        **** //  (It seems pixels changing from one shade to another take an
 268:main.c        **** //   intermediate step halfway between)
 269:main.c        **** //  (Thus, two updates then a pause might clear that up)
 270:main.c        **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 271:main.c        **** //   is the same...)
 272:main.c        **** //  (but it is an interesting effect)
 273:main.c        **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 274:main.c        **** //  Reworded: Having several frame refreshes before a pause helps to
 275:main.c        **** //  "solidify" the color changes... especially the sharp changes 
 276:main.c        **** //  (e.g. yellow<->black)
 277:main.c        **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
 278:main.c        **** //   in LCDdirect that was only connected such that R, G, and B were each
 279:main.c        **** //   either full-off or full-on, i.e. all Red bits were connected to a
 280:main.c        **** //   single output pin (full on when 1, full off when 0).
 281:main.c        **** //   I hadn't attributed it to improper refresh synchronization
 282:main.c        **** //   as the refresh rate was too fast to see... That's a handy way to get
 283:main.c        **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 284:main.c        **** //  connected with each color 
 285:main.c        **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 286:main.c        **** //  If you WANT this effect (for intermediate shades?) 
 287:main.c        **** //   set FRAME_COUNT_TO_DELAY to 1
 288:main.c        **** //  Then, each change of color will (apparently) result in a value halfway
 289:main.c        **** //   between the old color and the new color
 290:main.c        **** //  Not sure whether it's an electrical problem, but these half-shades 
 291:main.c        **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 292:main.c        **** //   depends on the goal...
 293:main.c        **** #define FRAME_COUNT_TO_DELAY 2//7//1//5//2//3
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** //These two are mutually-exclusive (BLUE_VERT_BAR overrides DE_BLUE)
 297:main.c        **** // (BLUE_DIAG_BAR overrides both...)
 298:main.c        **** 
 299:main.c        **** 
 300:main.c        **** // Default is drawPix, from program memory...
 301:main.c        **** 
 302:main.c        **** //These are only used in drawPix...
 303:main.c        **** //This probably has no purpose outside of COLOR_BAR_SCROLL below
 304:main.c        **** // Actually, it's kinda funny watcching the top of the smiley's
 305:main.c        **** // head scroll... like he's getting a brain transplant
 306:main.c        **** //#define PIXEL_SCROLL TRUE
 307:main.c        **** 
 308:main.c        **** //This is only valid in drawPix with an image...
 309:main.c        **** #define IMAGE_CHANGE TRUE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 28


 310:main.c        **** 
 311:main.c        **** 
 312:main.c        **** //#define COLOR_BAR_SCROLL TRUE
 313:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
 314:main.c        **** 
 315:main.c        **** //#warning "COLOR_BAR_SCROLL is broken a/o v29, possibly earlier"
 316:main.c        **** // Probably just a timing issue...
 317:main.c        **** 
 318:main.c        **** //Optional, but only useful here...
 319:main.c        ****  #define PIXEL_SCROLL TRUE
 320:main.c        **** 
 321:main.c        ****  //Handles all the displayable colors in a single row for scrolling...
 322:main.c        ****  #define FB_WIDTH 64 //28
 323:main.c        ****  //Two different arrangements of colors...
 324:main.c        ****  #define FB_HEIGHT 2
 325:main.c        **** 
 326:main.c        **** #else //drawPix from program memory
 327:main.c        ****  #define FB_WIDTH	16
 328:main.c        ****  #define FB_HEIGHT 16
 329:main.c        **** #endif
 330:main.c        **** 
 331:main.c        **** 
 332:main.c        **** 
 333:main.c        **** //DC_DE is only used in drawPix...
 334:main.c        **** //#define DC_DE_DISABLE TRUE
 335:main.c        **** //This should remove DC from Vsync, etc...
 336:main.c        **** // Currently only implemented with FULL_INIT_TESTS below...
 337:main.c        **** //#define REMOVE_DC TRUE
 338:main.c        **** 
 339:main.c        **** //#define FULL_INIT_TESTS TRUE
 340:main.c        **** 
 341:main.c        **** 
 342:main.c        **** //#define BLUE_DIAG_BAR TRUE
 343:main.c        **** 
 344:main.c        **** //A single black bar, followed by a single blue bar... ~1/3 and 2/3's width
 345:main.c        **** //#define BLUE_VERT_BAR TRUE
 346:main.c        **** 
 347:main.c        **** //#define DE_BLUE TRUE
 348:main.c        **** // NONE SELECTED DOESN'T SYNC!!! DE not detected???
 349:main.c        **** 
 350:main.c        **** 
 351:main.c        **** //#define DE_ONLY_DISPLAY	TRUE
 352:main.c        **** 
 353:main.c        **** 
 354:main.c        **** //a/0 v24, this allows the clock signal to be affected by DT
 355:main.c        **** // if it works, we'll be able to use Green on /OC1B
 356:main.c        **** // Sort of works... Blues with DT=0 are good, timing's not screwed
 357:main.c        **** // but blues with DT!=0 are damn-near black except for a light pixel
 358:main.c        **** // before-hand
 359:main.c        **** //a/0 v26, this is now required for Green IN MODES OTHER THAN DRAWPIX
 360:main.c        **** // Not sure where that note makes sense...
 361:main.c        **** // a/o 56-36-3ish it's been removed completely.
 362:main.c        **** //DO NOT define CLOCK_INSENSITIVITY_TESTING TRUE
 363:main.c        **** 
 364:main.c        **** // Rather than *possibly* mess with timing (on other displays?)
 365:main.c        **** // Also for testing...
 366:main.c        **** //#define DT0_BLUES_ONLY	TRUE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 29


 367:main.c        **** 
 368:main.c        **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 369:main.c        **** // LTN appears to be content with my pseudo-LVDS scheme.
 370:main.c        **** // IAXG has never unblanked
 371:main.c        **** //      Even though suitable timings were found with SwitchResX
 372:main.c        **** //      Maybe due to psuedo-LVDS
 373:main.c        **** //            slight timing issues // It probably doesn't work with all cases...
 374:main.c        **** // Definitely with drawPix/Images...(RC oscillator variances?)
 375:main.c        **** //            glitches when switching LVDS states 
 376:main.c        **** //                 (thought I had that figured out, originally)
 377:main.c        **** //      The fact the LTN appears to recognize the signalling suggests the
 378:main.c        **** //      IAXG would be worth further exploration...
 379:main.c        **** //         Unfortunately, the CCFT blew out my inverter
 380:main.c        **** //                        And I must have put it back together incorrectly
 381:main.c        **** //                        (backlight filters out of order or flipped?)
 382:main.c        **** //                        (which actually makes for some very interesting
 383:main.c        **** //                         visuals, but hard to develop with)
 384:main.c        **** //      IAXG: uses DE, V, and H
 385:main.c        **** //             At low pixel-clock DE is active for fewer pixels...
 386:main.c        **** //              Last Tested: 680 was full-screen
 387:main.c        **** //             Nice because it increases the frame-rate!
 388:main.c        **** //      LTN:  uses DE only
 389:main.c        **** 
 390:main.c        **** 
 391:main.c        **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
 392:main.c        **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 393:main.c        **** //  (Though I am currently running with OSCAL set to the highest frequency
 394:main.c        **** //   and the PLL seems to be syncing at about 128MHz)
 395:main.c        **** 
 396:main.c        **** 
 397:main.c        **** // Wiring:
 398:main.c        **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 399:main.c        **** //   simplest of all:
 400:main.c        **** //
 401:main.c        **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 402:main.c        **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 403:main.c        **** //   It's spec'd to run from 4.5-5.5V, and its propagatio delays and slew
 404:main.c        **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 405:main.c        **** //     yet it's working...
 406:main.c        **** //   Further, the output voltages are right in the LVDS range,
 407:main.c        **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
 408:main.c        **** //      (Don't forget the LCD has a 100ohm resistor between
 409:main.c        **** //         RXinN/clk+ and RXinN/clk-)
 410:main.c        **** //   Most signals are connected as shown (RXin0, RXin2, RXclk)
 411:main.c        **** //   Green is the only one which has RXin1- and RXin1+ swapped
 412:main.c        **** //     since it is on the /OC1B (inverted) output
 413:main.c        **** //   Green may benefit from a pull-up resistor on /OC1B
 414:main.c        **** //     there was some weird noise appearing like a floating-input
 415:main.c        **** //     when the full frame was not filled with pixels
 416:main.c        **** //     (but it should've waited to disable /OC1B until *after* the delays,
 417:main.c        **** //      etc. So I'm not sure what it was)
 418:main.c        **** //
 419:main.c        **** //   It's probably best to use two XORs from the same chip for a single
 420:main.c        **** //    LVDS channel, since different chips may have slightly different
 421:main.c        **** //    characteristics. 
 422:main.c        **** //
 423:main.c        **** //   The entire circuit, thus, requires TWO 74LS86's 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 30


 424:main.c        **** //    (four XORs apiece, two per LVDS channel, 8-total)
 425:main.c        **** //
 426:main.c        **** //
 427:main.c        **** //              VCC3V3   VCC3V3
 428:main.c        **** //                |        |
 429:main.c        **** //                +---\ \-_
 430:main.c        **** //                     | |    -
 431:main.c        **** //                     | | XOR   >------> RXinN/clk-
 432:main.c        **** //   AVR               | |    _-
 433:main.c        **** //   OC1x >----+------/ /___-
 434:main.c        **** //   output    |
 435:main.c        **** //             |   
 436:main.c        **** //             |      
 437:main.c        **** //             `------\ \-_
 438:main.c        **** //                     | |    -
 439:main.c        **** //                     | | XOR   >------> RXinN/clk+
 440:main.c        **** //                     | |    _-
 441:main.c        **** //                +---/ /___-
 442:main.c        **** //                |        |
 443:main.c        **** //               GND      GND
 444:main.c        **** //
 445:main.c        **** //  
 446:main.c        **** //  Also used: The TTL 74AHC series...
 447:main.c        **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 448:main.c        **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
 449:main.c        **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 450:main.c        **** //     (with a 100ohm load in the LCD)
 451:main.c        **** //
 452:main.c        **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 453:main.c        **** //     channels, I had to implement Red and Green with the LS 
 454:main.c        **** //     before switching all channels to the LS... Using different chips
 455:main.c        **** //     (specifically, different TYPES of chips) for different channels
 456:main.c        **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 457:main.c        **** //     signals are synchronized, but the red and green signals were shifted
 458:main.c        **** //     a bit or two (resulting in "Black" appearing green, of course
 459:main.c        **** //     true black isn't really possible with my timing scheme... see below)
 460:main.c        **** //
 461:main.c        **** //  For other circuits attempted, see oldNotes.txt
 462:main.c        **** //     (and boy there were many, involving voltage dividers, AC coupling,
 463:main.c        **** //      reference voltages, BJT differential amplifiers... I doubt I 
 464:main.c        **** //      documented them all, or even most. Whoda thunk the simplest, 
 465:main.c        **** //      especially under- AND over-spec'd--timing, supply voltage, and
 466:main.c        **** //      output voltage--would be the one...?)
 467:main.c        **** //
 468:main.c        **** // LVDS/FPD-Link timing:
 469:main.c        **** 
 470:main.c        **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 471:main.c        **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
 472:main.c        **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 473:main.c        **** //            |____.____.____.____               |____.____.____.____
 474:main.c        **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 475:main.c        **** //            |         |            |         |
 476:main.c        **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 477:main.c        **** //            |                                  |
 478:main.c        **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 479:main.c        **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 480:main.c        **** //            | ^  ^ | 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 31


 481:main.c        **** //            |         |<--Not Blue-->|         |
 482:main.c        **** //            |                                  |
 483:main.c        **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 484:main.c        **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 485:main.c        **** //            | ^ ^  |  
 486:main.c        **** //            |         |<------->|-Not Green    |
 487:main.c        **** //
 488:main.c        **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 489:main.c        **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 490:main.c        **** //            | ^^     
 491:main.c        **** //            |         |<-->|-Not Red
 492:main.c        **** //
 493:main.c        **** //   Of course: The Not Green/Red bits above are low-bits and
 494:main.c        **** //              basically have little/no visible effect
 495:main.c        **** //
 496:main.c        **** //
 497:main.c        **** // Ponderings on using /OC1x's and OC1D for other colors...
 498:main.c        **** //    /OC1D could easily be used for another color, unaffected by others
 499:main.c        **** //          since DT1(L) and OCR1D are unused
 500:main.c        **** //
 501:main.c        **** // DE:   Blue Values
 502:main.c        **** //       -----------
 503:main.c        **** //       OCR1A=4,5,6   (OCR1A=6, Full-Blue would force /OC1A low,
 504:main.c        **** //       DT1(H)=0,1,2                      e.g. Green=Full-Green or Off)
 505:main.c        **** //                      Also: OCR1A=4,5 would affect Green
 506:main.c        **** //                            (DT1(L) is from this edge...)
 507:main.c        **** //                            DT1(H) also affects complementary OC1D
 508:main.c        **** //
 509:main.c        **** // CLK:  OCR1B=3       CLOCK can NOT be complementary-output mode
 510:main.c        **** //                                   (/OC1B unusuable)
 511:main.c        **** //                                   otherwise, DT1 would affect clock
 512:main.c        **** //
 513:main.c        **** //
 514:main.c        **** // CLOCK_INSENSITIVITY_TESTING:
 515:main.c        **** //   (a/o 56-36-3ish, no longer testable)
 516:main.c        **** //    Testing of DE/Blue's DeadTime values on Clocking...
 517:main.c        **** //    	Image-shift (not sure why, more calculations? Not *that* many!)
 518:main.c        **** //       Blue now has only two shades besides black
 519:main.c        **** //         ~66% and 100%
 520:main.c        **** //       Now each blue pixel (the ones appearing black)
 521:main.c        **** //         is bordered by a blue line...
 522:main.c        **** //    All doable. Would have preferred 3 shades besides black,
 523:main.c        **** //       but two isn't bad.
 524:main.c        **** //
 525:main.c        **** //  New Idea: Since CLOCK can be used with DT1H (during DE)
 526:main.c        **** //    DE/Blue DT values are 0, 1, or 2 (D0, D1, D2)
 527:main.c        **** //     Dn corresponds to the low-to-high dead-timer value
 528:main.c        **** //                   (aka counter-reset delay, on OCR1x)
 529:main.c        **** //     dn corresponds to the high-to-low dead-timer value
 530:main.c        **** //                   (aka OCR match delay, on /OCR1x)
 531:main.c        **** //     Cn corresponds to OCR1x=n
 532:main.c        **** //
 533:main.c        **** // This was easier to comprehend in v<26... now it's more informative
 534:main.c        **** //   but harder to view...
 535:main.c        **** //                          OCR1B = 3
 536:main.c        **** //  TCNT:     |  0   1    2    3  | 4    5    6
 537:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 32


 538:main.c        **** //  CLKideal: /\______________/
 539:main.c        **** //
 540:main.c        **** //            |____ ____ ____.____v              |
 541:main.c        **** //  CLK:   D0>/ D1>/ D2>/         \    .    .    /
 542:main.c        **** //  OC1B      |           |  |
 543:main.c        **** //            |                   |
 544:main.c        **** //            | G2   G1   B1   B0 | G5   G4   G3
 545:main.c        **** //  Green:    |                   |____ ____ ____
 546:main.c        **** //  /OC1B     \    .    .    . d0>/ d1>/ d2>/ d3?\  //
 547:main.c        **** //            |      
 548:main.c        **** //            |
 549:main.c        **** //            | R1   R0   G0   R5   R4   R3   R2
 550:main.c        **** //  Red:      |____ ____ ____ ____ ____ ____ ____
 551:main.c        **** //  OC1D   D0>/ D1>/ D2>/ C2>\ C3>\ C4>\ C5>\ C6...
 552:main.c        **** //                       
 553:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 554:main.c        **** //  /OC1D     \ ^OCR1D>=6^ L>/  M>/  N>/  O>/ P?>...
 555:main.c        **** //                   
 556:main.c        **** //
 557:main.c        **** //              B3   B2   DE   /V   /H   B5   B4
 558:main.c        **** // "Blue/DVH" |____ ____ ____.____.____ ____ ____
 559:main.c        **** //  OC1A:  D0>/ D1>/ D2>/           C4>\ C5>\ C6...
 560:main.c        **** //            |                  
 561:main.c        **** //             ____ ____ ____ ____ ____ ____ ____
 562:main.c        **** //  /OC1A:    \  ^^^--OCR1A>=6--^^^  X>/  Y>/ Z?>\  //
 563:main.c        **** //  (usable?)        
 564:main.c        **** //                 X: OCR1A=4, DTL=0
 565:main.c        **** //                 Y: OCR1A=4, DTL=1; OCR1A=5, DTL=0
 566:main.c        **** //                 Z: OCR1A=4, DTL=2; OCR1A=5, DTL=1; OCR1A>=6
 567:main.c        **** 
 568:main.c        **** //I've looked it over extensively, albiet exhaustedly, and it seems
 569:main.c        **** // there's only one way to do this. Unfortunately, DTH=1,2 *does* affect
 570:main.c        **** // the clocking. Everything displays properly, but the lighter shades of 
 571:main.c        **** // blue enabled by DTH=1,2 don't display at all (or dang-near black)
 572:main.c        **** // So there's really no benefit to using DTH=1,2 during DE for blues...
 573:main.c        **** // That gives two (similar) shades of bright blue 63/63 and 47/63
 574:main.c        **** // *'d are arbitrarily chosen for implementation
 575:main.c        **** // F'd are selected when FOUR_SHADES is TRUE
 576:main.c        **** //   (experimentation might show other choices are better)
 577:main.c        **** //
 578:main.c        **** // Red is connected to OC1D, Complementary output is not necessary
 579:main.c        **** //  OCR1D determines its brightness:
 580:main.c        **** //   (+OC1D => RX0+)
 581:main.c        **** //   *Off (0/63): OCR1D = 0  \      //
 582:main.c        **** //    3/63:			OCR1D = 1   > These three appear identical in glColorTest
 583:main.c        **** //    3/63:			OCR1D = 2  /  (G0 Active, from here down)
 584:main.c        **** //   *35/63:		OCR1D = 3
 585:main.c        **** //   F51/63:		OCR1D = 4
 586:main.c        **** //    59/63:		OCR1D = 5  \  These two appear identical in glColorTest
 587:main.c        **** //   *63/63:		OCR1D >= 6 /
 588:main.c        **** //    (+OC1D => RX0-)
 589:main.c        **** //    Not really worth pursuing, next step from 60/63 is 28/63 then 12
 590:main.c        **** //
 591:main.c        **** // Green is connected to /OC1B (the complementary channel to CLK)
 592:main.c        **** //  Its polarity is reversed (but that's easy since we have a single-ended
 593:main.c        **** //  to differential converter, and its outputs can just be swapped)
 594:main.c        **** //  DTL1 determines its brightness (G0 affected by Red):
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 33


 595:main.c        **** //   (/OC1B => RX1+)
 596:main.c        **** //    Off (0/63):	DTL1 = 3 (is this possible?)
 597:main.c        **** //    8-9/63:			DTL1 = 2
 598:main.c        **** //    24-25/63:		DTL1 = 1
 599:main.c        **** //    56-57/63:		DTL1 = 0
 600:main.c        **** //   (/OC1B => RX1-)				(B1,0 Active, as well as G2,1)
 601:main.c        **** //	  *Off (6/63):	DTL1 = 0
 602:main.c        **** //   *38-39/63:		DTL1 = 1
 603:main.c        **** //   F54-55/63:		DTL1 = 2
 604:main.c        **** //   *62-63/63:		DTL1 = 3
 605:main.c        **** //
 606:main.c        **** // Blue, as in previous versions, is connected to OC1A, DTH=0 during DE 
 607:main.c        **** //  so as not to interfere with the clock
 608:main.c        **** //  OCR1A determines the brightness (B1,0 active, per Green->RX1-):
 609:main.c        **** //    (+OC1A => RX2+)			      (B3,2 Active from here down)
 610:main.c        **** //    *Off (15/63):	OCR1A=4
 611:main.c        **** //    *47/63:		 	OCR1A=5
 612:main.c        **** //		*63/63:			OCR1A=6
 613:main.c        **** //
 614:main.c        **** // The clock is single-ended (complementary-mode disabled) during NON-DE
 615:main.c        **** //  because the DE/V/H signals (except in DE mode) require DT1H to vary.
 616:main.c        **** //  When DE is active the clock channel (OC1B) is switched to 
 617:main.c        **** //  complementary-output-mode to enable the Green PWM output
 618:main.c        **** //
 619:main.c        **** // For easier viewing:
 620:main.c        **** //   Red: (+OC1D => RX0+)
 621:main.c        **** //    Off (0/63): OCR1D = 0
 622:main.c        **** //    35/63:      OCR1D = 3
 623:main.c        **** //    51/63:      OCR1D = 4	(FOUR_SHADES only)
 624:main.c        **** //    63/63:      OCR1D >= 6
 625:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 626:main.c        **** //    Off (6/63): DTL1 = 0
 627:main.c        **** //    38-39/63:      DTL1 = 1
 628:main.c        **** //    54-55/63:		DTL1 = 2	(FOUR_SHADES only)
 629:main.c        **** //    62-63/63:      DTL1 = 3
 630:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 631:main.c        **** //    Off (15/63):  OCR1A=4
 632:main.c        **** //    47/63:        OCR1A=5
 633:main.c        **** //    63/63:        OCR1A=6
 634:main.c        **** //
 635:main.c        **** 
 636:main.c        **** // Toward creating a GIMP palette... v54.5
 637:main.c        **** // Probably absurd, but this was brown/orange on GIMP and it's yellow here
 638:main.c        **** //
 639:main.c        **** //   Red: (+OC1D => RX0+)
 640:main.c        **** //    Off (0/63): OCR1D = 0	r=0
 641:main.c        **** //    35/63:      OCR1D = 3	r=142
 642:main.c        **** //    51/63:      OCR1D = 4	r=206
 643:main.c        **** //    63/63:      OCR1D >= 6	r=255
 644:main.c        **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
 645:main.c        **** //    Off (6/63): DTL1 = 0		g=24
 646:main.c        **** //    38-39/63:      DTL1 = 1 g=154
 647:main.c        **** //    54-55/63:		DTL1 = 2	g=218
 648:main.c        **** //    62-63/63:      DTL1 = 3 g=251
 649:main.c        **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
 650:main.c        **** //    Off (15/63):  OCR1A=4	b=61
 651:main.c        **** //    47/63:        OCR1A=5	b=190
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 34


 652:main.c        **** //    63/63:        OCR1A=6	b=255
 653:main.c        **** //
 654:main.c        **** //  These numbers don't look entirely accurate...
 655:main.c        **** //    they vary depending on the other colors... and why is blue so high
 656:main.c        **** //    even when it's off?
 657:main.c        **** //  Maybe I'm looking at old notes...?
 658:main.c        **** //   SEE lvdsColorExperiments.c Now Here.
 659:main.c        **** 
 660:main.c        **** 
 661:main.c        **** //  Implementations/prospects:
 662:main.c        **** //  * rowBuffer.c (more like row-settings-buffer)
 663:main.c        **** //     calculate a row's worth of pixels before drawing that row
 664:main.c        **** //     (uses packed color settings in a single byte per drawable pixel)
 665:main.c        **** //     64 drawable pixels across, regardless of LVDS speed
 666:main.c        **** //  * For faster pixels: these settings values could be stored 
 667:main.c        **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 668:main.c        **** //     (not implemented)
 669:main.c        **** //  * rowSegBuffer.c
 670:main.c        **** //     also calculates an entire row before drawing it
 671:main.c        **** //     instead of storing pixels, store "segments"
 672:main.c        **** //     i.e. each segment is defined by a color value and a length
 673:main.c        **** //      the color-value is stored as DT/OCR values (not RGB values)
 674:main.c        **** //     Number of segments is limited only by memory...
 675:main.c        **** //      e.g. 64 segments per row (max) is 64*3Bytes
 676:main.c        **** //       Three bytes for color, and *really simple* packing for seg-length
 677:main.c        **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 678:main.c        **** //       as high as one LCD pixel.
 679:main.c        **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 680:main.c        **** //      (with packing)
 681:main.c        **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 682:main.c        **** //      only adds two clock cycles to each "pixel", so probably worth it
 683:main.c        **** 
 684:main.c        **** //   In Any Case: There's not enough RAM for a full frame
 685:main.c        **** //          64 pixels across * 64 pixels down is 4096 bytes
 686:main.c        **** //          So whatever method, we need to precalculate each row before
 687:main.c        **** //          displaying it
 688:main.c        **** //          Could be as simple as loading direct from program memory
 689:main.c        **** //
 690:main.c        **** 
 691:main.c        **** // Since low-bits are barely visible, their effect is neglected.
 692:main.c        **** //   Thus: Green is affected only by the Compare-Match deadTimer (DT1L)
 693:main.c        **** //         Red is affected only by OCR1D, and could be single-ended
 694:main.c        **** //   OTOH:
 695:main.c        **** //         The Visible blue values (with DT affecting clock)
 696:main.c        **** //         are only the high-two values, which are affected only by OCR1A
 697:main.c        **** //         So counter-reset dead-time (DT1H) needn't be varied
 698:main.c        **** //         And, then, the clock won't be affected at all
 699:main.c        **** //         (assuming we set it to single-ended during DE disabled, for V/H)
 700:main.c        **** //
 701:main.c        **** // NEW CONSIDERATION: "The dead timer delays the waveform by a minimum of
 702:main.c        **** //    "of one count, when DT=0..."
 703:main.c        **** // So changing the clock from single-ended to complementary
 704:main.c        **** //   might actually cause the clock output to be shifted!
 705:main.c        **** 
 706:main.c        **** 
 707:main.c        **** // DE/V/H Timing (LCDdirectLVDS):
 708:main.c        **** //  
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 35


 709:main.c        **** //
 710:main.c        **** //            |  0   1    2    3    4    5    6       All: set @ 0
 711:main.c        **** //            |____.____.____.____                         OCR1C = 6 
 712:main.c        **** //  Clock:    /                   \    .    .    /         Complementary-
 713:main.c        **** //                                             Output Mode
 714:main.c        **** //                                                          required for DT
 715:main.c        **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 716:main.c        **** //             ____ ____ ____ ____ ____ ____ ____|____    
 717:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 718:main.c        **** //   state2                      |    
 719:main.c        **** //   DE_BLUE: >|    DT=X, OCR=0
 720:main.c        **** //                         Watch the transition!! -------^
 721:main.c        **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 722:main.c        **** //   DC_DISABLED:
 723:main.c        **** //   maxBlue: >\____|		DT=0, OCR=5
 724:main.c        **** //             See below for more blue settings...
 725:main.c        **** //
 726:main.c        **** //             ____ ____      ____      ____ ____|____ 
 727:main.c        **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 728:main.c        **** //   state1              | 
 729:main.c        **** //            >______________/\______________|    DT=3, OCR=3
 730:main.c        **** //  DC_DISABLED:
 731:main.c        **** //   Not much can be done...
 732:main.c        **** //
 733:main.c        **** //             ____ ____           ____ ____ ____|____ 
 734:main.c        **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 735:main.c        **** //   state3              |
 736:main.c        **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 737:main.c        **** // DC_DISABLED:
 738:main.c        **** //            >___________________/\____|		DT=4, OCR=5
 739:main.c        **** 
 740:main.c        **** //             ____ ____                ____ ____|____ 
 741:main.c        **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 742:main.c        **** //   state4          | 
 743:main.c        **** //            >__________________________________|    DT=X, OCR=0
 744:main.c        **** //                             TransitionWatch!!! -------^
 745:main.c        **** //                             Shouldn't matter... DT from no-edge
 746:main.c        **** // DC_DISABLED:
 747:main.c        **** //            >\________________________|		DT=0, OCR=1
 748:main.c        **** 
 749:main.c        **** //             ____ ____      ____ ____ ____ ____|____ 
 750:main.c        **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 751:main.c        **** //   state0                  |     
 752:main.c        **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 753:main.c        **** // DC_DISABLED:
 754:main.c        **** //            >______________/\____|		DT=3, OCR=5
 755:main.c        **** 
 756:main.c        **** // Transitions: OLD!!!!! WRONG!!!!
 757:main.c        **** //   (are they? There're several additional transitions, now, for one.)
 758:main.c        **** //  The idea is to reduce the number of instructions between each
 759:main.c        **** //  LVDS "state."
 760:main.c        **** //  These are implemented below in the case:
 761:main.c        **** //    "#else //NOT FULL_INIT_TESTS"
 762:main.c        **** //  Since each instruction takes *longer than* a single pixel
 763:main.c        **** //    two instructions would *at best* occur on two consecutive pixels
 764:main.c        **** //    Thus, there's likely to be a transition-glitch
 765:main.c        **** //    (e.g. old OCR value with new DT value)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 36


 766:main.c        **** //  Note that the new DT values are implemented at the next corresponding
 767:main.c        **** //    edge after the DT-write instruction completes
 768:main.c        **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 769:main.c        **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 770:main.c        **** //    New OCR values are delayed until the next TCNT reset to 0
 771:main.c        **** //
 772:main.c        **** //  Initial:
 773:main.c        **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 774:main.c        **** 
 775:main.c        **** //  Nada	->	H			OCR=2
 776:main.c        **** //  H		->	Nada		OCR=NADA_OCR
 777:main.c        **** //  
 778:main.c        **** //  Nada	->	V			DT=3
 779:main.c        **** //  V		->	V+H		OCR=0
 780:main.c        **** //  V+H	->	V			OCR=NADA_OCR
 781:main.c        **** //  V		->	Nada		DT=2
 782:main.c        **** //
 783:main.c        **** //  Nada	->	DE			DT=1
 784:main.c        **** //  DE	->	Nada		DT=2
 785:main.c        **** 
 786:main.c        **** 
 787:main.c        **** #if (defined(REMOVE_DC) && REMOVE_DC)
 788:main.c        **** #error "REMOVE_DC hasn't been tested since lcdStuff, or long prior"
 789:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 790:main.c        **** 
 791:main.c        ****  //Unused, normally...
 792:main.c        ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 793:main.c        ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
 794:main.c        ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 795:main.c        ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
 796:main.c        ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 797:main.c        **** 
 798:main.c        **** #else //!REMOVE_DC
 799:main.c        **** //Nada init
 800:main.c        ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 801:main.c        **** 
 802:main.c        **** //Unused, normally...
 803:main.c        ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 804:main.c        ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 805:main.c        ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 806:main.c        **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 807:main.c        ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
 808:main.c        ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 809:main.c        **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 810:main.c        ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 811:main.c        **** #endif //REMOVE_DC
 812:main.c        **** 
 813:main.c        **** 
 814:main.c        **** //#define FULL_INIT_TESTS TRUE
 815:main.c        **** 
 816:main.c        **** //Display is DE-Only (doesn't use H/Vsync)
 817:main.c        **** // Shouldn't be necessary to select this if it is,
 818:main.c        **** // since DE timing is the same either way
 819:main.c        **** // but I want to test whether a single-bit is being detected
 820:main.c        **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 821:main.c        **** //  single bit, which might explain why the other display didn't work)
 822:main.c        **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 37


 823:main.c        **** #define Vsync_fromNada()      Nada_init()
 824:main.c        **** #define VplusH_fromVsync()    Nada_init()
 825:main.c        **** #define Vsync_fromVplusH()    Nada_init()
 826:main.c        **** #define Nada_fromVsync()      Nada_init()
 827:main.c        **** #define Hsync_fromNada()      Nada_init()
 828:main.c        **** #define Nada_fromHsync()      Nada_init()
 829:main.c        **** #define DEonly_fromNada()     DE_init()
 830:main.c        **** #define DEblue_fromDEonly()	DE_init()
 831:main.c        **** #define Nada_fromDEblue()		Nada_init()
 832:main.c        ****  #if(DE_BLUE)
 833:main.c        ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 834:main.c        ****   #warning "...The display should be blank"
 835:main.c        ****  #endif
 836:main.c        **** //Use full initialization of each LVDS state
 837:main.c        **** // (might not be good during transitions, but should guarantee
 838:main.c        **** //  steady-state, in case my transitions aren't correct...)
 839:main.c        **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 840:main.c        **** #define Vsync_fromNada()		Vsync_init()
 841:main.c        **** #define VplusH_fromVsync()		VplusH_init()
 842:main.c        **** #define Vsync_fromVplusH()		Vsync_init()
 843:main.c        **** #define Nada_fromVsync()		Nada_init()
 844:main.c        **** #define Hsync_fromNada()		Hsync_init()
 845:main.c        **** #define Nada_fromHsync()		Nada_init()
 846:main.c        **** #define DEonly_fromNada()		DEonly_init()
 847:main.c        **** #define DEblue_fromDEonly()	DEblue_init()
 848:main.c        **** #define Nada_fromDEonly()		Nada_init()
 849:main.c        **** #define Nada_fromDEblue()		Nada_init()
 850:main.c        **** 
 851:main.c        **** 
 852:main.c        **** #else	//NOT FULL_INIT_TESTS
 853:main.c        **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 854:main.c        **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 855:main.c        **** 																	 //for easy-scoping
 856:main.c        **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 857:main.c        **** #define VplusH_fromVsync() { OCR1A=0; }
 858:main.c        **** //#define Vsync_fromVplusH() { OCR1A=4; }
 859:main.c        **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
 860:main.c        **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 861:main.c        **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 862:main.c        **** #define Hsync_fromNada()   { OCR1A=3; }
 863:main.c        **** #define Nada_fromHsync()   { OCR1A=4; }
 864:main.c        **** 
 865:main.c        **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 866:main.c        **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 867:main.c        **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 868:main.c        **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 869:main.c        **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 870:main.c        **** 
 871:main.c        **** /*
 872:main.c        **** #if (!defined(DE_BLUE) || !DE_BLUE)
 873:main.c        ****  //Nada -> DE
 874:main.c        ****  //#define DE_fromNada()      { DT1=(1<<4); }	//DT1 = (1<<4);
 875:main.c        ****  #define DE_fromNada()      { DT1=(2<<4); }
 876:main.c        ****  //DE -> Nada
 877:main.c        ****  //#define Nada_fromDE()      { DT1=(2<<4); }	//DT1 = (2<<4);
 878:main.c        ****  #define Nada_fromDE()      { DT1=(3<<4); }
 879:main.c        **** #else
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 38


 880:main.c        ****  //Nada -> DE
 881:main.c        ****  //#define DE_fromNada()      { OCR1A=0xff; }   //DT1 = (1<<4);
 882:main.c        ****  #define DE_fromNada()      { OCR1A=0xff; }
 883:main.c        ****  //DE -> Nada
 884:main.c        ****  //#define Nada_fromDE()      { OCR1A=3; }   //DT1 = (2<<4);
 885:main.c        ****  #define Nada_fromDE()      { OCR1A=4; }
 886:main.c        **** #endif
 887:main.c        **** */
 888:main.c        **** #endif //End Of FULL_INIT_TESTS
 889:main.c        **** 
 890:main.c        **** 
 891:main.c        **** 
 892:main.c        **** // NOTES:
 893:main.c        **** //    DeadTimer requires
 894:main.c        **** //        COM1x1:0 = 01 ("Complementary Compare Output Mode" ?)
 895:main.c        **** //      Complementary Compare Output Mode:
 896:main.c        **** //        OCW1A: cleared on match, set at BOTTOM
 897:main.c        **** //    If PWM1X (pwm inversion) is used, OC1A = !OCW1A
 898:main.c        **** //        (Does not affect DT)
 899:main.c        **** //
 900:main.c        **** // CLOCK:
 901:main.c        **** //    Can NOT use differential mode with:
 902:main.c        **** //		 OC1B pin is -differential input (through a resistor)
 903:main.c        **** //    /OC1B pin is +differential input (through a resistor)
 904:main.c        **** //    BECAUSE: DeadTimer affects ALL PWM channels
 905:main.c        **** //
 906:main.c        **** 
 907:main.c        **** //
 908:main.c        **** //
 909:main.c        **** // ISSUES:
 910:main.c        **** //    Using Dead-Timer does not allow for use of complementary outputs
 911:main.c        **** //      as complementary LVDS inputs... 
 912:main.c        **** //      DeadTimer affects ALL PWM channels in complementary mode
 913:main.c        **** //    (e.g. RXclkin+ on OC1B and RXclkin- on /OC1B is not an option)
 914:main.c        **** //
 915:main.c        **** 
 916:main.c        **** 
 917:main.c        **** // The typical patterns look like this (not at all to scale):
 918:main.c        **** //   ----______------------------------------------------___----- V
 919:main.c        **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
 920:main.c        **** //      __________-__-__-__-__-__-__-__-__-__-  DE
 921:main.c        **** //                 
 922:main.c        **** //             ^^^^\														//blah
 923:main.c        **** //             1234 5?
 924:main.c        **** // Pixels are sent during DE High (basically all the CPU will be used here)
 925:main.c        **** //Ideally, 
 926:main.c        **** //  there won't be any glitches when changing from one state to another
 927:main.c        **** //
 928:main.c        **** //  NOTES: PWM1X inversion affects all PWM channels!
 929:main.c        **** //
 930:main.c        **** //  Unchangeables:
 931:main.c        **** //    FastPWM
 932:main.c        **** //		inverted with PWM1X
 933:main.c        **** //
 934:main.c        **** //  Init (pre 1):
 935:main.c        **** //    DeadTimerRising=1
 936:main.c        **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 39


 937:main.c        **** //  The states are:
 938:main.c        **** //   (Not necessarily accurate, just looking into necessary changes)
 939:main.c        **** //   (from Vsync L->H)
 940:main.c        **** //
 941:main.c        **** //   1  NothingActive (long, No DE, VporchFrontTimes)
 942:main.c        **** //      *  1<=DeadTimerRising<=5
 943:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 944:main.c        **** //      *  OCR1A == 6
 945:main.c        **** //
 946:main.c        **** //   2  Hsync
 947:main.c        **** //      *  DeadTimer _OFF_ -> Horiz
 948:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 949:main.c        **** //        (OCR1A == 6
 950:main.c        **** //   3  NothingActive (short)
 951:main.c        **** //      *  1<=DeadTimerRising<=5
 952:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 953:main.c        **** //        (OCR1A == 6
 954:main.c        **** //   4  DE
 955:main.c        **** //        (1<=DeadTimerRising<(=?)5 (>1 for blue pixels?) 
 956:main.c        **** //            (==5 cancelled by OCR1A match?)
 957:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 958:main.c        **** //      *  OCR1A = 5 (or 1<=OCR1A<5 for blue pixels?)
 959:main.c        **** //   5  NothingActive(?)
 960:main.c        **** //        (1<=DeadTimerRising<=5
 961:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 962:main.c        **** //      *  OCR1A == 6
 963:main.c        **** //
 964:main.c        **** //   7  Repeat 2-5 for each row
 965:main.c        **** //
 966:main.c        **** //   8  NothingActive (long, No DE, VporchBackTimes)
 967:main.c        **** //      ?  1<=DeadTimerRising<=5
 968:main.c        **** //        (OCW1A: set @ BOTTOM, cleared @ OCR1A
 969:main.c        **** //        (OCR1A == 6
 970:main.c        **** //
 971:main.c        **** //   9  V w/o H
 972:main.c        **** //      ?  OFF <= DeadTimer <= (5 - OCR1A)
 973:main.c        **** //     **  OCW1A: cleared at BOTTOM, set at OCR1A
 974:main.c        **** //            ??? What is the effect of changing this while running?
 975:main.c        **** //      *  1 <= OCR1A <= 5
 976:main.c        **** //   10 V w/  H
 977:main.c        **** //      ?   DeadTimer OFF (H -> Low)
 978:main.c        **** //      *   OCW1A: set @ BOTTOM, cleared @ OCR1A
 979:main.c        **** //      *   OCR1A > (=?) OCR1C
 980:main.c        **** //
 981:main.c        **** //   11 Repeat 9-10 for Vsync time...
 982:main.c        **** //
 983:main.c        **** 
 984:main.c        **** // Here's how it worked pre-lvds:
 985:main.c        **** // HSYNC, VSYNC, and DE refer to the actual pins
 986:main.c        **** // In the LVDS setup, there're modes corresponding to each pin-combination
 987:main.c        **** //
 988:main.c        **** // Timer Interrupt:
 989:main.c        **** //  loadData:
 990:main.c        **** //   HSYNC active
 991:main.c        **** //   HSYNC Low delay
 992:main.c        **** //   HSYNC inactive
 993:main.c        **** //   if(dataEnable)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 40


 994:main.c        **** //    DE active
 995:main.c        **** //     Send row data
 996:main.c        **** //    DE inactive
 997:main.c        **** //  //Prep for next interrupt
 998:main.c        **** //  switch(hsyncCount++)
 999:main.c        **** //    //Vsync H->L (active)
1000:main.c        **** //    1:
1001:main.c        **** //          dataEnable=FALSE
1002:main.c        **** //          VSYNC active
1003:main.c        **** //    //Vsync L->H (inactive)
1004:main.c        **** //    T_Vlow:
1005:main.c        **** //          VSYNC inactive
1006:main.c        **** //    //Start of frame
1007:main.c        **** //    T_VD +(T_Vlow):
1008:main.c        **** //          dataEnable=TRUE
1009:main.c        **** //    //All rows have been displayed
1010:main.c        **** //    V_COUNT +(T_VD+T_Vlow):
1011:main.c        **** //          dataEnable=FALSE
1012:main.c        **** //    //Frame Complete
1013:main.c        **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
1014:main.c        **** //          hsyncCount=0
1015:main.c        **** //  if(dataEnable)
1016:main.c        **** //    Use the remaining time to load the next row to memory
1017:main.c        **** 
1018:main.c        **** //  So:
1019:main.c        **** //Interrupt0       End
1020:main.c        **** //    |             |  Interrupt1
1021:main.c        **** //    v             v  v
1022:main.c        **** //  H |_||_||_|
1023:main.c        **** // DE ___________________________________________________ ...
1024:main.c        **** //  V |_____________________________________ ...
1025:main.c        **** //       |        ||
1026:main.c        **** // DETIME^--------^|
1027:main.c        **** //                 |
1028:main.c        **** //                 VSYNC active
1029:main.c        **** //                 dataEnable=FALSE (not necessary?)
1030:main.c        **** //
1031:main.c        **** //InterruptT_Vlow   End
1032:main.c        **** //    |             |
1033:main.c        **** //    v             v
1034:main.c        **** //  H |_||_||_|
1035:main.c        **** // DE ___________________________________________________ ...
1036:main.c        **** //  V _____________| ...
1037:main.c        **** //       |        ||
1038:main.c        **** // DETIME^--------^|
1039:main.c        **** //                 |
1040:main.c        **** //                 VSYNC inactive
1041:main.c        **** //
1042:main.c        **** //
1043:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1044:main.c        **** //    |             |  |            End
1045:main.c        **** //    v             v  v            v
1046:main.c        **** //  H |_||_||_|
1047:main.c        **** // DE ____________________||_______||____ ...
1048:main.c        **** //  V 
1049:main.c        **** //       |        ||      |        |
1050:main.c        **** // DETIME^--------^|      ^--------^
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 41


1051:main.c        **** //                 |
1052:main.c        **** //                 dataEnable=TRUE
1053:main.c        **** //
1054:main.c        **** //InterruptV_COUNT  End
1055:main.c        **** //    |             |
1056:main.c        **** //    v             v
1057:main.c        **** //  H |_||_||_|
1058:main.c        **** // DE ___||______________________________________ ...
1059:main.c        **** //  V 
1060:main.c        **** //       |        ||      |        |
1061:main.c        **** // DETIME^--------^|      ^--------^
1062:main.c        **** //                 |
1063:main.c        **** //                 dataEnable=FALSE
1064:main.c        **** //
1065:main.c        **** //
1066:main.c        **** // This isn't really a state, it's basically just:
1067:main.c        **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
1068:main.c        **** //    hsyncCount = 0;
1069:main.c        **** //                    .....................................
1070:main.c        **** //                    .                                   .
1071:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1072:main.c        **** //    |             | .|                                  .
1073:main.c        **** //    v             v .v                                  .
1074:main.c        **** //  H |_||_||_|
1075:main.c        **** // DE ___________________________________________________ .
1076:main.c        **** //  V |____________________ .
1077:main.c        **** //       |        ||  .   |        |                      .
1078:main.c        **** // DETIME^--------^|  .   ^--------^                      .
1079:main.c        **** //                 |  .                                   .
1080:main.c        **** //                 hsyncCount=0 (repeat from Interrupt0)  .
1081:main.c        **** //                    .                                   .
1082:main.c        **** //                    .....................................
1083:main.c        **** //
1084:main.c        **** 
1085:main.c        **** 
1086:main.c        **** // NOW to compare with LVDS states:
1087:main.c        **** //
1088:main.c        **** //Interrupt0       End
1089:main.c        **** //    |             |  Interrupt1
1090:main.c        **** //    v             v  v
1091:main.c        **** //  H |_||_||_|
1092:main.c        **** // DE ___________________________________________________ ...
1093:main.c        **** //  V |_____________________________________ ...
1094:main.c        **** //    ^ ^          ^   ^ ^
1095:main.c        **** //    | |          |   | |
1096:main.c        **** //    | |          |   | +--- V w/o H  \ These two toggle until
1097:main.c        **** //    | |          |   +----- V w/ H   / next LCD state...
1098:main.c        **** //    | |          |
1099:main.c        **** //    | |          +--------- V w/o H > Intermediate change of state
1100:main.c        **** //    | |
1101:main.c        **** //    | +----- NothingActive  \ From Previous State (?)
1102:main.c        **** //    +------- H_Only         /
1103:main.c        **** 
1104:main.c        **** 
1105:main.c        **** //InterruptT_Vlow   End
1106:main.c        **** //    |             |
1107:main.c        **** //    v             v
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 42


1108:main.c        **** //  H |_||_||_|
1109:main.c        **** // DE ___________________________________________________ ...
1110:main.c        **** //  V _____________| ...
1111:main.c        **** //    ^ ^          ^   ^ ^
1112:main.c        **** //    | |          |   | |
1113:main.c        **** //    | |          |   | +--- NothingActive  \ These two toggle until
1114:main.c        **** //    | |          |   +----- H_Only         / next LCD state...
1115:main.c        **** //    | |          |
1116:main.c        **** //    | |          +--------- NothingActive > Intermediate change of state
1117:main.c        **** //    | |
1118:main.c        **** //    | +----- V w/o H   \ From previous state
1119:main.c        **** //    +------- V w/ H    /
1120:main.c        **** 
1121:main.c        **** 
1122:main.c        **** //InterruptT_VD   End  InterruptT_VD+1
1123:main.c        **** //    |             |  |            End
1124:main.c        **** //    v             v  v            v
1125:main.c        **** //  H |_||_||_|
1126:main.c        **** // DE ____________________||_______||____ ...
1127:main.c        **** //  V 
1128:main.c        **** //    ^ ^              ^ ^^        ^ 
1129:main.c        **** //    | |              | ||        |
1130:main.c        **** //    | |              | ||        +--- NothingActive  \  These four
1131:main.c        **** //    | |              | |+------------ DE              | cycle until
1132:main.c        **** //    | |              | +------------- NothingActive   | next LCD state...
1133:main.c        **** //    | |              +--------------- H_Only  ^      /
1134:main.c        **** //    | |                                       |
1135:main.c        **** //    | +----- NothingActive  \ From previous   |
1136:main.c        **** //    +------- H_Only         / state           +-This intermediate state
1137:main.c        **** //                                                may not be necessary
1138:main.c        **** //                                                (IAXG01 shows 160 dots!)
1139:main.c        **** 
1140:main.c        **** 
1141:main.c        **** 
1142:main.c        **** //InterruptV_COUNT  End
1143:main.c        **** //    |             |
1144:main.c        **** //    v             v
1145:main.c        **** //  H |_||_||_|
1146:main.c        **** // DE ___||______________________________________ ...
1147:main.c        **** //  V 
1148:main.c        **** //    ^ ^^        ^    ^ ^
1149:main.c        **** //    | ||        |    | |
1150:main.c        **** //    | ||        |    | +--- NothingActive \  These two toggle
1151:main.c        **** //    | ||        |    +----- H_Only        /  until next LCD state
1152:main.c        **** //    | ||        |
1153:main.c        **** //    | ||        +---- NothingActive \ 								//blah
1154:main.c        **** //    | |+------------- DE             |  From previous state
1155:main.c        **** //    | +-------------- NothingActive  |
1156:main.c        **** //    +---------------- H_Only        /
1157:main.c        **** 
1158:main.c        **** // This isn't really a state, it's essentially just:
1159:main.c        **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
1160:main.c        **** //    hsyncCount = 0;
1161:main.c        **** //                    .....................................
1162:main.c        **** //                    .                                   .
1163:main.c        **** //InterruptT_DV   End .Interrupt0                         .
1164:main.c        **** //    |             | .|                                  .
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 43


1165:main.c        **** //    v             v .v                                  .
1166:main.c        **** //  H |_||_||_|
1167:main.c        **** // DE ___________________________________________________ .
1168:main.c        **** //  V |____________________ .
1169:main.c        **** //    ^ ^             .                                   .
1170:main.c        **** //    | |             .....................................
1171:main.c        **** //    | +--- NothingActive \											//blah
1172:main.c        **** //    +----- H_Only        / From previous state...
1173:main.c        **** 
1174:main.c        **** 
1175:main.c        **** 
1176:main.c        **** //  LVDS State transitions:
1177:main.c        **** //   1 H_Only
1178:main.c        **** //   2 NothingActive
1179:main.c        **** //
1180:main.c        **** //   3 V w/o H
1181:main.c        **** //   4 V w/ H
1182:main.c        **** //    
1183:main.c        **** //   (repeat 3,4)
1184:main.c        **** //
1185:main.c        **** //   5 V w/o H
1186:main.c        **** //
1187:main.c        **** //   6 NothingActive
1188:main.c        **** //   7 H_Only
1189:main.c        **** //
1190:main.c        **** //   (repeat 6,7)
1191:main.c        **** //
1192:main.c        **** //   8 NothingActive
1193:main.c        **** //
1194:main.c        **** //   9 H_Only
1195:main.c        **** //  10 NothingActive
1196:main.c        **** //  11 DE
1197:main.c        **** //  12 NothingActive
1198:main.c        **** //
1199:main.c        **** //  (repeat 9-12)
1200:main.c        **** //
1201:main.c        **** //  13 H_Only
1202:main.c        **** //  14 NothingActive
1203:main.c        **** //
1204:main.c        **** //  (repeat 13-14)
1205:main.c        **** //
1206:main.c        **** //   These should be reviewed to determine which changes are necessary
1207:main.c        **** //   between each state...
1208:main.c        **** //   (the fewer changes, the less likely we'll glitch...?)
1209:main.c        **** 
1210:main.c        **** 
1211:main.c        **** // This'll probably be better rearranged...
1212:main.c        **** //  For now, though, OC1A is in all the notes above, for the D/V/H signal
1213:main.c        **** //  so OC1B is for the clock...
1214:main.c        **** // CHANGING THESE does NOT change channel association.
1215:main.c        **** #define DVH_OCR	OCR1A
1216:main.c        **** #define CLOCK_OCR	OCR1B
1217:main.c        **** 
1218:main.c        **** 
1219:main.c        **** void pll_enable(void)
1220:main.c        **** {
1221:main.c        **** 	//Stolen from threePinIDer109t:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 44


1222:main.c        **** 
1223:main.c        ****    //Set Timer1 to use the "asynchronous clock source" (PLL at 64MHz)
1224:main.c        ****    // With phase-correct PWM (256 steps up, then back down) and CLKDIV1
1225:main.c        ****    // this is 64MHz/512=125kHz
1226:main.c        ****    // The benefit of such high PWM frequency is the low RC values necessary
1227:main.c        ****    //  for filtering to DC.
1228:main.c        ****    // "To change Timer/Counter1 to the async mode follow this procedure"
1229:main.c        ****    // 1: Enable the PLL
1230:main.c        ****    setbit(PLLE, PLLCSR);
1231:main.c        ****    // 2: Wait 100us for the PLL to stabilize
1232:main.c        ****    // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
1233:main.c        ****    _delay_us(100);
1234:main.c        **** //   dmsWait(1);
1235:main.c        ****    // 3: Poll PLOCK until it is set...
1236:main.c        ****    while(!getbit(PLOCK, PLLCSR))
1237:main.c        ****    {
1238:main.c        ****       asm("nop");
1239:main.c        ****    }
1240:main.c        ****    // 4: Set the PCKE bit to enable async mode
1241:main.c        ****    setbit(PCKE, PLLCSR);
1242:main.c        **** 
1243:main.c        **** }
1244:main.c        **** 
1245:main.c        **** void lvds_timerInit(void)
1246:main.c        **** {
1247:main.c        ****    //Timer1 is used for LVDS (in PLL clocking mode)
1248:main.c        ****   
1249:main.c        ****   	//pll_enable();	
1250:main.c        ****    
1251:main.c        ****    //We want it to count 7 bits, 0-6 and reset at 7
1252:main.c        ****    OCR1C = 6;
1253:main.c        **** 
1254:main.c        **** 	//We want the clock to go low at TCNT=0 and high at TCNT=4
1255:main.c        **** 	CLOCK_OCR = 3; //2; //3;
1256:main.c        ****    
1257:main.c        **** 
1258:main.c        **** // My 'scope is only 20MHz, and I'd rather be able to use the digital mode
1259:main.c        **** // which is even slower...
1260:main.c        **** 
1261:main.c        **** 
1262:main.c        **** //Overridden when SLOW_EVERYTHING_TEST is true...
1263:main.c        **** //#define TOOFAST_TEST TRUE
1264:main.c        **** #warning "HERE AND BELOW, doesn't OSCCAL have special write requirements?"
1265:main.c        **** //OSCCAL = 0x00;
1266:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1267:main.c        **** //FOR TESTING. This should slow the clock...
1268:main.c        **** 	// Gives roughly 4MHz...
1269:main.c        **** 	OSCCAL = 0x00; //0x80; 
1270:main.c        **** 
1271:main.c        **** 	// This should divide the system clock by 256
1272:main.c        **** 	// does this affect the PLL? NO.
1273:main.c        **** 	// The PLL is clocked only by the RC Oscillator
1274:main.c        **** 	//   OSCCAL does affect it.
1275:main.c        **** 	// OPTIONS FOR SIMULATING FULL FUNCTIONALITY AT LOW SPEED:
1276:main.c        **** 	// Run PLL as normal
1277:main.c        **** 	//  Prescale Timer1 and DeadTimer equally
1278:main.c        **** 	//  Prescale System clock equally
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 45


1279:main.c        **** 	CLKPR = (1<<CLKPCE);
1280:main.c        **** 	CLKPR = (1<<CLKPS1) | (1<<CLKPS0);	//CLKDIV8
1281:main.c        **** 	//4MHz / 8 = .5Mhz...
1282:main.c        **** 	//PLL is 4MHz*8 = 32MHz
1283:main.c        **** 	// then TimerClockDivisor=8 gives 4MHz
1284:main.c        **** 	pll_enable();
1285:main.c        **** 	#define SLOW_LVDS_TEST TRUE
1286:main.c        **** #elif (defined(OSCCAL_VAL))
1287:main.c        ****    OSCCAL = OSCCAL_VAL;
1288:main.c        **** #endif
1289:main.c        **** 
1290:main.c        **** 
1291:main.c        **** 
1292:main.c        **** #if (defined(SLOW_LVDS_TEST) && SLOW_LVDS_TEST)
1293:main.c        **** 	//This case doesn't really make sense without SLOW_EVERYTHING...
1294:main.c        **** 	//8x prescaler for Timer1
1295:main.c        **** 	#define CSBITS (1<<CS12)
1296:main.c        **** 	//8x prescaler for the dead-timer
1297:main.c        **** 	#define DTPSBITS ((1<<DTPS11) | (1<<DTPS10))
1298:main.c        **** #elif (defined(LVDS_PRESCALER))
1299:main.c        **** 	//Timer1 on the Tiny861 uses a strange CLKDIV scheme...
1300:main.c        **** 	// (but it's nicer!)
1301:main.c        **** 	// The divisor is (1<<(csbits-1))
1302:main.c        **** 	// so a divisor of 1 = (1<<0) = (1<<(1-1)), (csbits = 0x1)
1303:main.c        **** 	// 256 = (1<<8) = (1<<(9-1)), (csbits = 0x9)
1304:main.c        **** 	// 512 = (1<<9) = (1<<(10-1)), (csbits = 0xA)
1305:main.c        **** 	// ...
1306:main.c        **** 	// (0x0 stops the timer)
1307:main.c        **** 	/*
1308:main.c        **** 		uint16_t divisor;
1309:main.c        **** 		uint8_t csbits = 0;
1310:main.c        **** 		for(divisor=CLKDIV; divisor != 0; divisor>>=1)
1311:main.c        **** 		   csbits++;
1312:main.c        **** 			writeMasked(csbits, 0x0f, TCCR1B);
1313:main.c        **** 	*/
1314:main.c        **** 
1315:main.c        **** //#if ((LVDS_PRESCALER != 64) && (LVDS_PRESCALER != 32) && \
1316:main.c        **** //	  (LVDS_PRESCALER != 16) && 
1317:main.c        **** #if ((LVDS_PRESCALER != 8) && \
1318:main.c        **** 	  (LVDS_PRESCALER != 4)  && (LVDS_PRESCALER != 2) && \
1319:main.c        **** 	  (LVDS_PRESCALER != 1))
1320:main.c        **** #error "LVDS_PRESCALER must be a power of 2, from 1 to 8"
1321:main.c        **** #endif
1322:main.c        **** 
1323:main.c        **** 	//Figured this out in cTools/dePower.c...
1324:main.c        **** 	//64 is overkill here, since the deadTimer prescaler only goes to 8...
1325:main.c        **** #define divToCS(div) \
1326:main.c        **** 	( (div == 64) ? 7 : (div == 32) ? 6 : (div == 16) ? 5 : (div == 8) ? 4 \
1327:main.c        **** 	  : (div == 4) ? 3 : (div == 2) ? 2 : (div == 1) ? 1 : 0)
1328:main.c        **** 
1329:main.c        **** 
1330:main.c        **** 	//CSBITS (through PLL/8) (CS10 is bit 0)
1331:main.c        **** 	//CS12:10	CS12	CS11	CS10		PLL division
1332:main.c        **** 	//1			0		0		1			1
1333:main.c        **** 	//2			0		1		0			2
1334:main.c        **** 	//3			0		1		1			4
1335:main.c        **** 	//4			1		0		0			8
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 46


1336:main.c        **** 	#define CSBITS divToCS(LVDS_PRESCALER) //<<CS10 should be redundant
1337:main.c        **** 	//DTPSBITS (DTPS10 is bit 4)
1338:main.c        **** 	//DTPS11:10	DTPS11 DTPS10	PLL division
1339:main.c        **** 	//0			0		0			1
1340:main.c        **** 	//1			0		1			2
1341:main.c        **** 	//2			1		0			4
1342:main.c        **** 	//3			1		1			8
1343:main.c        **** 	#define DTPSBITS ((CSBITS-1)<<DTPS10)
1344:main.c        **** 
1345:main.c        **** 	//Whoops! Forgot this (a/o 42-som'n WTF1pix)
1346:main.c        **** 	// so, it's promising to get single-pixel control...
1347:main.c        **** 	//  the result was kinda ugly, though... scroll was quite slow
1348:main.c        **** 	// Further, it was only drawing a certain number of pixels...
1349:main.c        **** 	//  (horizontally... pre LVDS_PRESCALER affecting DOTS_TO_CYC)
1350:main.c        **** 	//  so accessing *all* pixels in a row would make it even slower...
1351:main.c        **** 	// Further, it didn't seem to be paying attention to the fact that
1352:main.c        **** 	// the same pixels are drawn on multiple rows...
1353:main.c        **** 	// WTF? (the image was scaled, proportionately! 1pix x 1pix)
1354:main.c        **** 	pll_enable();
1355:main.c        **** 
1356:main.c        **** #else
1357:main.c        **** 	//No clock divisor
1358:main.c        **** 	#define CSBITS (1<<CS10)
1359:main.c        **** 	//No dead-timer divisor
1360:main.c        **** 	#define DTPSBITS 0
1361:main.c        **** 	pll_enable();
1362:main.c        **** 	//#warning "The PLL configuration code is not in here yet!"
1363:main.c        **** #endif
1364:main.c        **** 
1365:main.c        **** 	//Set the Timer1 clock prescaler...
1366:main.c        **** 	writeMasked(CSBITS, 
1367:main.c        **** 					((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)),
1368:main.c        **** 					TCCR1B);
1369:main.c        **** 
1370:main.c        **** 	//Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
1371:main.c        **** 	// Allegedly this is prescaled from the PCK (or CK)
1372:main.c        **** 	// 	NOT from the Timer1 prescaler...
1373:main.c        **** 	writeMasked(DTPSBITS,
1374:main.c        **** 					((1<<DTPS11) | (1<<DTPS10)),
1375:main.c        **** 					TCCR1B);
1376:main.c        **** 
1377:main.c        **** 
1378:main.c        **** 
1379:main.c        ****    //All LVDS modes (and signals) use FastPWM.. 
1380:main.c        ****  
1381:main.c        ****    //FastPWM
1382:main.c        **** //Now Handled in lvds_xxxOnCompare():
1383:main.c        **** 
1384:main.c        **** 	//These are also written below (excluding PWM1D)
1385:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
1386:main.c        ****                            //Need to do the same for other channels
1387:main.c        ****   
1388:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
1389:main.c        **** 
1390:main.c        **** 	setbit(PWM1D, TCCR1C);
1391:main.c        **** 
1392:main.c        **** 	//PWM1D is not in TCCR1A...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 47


1393:main.c        **** 
1394:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
1395:main.c        **** //	setoutPORT(PB0, PORTB);	//-OC1A 	MOSI unused
1396:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
1397:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
1398:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
1399:main.c        **** 
1400:main.c        **** 
1401:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
1402:main.c        ****                ((1<<WGM11) | (1<<WGM10)), // (affects all PWM channels)
1403:main.c        ****                TCCR1D);
1404:main.c        **** 
1405:main.c        **** 	//OC1A is used, but /OC1A isn't
1406:main.c        **** // Not Valid (deadTime only functions if in complementary-mode):
1407:main.c        **** 	// OTOH: dead-time is not necessary in the only case we need to switch
1408:main.c        **** 	// Most lvds states use clear on compare-match, set at 0
1409:main.c        **** 	// But there is one that uses the opposite
1410:main.c        **** 	// This can be toggled by a single bit-change
1411:main.c        **** 	//  COM1A1 = 1
1412:main.c        **** 	//  COM1A0 value indicates what happens on Compare-Match
1413:main.c        **** 	//					  or ! at BOTTOM
1414:main.c        **** //#define lvds_clrOnCompare() clrbit(COM1A0, TCCR1A)
1415:main.c        **** //#define lvds_setOnCompare() setbit(COM1A0, TCCR1A)
1416:main.c        **** 	//HOWEVER: the alternative is possible:
1417:main.c        **** 	// Use complementary (clear-on-compare)
1418:main.c        **** 	// and single-ended with set-on-compare
1419:main.c        **** 	// COM1A0 = 1
1420:main.c        **** 	// COM1A1 value indicates what happens on Compare-Match
1421:main.c        **** 
1422:main.c        **** /* These are three instructions apiece!
1423:main.c        **** #define lvds_ComplementaryClrOnCompare() clrbit(COM1A1, TCCR1A)
1424:main.c        **** 
1425:main.c        **** #define lvds_setOnCompare() setbit(COM1A1, TCCR1A)
1426:main.c        **** #define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1427:main.c        **** */
1428:main.c        **** 
1429:main.c        **** //Page 99:
1430:main.c        **** // "In Fast PWM Mode ... when the COM1x1:0 bits are set to 01 ...
1431:main.c        **** //  an user programmable Dead Time delay is inserted for 
1432:main.c        **** //  these complementary output pairs (OC1x and OC1x)."
1433:main.c        **** 
1434:main.c        **** //Page 98:
1435:main.c        **** // "The counter is loaded with a 4-bit DT1H or DT1L value from DT1 
1436:main.c        **** //  I/O register, depending on the edge of the Waveform 
1437:main.c        **** //  Output (OCW1x) when the dead time insertion is started."
1438:main.c        **** // In other words, (as it appears from the diagram)
1439:main.c        **** //  the dead-time value is loaded into the counter when the corresponding
1440:main.c        **** //  edge in OCW1x is detected
1441:main.c        **** //  So changing the value of DT1 affects the *next* corresponding edge 
1442:main.c        **** //   (NOT if the dead timer is already running)
1443:main.c        **** 
1444:main.c        **** //Page 96:
1445:main.c        **** // "The OCR1x Registers are double buffered when using any of the 
1446:main.c        **** // Pulse Width Modulation (PWM) modes."
1447:main.c        **** // "The double buffering synchronizes the update of the OCR1x 
1448:main.c        **** // Compare Registers to either top or bottom of the counting sequence.
1449:main.c        **** // The synchronization prevents the occurrence of odd-length, non-sym- 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 48


1450:main.c        **** // metrical PWM pulses, thereby making the output glitch-free."
1451:main.c        **** 
1452:main.c        **** //Page 100:
1453:main.c        **** //"A change of the COM1x1:0 bits state will have effect 
1454:main.c        **** // at the first Compare Match after the bits are written."
1455:main.c        **** //Page 97: HAH!
1456:main.c        **** //"Be aware that the COM1x1:0 bits are not double buffered 
1457:main.c        **** // together with the compare value. 
1458:main.c        **** // Changing the COM1x1:0 bits will take effect immediately."
1459:main.c        **** 
1460:main.c        **** 
1461:main.c        **** //#define lvds_setOnCompare()	
1462:main.c        **** //	TCCR1A = ( (1<<COM1A1) | (1<<COM1A0) 
1463:main.c        **** //			   | (0<<COM1B1) | (1<<COM1B0) 
1464:main.c        **** //			   | (1<<PWM1A) | (1<<PWM1B) )
1465:main.c        **** //#define lvds_ComplementaryClrOnCompare() \ //
1466:main.c        **** 	//Do TCCR1C first, because it contains shadow-bits of TCCR1A that I
1467:main.c        **** 	// don't want to have to rewrite...
1468:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
1469:main.c        **** 				| (1<<PWM1D) );
1470:main.c        **** 
1471:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
1472:main.c        ****             | (1<<COM1B1) | (0<<COM1B0) //Don't use complementary for CLK
1473:main.c        ****             | (1<<PWM1A) | (1<<PWM1B) );
1474:main.c        **** 
1475:main.c        **** //#define lvds_clrOnCompare() lvds_ComplementaryClrOnCompare()
1476:main.c        **** 
1477:main.c        **** 	// Enable Complementary-Mode (and thus the dead-timer)
1478:main.c        **** 	// This'll be changed as needed, but we need COM1A0 set prior to that
1479:main.c        **** 
1480:main.c        **** 	//	lvds_clrOnCompare();
1481:main.c        **** //	writeMasked(((0<<COM1A1) | (1<<COM1A0)), 
1482:main.c        **** //					((1<<COM1A1) | (1<<COM1A0)), 
1483:main.c        **** //					TCCR1A);
1484:main.c        **** 
1485:main.c        **** 
1486:main.c        **** 
1487:main.c        **** 	//THIS IS NOT THOROUGHLY THOUGHT-OUT...
1488:main.c        **** 	// as I recall, we need to use /OC1B for the clock output
1489:main.c        **** 	//  because it won't be affected by the deadtime...
1490:main.c        **** //Now Handled in lvds_xxxOnCompare():
1491:main.c        **** //	writeMasked(((0<<COM1B1) | (1<<COM1B0)),
1492:main.c        **** //					((1<<COM1B1) | (1<<COM1B0)),
1493:main.c        **** //					TCCR1A);
1494:main.c        **** 
1495:main.c        ****    //Since PWM inversion affects all channels, great-pains were taken
1496:main.c        ****    // to assure that it needn't be changed in any lvds state...
1497:main.c        ****    // PWM inversion must be enabled:
1498:main.c        **** 
1499:main.c        **** 	//inverted with PWM1X
1500:main.c        **** //   setbit(PWM1X, TCCR1B);
1501:main.c        ****  
1502:main.c        ****  	Nada_init();
1503:main.c        **** }
1504:main.c        **** 
1505:main.c        **** 
1506:main.c        **** //PWM Timing:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 49


1507:main.c        **** // (ATTiny861, Timer1, FastPWM, PWM1X;
1508:main.c        **** //  a/o LCDdirectLVDS1_5_PWMtimingTests):
1509:main.c        **** //
1510:main.c        **** //  PWM output on OC1A
1511:main.c        **** //    if OCR1A = 0, OC1A remains constant High
1512:main.c        **** //       OCR1A = 1, OC1A is low for 2 counts
1513:main.c        **** //       OCR1A = 2, OC1A is low for 3 counts
1514:main.c        **** //       OCR1A = 3, OC1A is low for 4 counts
1515:main.c        **** //       OCR1A = OCR1C, OC1A remains constant Low
1516:main.c        **** //
1517:main.c        **** //    THUS:
1518:main.c        **** //       compare-match occurs when TCNT changes AWAY from match
1519:main.c        **** //         (assuming TCNT starts at 0 for one pulse, 1 for one pulse...)
1520:main.c        **** //       TOP (OCR1C) is included in the count...
1521:main.c        **** //       There is no single-count pulse-width
1522:main.c        **** //         (Though, it seems dead-time could simulate it...)
1523:main.c        **** //         (set a deadtime of 1 on the BOTTOM edge and OCR1A)
1524:main.c        **** //         (but then there's no high for only one clock)
1525:main.c        **** 
1526:main.c        **** 
1527:main.c        **** 
1528:main.c        **** 
1529:main.c        **** //This isn't valid, who knows how many instructions the for loop takes
1530:main.c        **** static __inline__ \
1531:main.c        **** void delay_cyc(int32_t numCyc) \
1532:main.c        **** 	  __attribute__((__always_inline__));
1533:main.c        **** 
1534:main.c        **** //This'll optimze-out in some cases.
1535:main.c        **** // The timings and instructions used are probably specific to the
1536:main.c        **** // instruction-set in the MCU, the GCC version, optimization-level, etc.
1537:main.c        **** // a/o LCDdirectLVDS11 HLow_delay() this is how it's compiling...
1538:main.c        **** 
1539:main.c        **** // The actual number of cycs will probably be a few higher...
1540:main.c        **** // (or who knows, if things optimze-out, e.g. small ~0-8 numCycs)
1541:main.c        **** // Due to init, and division...
1542:main.c        **** // Using rounding-up as well...
1543:main.c        **** 
1544:main.c        **** // the argument is int32_t to allow for negative value testing
1545:main.c        **** // BUT: numCyc is only tested against a uint16_t...
1546:main.c        **** //  the greatest value (?) is (UINT16_MAX - 7)
1547:main.c        **** // (maybe it'd make more sense to do the math outside the delay_cyc call
1548:main.c        **** // and allow the preprocessor to change it to 0, instead of doing it here.
1549:main.c        **** 
1550:main.c        **** //This should probably be reimplemented using _delay_loop_1/2() from 
1551:main.c        **** // util/delay_basic.h
1552:main.c        **** //  1 uses three cycles per count, counts from 1-256, 
1553:main.c        **** //		256 counts: _delay_loop_1(0)
1554:main.c        **** //  2 uses four, counts from 1-65536, 65536 is passed as 0
1555:main.c        **** 
1556:main.c        **** #define DELAY_CYC_DELAY_LOOP TRUE//FALSE
1557:main.c        **** 
1558:main.c        **** #if(defined(DELAY_CYC_DELAY_LOOP) && DELAY_CYC_DELAY_LOOP)
1559:main.c        **** #warning "This has only been tested with v54+... rowSegBuffer, etc."
1560:main.c        **** void delay_cyc(int32_t numCyc)
1561:main.c        **** {
1562:main.c        **** 	if(numCyc <= 0)
1563:main.c        **** 		return;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 50


1564:main.c        **** 
1565:main.c        **** 	uint16_t numLoops = (numCyc+3)/4;
1566:main.c        **** 
1567:main.c        **** 	_delay_loop_2(numLoops);
1568:main.c        **** 
1569:main.c        **** /*	uint32_t delayLoops = (numCyc+3)/4;
1570:main.c        **** 
1571:main.c        **** 	do
1572:main.c        **** 	{
1573:main.c        **** 		delayLoops--;
1574:main.c        **** //		_delay_loop_2(delayLoops&0xffff);
1575:main.c        **** 
1576:main.c        **** //		delayLoops -= (delayLoops&0xffff);
1577:main.c        **** 	} while(delayLoops);
1578:main.c        **** */
1579:main.c        **** /*
1580:main.c        **** 	//Since this is inline, AND it's only called with values computed
1581:main.c        **** 	// at compile time, only one of these should be compiled in...
1582:main.c        **** 	// as necessary...
1583:main.c        **** 	// If called without precomputed value (i.e. a variable)????
1584:main.c        **** 	// Maybe I should only use delay_loop_2...
1585:main.c        **** 	if(numCyc < 256*3)
1586:main.c        **** 		_delay_loop_1(numCyc/&0xff);
1587:main.c        **** 
1588:main.c        **** 	else
1589:main.c        **** */
1590:main.c        **** }
1591:main.c        **** 
1592:main.c        **** #else
1593:main.c        **** void delay_cyc(int32_t numCyc)
1594:main.c        **** {
1595:main.c        **** 
1596:main.c        **** 	//This shouldn't happen often, but some delay_cyc() calls use math
1597:main.c        **** 	// to calculate the number of cycles, and it could be negative
1598:main.c        **** 	if(numCyc < 0)
1599:main.c        **** 		return;
1600:main.c        **** 											//#Clocks
1601:main.c        **** 	//Two instructions:
1602:main.c        **** 	// ldi r24, 0						//1 			i=0
1603:main.c        **** 	// ldi r25, 0						//1
1604:main.c        **** 	uint16_t i;
1605:main.c        **** 
1606:main.c        **** 
1607:main.c        **** 	//Loop instructions:
1608:main.c        **** 	//nop									//1
1609:main.c        **** 	//adiw  r24, 0x01   ; 1			//2 			i++
1610:main.c        **** 	//cpi   r24, 0x77   ; 119		//1 			i<numCyc (119 in this case)
1611:main.c        **** 	//cpc   r25, r1					//1 			Apparently it's also testing
1612:main.c        **** 											//  			the high byte is 0
1613:main.c        **** 	//brne  .-10        ;			//"1/2"		return to nop
1614:main.c        **** 											//				if I understand, this is two
1615:main.c        **** 											//				cyc when branching
1616:main.c        **** 											//				or one if not (when complete)
1617:main.c        **** 
1618:main.c        **** 	//READ THIS:
1619:main.c        **** 	// Current Compilation Settings: A/O v18:
1620:main.c        **** 	//    THIS LOOP WILL BE UNROLLED if numLoops <= 5!!!
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 51


1621:main.c        **** 	//    Which then turns into numLoops*2 cycles (instead of numLoops*8)
1622:main.c        **** 	// 
1623:main.c        **** 	// Here's an attempted hack...
1624:main.c        **** 	//  it *should* optimize the test out in either case, so it's like a 
1625:main.c        **** 	//  preprocessing directive...
1626:main.c        **** 	uint16_t numLoops = (((uint16_t)(numCyc)+7)>>3);
1627:main.c        **** 
1628:main.c        **** 
1629:main.c        **** 	// HACK ATTEMPT 2: THATS A LOT OF CODE.
1630:main.c        **** 		switch(numLoops)
1631:main.c        **** 		{
1632:main.c        **** 			case 5:
1633:main.c        **** 				asm("nop");
1634:main.c        **** 				asm("nop");
1635:main.c        **** 				asm("nop");
1636:main.c        **** 				asm("nop");
1637:main.c        **** 				asm("nop");
1638:main.c        **** 				asm("nop");
1639:main.c        **** 				asm("nop");
1640:main.c        **** 				asm("nop");
1641:main.c        **** 			case 4:
1642:main.c        **** 				asm("nop");
1643:main.c        **** 				asm("nop");
1644:main.c        **** 				asm("nop");
1645:main.c        **** 				asm("nop");
1646:main.c        **** 				asm("nop");
1647:main.c        **** 				asm("nop");
1648:main.c        **** 				asm("nop");
1649:main.c        **** 				asm("nop");
1650:main.c        **** 			case 3:
1651:main.c        **** 				asm("nop");
1652:main.c        **** 				asm("nop");
1653:main.c        **** 				asm("nop");
1654:main.c        **** 				asm("nop");
1655:main.c        **** 				asm("nop");
1656:main.c        **** 				asm("nop");
1657:main.c        **** 				asm("nop");
1658:main.c        **** 				asm("nop");
1659:main.c        **** 			case 2:
1660:main.c        **** 				asm("nop");
1661:main.c        **** 				asm("nop");
1662:main.c        **** 				asm("nop");
1663:main.c        **** 				asm("nop");
1664:main.c        **** 				asm("nop");
1665:main.c        **** 				asm("nop");
1666:main.c        **** 				asm("nop");
1667:main.c        **** 				asm("nop");
1668:main.c        **** 			case 1:
1669:main.c        **** 				asm("nop");
1670:main.c        **** 				asm("nop");
1671:main.c        **** 				asm("nop");
1672:main.c        **** 				asm("nop");
1673:main.c        **** 				asm("nop");
1674:main.c        **** 				asm("nop");
1675:main.c        **** 				asm("nop");
1676:main.c        **** 				asm("nop");
1677:main.c        **** 				return;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 52


1678:main.c        **** 				break;
1679:main.c        **** 			default:
1680:main.c        **** 				break;
1681:main.c        **** 		}
1682:main.c        **** 	// THUS:
1683:main.c        **** 	// Each loop is 7 cycles, make it 8 by adding an extra nop and we can
1684:main.c        **** 	// use >> instead of / for calculations...
1685:main.c        **** 	// +7 assures rounding-up...
1686:main.c        **** #warning "This loop seems to be optimizing out!"
1687:main.c        **** 	//for(i=0; i<((numCyc+7)>>3); i++)
1688:main.c        **** 	for(i=0; i<numLoops; i++)
1689:main.c        **** 	{
1690:main.c        **** 		//THIS IS A HACK DUE TO OPTIMIZATION, see above
1691:main.c        **** 		// It will NOT likely be happy with different versions of gcc...
1692:main.c        **** 	/*	// NOGO: Apparently it won't expand the loop if this is part of it
1693:main.c        **** 		// so then we have 5 loops AND 8 instructions /within/ the loop
1694:main.c        **** 		// AND the comparison overhead!`
1695:main.c        **** 		if(numLoops <= 5)
1696:main.c        **** 		{
1697:main.c        **** 		   asm("nop");
1698:main.c        **** 			asm("nop");
1699:main.c        **** 		//	asm("nop");
1700:main.c        **** 		//	asm("nop");
1701:main.c        **** 		//	asm("nop");
1702:main.c        **** 		//	asm("nop");
1703:main.c        **** 		}
1704:main.c        **** 		else
1705:main.c        **** 		{
1706:main.c        **** 			asm("nop");
1707:main.c        **** 			asm("nop");
1708:main.c        **** 		}
1709:main.c        **** 	*/
1710:main.c        **** 		//Apparently this loop will optimize-out without this:
1711:main.c        **** 		// Obviously, one instruction each...
1712:main.c        **** 		asm("nop");
1713:main.c        **** 		asm("nop");
1714:main.c        **** 	}
1715:main.c        **** }
1716:main.c        **** #endif
1717:main.c        **** 
1718:main.c        **** //One dot-clock is 7/8ths of a CPU cycle... (prescaler = 1)
1719:main.c        **** //                 14/8ths with prescaler = 2 ...
1720:main.c        **** //
1721:main.c        **** //    1 dot = 7/8 cyc
1722:main.c        **** //    n dots = n * 7/8 cyc
1723:main.c        **** //
1724:main.c        **** //    1 = 1 dot / (7/8) cyc
1725:main.c        **** //    1 = 8 dots / 7 cyc
1726:main.c        **** //
1727:main.c        **** //  With prescaling = 2:
1728:main.c        **** //
1729:main.c        **** //    1 dot = 7/8 * 2 cyc = 14/8 cyc
1730:main.c        **** //   
1731:main.c        **** //    8/14 dots = 1 cyc
1732:main.c        **** //    n dots = n*14/8 cyc
1733:main.c        **** //   
1734:main.c        **** //    I coulda sworn the prescaler was on the divide-side...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 53


1735:main.c        **** //   Also, is there any benefit to adding +7*LVDS_PRESCALER-1 for rounding?
1736:main.c        **** #define DOTS_TO_CYC(dots) ((((dots)*(7l)*(LVDS_PRESCALER))/8))
1737:main.c        **** 
1738:main.c        **** #define delay_Dots(numDots) delay_cyc(DOTS_TO_CYC(numDots))
1739:main.c        **** 
1740:main.c        **** 
1741:main.c        **** //THESE NOTES ARE OLD:
1742:main.c        **** //This has to be changed every time the DE code is changed...
1743:main.c        **** // Actually, I think it should just match IMAGE_WIDTH
1744:main.c        **** //#define FB_WIDTH 28 //21//19
1745:main.c        **** //#define IMAGE_WIDTH 21
1746:main.c        **** 
1747:main.c        **** 
1748:main.c        **** #define TESTVALS	0
1749:main.c        **** #define LTN 1
1750:main.c        **** #define IDT 2
1751:main.c        **** 
1752:main.c        **** 
1753:main.c        **** //TIMING:
1754:main.c        **** //  Measurements below (in microseconds) are referring to preLVDS
1755:main.c        **** //  There may be other such old-notes...
1756:main.c        **** 
1757:main.c        **** 
1758:main.c        **** //        |<--T_Hhigh-->| |<-T_Hlow
1759:main.c        **** //    __   _____________   ____________  3.6V
1760:main.c        **** // H    |_|             |_|           _  0V
1761:main.c        **** //
1762:main.c        **** //    Data Enable
1763:main.c        **** //       Only active when there's valid pixel data
1764:main.c        **** //       (for 512 of the 717 clocks in HSYNC-active)
1765:main.c        **** //       Low during Vsync... (~720us)
1766:main.c        **** //
1767:main.c        **** 
1768:main.c        **** //IDTech display: 136 dots
1769:main.c        **** //2-136+
1770:main.c        **** //IDTech, last used: 40
1771:main.c        **** //LTN Last used 8
1772:main.c        **** // LTN: 1072-1344-1500 clocks per line, 1024DE... Hsync unused
1773:main.c        **** // SEE Hlow_Delay() notes if this value is large!
1774:main.c        **** 
1775:main.c        **** #if (DISPLAY == LTN)
1776:main.c        **** #define H_LOW_DOTS	8
1777:main.c        **** #elif (DISPLAY == IDT)
1778:main.c        **** #define H_LOW_DOTS   40//8//1//40 //30 //2//136
1779:main.c        **** #elif (DISPLAY == TESTVALS)
1780:main.c        **** #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
1781:main.c        **** 							  // And having a value here increases codesize
1782:main.c        **** #endif
1783:main.c        **** 
1784:main.c        **** 
1785:main.c        **** //H is set low immediately upon entry of the timer interrupt
1786:main.c        **** // its low-time is controlled via nops
1787:main.c        **** // (so if HLow is long for a particular display, this might need revising)
1788:main.c        **** #define Hlow_Delay() \
1789:main.c        **** 	delay_Dots(H_LOW_DOTS)
1790:main.c        **** 
1791:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 54


1792:main.c        **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1793:main.c        **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
1794:main.c        **** 
1795:main.c        **** 
1796:main.c        **** 
1797:main.c        **** //This was found expermentally with SwitchResX
1798:main.c        **** //IDTech Last Used: 680
1799:main.c        **** //LTN last used 1024
1800:main.c        **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
1801:main.c        **** //        it does, however, affect the vertical(!)
1802:main.c        **** // If I recall Correctly, this is used only for setting the timer interrupt
1803:main.c        **** //  rate...
1804:main.c        **** #if (DISPLAY == LTN)
1805:main.c        **** #define DE_ACTIVE_DOTS	1024
1806:main.c        **** #elif (DISPLAY == IDT)
1807:main.c        **** #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
1808:main.c        **** #elif (DISPLAY == TESTVALS)
1809:main.c        **** #define DE_ACTIVE_DOTS	1024
1810:main.c        **** #endif
1811:main.c        **** 
1812:main.c        **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
1813:main.c        **** 
1814:main.c        **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
1815:main.c        **** //  90-320+
1816:main.c        **** //Horizontal Total Time: 1206-1344-2047
1817:main.c        **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
1818:main.c        **** // Excess waits should be thrown in DH (since that's between interrupts)
1819:main.c        **** //T_HD is the time from H inactivated to DE activated
1820:main.c        **** //aka H back-porch: 1-160+
1821:main.c        **** //IDTech Last Used: 50
1822:main.c        **** //LTN last used 5
1823:main.c        **** 
1824:main.c        **** #if (DISPLAY == LTN)
1825:main.c        **** #define HD_DOTS 5
1826:main.c        **** #elif (DISPLAY == IDT)
1827:main.c        **** #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
1828:main.c        **** #elif (DISPLAY == TESTVALS)
1829:main.c        **** #define HD_DOTS 50//5
1830:main.c        **** #endif
1831:main.c        **** 
1832:main.c        **** #define HD_Delay()	delay_Dots(HD_DOTS)
1833:main.c        **** 
1834:main.c        **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1835:main.c        **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1836:main.c        **** 
1837:main.c        **** // This is the number of CPU cycles between DE->L and Horiz->L
1838:main.c        **** // This is just used in calculating the OCR value...
1839:main.c        **** // aka H Front Porch: 0-24+
1840:main.c        **** // IDTech Last Used: 24
1841:main.c        **** // LTN last used 46
1842:main.c        **** // 1072-1024-1-1 = 46
1843:main.c        **** #if (DISPLAY == LTN)
1844:main.c        **** #define DH_DOTS	46
1845:main.c        **** #elif (DISPLAY == IDT)
1846:main.c        **** #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
1847:main.c        **** #elif (DISPLAY == TESTVALS)
1848:main.c        **** #define DH_DOTS	0//1000//100//46
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 55


1849:main.c        **** #endif
1850:main.c        **** 
1851:main.c        **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1852:main.c        **** 
1853:main.c        **** //       |
1854:main.c        **** //       v
1855:main.c        **** //      T_DH
1856:main.c        **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
1857:main.c        **** // H   __.  ____________  .___________
1858:main.c        **** //      .|_|  .        .|_|  .
1859:main.c        **** //     _.     .________.     .___________
1860:main.c        **** // DE   |_____| 512clk |_____|
1861:main.c        **** //      ^              ^
1862:main.c        **** //       \___________   \                        (just avoiding \ warning)
1863:main.c        **** //                   \  |     768 Hsyncs
1864:main.c        **** //                    v v
1865:main.c        **** //     _             _ _ _ _ _ _ _ _ _ _ 
1866:main.c        **** // DE   |___________| | | | | | | | | | |______
1867:main.c        **** //
1868:main.c        **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1869:main.c        **** 
1870:main.c        **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1871:main.c        **** // IDTech Last Used: 29
1872:main.c        **** // LTN last used 3
1873:main.c        **** //LTN Frame: 772-806-1000 lines...
1874:main.c        **** #if (DISPLAY == LTN)
1875:main.c        **** #define T_VD 3
1876:main.c        **** #elif (DISPLAY == IDT)
1877:main.c        **** #define  T_VD 29 //3//29 //7 //29
1878:main.c        **** #elif (DISPLAY == TESTVALS)
1879:main.c        **** #define T_VD 3
1880:main.c        **** #endif
1881:main.c        **** 
1882:main.c        **** //aka V-sync front porch: 1-3+
1883:main.c        **** // IDTech Last Used: 3
1884:main.c        **** // LTN last used 3
1885:main.c        **** #if (DISPLAY == LTN)
1886:main.c        **** #define T_DV 3
1887:main.c        **** #elif (DISPLAY == IDT)
1888:main.c        **** #define T_DV 3//3 //1 //3
1889:main.c        **** #elif (DISPLAY == TESTVALS)
1890:main.c        **** #define T_DV 3
1891:main.c        **** #endif
1892:main.c        **** 
1893:main.c        **** //1-6+ (1 is used by the first switch-case...)
1894:main.c        **** // IDTech Last Used: 6
1895:main.c        **** // LTN Last used 16
1896:main.c        **** // 772 - 768 - 1 - 1 = 2
1897:main.c        **** #if (DISPLAY == LTN)
1898:main.c        **** #define T_Vlow 16
1899:main.c        **** #elif (DISPLAY == IDT)
1900:main.c        **** #define T_Vlow	6 //16//6 //2 //6
1901:main.c        **** #elif (DISPLAY == TESTVALS)
1902:main.c        **** #define T_Vlow 32
1903:main.c        **** #endif
1904:main.c        **** 
1905:main.c        **** // IDTech Last Used: 768
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 56


1906:main.c        **** #if (DISPLAY == LTN)
1907:main.c        **** #define V_COUNT	768
1908:main.c        **** #elif (DISPLAY == IDT)
1909:main.c        **** #define V_COUNT	768
1910:main.c        **** #elif (DISPLAY == TESTVALS)
1911:main.c        ****  #if (LVDS_PRESCALER == 8)
1912:main.c        ****   #define V_COUNT 768
1913:main.c        ****  #else
1914:main.c        ****   #define V_COUNT	(768*2/3)
1915:main.c        ****  #endif
1916:main.c        **** #endif
1917:main.c        **** 
1918:main.c        **** //                       
1919:main.c        **** //                      |           
1920:main.c        **** //                      V           
1921:main.c        **** //              |<-T_DV>|           |<-T_VD-->|
1922:main.c        **** //              .       .           .         .
1923:main.c        **** //     _____________||__.   124us   .____||___________________
1924:main.c        **** //  V           .   ||  |___________|    ||   .
1925:main.c        **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
1926:main.c        **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
1927:main.c        **** //              .   ||                   ||   .
1928:main.c        **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
1929:main.c        **** // DE   | | | | |___||___________________||___| | | | | | | | |
1930:main.c        **** //                  ||                   ||
1931:main.c        **** //
1932:main.c        **** //                        1
1933:main.c        **** //                        |
1934:main.c        **** //                        v               
1935:main.c        **** //     _________________   ___________________   _____________
1936:main.c        **** //  V                   |_|                   |_|
1937:main.c        **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
1938:main.c        **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
1939:main.c        **** //                          ^
1940:main.c        **** //                          |
1941:main.c        **** //                          2
1942:main.c        **** 
1943:main.c        **** 
1944:main.c        **** 
1945:main.c        **** 
1946:main.c        **** static __inline__ \
1947:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
1948:main.c        **** 	  __attribute__((__always_inline__));
1949:main.c        **** 
1950:main.c        **** //volatile uint8_t rowBuffer[FB_WIDTH] =
1951:main.c        **** //There's not enough memory for a full frame-buffer...
1952:main.c        **** // but this is how LCDdirect worked, and changing it would be a pain.
1953:main.c        **** //uint8_t settingBuffer[FB_HEIGHT][FB_WIDTH]; 
1954:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
1955:main.c        **** uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH];
1956:main.c        **** #else
1957:main.c        **** uint8_t *pimage;
1958:main.c        **** #endif
1959:main.c        **** 
1960:main.c        **** /* in LCDStuff
1961:main.c        **** uint8_t dataEnable = 0;
1962:main.c        **** uint8_t vSync = 0;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 57


1963:main.c        **** uint16_t hsyncCount = 0;
1964:main.c        **** */
1965:main.c        **** 
1966:main.c        **** /* in LCDStuff, along with the if, woot
1967:main.c        **** //frameCount=0 can be used in main to detect whether we've completed a 
1968:main.c        **** //  a frame AND its FRAME_UPDATE_DELAY
1969:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
1970:main.c        **** uint8_t frameCount = 0;
1971:main.c        **** #endif
1972:main.c        **** */
1973:main.c        **** 
1974:main.c        **** static __inline__ \
1975:main.c        **** void loadRow(uint16_t rowNum) \
1976:main.c        **** 	__attribute__((__always_inline__));
1977:main.c        **** 
1978:main.c        **** 
1979:main.c        **** #include _LCDSTUFF_CFILE_
1980:main.c        **** //#include "../../../_commonCode/lcdStuff/0.50ncf/lcdStuff.c"
1981:main.c        **** //#include "lcdUpdate.c"
1982:main.c        **** 
1983:main.c        **** //SIGNAL(TIMER1_COMPA_vect)
1984:main.c        **** SIGNAL(TIMER0_COMPA_vect)
1985:main.c        **** {
1986:main.c        **** 	static uint8_t frameCount = 0;
1987:main.c        **** 
1988:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1989:main.c        **** 	while(TCNT0L != 7){};
1990:main.c        **** 	//This won't work... who knows how many cycles interrupt-entry will be
1991:main.c        **** 	//Above should fix that...
1992:main.c        **** 	setpinPORT(PB2, PORTB);
1993:main.c        **** 	clrpinPORT(PB2, PORTB);
1994:main.c        **** #endif
1995:main.c        **** 
1996:main.c        **** 
1997:main.c        **** 	if(updateLCD())
1998:main.c        **** 	{
1999:main.c        **** #if (FRAME_COUNT_TO_DELAY != 0)
2000:main.c        **** 			//static uint8_t frameCount = 0;
2001:main.c        **** 			frameCount++;
2002:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
2003:main.c        **** 			{
2004:main.c        **** 				frameCount = 0;
2005:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
2006:main.c        **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
2007:main.c        **** 			}
2008:main.c        **** #endif
2009:main.c        **** 	}
2010:main.c        **** 
2011:main.c        **** #if(defined(LOADROW) && LOADROW)
2012:main.c        **** 	//Load the next row into the row(seg)buffer
2013:main.c        **** 	//data is enabled after T_VD+T_Vlow...
2014:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
2015:main.c        **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
2016:main.c        **** #endif
2017:main.c        **** 	// Here is where loadRow used to be called
2018:main.c        **** 	// it has been moved to oldNotes.txt, but it would make more sense
2019:main.c        **** 	// to look at LCDdirectLVDS <25 or LCDdirect
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 58


2020:main.c        **** 	// loadRow used the time between DE inactive and the next Hsync
2021:main.c        **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
2022:main.c        **** 	// thus, DE could gain more pixels because there would be fewer
2023:main.c        **** 	// calculations to determine the memory location to write from
2024:main.c        **** 	// This effect has since been minimized
2025:main.c        **** 	// BUT loadRow might be necessary for program-memory-based images...
2026:main.c        **** }
2027:main.c        **** 
2028:main.c        **** 
2029:main.c        **** #define nibbletochar(val)	\
2030:main.c        **** 	(((val)<=9) ? ((val) + '0') : ((val) + ('A' - 10)))
2031:main.c        **** 
2032:main.c        **** 
2033:main.c        **** #if 0
2034:main.c        **** uint8_t hexColor = 0;
2035:main.c        **** 
2036:main.c        **** static __inline__ \
2037:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[]) \
2038:main.c        **** 	  __attribute__((__always_inline__));
2039:main.c        **** 
2040:main.c        **** //Takes a nibble and makes it a hex character...
2041:main.c        **** 
2042:main.c        **** #define HEXCOLOR_TOPROW 32
2043:main.c        **** void hexColor_drawRow(uint8_t rbRowNum, uint8_t rowBuffer[])
2044:main.c        **** {
2045:main.c        **** //	static uint8_t color = 0;
2046:main.c        **** 
2047:main.c        **** 	if( (rbRowNum >= HEXCOLOR_TOPROW) &&
2048:main.c        **** 		 (rbRowNum < HEXCOLOR_TOPROW+8) )
2049:main.c        **** 	{
2050:main.c        **** 		uint8_t charRow1, charRow2;
2051:main.c        **** 		//uint8_t color;
2052:main.c        **** 
2053:main.c        **** 		charRow1 = 
2054:main.c        **** 			getCharRow(nibbletochar((hexColor)>>4), rbRowNum-HEXCOLOR_TOPROW);
2055:main.c        **** 		charRow2 = 
2056:main.c        **** 			getCharRow(nibbletochar(hexColor&0x0f), rbRowNum-HEXCOLOR_TOPROW);
2057:main.c        **** 
2058:main.c        **** 		uint8_t col;
2059:main.c        **** 		for(col=0; col<8; col++)
2060:main.c        **** 		{
2061:main.c        **** 			if(getbit(col, charRow1))
2062:main.c        **** 				rowBuffer[col+1] = fb_to_rb(hexColor);
2063:main.c        **** 			//else
2064:main.c        **** 			//	rowBuffer[col] = fb_to_rb(0x00);
2065:main.c        **** 
2066:main.c        **** 			if(getbit(col, charRow2))
2067:main.c        **** 				rowBuffer[col+8+1] = fb_to_rb(hexColor);
2068:main.c        **** 		}
2069:main.c        **** 	}
2070:main.c        **** }
2071:main.c        **** #endif //0
2072:main.c        **** 
2073:main.c        **** 
2074:main.c        **** #if(defined(LOADROW) && LOADROW)
2075:main.c        **** #warning "loadRow is currently in an intermediate phase..."
2076:main.c        **** void loadRow(uint16_t rowNum)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 59


2077:main.c        **** {
2078:main.c        **** 
2079:main.c        **** #if 0
2080:main.c        **** 	uint8_t i=0;
2081:main.c        **** 
2082:main.c        **** //	if((rowNum < 0) || (rowNum >= V_COUNT))
2083:main.c        **** //		return;
2084:main.c        **** 
2085:main.c        **** 	//THIS DOES NOT MAKE AN OUNCE OF SENSE TO ME:
2086:main.c        **** 	// why do I need *2 here?! Without it, the image is stretched and cut
2087:main.c        **** 	// in half vertically!
2088:main.c        **** 	// Apparently has to do with delayed Hsyncs due to calculations...?
2089:main.c        **** 	// LIFE with delay = 10 causes 2/3 frame at *2
2090:main.c        **** 	// The screen itself appears to be repeating rows...
2091:main.c        **** #if(!defined(HORIZONTAL_COLOR_BARS) || !HORIZONTAL_COLOR_BARS)
2092:main.c        ****  #if(LVDS_PRESCALER == 8)
2093:main.c        ****   #define ROW_SCALE 1
2094:main.c        ****  #else
2095:main.c        ****   #define ROW_SCALE 2
2096:main.c        ****  #endif
2097:main.c        **** 	uint8_t rbRowNum = ((uint32_t)rowNum)*RB_HEIGHT*ROW_SCALE/V_COUNT;
2098:main.c        **** 
2099:main.c        **** 	//Old note pre tet_drawRow... (code deleted a/o v45)	
2100:main.c        **** 	//WITHOUT THIS: syncing seems OK
2101:main.c        **** 	// But this is necessary for the right-border...
2102:main.c        **** 	// Adding it causes syncing problems at _b and _c -> _W
2103:main.c        **** 	// TODO: Look into sync-problems above!!!
2104:main.c        **** 	//  (revisit 41-1)
2105:main.c        **** 	//i++;
2106:main.c        **** 
2107:main.c        **** 	//Clear the rowBuffer, it will be reloaded, where appropriate, after
2108:main.c        **** 	// This isn't particularly speed-efficient, since most pixels will 
2109:main.c        **** 	// be written twice... but it should make things more plug-n-play...
2110:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2111:main.c        **** 		rowBuffer[i]=fb_to_rb(0);
2112:main.c        **** 
2113:main.c        **** 
2114:main.c        **** 	tet_drawRow(rbRowNum, rowBuffer);
2115:main.c        **** 
2116:main.c        **** 
2117:main.c        **** 	hexColor_drawRow(rbRowNum, rowBuffer);
2118:main.c        **** 
2119:main.c        **** 	
2120:main.c        **** 	i=63-40;
2121:main.c        **** 
2122:main.c        **** 	static uint16_t colorShift = 0;
2123:main.c        **** 
2124:main.c        **** 	//!!! This *should* only increment once per frame (RIGHT?)
2125:main.c        **** 	// BUT, set colorShift>>5 to colorShift>>3 or even >>0
2126:main.c        **** 	// and it seems this is not true... WTF, again?
2127:main.c        **** 	if(rbRowNum == 0)
2128:main.c        **** 		colorShift++;
2129:main.c        **** 
2130:main.c        **** 	//Just fill up the remaining pixels with color...
2131:main.c        **** 	// i-- to overwrite the blank column in the characters
2132:main.c        **** 	// Leaving one column of black to check into syncing problems
2133:main.c        **** 	// with LVDS_PRESCALER=8...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 60


2134:main.c        **** 	// apparently, the garbage-lines are related to the last color drawn(?!)
2135:main.c        **** 	for( ;i<RB_WIDTH;i++)
2136:main.c        **** 	{
2137:main.c        **** 			uint8_t colorVal = (i + rbRowNum + (colorShift>>5)) & 0x3f;
2138:main.c        **** 
2139:main.c        **** 			//We don't want Black, since it's used for LIFE...
2140:main.c        **** 			if(colorVal==0)
2141:main.c        **** 				colorVal = 0x15;
2142:main.c        **** 
2143:main.c        **** 			//Only draw colors where there isn't already data
2144:main.c        **** 			// (e.g. LIFE or the SMILEY)
2145:main.c        **** 			// Actually, this can't work, since Black is a possibility...
2146:main.c        **** 			//if(!rowBuffer[i])
2147:main.c        **** 				rowBuffer[i] = fb_to_rb(colorVal);
2148:main.c        **** 	}
2149:main.c        **** 
2150:main.c        **** /* This is now handled in the rowSegBuffer loading...
2151:main.c        **** 	I guess that doesn't fix it for the old non-row-seg case...
2152:main.c        **** 
2153:main.c        **** 	//Apparently *black* causes issues... as well as some dark colors
2154:main.c        **** 	// (certain shades of blue?)
2155:main.c        **** 	// White, as the last pixel, causes syncing to work fine, ish
2156:main.c        **** 	//And adding a black column doesn't do anything?!
2157:main.c        **** 	// either way, thsi should be redundant due to rowBuffer clearing
2158:main.c        **** 	// and RB_WIDTH-2 in the color-filling
2159:main.c        **** 	// WTF?
2160:main.c        **** 	//rowBuffer[RB_WIDTH-2] = fb_to_rb(_K);
2161:main.c        **** 	rowBuffer[RB_WIDTH-1] = fb_to_rb(_W);
2162:main.c        **** */
2163:main.c        **** 
2164:main.c        **** 	//Draw the smiley on top of the color pixels
2165:main.c        **** #define SMILE_TOP_ROW (20)
2166:main.c        **** #define SMILE_HEIGHT FB_HEIGHT
2167:main.c        **** #define SMILE_SHIFT	(24+(40-FB_WIDTH)/2)
2168:main.c        **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
2169:main.c        **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
2170:main.c        **** 	{
2171:main.c        **** 			for(i=0; i<FB_WIDTH; i++)
2172:main.c        **** 			{
2173:main.c        **** 				uint8_t temp;
2174:main.c        **** 			#if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
2175:main.c        ****          	temp=frameBuffer[rbRowNum-SMILE_TOP_ROW][i];
2176:main.c        **** 			#else
2177:main.c        ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
2178:main.c        **** 			#endif
2179:main.c        **** 
2180:main.c        **** 				if(!(temp & 0xC0))
2181:main.c        **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
2182:main.c        **** 			}
2183:main.c        **** 	}
2184:main.c        **** 
2185:main.c        **** 
2186:main.c        **** 	#if(defined(LIFE) && LIFE)
2187:main.c        **** 	//This has to be called *after* the colored background is drawn...
2188:main.c        **** 	// (that could be changed... with _Tr?)
2189:main.c        **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
2190:main.c        **** 	#endif //LIFE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 61


2191:main.c        **** 
2192:main.c        **** 
2193:main.c        **** #else //HORIZONTAL_COLOR_BARS
2194:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2195:main.c        **** 		rowBuffer[i] = fb_to_rb(rowNum);
2196:main.c        **** #endif
2197:main.c        **** 
2198:main.c        **** 
2199:main.c        **** #endif //0
2200:main.c        **** 
2201:main.c        **** 	
2202:main.c        **** //#define SEG_LINE TRUE
2203:main.c        **** //#define SEG_SINE TRUE
2204:main.c        **** 
2205:main.c        **** //#define SEG_QUESTION TRUE
2206:main.c        **** 	//Isn't BLAH = 1 necessary so we don't get a row with no data?
2207:main.c        **** 	// *looks* like it's working, but I dunno...
2208:main.c        **** #define BLAH 0
2209:main.c        **** 
2210:main.c        **** 
2211:main.c        **** #if(defined(ROW_SEG_BUFFER) && ROW_SEG_BUFFER)
2212:main.c        **** // Wasn't sure where 357 came from... and now I'm wondering where the
2213:main.c        **** // notes I wrote regarding it disappeared to...
2214:main.c        **** // Anyhow, from line 72, if ROW_SEG_BUFFER && !LVDS_PRESCALER
2215:main.c        **** // "ROW_SEG_BUFFER uses 20cyc/pixel" (doesn't match the math I've 
2216:main.c        **** // elsewhere) 1024/20*7 = 358.4... so maybe that's something to do with it
2217:main.c        **** // TODO: If it was 21cyc/pixel, wouldn't we have perfect alignment with
2218:main.c        **** //       color-transitions and segment widths?
2219:main.c        **** //#define NUM_PSEGS	(1024/3+16) //357
2220:main.c        ****  #if (defined(SEG_RACER) && SEG_RACER)
2221:main.c        ****   #include <stdlib.h>	//rand()
2222:main.c        ****   #define NEXT_COLOR	_R
2223:main.c        ****   #define THIS_COLOR	_G
2224:main.c        ****   #define OVERLAP_COLOR	_Y
2225:main.c        ****   #define BG_COLOR	_C
2226:main.c        ****   #define BG_BAD_COLOR	_M
2227:main.c        **** 
2228:main.c        **** 
2229:main.c        **** 
2230:main.c        **** 	int16_t racerPseg = NUM_PSEGS/2 - 2;
2231:main.c        **** 
2232:main.c        **** 	adc_startConversion();
2233:main.c        **** 	while(adc_isBusy())
2234:main.c        **** 		asm("nop;");
2235:main.c        **** 	racerPseg = (adc_getValue()>>2)+5;
2236:main.c        **** 	if(racerPseg > NUM_PSEGS-2)
2237:main.c        **** 		racerPseg = NUM_PSEGS-2;
2238:main.c        **** 
2239:main.c        **** 	segClear();
2240:main.c        **** 	addSegfb(1, _W);
2241:main.c        **** 	static uint16_t raceWidth = 16;
2242:main.c        **** 	static uint8_t trackPosition = 0;
2243:main.c        ****   #define TRACK_LENGTH	24	//24*32 = 768
2244:main.c        ****   #define TRACK_ROWS	(V_COUNT/TRACK_LENGTH)
2245:main.c        **** 	static uint16_t raceTrack[TRACK_LENGTH*2];
2246:main.c        **** 
2247:main.c        **** 	uint8_t bgColor = BG_COLOR;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 62


2248:main.c        **** 
2249:main.c        **** 	//racePseg += ((rand()&0xff0)>>4)*2/0xff - 1;
2250:main.c        **** 
2251:main.c        **** 	uint8_t thisTrackRow = rowNum/TRACK_ROWS; //(V_COUNT/TRACK_LENGTH);
2252:main.c        **** 	uint8_t thisPosition = thisTrackRow + (trackPosition? TRACK_LENGTH : 0);
2253:main.c        **** 	uint8_t nextPosition = thisTrackRow + (trackPosition? 0 : TRACK_LENGTH);
2254:main.c        **** 
2255:main.c        **** 	static hfm_t thisSmoothingHFM, nextSmoothingHFM;
2256:main.c        **** 	static uint8_t thisTrackGrowing, nextTrackGrowing;
2257:main.c        **** 
2258:main.c        **** /*
2259:main.c        **** 	static theta_t racerTheta = 0;
2260:main.c        **** 	if(racerTheta >= SINE_2PI)
2261:main.c        **** 		racerTheta -= SINE_2PI;
2262:main.c        **** 
2263:main.c        **** 	racerPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2264:main.c        **** 	racerTheta++;
2265:main.c        **** */
2266:main.c        **** 
2267:main.c        **** 	uint8_t outOfTrack = FALSE;
2268:main.c        **** 	typedef struct _IST_BLAH_
2269:main.c        **** 	{
2270:main.c        **** 		uint16_t length;
2271:main.c        **** 		uint8_t color;
2272:main.c        **** 	}	intermediateSeg_t;
2273:main.c        **** 
2274:main.c        **** #define ISEGS_PER_WHATEVER	3
2275:main.c        **** #define IS_SEGS (5*ISEGS_PER_WHATEVER)
2276:main.c        **** 	intermediateSeg_t is[IS_SEGS] = 
2277:main.c        **** 	{ {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2278:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W},
2279:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W} };
2280:main.c        **** 
2281:main.c        **** 	uint8_t isPos = 0;
2282:main.c        **** 
2283:main.c        **** #define addSegIS(len, c) \
2284:main.c        **** ({\
2285:main.c        ****  	is[isPos].length = (len); \
2286:main.c        ****  	is[isPos].color = (c); \
2287:main.c        ****  	isPos+=ISEGS_PER_WHATEVER; \
2288:main.c        ****  	{}; \
2289:main.c        **** })
2290:main.c        **** 
2291:main.c        **** 
2292:main.c        **** 
2293:main.c        **** 	int8_t prevNextPosition;
2294:main.c        **** 	int8_t prevThisPosition;
2295:main.c        **** 
2296:main.c        **** 	static uint16_t thisIS, nextIS;
2297:main.c        **** 
2298:main.c        **** 	static uint8_t level = 1;
2299:main.c        **** 
2300:main.c        **** 
2301:main.c        **** 	if(rowNum%TRACK_ROWS == 0) //(V_COUNT/TRACK_LENGTH) == 0)
2302:main.c        **** 	{
2303:main.c        **** 		prevNextPosition = nextPosition - 1;
2304:main.c        **** 		if(prevNextPosition < 0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 63


2305:main.c        **** 			prevNextPosition = TRACK_LENGTH*2 - 1; //+prevNextPosition;
2306:main.c        **** 
2307:main.c        **** 		prevThisPosition = thisPosition - 1;
2308:main.c        **** 		if(prevThisPosition < 0)
2309:main.c        **** 			prevThisPosition = TRACK_LENGTH*2 - 1; //+prevThisPosition;
2310:main.c        **** 		
2311:main.c        **** 		static theta_t racerTheta=0;
2312:main.c        **** 
2313:main.c        **** 		int16_t nextTrackPseg;
2314:main.c        **** 
2315:main.c        **** 		nextTrackPseg = sineRaw8(racerTheta) + -(INT8_MIN);
2316:main.c        **** 		racerTheta+=level;
2317:main.c        **** 		if(racerTheta >= SINE_2PI)
2318:main.c        **** 			racerTheta-=SINE_2PI;
2319:main.c        **** /*
2320:main.c        **** 	int8_t randomVal = rand()&0x03;
2321:main.c        **** 	switch(randomVal)
2322:main.c        **** 	{
2323:main.c        **** 		case 1:
2324:main.c        **** 			if(nextTrackPseg < NUM_PSEGS-2-raceWidth)
2325:main.c        **** 				nextTrackPseg += 1;
2326:main.c        **** 			break;
2327:main.c        **** 		case 2:
2328:main.c        **** 			if(nextTrackPseg > 1)
2329:main.c        **** 				nextTrackPseg -= 1;
2330:main.c        **** 			break;
2331:main.c        **** 		default:
2332:main.c        **** 			break;
2333:main.c        **** 	}
2334:main.c        **** */
2335:main.c        **** 
2336:main.c        **** 
2337:main.c        **** 		raceTrack[nextPosition] = nextTrackPseg;
2338:main.c        **** 
2339:main.c        **** 		thisIS = raceTrack[prevThisPosition];
2340:main.c        **** 		nextIS = raceTrack[prevNextPosition];
2341:main.c        **** 		uint8_t nextHFMdist, thisHFMdist;
2342:main.c        **** 
2343:main.c        **** 		if(raceTrack[nextPosition] > nextIS)
2344:main.c        **** 		{
2345:main.c        **** 			nextTrackGrowing = TRUE;
2346:main.c        **** 			nextHFMdist = raceTrack[nextPosition] - nextIS;
2347:main.c        **** 		}
2348:main.c        **** 		else
2349:main.c        **** 		{
2350:main.c        **** 			nextTrackGrowing = FALSE;
2351:main.c        **** 			nextHFMdist = nextIS - raceTrack[nextPosition];
2352:main.c        **** 		}
2353:main.c        **** 		
2354:main.c        **** 		if(raceTrack[thisPosition] > thisIS)
2355:main.c        **** 		{
2356:main.c        **** 			thisTrackGrowing = TRUE;
2357:main.c        **** 			thisHFMdist = raceTrack[thisPosition] - thisIS;
2358:main.c        **** 		}
2359:main.c        **** 		else
2360:main.c        **** 		{
2361:main.c        **** 			thisTrackGrowing = FALSE;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 64


2362:main.c        **** 			thisHFMdist = thisIS - raceTrack[thisPosition];
2363:main.c        **** 		}
2364:main.c        **** 
2365:main.c        **** 		hfm_setup(&nextSmoothingHFM, nextHFMdist, TRACK_ROWS);
2366:main.c        **** 
2367:main.c        **** 		hfm_setup(&thisSmoothingHFM, thisHFMdist, TRACK_ROWS);
2368:main.c        **** 	}
2369:main.c        **** 
2370:main.c        **** 
2371:main.c        **** 	if(thisTrackGrowing)//raceTrack[thisPosition] > raceTrack[prevThisPosition])
2372:main.c        **** 		thisIS += hfm_nextOutput(&thisSmoothingHFM);
2373:main.c        **** 	else
2374:main.c        **** 		thisIS -= hfm_nextOutput(&thisSmoothingHFM);
2375:main.c        **** 
2376:main.c        **** 	if(nextTrackGrowing)//raceTrack[nextPosition] > raceTrack[prevNextPosition])
2377:main.c        **** 		nextIS += hfm_nextOutput(&nextSmoothingHFM);
2378:main.c        **** 	else
2379:main.c        **** 		nextIS -= hfm_nextOutput(&nextSmoothingHFM);
2380:main.c        **** 
2381:main.c        **** 	if(thisIS < nextIS)
2382:main.c        **** 	{
2383:main.c        **** 		addSegIS(thisIS, bgColor);
2384:main.c        **** 
2385:main.c        **** 		//Tracks overlap
2386:main.c        **** 		if(nextIS < thisIS + raceWidth)
2387:main.c        **** 		{
2388:main.c        **** 			addSegIS(nextIS - thisIS, THIS_COLOR);
2389:main.c        **** 			addSegIS(thisIS + raceWidth - nextIS, OVERLAP_COLOR);
2390:main.c        **** 			addSegIS(nextIS - thisIS, NEXT_COLOR);
2391:main.c        **** 			//outOfTrack=TRUE;
2392:main.c        **** 		}
2393:main.c        **** 		else
2394:main.c        **** 		{
2395:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2396:main.c        **** 			addSegIS(nextIS - thisIS - raceWidth, bgColor);
2397:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
2398:main.c        **** 		}
2399:main.c        **** 
2400:main.c        **** 		//addSegIS(NUM_PSEGS-2-nextIS-raceWidth, bgColor);
2401:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-nextIS-raceWidth, bgColor);
2402:main.c        **** 
2403:main.c        **** 	}
2404:main.c        **** 	else if(thisIS > nextIS)
2405:main.c        **** 	{
2406:main.c        **** 		addSegIS(nextIS, bgColor);
2407:main.c        **** 
2408:main.c        **** 		//Tracks overlap
2409:main.c        **** 		if(thisIS < nextIS + raceWidth)
2410:main.c        **** 		{
2411:main.c        **** 			addSegIS(thisIS - nextIS, NEXT_COLOR);
2412:main.c        **** 			addSegIS(nextIS + raceWidth - thisIS, OVERLAP_COLOR);
2413:main.c        **** 			addSegIS(thisIS - nextIS, THIS_COLOR);
2414:main.c        **** 			//outOfTrack=TRUE;
2415:main.c        **** 		}
2416:main.c        **** 		else
2417:main.c        **** 		{
2418:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 65


2419:main.c        **** 			addSegIS(thisIS - nextIS - raceWidth, bgColor);
2420:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
2421:main.c        **** 		}
2422:main.c        **** 	
2423:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2424:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2425:main.c        **** 	}
2426:main.c        **** 	else //Positions equal
2427:main.c        **** 	{
2428:main.c        **** 		//outOfTrack=TRUE;
2429:main.c        **** 		addSegIS(thisIS, bgColor);
2430:main.c        **** 
2431:main.c        **** 		addSegIS(raceWidth, OVERLAP_COLOR);
2432:main.c        **** 		//addSegIS(NUM_PSEGS-2-thisIS-raceWidth, bgColor);
2433:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
2434:main.c        **** 	}
2435:main.c        **** /*
2436:main.c        **** addSegfb(raceWidth, _W);
2437:main.c        **** 	addSegfb(NUM_PSEGS-racePseg-raceWidth-2, _R);
2438:main.c        **** */
2439:main.c        **** 	uint8_t isSeg;
2440:main.c        **** 	uint16_t isSegTrackPos = 0;
2441:main.c        **** 	uint16_t oldTrackPos = 0;
2442:main.c        **** 	//uint8_t racerFound = FALSE;
2443:main.c        **** 
2444:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2445:main.c        **** 	{
2446:main.c        **** 		isSegTrackPos += is[isSeg].length;
2447:main.c        **** 
2448:main.c        **** 		//if(!racerFound && 
2449:main.c        **** 		if((isSegTrackPos >= (uint16_t)racerPseg))
2450:main.c        **** 		{
2451:main.c        **** 			//racerFound = TRUE;
2452:main.c        **** 			uint16_t oldLength = is[isSeg].length;
2453:main.c        **** 			is[isSeg].length = racerPseg - oldTrackPos;
2454:main.c        **** 			is[isSeg+1].length = 1;
2455:main.c        **** 			is[isSeg+1].color = _K;
2456:main.c        **** 			//Not sure why this shouldn't be -1...
2457:main.c        **** 			is[isSeg+2].length = oldLength - is[isSeg].length; //- 1;
2458:main.c        **** 			is[isSeg+2].color = is[isSeg].color;
2459:main.c        **** 			if((is[isSeg].color != THIS_COLOR) && (is[isSeg].color != OVERLAP_COLOR))
2460:main.c        **** 				outOfTrack = TRUE;
2461:main.c        **** 			isSeg++;
2462:main.c        **** 			break;
2463:main.c        **** 		}
2464:main.c        **** 		oldTrackPos = isSegTrackPos;
2465:main.c        **** 	}
2466:main.c        **** 
2467:main.c        **** 	
2468:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
2469:main.c        ****   	{
2470:main.c        **** 		if(is[isSeg].length == 0)
2471:main.c        **** 			continue;
2472:main.c        **** 		if(outOfTrack && (is[isSeg].color==BG_COLOR))
2473:main.c        **** 			addSegfb(is[isSeg].length, BG_BAD_COLOR);
2474:main.c        **** 		else
2475:main.c        **** 			addSegfb(is[isSeg].length, is[isSeg].color);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 66


2476:main.c        **** 	}
2477:main.c        **** 
2478:main.c        **** 	static uint32_t badCount=0;
2479:main.c        **** 	static uint32_t goodCount=0;
2480:main.c        **** 
2481:main.c        **** 	if(outOfTrack)
2482:main.c        **** 		badCount++;
2483:main.c        **** 	else
2484:main.c        **** 		goodCount++;
2485:main.c        **** 
2486:main.c        **** 	
2487:main.c        **** 	addSegfb(1, _B);
2488:main.c        **** 
2489:main.c        **** 
2490:main.c        **** 	uint8_t percentage = goodCount*100/(badCount+goodCount);
2491:main.c        **** 	static uint32_t lastLevelUpdate = 0;
2492:main.c        **** 
2493:main.c        **** 	if((percentage > 50) && (goodCount - lastLevelUpdate > V_COUNT*3))
2494:main.c        **** 	{
2495:main.c        **** 		lastLevelUpdate = goodCount;
2496:main.c        **** 		level++;
2497:main.c        **** 	}
2498:main.c        **** 
2499:main.c        **** 	if((rowNum>=6) && (rowNum < 22))
2500:main.c        **** 		showScore(rowNum-6, level, _C);
2501:main.c        **** 
2502:main.c        **** 	else if((rowNum>=24) && (rowNum <40))
2503:main.c        **** 		showScore(rowNum-24, goodCount, _G);
2504:main.c        **** 	else if((rowNum >= 42) && rowNum < 58)
2505:main.c        **** 		showScore(rowNum-42, badCount, _R);
2506:main.c        **** 	else if((rowNum >= 60) && (rowNum < 76))
2507:main.c        **** 		showScore(rowNum-60, percentage, _Y);
2508:main.c        **** 
2509:main.c        **** 
2510:main.c        **** 	addSegfb(NUM_PSEGS-2-RACE_WIDTH_PSEGS, _B);
2511:main.c        **** 
2512:main.c        **** 	addSegfb(1, _W);
2513:main.c        **** 	segTerminate();
2514:main.c        **** 
2515:main.c        **** 	if(rowNum >= V_COUNT-1)
2516:main.c        **** 		trackPosition = !trackPosition;
2517:main.c        **** 
2518:main.c        ****  #elif (defined(SEG_HFM) && SEG_HFM)
2519:main.c        **** 	segClear();
2520:main.c        **** 	//Just some experimenting... 1024/3+16 seems to be the width...
2521:main.c        **** 	// == 357 segments (Where does this come from?)
2522:main.c        **** //Pixel Segments...
2523:main.c        **** #define BORDER_PSEGS	1
2524:main.c        **** #define SEGS_AVAILABLE (NUM_SEGMENTS-2)
2525:main.c        **** #define PSEGS_AVAILABLE	(NUM_PSEGS-BORDER_PSEGS*2)
2526:main.c        **** #define HFM_PSEGS	(PSEGS_AVAILABLE/SEGS_AVAILABLE)
2527:main.c        **** #define HFM_PSEGS_REMAINDER	(PSEGS_AVAILABLE%SEGS_AVAILABLE)
2528:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2529:main.c        **** 
2530:main.c        **** 	hfm_t hfmThing;
2531:main.c        **** 	hfm_setup(&hfmThing, (uint8_t)((uint32_t)rowNum*(uint32_t)SEGS_AVAILABLE/V_COUNT), SEGS_AVAILABLE)
2532:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 67


2533:main.c        **** 	hfm_t hfmColStretcher;
2534:main.c        **** 	hfm_setup(&hfmColStretcher, HFM_PSEGS_REMAINDER, SEGS_AVAILABLE);
2535:main.c        **** 
2536:main.c        **** 	uint16_t pseg;
2537:main.c        **** 	for(pseg=0; pseg<SEGS_AVAILABLE; pseg++)
2538:main.c        **** 	{
2539:main.c        **** 		if(hfm_nextOutput(&hfmThing))
2540:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_R);
2541:main.c        **** 		else
2542:main.c        **** 			addSegfb(HFM_PSEGS + hfm_nextOutput(&hfmColStretcher),_C);
2543:main.c        **** 	}
2544:main.c        **** 
2545:main.c        **** 	//addSegfb(NUM_PSEGS-BORDER_PSEGS*2-SEGS_AVAILABLE*HFM_PSEGS, _M);
2546:main.c        **** 	addSegfb(BORDER_PSEGS,_W);
2547:main.c        **** 	segTerminate();
2548:main.c        **** 
2549:main.c        ****  #elif (defined(SEG_QUESTION) && SEG_QUESTION)
2550:main.c        **** 
2551:main.c        **** //Actually, this probably won't work right...
2552:main.c        **** // because the rgb values aren't exact like that, right?
2553:main.c        **** // e.g. black = 0,0,0 but it shows as 0,0,60 ish...
2554:main.c        **** // then again, going in reverse like this might work fine...
2555:main.c        **** // due to rounding (seems OK with this color-scheme)
2556:main.c        **** // The idea wasn't so much to be able to input an 8-bit RGB value to get
2557:main.c        **** // a close match (would probably want rounding up for that, not that it'd
2558:main.c        **** // be even close)
2559:main.c        **** // but to be able to read color-values from GIMP when using the 
2560:main.c        **** //  LCDdirectLVDS color-palette... which isn't especially necessary since
2561:main.c        **** //  now the colors are named with 3-based colors.
2562:main.c        **** #define rgb8(r,g,b) \
2563:main.c        **** 		rgb((((r)*3)/255), (((g)*3)/255), (((b)*3)/255))
2564:main.c        **** 
2565:main.c        **** 
2566:main.c        **** 
2567:main.c        **** //THESE DON'T BELONG HERE
2568:main.c        **** // AND they shouldn't be "Q" specific, at all.
2569:main.c        **** #define Q_WIDTH	16
2570:main.c        **** #define Q_HEIGHT	16
2571:main.c        **** 		//This should be an init-thing, I guess... it's only a 2-cycle
2572:main.c        **** 		// instruction, so it doesn't hurt too much to have it in the loop
2573:main.c        **** 		// BUT it does have to occur a while before the first getpinPORT
2574:main.c        **** 		// to allow time for the pull-ups to do their job
2575:main.c        **** 		setinpuPORT(PB0, PORTB);
2576:main.c        **** 
2577:main.c        **** 	static uint8_t qCount = 0;
2578:main.c        **** 
2579:main.c        **** 	segClear();
2580:main.c        **** 	//Not sure why this is stretched without /2...
2581:main.c        **** 	// I think I ran into this elsewhere as well.
2582:main.c        **** 	//!!! INSTEAD: filled the rest of the row properly...
2583:main.c        **** 	// (wasn't filling up the entire row, due to rounding...
2584:main.c        **** 	//   result was the rows were carrying-over into the next)
2585:main.c        **** 	uint8_t qRow;// = (rowNum*Q_HEIGHT/(V_COUNT)); ///2));
2586:main.c        **** 	uint8_t qCol;
2587:main.c        **** 	
2588:main.c        **** 	//Guess white helps with sync...?
2589:main.c        **** 	// can't hurt.
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 68


2590:main.c        **** 	//addSegfb(3, _W);
2591:main.c        **** 	// Looks like some white is already being inserted (or syncing on end-
2592:main.c        **** 	// white?) about 3pixels wide.
2593:main.c        **** 
2594:main.c        **** 	// 1024/3/32 = 10.67... so for every 3 segments, add 2
2595:main.c        **** #define Q_STRETCHTOP	1//0//28//2
2596:main.c        **** #define Q_STRETCHDIV 5//30//3
2597:main.c        **** 	hfm_t colincrementer_hfm;
2598:main.c        **** 	hfm_setup(&colincrementer_hfm, Q_STRETCHTOP, Q_STRETCHDIV);
2599:main.c        **** 
2600:main.c        **** 	for(qCol=0; qCol<Q_WIDTH; qCol++)
2601:main.c        **** 	{
2602:main.c        **** 		//Not sure where this is defined, if it is...
2603:main.c        **** 		// each "segment length" appears to be 3 physical pixels
2604:main.c        **** 		//+1 is a result of random experiments with stretch
2605:main.c        **** 		// resulting in a stretch larger than 1
2606:main.c        **** 		#define Q_SEGLENGTH	(1024/3/Q_WIDTH+1)
2607:main.c        **** 
2608:main.c        **** 	//These are not included in NUM_ICONS
2609:main.c        **** 	#include "icons/Question.h"
2610:main.c        **** 	#include "icons/Solid.h"
2611:main.c        **** 	#include "icons/GoombaDead.h"
2612:main.c        **** 
2613:main.c        **** 	//These are included in NUM_ICONS
2614:main.c        **** 	#include "icons/1up.h"
2615:main.c        **** 	#include "icons/Biggie.h"
2616:main.c        **** 	#include "icons/StarV.h"
2617:main.c        **** 	#include "icons/FlowerPowerV.h"
2618:main.c        **** 	#include "icons/Goomba.h"
2619:main.c        **** 	#include "icons/Coin.h"
2620:main.c        **** 
2621:main.c        **** 	//Excluding Solid and Question, etc...
2622:main.c        **** 	#define NUM_ICONS 6
2623:main.c        **** 		/*
2624:main.c        **** 		static uint8_t iconSelection = 0;
2625:main.c        **** 		static uint8_t * icon[NUM_ICONS] = { pgm_imageUP, pgm_imageCOIN};
2626:main.c        **** 		static uint8_t iconFrames[NUM_ICONS] = {NUM_UPS, NUM_COINS};
2627:main.c        **** 
2628:main.c        **** 		static uint8_t * p_image = pgm_imageUP; // = icon[0]; //(pgm_imageFLOWER);
2629:main.c        **** 		static uint8_t NumFramesInImage = NUM_UPS; // = NUM_FLOWERS;
2630:main.c        **** 		*/
2631:main.c        **** 		//For changing images...
2632:main.c        **** 		static sprite_t *p_selectedSprite = &spriteQ;
2633:main.c        **** 		static uint16_t buttonPressed = FALSE;
2634:main.c        **** 
2635:main.c        **** #define DEBUGGING_PRESSIMMEDIATE TRUE
2636:main.c        **** 
2637:main.c        **** #if(!defined(DEBUGGING_PRESSIMMEDIATE) || !DEBUGGING_PRESSIMMEDIATE)
2638:main.c        **** 		if((p_selectedSprite == &spriteQ) 
2639:main.c        **** 				|| (p_selectedSprite == &spriteGOOMBA))
2640:main.c        **** #else
2641:main.c        **** 	#warning "Debugging mode... players can change their result!"
2642:main.c        **** #endif
2643:main.c        **** 		if(!getpinPORT(PB0, PORTB))
2644:main.c        **** 		{
2645:main.c        **** 			if(!buttonPressed)
2646:main.c        **** 			{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 69


2647:main.c        **** 				buttonPressed = rowNum;
2648:main.c        **** 				if(buttonPressed == 0)
2649:main.c        **** 					buttonPressed = 1;
2650:main.c        **** 			}
2651:main.c        **** 			else if((rowNum-buttonPressed) >= 64)
2652:main.c        **** 				buttonPressed += 0x4000;
2653:main.c        **** 		}
2654:main.c        **** 
2655:main.c        **** 
2656:main.c        **** #define REALLY_IMMEDIATE	TRUE
2657:main.c        **** #if (defined(REALLY_IMMEDIATE) && REALLY_IMMEDIATE)
2658:main.c        **** 		if((rowNum == 0) || (buttonPressed&0x8000))
2659:main.c        **** #else
2660:main.c        **** 		if(rowNum==0)
2661:main.c        **** #endif
2662:main.c        **** 		{
2663:main.c        **** 			if(!(buttonPressed&0x8000) && !((p_selectedSprite == &spriteQ) ||
2664:main.c        **** 												(p_selectedSprite == &spriteGOOMBA)))
2665:main.c        **** 				buttonPressed = FALSE;
2666:main.c        **** 
2667:main.c        **** 			if(buttonPressed)
2668:main.c        **** 			{
2669:main.c        **** 				if(p_selectedSprite == &spriteGOOMBA)
2670:main.c        **** 				{
2671:main.c        **** 					if(qCount == 1)
2672:main.c        **** 						p_selectedSprite = &spriteDEADGOOMBA;
2673:main.c        **** 
2674:main.c        **** 				}
2675:main.c        **** 				else
2676:main.c        **** 				{
2677:main.c        **** 					//Duh...
2678:main.c        **** 					// But still, 255 % 3 should give a value from 0 to 2
2679:main.c        **** 					//buttonPressed=FALSE;
2680:main.c        **** 					qCount = 0;
2681:main.c        **** 					//static uint8_t iconSelection;
2682:main.c        **** 					//iconSelection++;
2683:main.c        **** 					//iconSelection%=NUM_ICONS;
2684:main.c        **** 					//NumFramesInImage = iconFrames[iconSelection];
2685:main.c        **** //#define RANDOMSPRITE_OVERRIDE 0
2686:main.c        **** #if(defined(RANDOMSPRITE_OVERRIDE))
2687:main.c        **** 					switch(RANDOMSPRITE_OVERRIDE)
2688:main.c        **** #else
2689:main.c        **** 					switch ((buttonPressed-1)%(NUM_ICONS*2))
2690:main.c        **** #endif
2691:main.c        **** 					{
2692:main.c        **** 						case 0:
2693:main.c        **** 							p_selectedSprite = &spriteFLOWER;
2694:main.c        **** 							break;
2695:main.c        **** 						case 1:
2696:main.c        **** 							p_selectedSprite = &sprite1UP;
2697:main.c        **** 							break;
2698:main.c        **** 						case 2:
2699:main.c        **** 							p_selectedSprite = &spriteBIG;
2700:main.c        **** 							break;
2701:main.c        **** 						case 3:
2702:main.c        **** 							p_selectedSprite = &spriteSTAR;
2703:main.c        **** 							break;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 70


2704:main.c        **** 						case 4:
2705:main.c        **** 							p_selectedSprite = &spriteGOOMBA;
2706:main.c        **** 							break;
2707:main.c        **** 						default:
2708:main.c        **** 							p_selectedSprite = &spriteCOIN;
2709:main.c        **** 							break;
2710:main.c        **** 					}
2711:main.c        **** 				}
2712:main.c        **** 
2713:main.c        **** 				//buttonPressed=FALSE;
2714:main.c        **** 			}
2715:main.c        **** 			if(p_selectedSprite == &spriteCOIN)
2716:main.c        **** 			{
2717:main.c        **** 				if(qCount >= 2)
2718:main.c        **** 					p_selectedSprite = &spriteSOLID;
2719:main.c        **** 			}
2720:main.c        **** 			else if(p_selectedSprite != &spriteQ)
2721:main.c        **** 			{
2722:main.c        **** 				if(qCount >= 4)
2723:main.c        **** 				{
2724:main.c        **** 					qCount = 0;
2725:main.c        **** 					if(p_selectedSprite != &spriteSOLID)
2726:main.c        **** 						p_selectedSprite = &spriteSOLID;
2727:main.c        **** 					else
2728:main.c        **** 						p_selectedSprite = &spriteQ;
2729:main.c        **** 				}
2730:main.c        **** 			}
2731:main.c        **** 
2732:main.c        **** 			buttonPressed = FALSE;
2733:main.c        **** 		}
2734:main.c        **** 
2735:main.c        **** 		qRow = (rowNum*ICON_HEIGHT/(V_COUNT)); ///2));
2736:main.c        **** 		
2737:main.c        **** 
2738:main.c        **** 
2739:main.c        **** 
2740:main.c        **** //		p_image = (icon[iconSelection] + 
2741:main.c        **** //						(qCount%NumFramesInImage)*ICON_HEIGHT*ICON_WIDTH);
2742:main.c        **** 
2743:main.c        **** 		// Should use readImageByte... but it's specific to FB_WIDTH
2744:main.c        **** 		//uint8_t data=
2745:main.c        **** 		//  pgm_read_byte((uint8_t *)(&((p_image)[(qRow)*Q_WIDTH+(qCol)])));
2746:main.c        **** 		uint8_t data;
2747:main.c        **** 	  
2748:main.c        **** 		if(p_selectedSprite == &spriteFLOWER)
2749:main.c        **** 		{
2750:main.c        **** 			if(qRow<FLOWER_PALETTE1_ROW)
2751:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,
2752:main.c        **** 							qCount%(spriteFLOWER.numPalettes-1) + 1, qRow, qCol);
2753:main.c        **** 			else
2754:main.c        **** 				data = getGimpColorVal(&spriteFLOWER,0,qRow, qCol);
2755:main.c        **** 		}
2756:main.c        **** 		else if(p_selectedSprite == &spriteGOOMBA)
2757:main.c        **** 		{
2758:main.c        **** 			uint8_t gCol = qCol;
2759:main.c        **** 			//Goomba moves by flipping horizontally...
2760:main.c        **** 			if(qCount & 0x01)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 71


2761:main.c        **** 				gCol = 15-qCol;
2762:main.c        **** 
2763:main.c        **** 			data = getGimpColorVal(&spriteGOOMBA, 0, qRow, gCol);
2764:main.c        **** 		}
2765:main.c        **** 		else
2766:main.c        **** 		{
2767:main.c        **** 			data = getGimpColorVal(p_selectedSprite, 
2768:main.c        **** 							qCount%p_selectedSprite->numPalettes, qRow, qCol);
2769:main.c        **** 		}
2770:main.c        **** 		data = gimpPixelValToLColor(data);
2771:main.c        **** 
2772:main.c        **** 		addSegfb(Q_SEGLENGTH + hfm_nextOutput(&colincrementer_hfm), data);
2773:main.c        **** 	}
2774:main.c        **** 
2775:main.c        **** 
2776:main.c        **** 	//Wow, is it really so smart as to recognize that rowNum is never >=
2777:main.c        **** 	// V_COUNT?! was 7684 when if(rowNum==0), then 7668 after this bug...
2778:main.c        **** 	//if(rowNum >= V_COUNT)
2779:main.c        **** 	if(rowNum >= V_COUNT-1)
2780:main.c        **** 	{
2781:main.c        **** 		qCount++;
2782:main.c        **** 	}
2783:main.c        **** 
2784:main.c        **** 
2785:main.c        **** 	//Wait, what?! We can't fit 1024 segments! But this sorta works
2786:main.c        **** 	// We're gtting syncing, a tiny bit of white-space on the right
2787:main.c        **** 	// which seems reasonable based on shotty math, 
2788:main.c        **** 	//                10     *  32   +  10   *    2       /   3 = 326
2789:main.c        **** 	// but 1024/3 is 341 (where's my math error?)
2790:main.c        **** 	//addSegfb(1024-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2791:main.c        **** 	// But, nope, 341-... doesn't sync (vertical stretching again)
2792:main.c        **** 	// But, 342 does. Sweet. 1024/3=341.33333, actually.
2793:main.c        **** 	//addSegfb(342-Q_SEGLENGTH*Q_WIDTH-Q_WIDTH*Q_STRETCHTOP/Q_STRETCHDIV, _W);
2794:main.c        **** 	// Because it's not 10*2/3, it's 32*2/3=21.3...
2795:main.c        **** 	// which is exactly right
2796:main.c        **** 	// which then doesn't explain why it has whitespace and doesn't sync
2797:main.c        **** 	// without 342 above...
2798:main.c        **** 	// something to do with white being necessary?
2799:main.c        **** 	// Can't recall where 1024/3 was determined, maybe it varies
2800:main.c        **** 	// since the LVDS clock is 7 cycles...?
2801:main.c        **** 	//OK, so maybe we just need a white pixel at the end...
2802:main.c        **** 	// I mean, this works.
2803:main.c        **** 	addSegfb(1,_W);
2804:main.c        **** 
2805:main.c        **** 
2806:main.c        **** 	segTerminate();
2807:main.c        **** 
2808:main.c        ****  #elif (defined(SEG_LINE) && SEG_LINE)
2809:main.c        **** 
2810:main.c        **** 	//syncing issues due to recursion overflowing the stack???
2811:main.c        **** 	// Apparently was
2812:main.c        **** 	segClear();
2813:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
2814:main.c        **** 	newSeg((rowNum&0xff) | BLAH, 0x06, (4<<4) | 0);				//R
2815:main.c        **** 	newSeg(1,0x06, (6<<4) | 3);									//W
2816:main.c        **** 	newSeg((255-(rowNum&0xff)) | BLAH, 0x06, (4<<4) | 0 );	//R
2817:main.c        **** 	newSeg(3,0x06, (6<<4) | 3);									//W
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 72


2818:main.c        **** 	segTerminate();
2819:main.c        **** 
2820:main.c        ****  #elif (defined(SEG_SINE) && SEG_SINE)
2821:main.c        **** 	static uint16_t lastThetaOffset = 0;
2822:main.c        **** 	static uint8_t frameCount = 0;
2823:main.c        **** 
2824:main.c        **** 	if(rowNum == 0)
2825:main.c        **** 	{
2826:main.c        **** 		lastThetaOffset+=16;
2827:main.c        **** 		frameCount++;
2828:main.c        **** 	}
2829:main.c        **** 	//pgm_read_sine(sineTable[theta])
2830:main.c        **** 
2831:main.c        **** 	segClear();
2832:main.c        **** 	//addSegfb(3,0x06, (6<<4) | 3);
2833:main.c        **** 	addSegfb(3, _W);
2834:main.c        **** 
2835:main.c        **** 	uint8_t sineVal = (uint8_t)((int8_t)128 + 
2836:main.c        **** 			sineRaw8(rowNum+lastThetaOffset));
2837:main.c        **** 
2838:main.c        **** 	uint8_t nextSineVal = (uint8_t)((int8_t)128 +
2839:main.c        **** 			sineRaw8(rowNum+1+lastThetaOffset));
2840:main.c        **** 
2841:main.c        **** 	uint8_t length; 
2842:main.c        **** 
2843:main.c        **** 	//If the step-size is greater than one pixel, we'll see hashing
2844:main.c        **** 	// this should fix that.
2845:main.c        **** 	if(nextSineVal < sineVal)
2846:main.c        **** 	{
2847:main.c        **** 		length = (sineVal - nextSineVal);
2848:main.c        **** 		//This assures that the additional length of the white-segment
2849:main.c        **** 		// goes in the proper direction...
2850:main.c        **** 		sineVal-=length;//*4;
2851:main.c        **** 	}
2852:main.c        **** 	else if(nextSineVal > sineVal)
2853:main.c        **** 		length = (nextSineVal - sineVal);
2854:main.c        **** 		
2855:main.c        **** 	//But we don't want zero-length white segments (where the sine values
2856:main.c        **** 	// are horizontal)
2857:main.c        **** 	if(length == 0)
2858:main.c        **** 		length = 1;
2859:main.c        **** 
2860:main.c        **** 	uint8_t rgbVal=0;
2861:main.c        **** 	uint8_t J=0;
2862:main.c        **** 	uint8_t j = frameCount;
2863:main.c        **** 
2864:main.c        **** #define WIDTH 5//3//4
2865:main.c        **** 	while(1)
2866:main.c        **** 	{
2867:main.c        **** 		J++;
2868:main.c        **** 		j++; // = J+frameCount;
2869:main.c        **** 		
2870:main.c        **** 		rgbVal = rgbGradient(j);
2871:main.c        **** 
2872:main.c        **** 		if((uint16_t)J*(uint16_t)WIDTH>=sineVal)
2873:main.c        **** 			break;
2874:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 73


2875:main.c        **** 		addSegfb(WIDTH, rgbVal);
2876:main.c        **** 	}
2877:main.c        **** 
2878:main.c        **** 	J--;
2879:main.c        **** 
2880:main.c        **** 	addSegfb(sineVal-(uint16_t)J*(uint16_t)WIDTH, rgbVal); 
2881:main.c        **** 
2882:main.c        **** 	addSegfb(length, _W); 
2883:main.c        **** 	addSegfb(257-sineVal-length, rgbGradient(rowNum/8)); //rowNum/8);
2884:main.c        **** 
2885:main.c        **** 	addSegfb(3, _W);
2886:main.c        **** 
2887:main.c        **** 	//Draw a sideways character...
2888:main.c        **** 	{
2889:main.c        **** 		addSegfb(3, _R);
2890:main.c        **** 
2891:main.c        **** 		uint8_t i;
2892:main.c        **** 
2893:main.c        **** 		//Without + ' ' we get the same alphabet but shifted
2894:main.c        **** 		// starting with the lower-case letters which are shifted down a row
2895:main.c        **** 	   // and some garbage in the top row...
2896:main.c        **** 		// now I get that I'm reading weird memory locations, but this
2897:main.c        **** 		// doesn't seem right. I should be accessing outside the array 
2898:main.c        **** 		// altogether, no? 	
2899:main.c        **** 		char thisChar = (rowNum/8)%('~'-' '+1) + ' '; //pgm_read_byte(&(string[rowNum/8])); 
2900:main.c        **** 		//'A'; //string[rowNum/8];
2901:main.c        **** 
2902:main.c        **** 		//Ironically, there are exactly the number of characters to be
2903:main.c        **** 		// displayed in 768 lines (plus one on the right, to center)
2904:main.c        **** 		for(i=8; i>0; i--)
2905:main.c        **** 		{
2906:main.c        **** 			if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
2907:main.c        **** 				addSegfb(1, _Y); //0x06, (4<<4) | 3);
2908:main.c        **** 			else
2909:main.c        **** 				addSegfb(1, _R); //0x06, (4<<4) | 0);
2910:main.c        **** 		}
2911:main.c        **** 
2912:main.c        **** 		addSegfb(3, _R); //0x06, (4<<4) | 0);
2913:main.c        **** 
2914:main.c        **** 		addSegfb(1, _W); //0x04, (6<<4) | 3);
2915:main.c        **** 
2916:main.c        **** 		//PGM_P charPtr = strchrnul_P(
2917:main.c        **** 		PGM_P tqbf = PSTR(" The Quick Brown Fox Jumped Over The Lazy Dog!"); 
2918:main.c        **** 		//, rowNum/8);
2919:main.c        **** 
2920:main.c        **** 		strncpy_P(&thisChar, tqbf+(rowNum/8), 1);
2921:main.c        **** 
2922:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0, (6<<4) | 0);
2923:main.c        **** 
2924:main.c        **** 		if(rowNum/8 < strlen_P(tqbf))
2925:main.c        **** 		{
2926:main.c        **** 			for(i=8; i>0; i--)
2927:main.c        **** 			{
2928:main.c        **** 				if(getbit(rowNum%8, getCharRow(thisChar,i-1)))
2929:main.c        **** 					addSegfb(1, rgb(3,0,1));//_C); //0, (6<<4) | 3);
2930:main.c        **** 				else
2931:main.c        **** 					addSegfb(1, rgb(0,0,1));//_B); //0, (6<<4) | 0);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 74


2932:main.c        **** 			}
2933:main.c        **** 		}
2934:main.c        **** 		else
2935:main.c        **** 			addSegfb(8, rgb(0,0,1));//_B); //0,(6<<4) | 0);
2936:main.c        **** 
2937:main.c        **** 		addSegfb(3, rgb(0,0,1));//_B); //0,(6<<4)|0);
2938:main.c        **** 
2939:main.c        **** 	}
2940:main.c        **** 
2941:main.c        **** 	//newSeg(3,0x06,(4<<4) | 0);
2942:main.c        **** 
2943:main.c        **** 	for(i=0; i<64; i++)
2944:main.c        **** 		addSegfb(1, (i+rowNum/4)&0x3f);
2945:main.c        **** 
2946:main.c        **** 	addSegfb(3, _W); //0x06, (6<<4) | 3);
2947:main.c        **** 
2948:main.c        **** 	segTerminate();
2949:main.c        **** 
2950:main.c        ****  #else //NOT SEG_LINE NOR SEG_SINE
2951:main.c        ****   #if(!defined(SEG_STRETCH))
2952:main.c        **** 	#define SEG_STRETCH 1
2953:main.c        ****   #endif
2954:main.c        **** 
2955:main.c        **** 	segClear();
2956:main.c        **** 
2957:main.c        **** 	//Good for syncing to have white on both borders...
2958:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
2959:main.c        **** 	
2960:main.c        **** 	//i+1 because we don't want to overwrite the white border...
2961:main.c        **** 	for(i=0; i<RB_WIDTH; i++)
2962:main.c        **** 		rbpix_to_seg(rowBuffer[i], i+1, SEG_STRETCH);
2963:main.c        **** 	
2964:main.c        **** 	//white...
2965:main.c        **** 	newSeg(1, 0x06, (6<<4) | 3);
2966:main.c        **** 	segTerminate();
2967:main.c        ****  #endif //SEG_LINE
2968:main.c        **** #endif //ROW_SEG_BUFFER
2969:main.c        **** }
2970:main.c        **** #endif //LOAD_ROW
2971:main.c        **** 
2972:main.c        **** void init_timer0Hsync(void)
2973:main.c        **** {
2974:main.c        **** 	//T_HD + T_DH + T_low + T_DE
2975:main.c        **** 	// For the original system, 19.865us = 695 dot-clocks
2976:main.c        **** 	// We'd need to take advantage of the 16-bit timer
2977:main.c        **** 	//  OCR1A may not be written properly (with a temporary high-byte)
2978:main.c        **** 	//  ... not sure.
2979:main.c        **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
2980:main.c        **** 
2981:main.c        **** // This is a hack, for testing syncability with long row-calculations
2982:main.c        **** // before actually drawing it... e.g. loading from program memory
2983:main.c        **** // This value needs to be larger than the calculation time
2984:main.c        **** // otherwise, it seems, syncing isn't stable
2985:main.c        **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
2986:main.c        **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
2987:main.c        **** 
2988:main.c        **** #define DISPLAY_CYC_COUNT \
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 75


2989:main.c        **** 	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
2990:main.c        **** 
2991:main.c        **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
2992:main.c        **** // apparently an effect of the display, definitely not a code-thing
2993:main.c        **** // in which case the vertical resolution decreases
2994:main.c        **** // though, this could be used to advantage... 
2995:main.c        **** // (e.g. more processing time outside the drawing interrupts?)
2996:main.c        **** // NOTE that if the value is too small and calculations take longer in some
2997:main.c        **** // lines than others (?), those lines may repeat, or syncing could be off
2998:main.c        **** #if (LVDS_PRESCALER == 8)
2999:main.c        ****  //#define ROW_CALCULATION_DELAY 1//20
3000:main.c        ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
3001:main.c        **** #else
3002:main.c        ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
3003:main.c        ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
3004:main.c        **** #endif
3005:main.c        **** 
3006:main.c        **** #define TOTAL_CYC_COUNT \
3007:main.c        **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
3008:main.c        **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
3009:main.c        **** //#define TOTAL_CYC_COUNT 2000
3010:main.c        **** #if (TOTAL_CYC_COUNT > 255)
3011:main.c        ****  //Adding +7 causes it to round up (hopefully)
3012:main.c        ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
3013:main.c        ****  #define TIMER0_CLKDIV	CLKDIV8
3014:main.c        ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
3015:main.c        ****  #if (TIMER0_TCNTS > 255)
3016:main.c        ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
3017:main.c        ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
3018:main.c        ****   #define TIMER0_CLKDIV CLKDIV64
3019:main.c        ****   #if (TIMER0_TCNTS > 255)
3020:main.c        **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
3021:main.c        **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
3022:main.c        **** 	 #define TIMER0_CLKDIV CLKDIV256
3023:main.c        **** 	 #if (TIMER0_TCNTS > 255)
3024:main.c        **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
3025:main.c        **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
3026:main.c        **** 		#define TIMER0_CLKDIV	CLKDIV1024
3027:main.c        **** 	 #endif
3028:main.c        ****   #endif
3029:main.c        ****  #endif
3030:main.c        ****  #if (TIMER0_TCNTS == 0)
3031:main.c        ****   #error "TIMER0_OCRVAL == 0"
3032:main.c        ****  #endif
3033:main.c        **** #else
3034:main.c        ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
3035:main.c        ****  #define TIMER0_CLKDIV CLKDIV1
3036:main.c        **** #endif
3037:main.c        **** 
3038:main.c        **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
3039:main.c        ****  //For testing, I want to see the pulses with the 'scope
3040:main.c        ****  // Unless the timer is divisible by 7 the pulses will not align with the
3041:main.c        ****  // timer overflow...
3042:main.c        ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
3043:main.c        ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
3044:main.c        ****  // and we'll only start visualizing *after* the extra TCNTs...
3045:main.c        ****  //Since the timer counts from 0 to (and including) OCR1A
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 76


3046:main.c        ****  // Add one to this test...
3047:main.c        ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
3048:main.c        ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
3049:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
3050:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
3051:main.c        **** 
3052:main.c        ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
3053:main.c        ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
3054:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
3055:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
3056:main.c        **** 
3057:main.c        ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
3058:main.c        ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
3059:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
3060:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
3061:main.c        **** 
3062:main.c        ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
3063:main.c        ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
3064:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
3065:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
3066:main.c        **** 
3067:main.c        ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
3068:main.c        ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
3069:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
3070:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
3071:main.c        **** 
3072:main.c        ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
3073:main.c        ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
3074:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
3075:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
3076:main.c        **** 
3077:main.c        ****  #elif (((TIMER0_TCNTS) % 7) == 0)
3078:main.c        ****   #warning "(TIMER0_TCNTS) % 7 == 0"
3079:main.c        ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
3080:main.c        ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
3081:main.c        **** 
3082:main.c        ****  #else
3083:main.c        ****   #error "WTF?"
3084:main.c        ****  #endif
3085:main.c        **** #else
3086:main.c        ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
3087:main.c        **** #endif
3088:main.c        **** 
3089:main.c        **** #if (TIMER0_OCRVAL > 255)
3090:main.c        ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
3091:main.c        **** #endif
3092:main.c        **** 
3093:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
3094:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
3095:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
3096:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
3097:main.c        **** }
3098:main.c        **** 
3099:main.c        **** //For a first go...
3100:main.c        **** // B5 = OCR=5
3101:main.c        **** // B4 = OCR=6+
3102:main.c        **** // B3 = DT=0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 77


3103:main.c        **** // B2 = DT=1
3104:main.c        **** // Possible combinations:
3105:main.c        **** // B3, B2, B5, B4		OCR>6 (DT=0)
3106:main.c        **** // B3, B2, B5			OCR=5, DT=0
3107:main.c        **** // B3, B2				OCR=4, DT=0
3108:main.c        **** //     B2, B5, B4		OCR=6, DT=1 (is OCR=6 possible?)
3109:main.c        **** //     B2, B5			OCR=5, DT=1
3110:main.c        **** //     B2				OCR=4, DT=1
3111:main.c        **** //         B5, B4		OCR=6, DT=2 (is OCR=6 possible?)
3112:main.c        **** //         B5			OCR=5, DT=2
3113:main.c        **** // OCR=6 is full-on...
3114:main.c        **** 
3115:main.c        **** //            |  0   1    2    3    4    5    6    
3116:main.c        **** //            |____ ____ ____ ____ ____ ____ ____
3117:main.c        **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X
3118:main.c        **** //            |                  
3119:main.c        **** 
3120:main.c        **** // Active Bits     | Brightness   |
3121:main.c        **** //                 | (0-63)       |    Configuration
3122:main.c        **** // ----------------+--------------+-------------------------
3123:main.c        **** // B5  B4  B3  B2  |     60		 |		OCR>6 (DT=0)  //DC
3124:main.c        **** // B5      B3  B2  |     44 		 |		OCR=5, DT=0
3125:main.c        **** // B5          B2  |     36 		 |		OCR=5, DT=1
3126:main.c        **** // B5              |     32 		 |		OCR=5, DT=2  
3127:main.c        **** //         B3  B2  |     12 		 |		OCR=4, DT=0  //Damn-near black...
3128:main.c        **** //             B2  |     4  		 |		OCR=4, DT=1  //Even closer
3129:main.c        **** // None = Black    |     0        |    OCR=4, DT=2
3130:main.c        **** //
3131:main.c        **** // The colors 60, 44, 36, and 32 are all discernable
3132:main.c        **** // (though 36 and 32 mightn't be if not side-by-side)
3133:main.c        **** // 12, 4, and 0 are damn-near identical and may not be worth the overhead
3134:main.c        **** // There is a SIGNIFICANT jump between 32 and 12
3135:main.c        **** //   32 is I'd say half-bright, maybe more
3136:main.c        **** //   12 is damn-near black
3137:main.c        **** 
3138:main.c        **** #define fullBlue()	DEblue_init()
3139:main.c        **** 
3140:main.c        **** /*
3141:main.c        **** static __inline__ \
3142:main.c        **** void writeBlue(uint8_t settingVal) \
3143:main.c        **** 	  __attribute__((__always_inline__));
3144:main.c        **** */
3145:main.c        **** 
3146:main.c        **** #if FALSE
3147:main.c        **** #define GREEN_PIN_MASK	0x03
3148:main.c        **** #define GREEN_PORT		PORTA
3149:main.c        **** #define GREEN_ON			0x01
3150:main.c        **** #define GREEN_ON_STRING	"0x01"
3151:main.c        **** #define GREEN_OFF			0x02
3152:main.c        **** #define GREEN_OFF_STRING "0x02"
3153:main.c        **** // in settingVal: bit 3 is unused by blue (4<=OCR<=6), so use it for green
3154:main.c        **** #define GREEN_SETTING_BIT	3
3155:main.c        **** #define GREEN_SETTING_BIT_STRING	"3"
3156:main.c        **** // for setBlue:
3157:main.c        **** #define GREEN_BLUEVAL_BIT	0
3158:main.c        **** 
3159:main.c        **** #define RED_PIN_MASK		0x0C
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 78


3160:main.c        **** #define RED_PORT			PORTA
3161:main.c        **** #define RED_ON				0x04
3162:main.c        **** #define RED_ON_STRING	"0x04"
3163:main.c        **** #define RED_OFF			0x08
3164:main.c        **** #define RED_OFF_STRING	"0x08"
3165:main.c        **** #define RED_SETTING_BIT	7
3166:main.c        **** #define RED_SETTING_BIT_STRING "7"
3167:main.c        **** #define RED_BLUEVAL_BIT	1
3168:main.c        **** 
3169:main.c        **** #define REDGREEN_PORT 	RED_PORT
3170:main.c        **** 
3171:main.c        **** 
3172:main.c        **** void writeBlue(uint8_t settingVal)
3173:main.c        **** {
3174:main.c        **** 	//Best to do these calculations first and write the registers later
3175:main.c        **** 	// it's a noticeable change (green is offset a bit, but much less)
3176:main.c        **** 	uint8_t dt = settingVal & 0x70;
3177:main.c        **** 	uint8_t ocr = settingVal & 0x07;
3178:main.c        **** 
3179:main.c        **** 	//The red and green PORT value will be temporarily calculated here...
3180:main.c        **** 	uint8_t redGreen; 
3181:main.c        **** 
3182:main.c        **** 
3183:main.c        **** 	//ASM Notes:
3184:main.c        ****    // avr-libc-user-manual-1.7.0/inline__asm.html
3185:main.c        **** 
3186:main.c        **** 	//This is timing-critical... the amount of time taken in writeBlue
3187:main.c        **** 	// determines the width of each pixel.
3188:main.c        **** 	// Most importantly: if standard C-style if/else statements are used
3189:main.c        **** 	//  it compiles differently each time (based on optimization, etc.)
3190:main.c        **** 	//  Often, though not always, it would compile such that different
3191:main.c        **** 	//  color values would use more instructions than others (branching)...
3192:main.c        **** 	//  It was too unpredictable (and believe me I tried) to code it in C
3193:main.c        **** 	//  and make it consistent. e.g. adding a nop in an else-case caused
3194:main.c        **** 	//  it to compile using brne, but not adding the nop caused breq
3195:main.c        **** 
3196:main.c        **** 	//Simply: if(getbit(greenBit, settingVal)) 	redGreen=GREEN_ON;
3197:main.c        **** 	//        else											redGreen=GREEN_OFF;
3198:main.c        **** __asm__ __volatile__
3199:main.c        **** 		  //SBRC takes 1 cycle if not skipping, 2 (or 3) if skipping
3200:main.c        **** 	     ( "sbrc %1, " GREEN_SETTING_BIT_STRING "; \n\t"				//0,1
3201:main.c        **** 							//Skip the jump if !getbit(GREEN, settingVal)
3202:main.c        **** 			 "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)	//1-
3203:main.c        **** 			 "ldi  %0, " GREEN_OFF_STRING "; \n\t"							//0-
3204:main.c        **** 			 "rjmp .+4; \n\t"  // skip setting GREEN_ON					//0-
3205:main.c        **** 			 "nop; \n\t"
3206:main.c        **** 			 "ldi  %0, " GREEN_ON_STRING "; \n\t"							//1-
3207:main.c        **** 			: "=r" (redGreen)		//redGreen is assigned to %0
3208:main.c        **** 			: "r"  (settingVal)	//settingVal is assigned to %1
3209:main.c        **** 			);
3210:main.c        **** 	//Simply: if(getbit(redBit, settingVal))		redGreen|=RED_ON;
3211:main.c        **** 	//			 else											redGreen|=RED_OFF;
3212:main.c        **** __asm__ __volatile__
3213:main.c        **** 	     ( "sbrc %1, " RED_SETTING_BIT_STRING "; \n\t"
3214:main.c        ****                      //Skip the jump if !getbit(GREEN, settingVal)
3215:main.c        ****           "rjmp .+4; \n\t"  //jump if getbit(GREEN, settingVal)
3216:main.c        ****           "ori  %2, " RED_OFF_STRING "; \n\t"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 79


3217:main.c        ****           "rjmp .+4; \n\t"  // skip setting GREEN_ON
3218:main.c        ****           "nop; \n\t"
3219:main.c        **** 			 "ori  %2, " RED_ON_STRING "; \n\t"
3220:main.c        ****          : "=r" (redGreen)    //redGreen is assigned to %0
3221:main.c        ****          : "r"  (settingVal),  //settingVal is assigned to %1
3222:main.c        **** 			  "d0"  (redGreen) //d is necessary for ori
3223:main.c        ****          );                 // 0 means 2 is shared with 0 for r/w... 
3224:main.c        **** 									 //(its value is also an input)
3225:main.c        **** 	//See notes in [the new] setBlue()
3226:main.c        **** 
3227:main.c        **** 	//Since instructions are longer than pixels, it's damn-near impossible
3228:main.c        **** 	// to have perfectly sharp edges... this order seems best,
3229:main.c        **** 	// but I haven't experimented much
3230:main.c        **** 	// May be that the reverse order is best when switching from lighter
3231:main.c        **** 	// to darker, which would require more overhead to detect
3232:main.c        **** 	// making pixels even longer. Best to have a single-LCD-pixel of ugly
3233:main.c        **** 	// than to make displayable pixels wider, reducing resolution...
3234:main.c        **** 	OCR1A = ocr;
3235:main.c        **** 	DT1 = dt;
3236:main.c        **** 	REDGREEN_PORT = redGreen;
3237:main.c        **** 
3238:main.c        **** 	//This is just to try to mimic 17's timing...
3239:main.c        **** 	// (right now, there's some timing issues, 
3240:main.c        **** 	//   line seems to start somewhat randomly, near the right edge
3241:main.c        **** 	//   some PIXEL_SCROLLs give static...)
3242:main.c        **** 	// <= 46 optimizes out, somehow, even though the code-size is larger
3243:main.c        **** 	// Should be fixed now... (see delay_cyc hacks)
3244:main.c        **** //	delay_Dots(15);
3245:main.c        **** 
3246:main.c        **** }
3247:main.c        **** #endif //FALSE
3248:main.c        **** 
3249:main.c        **** static __inline__ \
3250:main.c        **** void writeColor(uint8_t colorVal) \
3251:main.c        **** 	  __attribute__((__always_inline__));
3252:main.c        **** 
3253:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3254:main.c        **** //THIS IS JUST AN ESTIMATE
3255:main.c        ****  #define WRITE_COLOR_CYCS	(13)
3256:main.c        **** #elif(defined(FOUR_SHADES) && FOUR_SHADES)
3257:main.c        ****  // Roughly...
3258:main.c        ****  #define WRITE_COLOR_CYCS	(12*2+9+3)
3259:main.c        **** #else
3260:main.c        ****  // Roughly...
3261:main.c        ****  #define WRITE_COLOR_CYCS	(9*3+3)
3262:main.c        **** #endif
3263:main.c        **** 
3264:main.c        **** void writeColor(uint8_t colorVal)
3265:main.c        **** {
3266:main.c        **** //#warning "I'm absolutely certain this'll need to be revised, probably asm"
3267:main.c        **** 	//   Red: (+OC1D => RX0+)
3268:main.c        **** 	//    Off (0/63): OCR1D = 0
3269:main.c        **** 	//    35/63:      OCR1D = 3
3270:main.c        **** 	//    63/63:      OCR1D >= 6
3271:main.c        **** 
3272:main.c        **** /* No Shit: This compiles to a 16-bit test!
3273:main.c        **** 	switch((uint8_t)(colorVal & (uint8_t)0x03))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 80


3274:main.c        **** 	{
3275:main.c        **** 		case (uint8_t)0:
3276:main.c        **** 			OCR1D = 0;
3277:main.c        **** 			break;
3278:main.c        **** 		case (uint8_t)1:
3279:main.c        **** 			OCR1D = 3;
3280:main.c        **** 			break;
3281:main.c        **** 		case (uint8_t)2:
3282:main.c        **** 		default:
3283:main.c        **** 			OCR1D = 6;
3284:main.c        **** 			break;
3285:main.c        **** 	}
3286:main.c        **** */
3287:main.c        **** 
3288:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3289:main.c        **** 	// In this case, colorVal is actually settingVal...
3290:main.c        **** 	// Between LDI, these instructions, and OCR/DT register writes
3291:main.c        **** 	// this is 14 cycles... or 16 pixels...
3292:main.c        **** 
3293:main.c        **** 	//										//ldi (colorVal) (2 cyc)
3294:main.c        **** 	//Red: (temp)
3295:main.c        **** 	uint8_t ocrd = colorVal >> 2;	//mov, shl, shl
3296:main.c        **** 	//Green:
3297:main.c        **** 	uint8_t dt = colorVal & 0x03; //andi
3298:main.c        **** 	//Blue:
3299:main.c        **** 	uint8_t ocra = ocrd >> 3;		//mov, shl, shl, shl
3300:main.c        **** 	//And red...
3301:main.c        **** 	ocrd &= 0x07;						//andi
3302:main.c        **** 											//out OCRD, out DT, out OCRA
3303:main.c        **** 
3304:main.c        **** #else //NOT ROW_BUFFER (FRAMEBUFFER)
3305:main.c        **** 
3306:main.c        **** //	uint8_t redVal; // = colorVal & 0x03;
3307:main.c        **** 	uint8_t ocrd;
3308:main.c        **** 
3309:main.c        **** /*
3310:main.c        **** 	if(redVal == 0x00)
3311:main.c        **** 		ocrd = 0;
3312:main.c        **** 	else if(redVal == 0x01)
3313:main.c        **** 		ocrd = 3;
3314:main.c        **** 	else //2, 3
3315:main.c        **** 		ocrd = 6;
3316:main.c        **** */
3317:main.c        **** #if(defined(FOUR_SHADES) && FOUR_SHADES)
3318:main.c        ****  // "nop; nop; nop;" compiles to just a single nop! 
3319:main.c        ****  //"\n\t" or maybe the space is necessary
3320:main.c        ****  #define FOUR_SHADES_NOPS "nop ; \n\t nop ; \n\t nop ; \n\t"
3321:main.c        **** #else
3322:main.c        ****  #define FOUR_SHADES_NOPS "\n\t"
3323:main.c        **** #endif
3324:main.c        **** 	//Each branch is 9 cycles... (12 with FOUR_SHADES)
3325:main.c        **** __asm__ __volatile__
3326:main.c        **** 	( "mov 	%0, %1 	; \n\t"	// ocrd (redVal) = colorVal			  //1
3327:main.c        **** 	  "andi	%0, 0x03	; \n\t"	// ocrd = ocrd & 0x03					  //1
3328:main.c        **** 	  "brne	red1tst_%=; \n\t"	// if(ocrd != 0x00) jump to red1test  //1`2
3329:main.c        **** 	  "ldi   %0, 0x00	; \n\t"	// (ocrd==0x00) add some delays		  //1 .
3330:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 81


3331:main.c        **** 	  "nop            ; \n\t"  //                                    //1 .
3332:main.c        **** 	  "nop				; \n\t"  //                                    //1 .
3333:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //N .
3334:main.c        **** 	  "rjmp  end_%=	; \n\t"	//   jump to the end						  //2 .
3335:main.c        **** 	  									// (ocrd_reg = redVal_reg = 0)            .
3336:main.c        **** 	"red1tst_%=:"					//"%=" is a unique identifier for this asm.
3337:main.c        **** 										//  invocation, so the label won't be     .
3338:main.c        **** 										//  mistaken from another invocation      .
3339:main.c        **** 	  "cpi	%0, 0x01	; \n\t"	// if(ocrd-0x01 != 0)					  //  1
3340:main.c        **** 	  "brne	red23_%=	; \n\t"	//   jump to red=2,3						  //  1`2
3341:main.c        **** 	  FOUR_SHADES_NOPS         //                                    //  N .
3342:main.c        **** 	  "ldi	%0, 0x03	; \n\t"	// else ocrd = 0x03                   //  1 .
3343:main.c        **** 	  "rjmp	end_%=	; \n\t"	//      jump to the end               //  2 .
3344:main.c        **** 	"red23_%=:"                                                      //    .
3345:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3346:main.c        **** 	  "cpi	%0, 0x02 ; \n\t"	// if(ocrd-0x02 !=0)                  //( . 1
3347:main.c        **** 	  "brne  red3_%=	; \n\t"	//		jump to red=3                   //( . 1`2
3348:main.c        **** 	  "ldi   %0, 0x04 ; \n\t"	// else ocrd=4                        //( . 1 .
3349:main.c        **** 	  "rjmp  end_%=	; \n\t"	//      jump to the end               //( . 2 .
3350:main.c        **** 	"red3_%=:"                                                       //( .   /
3351:main.c        **** #endif                                                              //(  \ /
3352:main.c        ****      "ldi	%0, 0x06	; \n\t"	// ocrd = 0x06                        //    1
3353:main.c        **** 	  "nop				; \n\t"  // one delay...							  //    1
3354:main.c        ****   "end_%=:"
3355:main.c        **** 
3356:main.c        **** 	  : "=r" (ocrd)      //Output only "%0"
3357:main.c        **** 	  : "r"  (colorVal)  //colorVal is "%1"
3358:main.c        **** 	  //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3359:main.c        **** 	);
3360:main.c        **** 
3361:main.c        **** 
3362:main.c        **** //	OCR1D = ocrd;
3363:main.c        **** 
3364:main.c        **** 
3365:main.c        **** 	//   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
3366:main.c        **** 	//    Off (6/63): DTL1 = 0
3367:main.c        **** 	//    38-39/63:      DTL1 = 1
3368:main.c        **** 	//    62-63/63:      DTL1 = 3
3369:main.c        **** /*	switch(colorVal & 0x0C)
3370:main.c        **** 	{
3371:main.c        **** 		case 0x00:
3372:main.c        **** 			DT1 = 0;
3373:main.c        **** 			break;
3374:main.c        **** 		case 0x04:
3375:main.c        **** 			DT1 = 1;
3376:main.c        **** 			break;
3377:main.c        **** 		case 0x08:
3378:main.c        **** 		default:
3379:main.c        **** 			DT1 = 3;
3380:main.c        **** 			break;
3381:main.c        **** 	}
3382:main.c        **** */
3383:main.c        **** //	uint8_t greenVal = colorVal & 0x0C;
3384:main.c        **** 	uint8_t dt;
3385:main.c        **** /*	if(greenVal == 0x00)
3386:main.c        **** 		dt=0;
3387:main.c        **** 	else if(greenVal == 0x04)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 82


3388:main.c        **** 		dt=1;
3389:main.c        **** 	else //0x06, 0x0C
3390:main.c        **** 		dt=3;
3391:main.c        **** */
3392:main.c        ****    //Each branch is 9 cycles... (12 with FOUR_SHADES)
3393:main.c        **** __asm__ __volatile__
3394:main.c        ****    ( "mov   %0, %1   ; \n\t"  // dt (greenVal) = colorVal           //1
3395:main.c        ****      "andi  %0, 0x0C ; \n\t"  // dt = dt & 0x0C                     //1
3396:main.c        ****      "brne  grn4tst_%=; \n\t" // if(dt != 0x00) jump to grn4test    //1`2
3397:main.c        ****      "ldi   %0, 0x00 ; \n\t"  // (dt==0x00) add some delays         //1 .
3398:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3399:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3400:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3401:main.c        ****      FOUR_SHADES_NOPS         //                                    //N .
3402:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3403:main.c        ****    "grn4tst_%=:"              //"%=" is a unique identifier for this asm.
3404:main.c        ****                               //  invocation, so the label won't be     .
3405:main.c        ****                               //  mistaken from another invocation      .
3406:main.c        ****      "cpi   %0, 0x04 ; \n\t"  // if(dt-0x04 != 0)                   //  1
3407:main.c        ****      "brne  grn8C_%= ; \n\t"  //   jump to green=8,C                //  1`2
3408:main.c        ****      "ldi   %0, 0x01 ; \n\t"  // else dt = 0x01                     //  1 .
3409:main.c        ****      FOUR_SHADES_NOPS         //                                    //  N .
3410:main.c        **** 	  "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3411:main.c        ****    "grn8C_%=:"                                                      //    .
3412:main.c        **** #if (defined(FOUR_SHADES) && FOUR_SHADES)                           //   /.
3413:main.c        ****      "cpi   %0, 0x08 ; \n\t"  // if(dt-0x08 !=0)                    //( . 1
3414:main.c        ****      "brne  grn3_%=  ; \n\t"  //    jump to green=3                 //( . 1`2
3415:main.c        ****      "ldi   %0, 0x02 ; \n\t"  // else dt=2                          //( . 1 .
3416:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //( . 2 .
3417:main.c        ****    "grn3_%=:"                                                       //( .   /
3418:main.c        **** #endif                                                              //(  \ /
3419:main.c        ****      "ldi   %0, 0x03 ; \n\t"  // dt = 0x03                          //    1
3420:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3421:main.c        ****    "end_%=:"
3422:main.c        **** 
3423:main.c        ****      : "=r" (dt)      //Output only "%0"
3424:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3425:main.c        ****      //,  "d0"  (ocrd)     //ocrd is also used for andi, and is %2
3426:main.c        ****    );
3427:main.c        **** 
3428:main.c        **** 
3429:main.c        **** 
3430:main.c        **** //	DT1 = dt;
3431:main.c        **** 	//   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
3432:main.c        **** 	//    Off (15/63):  OCR1A=4
3433:main.c        **** 	//    47/63:        OCR1A=5
3434:main.c        **** 	//    63/63:        OCR1A=6
3435:main.c        **** /*	switch(colorVal & 0x30)
3436:main.c        **** 	{
3437:main.c        **** 		case 0x00:
3438:main.c        **** 			OCR1A = 4;
3439:main.c        **** 			break;
3440:main.c        **** 		case 0x10:
3441:main.c        **** 			OCR1A = 5;
3442:main.c        **** 			break;
3443:main.c        **** 		case 0x20:
3444:main.c        **** 		default:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 83


3445:main.c        **** 			OCR1A = 6;
3446:main.c        **** 			break;
3447:main.c        **** 	}
3448:main.c        **** */
3449:main.c        **** //	uint8_t blueVal = colorVal & 0x30;
3450:main.c        **** 	uint8_t ocra;
3451:main.c        **** /*	if(blueVal == 0x00)
3452:main.c        **** 		ocra=4;
3453:main.c        **** 	else if(blueVal == 0x10)
3454:main.c        **** 		ocra=5;
3455:main.c        **** 	else //0x20, 0x30
3456:main.c        **** 		ocra=6;
3457:main.c        **** */
3458:main.c        **** 
3459:main.c        ****    //Each branch is 9 cycles...
3460:main.c        **** __asm__ __volatile__
3461:main.c        ****    ( "mov   %0, %1   ; \n\t"  // ocra (blueVal) = colorVal          //1
3462:main.c        ****      "andi  %0, 0x30 ; \n\t"  // ocra = ocra & 0x30                 //1
3463:main.c        ****      "brne  blu1tst_%=; \n\t" // if(ocra != 0x00) jump to red1test  //1`2
3464:main.c        ****      "ldi   %0, 0x04 ; \n\t"  // (ocra==0x00) add some delays       //1 .
3465:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3466:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3467:main.c        ****      "nop            ; \n\t"  //                                    //1 .
3468:main.c        ****      "rjmp  end_%=   ; \n\t"  //   jump to the end                  //2 .
3469:main.c        ****                               // (ocra_reg = blueVal_reg = 0)            .
3470:main.c        ****    "blu1tst_%=:"              //"%=" is a unique identifier for this asm.
3471:main.c        ****                               //  invocation, so the label won't be     .
3472:main.c        ****                               //  mistaken from another invocation      .
3473:main.c        ****      "cpi   %0, 0x10 ; \n\t"  // if(ocra-0x10 != 0)                 //  1
3474:main.c        ****      "brne  blu23_%= ; \n\t"  //   jump to red=2,3                  //  1`2
3475:main.c        ****      "ldi   %0, 0x05 ; \n\t"  // else ocra = 0x05                   //  1 .
3476:main.c        ****      "rjmp  end_%=   ; \n\t"  //      jump to the end               //  2 .
3477:main.c        ****    "blu23_%=:"                                                      //    .
3478:main.c        ****      "ldi   %0, 0x06 ; \n\t"  // ocra = 0x06                        //    1
3479:main.c        ****      "nop            ; \n\t"  // one delay...                       //    1
3480:main.c        ****    "end_%=:"
3481:main.c        **** 
3482:main.c        ****      : "=r" (ocra)      //Output only "%0"
3483:main.c        ****      : "r"  (colorVal)  //colorVal is "%1"
3484:main.c        ****      //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
3485:main.c        ****    );
3486:main.c        **** 
3487:main.c        **** #endif //SETTING vs. FRAMEBUFFER
3488:main.c        **** 
3489:main.c        **** 	DT1 = dt;
3490:main.c        **** 	OCR1D = ocrd;
3491:main.c        **** 	OCR1A=ocra;
3492:main.c        **** }
3493:main.c        **** 
3494:main.c        **** #if(defined(IMAGE_BUFFER) && IMAGE_BUFFER)
3495:main.c        **** void setColor(uint8_t red, uint8_t green, uint8_t blue, 
3496:main.c        **** 					uint8_t row, uint8_t col)
3497:main.c        **** {
3498:main.c        **** 	red = (red > 3) ? 3 : red;
3499:main.c        **** 	green = (green > 3) ? 3 : green;
3500:main.c        **** 	blue = (blue > 3) ? 3 : blue;
3501:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 84


3502:main.c        **** 	frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
3503:main.c        **** }
3504:main.c        **** #endif
3505:main.c        **** 
3506:main.c        **** /*
3507:main.c        **** void setBlue(uint8_t val, uint8_t r, uint8_t c)
3508:main.c        **** {
3509:main.c        **** 	//Each If statement consists of (rougly):
3510:main.c        **** 	//  comparison (cpi)
3511:main.c        **** 	//  jump if false to next (brcs)
3512:main.c        **** 	//    load immediate -> register
3513:main.c        **** 	//    out OCR1a <- register
3514:main.c        **** 	//    load immediate -> register
3515:main.c        **** 	//    out DT1 <- register
3516:main.c        **** 	//    jump to end of If's...
3517:main.c        **** 
3518:main.c        **** 	//THUS: the brighter the color, the fewer cycles are executed
3519:main.c        **** 	// (fewer comparisons, fewer jumps)
3520:main.c        **** 	
3521:main.c        **** 	// One option: insert NOPs...
3522:main.c        **** 	// Another option (and probably better all 'round):
3523:main.c        **** 	//   Store the OCR1A and DT1 values in the settingBuffer
3524:main.c        **** 	//   instead of storing the color value
3525:main.c        **** 	//   (IOW: do this test when writing the "settingBuffer"
3526:main.c        **** 	//    instead of when reading)
3527:main.c        **** 	//   Then, here, just write OCR1A and DT1
3528:main.c        **** 	//   If a single-byte is used for both, DT1 could be written directly
3529:main.c        **** 	//     e.g. blueSetting=(DTVal<<4) | OCR1AVal
3530:main.c        **** 	//     DT1 = blueSetting; //OK since /OCR1n outputs are unused
3531:main.c        **** 	//     OCR1A = (blueSetting & 0x0f);
3532:main.c        **** 
3533:main.c        **** 
3534:main.c        **** 
3535:main.c        ****    // | (val & GREEN_SETTING_BIT)  is a hack a/o v20, for GREEN
3536:main.c        ****    uint8_t green =
3537:main.c        ****       getbit(GREEN_BLUEVAL_BIT, val) ? (1<<GREEN_SETTING_BIT) : 0 ;
3538:main.c        ****    uint8_t red =
3539:main.c        ****       getbit(RED_BLUEVAL_BIT, val) ? (1<<RED_SETTING_BIT) : 0 ;
3540:main.c        **** 
3541:main.c        ****    uint8_t redGreen = green | red;
3542:main.c        **** 
3543:main.c        **** 
3544:main.c        **** 
3545:main.c        **** #if(defined(DC_DE_DISABLE) && DC_DE_DISABLE)
3546:main.c        **** // #define NUM_BLUES 5		//Currently Unused... (not including black)
3547:main.c        **** #else
3548:main.c        **** // #define NUM_BLUES 6		//Currently Unused... (not including black)
3549:main.c        **** 
3550:main.c        **** 	if(val>=(60<<2)) 
3551:main.c        **** 	{
3552:main.c        **** 		//OCR1A = 0xff;
3553:main.c        **** 		settingBuffer[r][c] = (0<<4) | 6 | redGreen;
3554:main.c        **** 	}
3555:main.c        **** 	else
3556:main.c        **** #endif
3557:main.c        **** 	if(val >= (44<<2))
3558:main.c        **** 	{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 85


3559:main.c        **** 		//OCR1A = 5;
3560:main.c        **** 		//DT1 = (0<<4);
3561:main.c        **** 		settingBuffer[r][c] = (0<<4) | 5 | redGreen;
3562:main.c        **** 	}
3563:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3564:main.c        **** 	else if(val >= (36<<2)) //OK
3565:main.c        **** 	{
3566:main.c        **** 		//OCR1A = 5;
3567:main.c        **** 		//DT1 = (1<<4);
3568:main.c        **** 		settingBuffer[r][c] = (1<<4) | 5 | redGreen;
3569:main.c        **** 	}
3570:main.c        **** 	else if(val >= (32<<2)) //OK
3571:main.c        **** 	{
3572:main.c        **** 		//DT1=(2<<4);
3573:main.c        **** 		//OCR1A = 5;
3574:main.c        **** 		settingBuffer[r][c] = (2<<4) | 5 | redGreen;
3575:main.c        **** 	}
3576:main.c        **** 	else if(val >= (12<<2)) //DIM
3577:main.c        **** #else //DT0_BLUES_ONLY
3578:main.c        **** 	else //Closest to black we can get with DT=0
3579:main.c        **** #endif
3580:main.c        **** 	{
3581:main.c        **** 		//DT1=(0<<4);
3582:main.c        **** 		//OCR1A = 4;
3583:main.c        **** 		settingBuffer[r][c] = (0<<4) | 4 | redGreen;
3584:main.c        **** 	}
3585:main.c        **** #if (!defined(DT0_BLUES_ONLY) || !DT0_BLUES_ONLY)
3586:main.c        **** 	else if(val >= (4<<2)) //DIM
3587:main.c        **** 	{
3588:main.c        **** 		//DT1=(1<<4);
3589:main.c        **** 		//OCR1A = 4;
3590:main.c        **** 		settingBuffer[r][c] = (1<<4) | 4 | redGreen;
3591:main.c        **** 	}
3592:main.c        **** 	else	//Black
3593:main.c        **** 	{
3594:main.c        **** 		//DT1=(2<<4);
3595:main.c        **** 		//OCR1A = 4;
3596:main.c        **** 		settingBuffer[r][c] = (2<<4) | 4 | redGreen;
3597:main.c        **** 	}
3598:main.c        **** #endif
3599:main.c        **** }
3600:main.c        **** */
3601:main.c        **** 
3602:main.c        **** /*
3603:main.c        **** static __inline__ \
3604:main.c        **** void drawPix(uint8_t rowNum) \
3605:main.c        **** 	  __attribute__((__always_inline__));
3606:main.c        **** */
3607:main.c        **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
3608:main.c        **** void drawPix(uint8_t rowNum)
3609:main.c        **** {
3610:main.c        **** 	//uint8_t *setting = &(settingBuffer[rowNum][0]);
3611:main.c        **** #if(defined(ROW_BUFFER) && ROW_BUFFER)
3612:main.c        **** 	uint8_t *color = &(rowBuffer[0]);
3613:main.c        **** #else
3614:main.c        **** 	uint8_t *color = &(frameBuffer[rowNum][0]);
3615:main.c        **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 86


3616:main.c        **** 	/*
3617:main.c        ****       DEonly_fromNada();
3618:main.c        ****       //Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
3619:main.c        ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3620:main.c        ****                | (0<<COM1B1) | (1<<COM1B0)
3621:main.c        ****                | (1<<PWM1A) | (1<<PWM1B) );
3622:main.c        **** 	*/
3623:main.c        **** 		//The Greenish-bar on the left is due to the time it takes to execute
3624:main.c        **** 		// the first writeColor (since its value is only written at the END)
3625:main.c        **** 		// Thus the greenish-bar is about one write-color wide...
3626:main.c        **** 
3627:main.c        **** 	//Judging by some weird experiences re v21/22,
3628:main.c        **** 	// it's not entirely likely this will be predictable
3629:main.c        **** 	// it may try to recalculate the Z register between writeBlues...
3630:main.c        **** 	// hopefully not, for now. I should probably assemblify this
3631:main.c        **** 		writeColor(*(color+0));
3632:main.c        **** 
3633:main.c        **** 		//Moving this here not only removes (most of) the green bar
3634:main.c        **** 		// but also seems to make the pixel edges significantly sharper
3635:main.c        **** 		// (v29 has ~1/8in of noise, v30 has ~1pixel noise at the right edge)
3636:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3637:main.c        **** 		         | (0<<COM1B1) | (1<<COM1B0)
3638:main.c        **** 		         | (1<<PWM1A) | (1<<PWM1B) );
3639:main.c        **** 
3640:main.c        **** 		writeColor(*(color+1));	 
3641:main.c        **** 		writeColor(*(color+2));	 
3642:main.c        **** 		writeColor(*(color+3)); 
3643:main.c        **** 		writeColor(*(color+4));	 
3644:main.c        **** 		writeColor(*(color+5));					 
3645:main.c        **** 		writeColor(*(color+6));  
3646:main.c        **** 		writeColor(*(color+7));                         
3647:main.c        **** 		writeColor(*(color+8));                         
3648:main.c        **** 		writeColor(*(color+9));                         
3649:main.c        **** 		writeColor(*(color+10));                         
3650:main.c        **** 		writeColor(*(color+11));                         
3651:main.c        **** 		writeColor(*(color+12));                         
3652:main.c        **** 		writeColor(*(color+13));                         
3653:main.c        **** 		writeColor(*(color+14));                         
3654:main.c        **** 		writeColor(*(color+15));   
3655:main.c        **** #define COLORS_WRITTEN	16		
3656:main.c        **** #if ( (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL) \
3657:main.c        **** 	|| (defined(ROW_BUFFER) && (ROW_BUFFER)) )
3658:main.c        **** 		writeColor(*(color+16));
3659:main.c        **** 		writeColor(*(color+17));
3660:main.c        **** 		writeColor(*(color+18));
3661:main.c        **** 		writeColor(*(color+19));
3662:main.c        **** writeColor(*(color+20));
3663:main.c        **** writeColor(*(color+21));
3664:main.c        **** writeColor(*(color+22));
3665:main.c        **** writeColor(*(color+23));
3666:main.c        **** writeColor(*(color+24));
3667:main.c        **** writeColor(*(color+25));
3668:main.c        **** writeColor(*(color+26));
3669:main.c        **** writeColor(*(color+27));
3670:main.c        **** #define COLORS_WRITTEN	28
3671:main.c        **** #if (defined(ROW_BUFFER) && (ROW_BUFFER))
3672:main.c        **** writeColor(*(color+28));
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 87


3673:main.c        **** writeColor(*(color+29));
3674:main.c        **** writeColor(*(color+30));
3675:main.c        **** writeColor(*(color+31));
3676:main.c        **** //Some sort of syncing problem after 32... (?)
3677:main.c        **** 
3678:main.c        **** writeColor(*(color+32));
3679:main.c        **** writeColor(*(color+33));
3680:main.c        **** writeColor(*(color+34));
3681:main.c        **** writeColor(*(color+35));
3682:main.c        **** writeColor(*(color+36));
3683:main.c        **** writeColor(*(color+37));
3684:main.c        **** writeColor(*(color+38));
3685:main.c        **** writeColor(*(color+39));
3686:main.c        **** writeColor(*(color+40));
3687:main.c        **** writeColor(*(color+41));
3688:main.c        **** writeColor(*(color+42));
3689:main.c        **** writeColor(*(color+43));
3690:main.c        **** writeColor(*(color+44));
3691:main.c        **** writeColor(*(color+45));
3692:main.c        **** writeColor(*(color+46));
3693:main.c        **** writeColor(*(color+47));
3694:main.c        **** writeColor(*(color+48));
3695:main.c        **** writeColor(*(color+49));
3696:main.c        **** writeColor(*(color+50));
3697:main.c        **** writeColor(*(color+51));
3698:main.c        **** writeColor(*(color+52));
3699:main.c        **** writeColor(*(color+53));
3700:main.c        **** writeColor(*(color+54));
3701:main.c        **** writeColor(*(color+55));
3702:main.c        **** writeColor(*(color+56));
3703:main.c        **** writeColor(*(color+57));
3704:main.c        **** writeColor(*(color+58));
3705:main.c        **** writeColor(*(color+59));
3706:main.c        **** writeColor(*(color+60));
3707:main.c        **** writeColor(*(color+61));
3708:main.c        **** writeColor(*(color+62));
3709:main.c        **** writeColor(*(color+63));
3710:main.c        **** // WriteColor writes the pixel *after* the calculations...
3711:main.c        **** // thus the pixel appears basically after writeColor completes
3712:main.c        **** // These nops assure the 64th pixel is fully-displayed before exitting
3713:main.c        **** // (Not sure how the other following instructions apply to this)
3714:main.c        **** // The number of nops was found experimentally...
3715:main.c        **** asm("nop");
3716:main.c        **** asm("nop");
3717:main.c        **** asm("nop");
3718:main.c        **** asm("nop");
3719:main.c        **** asm("nop");
3720:main.c        **** asm("nop");
3721:main.c        **** asm("nop");
3722:main.c        **** asm("nop");
3723:main.c        **** //count "0" below, as well..
3724:main.c        **** #define COLORS_WRITTEN 65
3725:main.c        **** #endif //ROW_BUFFER
3726:main.c        **** #else
3727:main.c        **** //	writeColor(0);
3728:main.c        **** #endif //COLOR_BARS || ROW_BUFFER
3729:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 88


3730:main.c        **** /*		reg[17] = colorBuffer[rowNum][17];                         
3731:main.c        **** 		writeColor(reg[17]);                         
3732:main.c        **** 		...
3733:main.c        **** 		reg[20] = colorBuffer[rowNum][20];                         
3734:main.c        **** 		writeColor(reg[20]);  
3735:main.c        **** 		
3736:main.c        **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
3737:main.c        **** 		reg[0] = colorBuffer[rowNum][0];
3738:main.c        **** 		writeColor(reg[0]);
3739:main.c        **** 		...
3740:main.c        **** 		reg[10] = colorBuffer[rowNum][10];
3741:main.c        **** 		writeColor(reg[10]);
3742:main.c        **** */
3743:main.c        **** 		//Display the rest as black...
3744:main.c        **** 		writeColor(0);
3745:main.c        **** 		//writeColor(0xff);
3746:main.c        **** 	  	//delay_Dots(500);//142); //Don't want to disable DE too early...	
3747:main.c        **** 		//900 leaves a buffer for various calculations while also showing
3748:main.c        **** 		// a blue bar at the right-side...
3749:main.c        **** 		//LTN Last Used 900
3750:main.c        **** 		// -68 is from 900's intent, IIRC
3751:main.c        **** 		//  seems arbitrary, but its value (especially if too small)
3752:main.c        **** 		// causes blank lines... (?!)
3753:main.c        **** 		// -60 makes more sense for a delay (was the original post-900)
3754:main.c        **** 		//  (outside DOTS_TO_CYC because it's for cycles used for calcs...
3755:main.c        **** 		// -68 worked for LVDS_PRE=2
3756:main.c        **** 		// -60 for 1
3757:main.c        **** 		// 4 doesn't work... blue-lines
3758:main.c        **** 
3759:main.c        **** #else		//ROW_SEG_BUFFER
3760:main.c        **** void drawPix(uint8_t rowNum)
3761:main.c        **** {
3762:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3763:main.c        **** 	         | (0<<COM1B1) | (1<<COM1B0)
3764:main.c        **** 	         | (1<<PWM1A) | (1<<PWM1B) );
3765:main.c        **** 
3766:main.c        **** 		drawSegs();
3767:main.c        **** 
3768:main.c        **** #if (defined(GB_COMBINED) && GB_COMBINED)
3769:main.c        ****  #define WRITE_COLOR_CYCS 20
3770:main.c        **** #else
3771:main.c        ****  #define WRITE_COLOR_CYCS 16
3772:main.c        **** #endif
3773:main.c        **** #define COLORS_WRITTEN	64
3774:main.c        **** 
3775:main.c        **** #endif
3776:main.c        **** 
3777:main.c        **** 
3778:main.c        **** 
3779:main.c        **** #define ROW_COMPLETION_DELAY \
3780:main.c        **** 		(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60  \
3781:main.c        **** 		 - WRITE_COLOR_CYCS * COLORS_WRITTEN)
3782:main.c        **** /*
3783:main.c        **** 
3784:main.c        **** #error "should add SEG_STRETCH here..."
3785:main.c        **** #if (ROW_COMPLETION_DELAY > 0)
3786:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS) -60 // - 68)// - 60
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 89


3787:main.c        **** 				- WRITE_COLOR_CYCS*COLORS_WRITTEN);
3788:main.c        **** #else
3789:main.c        **** #warning "ROW_COMPLETION_DELAY <= 0"
3790:main.c        **** #endif
3791:main.c        **** */		//DE->Nada transition expects fullBlue...
3792:main.c        **** 		//Also helps to show the edge of the DE timing...
3793:main.c        **** 
3794:main.c        **** 		//!!! Not sure what the state is at this point...
3795:main.c        **** 		// could be any DE+Blue level, or could be NADA...
3796:main.c        **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
3797:main.c        ****          
3798:main.c        **** 		//Among the things that don't make sense...
3799:main.c        **** 		// This appears to go into affect BEFORE delay_cyc (?)
3800:main.c        **** 		// as, without a pull-up resistor on the /OC1B output, 
3801:main.c        **** 		// green seems to be floating between the last pixel and the
3802:main.c        **** 		// delay_cyc (!)
3803:main.c        **** 		//Disable complementary-output for Green 
3804:main.c        **** 		//  (on /OC1B, where CLK is OC1B)
3805:main.c        **** 		// Since Nada, V, and H DT's might be bad for clocking.
3806:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
3807:main.c        ****          | (1<<COM1B1) | (0<<COM1B0)
3808:main.c        ****          | (1<<PWM1A) | (1<<PWM1B) );
3809:main.c        **** 
3810:main.c        **** 		fullBlue();
3811:main.c        **** 		Nada_fromDEonly();
3812:main.c        **** }
3813:main.c        **** 
3814:main.c        **** #if 0   //in LCDStuff...
3815:main.c        **** // SCOPING has been removed in LVDS, revisit LCDdirect50
3816:main.c        **** //#else //NOT SCOPING
3817:main.c        **** void loadData(uint16_t rowNum, uint8_t dataEnable)
3818:main.c        **** {
3819:main.c        **** 	//H Active pulse...
3820:main.c        ****    if(vSync)
3821:main.c        ****    {
3822:main.c        **** 		//Vsync_fromNada() is called at the end of the last interupt
3823:main.c        ****       VplusH_fromVsync();
3824:main.c        ****       Hlow_Delay();
3825:main.c        ****       Vsync_fromVplusH();
3826:main.c        ****       HD_Delay();
3827:main.c        ****    }
3828:main.c        ****    else
3829:main.c        ****    {
3830:main.c        ****       Hsync_fromNada();
3831:main.c        ****       Hlow_Delay();
3832:main.c        ****       Nada_fromHsync();
3833:main.c        ****       HD_Delay();
3834:main.c        ****    }
3835:main.c        **** 
3836:main.c        ****    if(dataEnable)
3837:main.c        ****    {
3838:main.c        **** 
3839:main.c        **** /* WTF, how did this work?! Am I not using drawPix?!
3840:main.c        **** 	Yes, but drawPix calls drawSegs, which doesn't have an argument
3841:main.c        **** 	because loadRow takes the row argument elsewhere, drawSegs just
3842:main.c        **** 	draws 'em
3843:main.c        **** 		//#warning "see 'shouldBe' here..."
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 90


3844:main.c        **** 		//Should be:
3845:main.c        **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
3846:main.c        **** 		//rowNum = rowNum / (768/FB_HEIGHT);
3847:main.c        **** */
3848:main.c        **** 
3849:main.c        **** 		//DEonly_fromNada();
3850:main.c        ****       drawPix(rowNum);
3851:main.c        **** 		//Nada_init();
3852:main.c        **** //#warning "THIS ISN'T SAFE"
3853:main.c        **** //		Nada_fromDEonly();
3854:main.c        **** //#endif
3855:main.c        **** 
3856:main.c        **** 	}
3857:main.c        **** }
3858:main.c        **** #endif
3859:main.c        **** /* These are old tests from above, under if(dataEnable)
3860:main.c        **** 	They should all be implemented in lcdStuff.c, but have not been
3861:main.c        **** 	retested since...
3862:main.c        **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
3863:main.c        **** 		uint16_t blueCyc = DOTS_TO_CYC(rowNum);
3864:main.c        **** 		uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
3865:main.c        **** 		
3866:main.c        **** 		DEonly_fromNada();
3867:main.c        **** 		delay_cyc(notBlueCyc);
3868:main.c        **** 		DEblue_fromDEonly();
3869:main.c        **** 		delay_cyc(blueCyc);
3870:main.c        **** 
3871:main.c        **** 		Nada_fromDEblue();
3872:main.c        **** #elif(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
3873:main.c        **** 		DEonly_fromNada();
3874:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
3875:main.c        **** 		DEblue_fromDEonly();
3876:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
3877:main.c        **** 		Nada_fromDEblue();
3878:main.c        **** #elif(defined(DE_BLUE) && DE_BLUE)
3879:main.c        **** 		DEblue_fromNada();
3880:main.c        **** 		delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
3881:main.c        **** 		Nada_fromDEblue();
3882:main.c        **** #else  //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
3883:main.c        ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
3884:main.c        **** 		if(rowNum <= 256)
3885:main.c        **** 			rowNum=0;
3886:main.c        **** 		else
3887:main.c        **** 			rowNum=1;
3888:main.c        ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
3889:main.c        **** */
3890:main.c        **** 
3891:main.c        **** //Moved Above
3892:main.c        **** //Called as: pgm_readImageByte(pgm_image1, row, col)
3893:main.c        **** //#define pgm_readImageByte(image, row, col)	\
3894:main.c        **** //	pgm_read_byte((uint8_t *)(&((image)[(row)*FB_WIDTH+(col)])))
3895:main.c        **** 
3896:main.c        **** #if( !defined(COLOR_BAR_SCROLL) || !COLOR_BAR_SCROLL)
3897:main.c        **** #if ( (FB_WIDTH != 16) || (FB_HEIGHT != 16) )
3898:main.c        ****  #error "image1 dimensions don't match FB_HEIGHT/WIDTH"
3899:main.c        ****  #error "It's likely I just need to create a specific DRAWIMAGE definition and tests"
3900:main.c        **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 91


3901:main.c        **** 
3902:main.c        **** #define RED_IMAGEVAL_BIT 0
3903:main.c        **** #define GREEN_IMAGEVAL_BIT 1
3904:main.c        **** #define BLUE_IMAGEVAL_BIT 2
3905:main.c        **** 
3906:main.c        **** /*
3907:main.c        **** #define _R	0x03
3908:main.c        **** #define _O	0x07
3909:main.c        **** #define _G 0x0C
3910:main.c        **** #define _B 0x30
3911:main.c        **** #define _V 0x13
3912:main.c        **** #define _Y	0x0F
3913:main.c        **** #define _C 0x3C
3914:main.c        **** #define _M	0x33
3915:main.c        **** #define _K	0x00
3916:main.c        **** #define _W 0x3F
3917:main.c        **** #define _r 0x01
3918:main.c        **** #define _g 0x04
3919:main.c        **** #define _b 0x10
3920:main.c        **** #define _c 0x14
3921:main.c        **** #define _m 0x11
3922:main.c        **** #define _y 0x05
3923:main.c        **** #define _k 0x15
3924:main.c        **** #define Tr 0xC0	//Transparet
3925:main.c        **** */
3926:main.c        **** #if (TRUE || (!defined(LIFE) || !LIFE))
3927:main.c        **** uint8_t pgm_image1[256] PROGMEM =
3928:main.c        **** {
3929:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
3930:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
3931:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
3932:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
3933:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_K,Tr,
3934:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_K,_K,_Y,_Y,_Y,_K,
3935:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,
3936:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
3937:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
3938:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
3939:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
3940:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
3941:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
3942:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
3943:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
3944:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
3945:main.c        **** };
3946:main.c        **** #else
3947:main.c        **** /*uint8_t pgm_image1[256] PROGMEM =
3948:main.c        **** {  
3949:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3950:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3951:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3952:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3953:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3954:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3955:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3956:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3957:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 92


3958:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3959:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3960:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3961:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3962:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3963:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3964:main.c        ****    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3965:main.c        **** };
3966:main.c        **** */
3967:main.c        **** /*
3968:main.c        **** {  
3969:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3970:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3971:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3972:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
3973:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3974:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3975:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
3976:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_K,_K,_K,
3977:main.c        ****    _K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3978:main.c        ****    _K,_K,_K,_K,_K,_R,_R,_R,_K,_K,_K,_K,_K,_K,_K,_K,
3979:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_R,_R,_K,_K,
3980:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,_K,
3981:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_R,_K,_K,_K,
3982:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3983:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,
3984:main.c        ****    _K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K,_K
3985:main.c        **** };
3986:main.c        **** */
3987:main.c        **** 
3988:main.c        **** 
3989:main.c        **** 
3990:main.c        **** #endif
3991:main.c        **** 
3992:main.c        **** 
3993:main.c        **** uint8_t pgm_image2[256] PROGMEM =
3994:main.c        **** {
3995:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr,
3996:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,Tr,
3997:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,Tr,
3998:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,Tr,
3999:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,Tr,
4000:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_K,_Y,_Y,_K,_Y,_Y,_Y,_Y,_Y,_K,
4001:main.c        **** 	_K,_Y,_Y,_Y,_Y,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4002:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4003:main.c        **** 	_K,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_Y,_K,
4004:main.c        **** 	_K,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_K,
4005:main.c        **** 	_K,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_Y,_K,_K,_Y,_Y,_Y,_K,
4006:main.c        **** 	Tr,_K,_Y,_Y,_Y,_K,_K,_K,_K,_K,_K,_Y,_Y,_Y,_K,Tr,
4007:main.c        **** 	Tr,_K,_K,_Y,_Y,_Y,_K,_R,_K,_R,_K,_Y,_Y,_K,_K,Tr,
4008:main.c        **** 	Tr,Tr,_K,_K,_Y,_Y,_K,_R,_R,_R,_K,_Y,_K,_K,Tr,Tr,
4009:main.c        **** 	Tr,Tr,Tr,_K,_K,_Y,_Y,_K,_K,_K,_Y,_K,_K,Tr,Tr,Tr,
4010:main.c        **** 	Tr,Tr,Tr,Tr,Tr,_K,_K,_K,_K,_K,_K,Tr,Tr,Tr,Tr,Tr
4011:main.c        **** };
4012:main.c        **** #endif //COLOR_BAR_SCROLL
4013:main.c        **** 
4014:main.c        **** /*
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 93


4015:main.c        **** #if (IMAGE_WIDTH == 21)
4016:main.c        **** uint8_t mainData[2][768>>5][IMAGE_WIDTH] =
4017:main.c        **** {
4018:main.c        **** 	{
4019:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4020:main.c        **** 	{5,4,3,2,1,6,0,0,0,0,0,0,0,0,0,2,1,6,5,4,3},
4021:main.c        **** 	{4,3,2,1,0,0,0,3,3,3,3,3,3,3,0,0,0,5,4,3,4},
4022:main.c        **** 	{3,2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4023:main.c        **** 	{2,1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,1,6},
4024:main.c        **** 	{1,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,5},
4025:main.c        **** 	{6,0,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,0,4},
4026:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,0,0},
4027:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,0,0,0,3,3,3,3,3,3,0},
4028:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,0,3,3,3,3,3,3,3,0},
4029:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4030:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4031:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4032:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4033:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4034:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4035:main.c        **** 	{6,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,4},
4036:main.c        **** 	{5,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3},
4037:main.c        **** 	{4,3,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2},
4038:main.c        **** 	{3,2,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,3,2,1},
4039:main.c        **** 	{2,1,5,5,0,0,0,3,3,3,3,3,3,3,0,0,0,3,2,1,6},
4040:main.c        **** 	{1,6,3,4,3,2,0,0,0,0,0,0,0,0,0,4,3,2,1,6,5},
4041:main.c        **** 	{6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4},
4042:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3}
4043:main.c        **** 	},
4044:main.c        **** 	{	
4045:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4046:main.c        **** 	{4,3,2,1,6,5,0,0,0,0,0,0,0,0,0,1,6,5,4,3,2},
4047:main.c        **** 	{3,2,1,6,0,0,0,3,3,3,3,3,3,3,0,0,0,4,3,2,1},
4048:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,2,1,6},
4049:main.c        **** 	{1,6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,6,5},
4050:main.c        **** 	{6,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4},
4051:main.c        **** 	{5,0,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,0,3},
4052:main.c        **** 	{0,0,3,3,3,3,0,0,0,3,3,0,3,3,3,3,3,3,3,0,0},
4053:main.c        **** 	{0,3,3,3,3,3,0,0,0,3,3,3,0,0,0,3,3,3,3,3,0},
4054:main.c        **** 	{0,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,0},
4055:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4056:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4057:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4058:main.c        **** 	{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
4059:main.c        **** 	{0,3,3,3,3,0,0,3,3,3,3,3,3,3,0,0,3,3,3,3,0},
4060:main.c        **** 	{0,0,3,3,3,3,0,0,3,3,3,3,3,0,0,3,3,3,3,0,0},
4061:main.c        **** 	{5,0,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,0,3},
4062:main.c        **** 	{4,0,0,3,3,3,3,3,3,0,1,0,1,0,3,3,3,3,0,0,2},
4063:main.c        **** 	{3,2,0,0,3,3,3,3,3,0,1,1,1,0,3,3,3,0,0,2,1},
4064:main.c        **** 	{2,1,6,0,0,3,3,3,3,3,0,0,0,3,3,3,0,0,2,1,6},
4065:main.c        **** 	{1,6,5,4,0,0,0,3,3,3,3,3,3,3,0,0,0,2,1,6,5},
4066:main.c        **** 	{6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,3,2,1,6,5,4},
4067:main.c        **** 	{5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3},
4068:main.c        ****    {4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2}
4069:main.c        **** 	}
4070:main.c        **** };
4071:main.c        **** #else
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 94


4072:main.c        **** 	#error
4073:main.c        **** #endif
4074:main.c        **** */
4075:main.c        **** 
4076:main.c        **** 
4077:main.c        **** int main(void)
4078:main.c        **** {
4079:main.c        **** 
4080:main.c        **** #if(defined(SEG_RACER) && SEG_RACER)
4081:main.c        **** 	adc_takeInput(6);
4082:main.c        **** 	adc_init();
4083:main.c        **** 	adc_select(6);
4084:main.c        **** #endif
4085:main.c        **** 
4086:main.c        **** 	tetInit(7);
4087:main.c        **** 
4088:main.c        **** 	init_timer0Hsync();
4089:main.c        **** 
4090:main.c        **** 	//This starts pretty late... watch out for WDT
4091:main.c        **** 	init_heartBeat();
4092:main.c        **** 
4093:main.c        **** 	setHeartRate(0);
4094:main.c        **** 
4095:main.c        **** 	lvds_timerInit();
4096:main.c        **** 
4097:main.c        **** 	//For synchronizing timer1 settings (to avoid glitches)
4098:main.c        **** 	// count the number of CPU cycles...
4099:main.c        **** 	// depending on how many cycles it takes to start this and whatnot, 
4100:main.c        **** 	// there may be an offset. But the jist is we know every 7 cycles
4101:main.c        **** 	// the timer1 reset is synchronized with the CPU instructions...
4102:main.c        **** //	OCR0A = 6;
4103:main.c        **** //	timer_setWGM(0, WGM_CLR_ON_COMPARE);
4104:main.c        **** //	timer_selectDivisor(0, CLKDIV1);
4105:main.c        **** 
4106:main.c        **** /*
4107:main.c        **** 	segPosition=0;
4108:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4109:main.c        **** 	newSeg(16, 0x00, (4<<4) | 0);
4110:main.c        **** 	newSeg(8, 0x06, (4<<4) | 0);
4111:main.c        **** 	newSeg(32, 0x00, (4<<4) | 3);
4112:main.c        **** 	newSeg(32, 0x06, (6<<4) | 3);
4113:main.c        **** 	segTerminate();
4114:main.c        **** */
4115:main.c        **** 
4116:main.c        **** 	//For Green...
4117:main.c        **** 	// Possibly later to be reimplemented on PWM, but deadTime might inhibit
4118:main.c        **** 	setoutPORT(PA0, PORTA);
4119:main.c        **** 	setoutPORT(PA1, PORTA);
4120:main.c        **** 	//Red:
4121:main.c        **** 	setoutPORT(PA2, PORTA);
4122:main.c        **** 	setoutPORT(PA3, PORTA);
4123:main.c        **** 
4124:main.c        **** 
4125:main.c        **** 	// MUCH Of this is outside the screen...
4126:main.c        **** 
4127:main.c        **** #if (defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
4128:main.c        **** /*	uint8_t frameBuffer[FB_HEIGHT][FB_WIDTH] = 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 95


4129:main.c        **** 	{ {
4130:main.c        **** 		(0<<2), 
4131:main.c        **** 			(0<<2) | (1<<RED_BLUEVAL_BIT), (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4132:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (0<<2) | (1<<GREEN_BLUEVAL_BIT),
4133:main.c        **** 		(4<<2), 
4134:main.c        **** 			(4<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4135:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (4<<2) | (1<<GREEN_BLUEVAL_BIT),
4136:main.c        **** 	   (12<<2), 
4137:main.c        **** 			(12<<2) | (1<<RED_BLUEVAL_BIT), (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4138:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (12<<2) | (1<<GREEN_BLUEVAL_BIT),
4139:main.c        **** 		(32<<2), 
4140:main.c        **** 			(32<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4141:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (32<<2) | (1<<GREEN_BLUEVAL_BIT),
4142:main.c        **** 		(36<<2), 
4143:main.c        **** 			(36<<2) | (1<<RED_BLUEVAL_BIT), (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4144:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (36<<2) | (1<<GREEN_BLUEVAL_BIT),
4145:main.c        **** 		(44<<2), 
4146:main.c        **** 			(44<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4147:main.c        **** 	   	(1<<RED_BLUEVAL_BIT) | (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4148:main.c        **** 		(60<<2),
4149:main.c        **** 	  		(60<<2) | (1<<RED_BLUEVAL_BIT), (60<<2) | (1<<GREEN_BLUEVAL_BIT),
4150:main.c        **** 			(1<<RED_BLUEVAL_BIT) | (60<<2) | (1<<GREEN_BLUEVAL_BIT)
4151:main.c        **** 	  },
4152:main.c        **** 	  {
4153:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT), (4<<2) | (1<<RED_BLUEVAL_BIT),
4154:main.c        **** 	  	(12<<2) | (1<<RED_BLUEVAL_BIT), (32<<2) | (1<<RED_BLUEVAL_BIT),
4155:main.c        **** 	  	(36<<2) | (1<<RED_BLUEVAL_BIT), (44<<2) | (1<<RED_BLUEVAL_BIT),
4156:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT),
4157:main.c        **** 		
4158:main.c        **** 		(0<<2) | (1<<GREEN_BLUEVAL_BIT), (4<<2) | (1<<GREEN_BLUEVAL_BIT), 
4159:main.c        **** 		(12<<2) | (1<<GREEN_BLUEVAL_BIT), (32<<2) | (1<<GREEN_BLUEVAL_BIT), 
4160:main.c        **** 		(36<<2)| (1<<GREEN_BLUEVAL_BIT), (44<<2) | (1<<GREEN_BLUEVAL_BIT),
4161:main.c        **** 		(60<<2) | (1<<GREEN_BLUEVAL_BIT), 
4162:main.c        **** 		
4163:main.c        **** 		(0<<2), (4<<2), (12<<2),(32<<2), (36<<2), (44<<2), (60<<2),
4164:main.c        **** 
4165:main.c        **** 		(0<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4166:main.c        **** 	  	(4<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4167:main.c        **** 		(12<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4168:main.c        **** 	  	(32<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4169:main.c        **** 		(36<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4170:main.c        **** 	  	(44<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT),
4171:main.c        **** 		(60<<2) | (1<<RED_BLUEVAL_BIT) | (1<<GREEN_BLUEVAL_BIT)
4172:main.c        **** 
4173:main.c        ****   	  }
4174:main.c        **** 	};
4175:main.c        **** */
4176:main.c        **** 
4177:main.c        **** 
4178:main.c        **** 	//Init:
4179:main.c        **** 	uint8_t i;
4180:main.c        **** 	for(i=0; i<FB_WIDTH; i++)
4181:main.c        **** 	{
4182:main.c        **** 		uint8_t j=FB_WIDTH-1-i;
4183:main.c        **** 		setColor((i&0x03), (i&0x0C)>>2, (i&0x30)>>4, 0, i);
4184:main.c        **** 		setColor((i&0x30)>>4, (i&0x0C)>>2, (i&0x03), 1, i);
4185:main.c        **** //		setBlue(frameBuffer[0][i], 0, i);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 96


4186:main.c        **** //		setBlue(frameBuffer[1][i], 1, i);
4187:main.c        **** 	}
4188:main.c        **** #else	//NOT COLOR_BAR_SCROLL
4189:main.c        **** 	//uint8_t frameBuffer[16][16];
4190:main.c        **** 
4191:main.c        **** 	uint8_t row,col;
4192:main.c        **** /*	for(r=0; r<FB_HEIGHT; r++)
4193:main.c        **** 	{
4194:main.c        **** 		for(c=0; c<FB_WIDTH; c++)
4195:main.c        **** 		{
4196:main.c        **** 			uint8_t imagePixel=pgm_readImageByte(pgm_image1, r, c);
4197:main.c        **** 
4198:main.c        **** 			setColor(
4199:main.c        **** 				(getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4200:main.c        **** 				(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4201:main.c        **** 				(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
4202:main.c        **** 				r, c);
4203:main.c        **** //			setBlue(
4204:main.c        **** //					(
4205:main.c        **** //	(getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? (60<<2) : 0) |
4206:main.c        **** //	(getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? (1<<GREEN_BLUEVAL_BIT) : 0) |
4207:main.c        **** //	(getbit(RED_IMAGEVAL_BIT, imagePixel) ? (1<<RED_BLUEVAL_BIT) : 0)
4208:main.c        **** //					), r, c);
4209:main.c        **** 		}
4210:main.c        **** 	}
4211:main.c        **** */
4212:main.c        ****  #if (defined(IMAGE_CHANGE) && IMAGE_CHANGE)
4213:main.c        **** 	uint32_t counter=0;
4214:main.c        **** 	uint8_t imageNum = 0;
4215:main.c        **** 	uint8_t colorShift = 0;
4216:main.c        **** 	while(1)
4217:main.c        **** 	{
4218:main.c        ****  #if (defined(FRAME_SYNC) && FRAME_SYNC)
4219:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
4220:main.c        ****  #else
4221:main.c        **** 		if(counter==0)
4222:main.c        ****  #endif
4223:main.c        **** 		{
4224:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4225:main.c        **** 			uint8_t *pimage;
4226:main.c        ****  #endif
4227:main.c        **** 
4228:main.c        **** 	#if 0
4229:main.c        **** 			tetUpdate();
4230:main.c        **** 
4231:main.c        **** 			if(imageNum == 0)
4232:main.c        **** 			{
4233:main.c        **** 				imageNum = 1;
4234:main.c        **** 				pimage = pgm_image1;
4235:main.c        **** 				tetColorScheme = 1;
4236:main.c        **** 			}
4237:main.c        **** 			else
4238:main.c        **** 			{
4239:main.c        **** 				hexColor++;
4240:main.c        **** 				hexColor&=0x3f;
4241:main.c        **** 				imageNum = 0;
4242:main.c        **** 				pimage = pgm_image2;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 97


4243:main.c        **** 				tetColorScheme = 0;
4244:main.c        **** 			}
4245:main.c        **** 	#endif //0
4246:main.c        **** 
4247:main.c        ****  #if (defined(IMAGE_BUFFER) && IMAGE_BUFFER)
4248:main.c        **** 			for(row=0; row<FB_HEIGHT; row++)
4249:main.c        **** 	      for(col=0; col<FB_WIDTH; col++)
4250:main.c        **** 	      {
4251:main.c        **** 	         uint8_t imagePixel=pgm_readImageByte(pimage, row, col);
4252:main.c        **** 
4253:main.c        **** 
4254:main.c        **** 				if(imagePixel == Tr)
4255:main.c        **** 					frameBuffer[row][col] = colorShift+row+col;
4256:main.c        **** 				else
4257:main.c        **** 					frameBuffer[row][col] = imagePixel;	
4258:main.c        **** 			/*
4259:main.c        **** 	         setColor(
4260:main.c        **** 		         (getbit(RED_IMAGEVAL_BIT, imagePixel) ? 0x03 : 0),
4261:main.c        **** 	            (getbit(GREEN_IMAGEVAL_BIT, imagePixel) ? 0x0C : 0),
4262:main.c        **** 	            (getbit(BLUE_IMAGEVAL_BIT, imagePixel) ? 0x30 : 0),
4263:main.c        **** 	            r, c);
4264:main.c        **** 			*/
4265:main.c        **** 			}
4266:main.c        **** 			colorShift++;
4267:main.c        ****  #endif
4268:main.c        ****  #if (defined(LIFE) && LIFE)
4269:main.c        **** 			lifeRound();
4270:main.c        ****  #endif //LIFE
4271:main.c        ****  
4272:main.c        ****  #if (FRAME_COUNT_TO_DELAY != 0)
4273:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
4274:main.c        ****  #endif //FRAME_COUNT_TO_DELAY
4275:main.c        **** 		}
4276:main.c        ****  #if (!defined(FRAME_SYNC) && !FRAME_SYNC)
4277:main.c        **** 		counter+=16384;
4278:main.c        ****  #else
4279:main.c        **** 		//for LIFE testing...
4280:main.c        **** 		counter++;
4281:main.c        **** #endif
4282:main.c        **** 		heartUpdate();
4283:main.c        **** 	}
4284:main.c        ****  #else
4285:main.c        ****   #error "IMAGE_CHANGE is now required for drawPix with image..."
4286:main.c        ****  #endif
4287:main.c        **** #endif
4288:main.c        **** 
4289:main.c        **** #if (defined(PIXEL_SCROLL) && PIXEL_SCROLL)
4290:main.c        **** 	uint32_t counter=0;
4291:main.c        **** 
4292:main.c        **** 	while(1)
4293:main.c        **** 	{
4294:main.c        **** 		if(counter==0)
4295:main.c        **** 		{
4296:main.c        **** 			uint8_t firstCol[2];
4297:main.c        **** 			firstCol[0] = frameBuffer[0][0];
4298:main.c        **** 			firstCol[1] = frameBuffer[1][0];
4299:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 98


4300:main.c        **** 			uint8_t i;
4301:main.c        **** 			for(i=0; i<FB_WIDTH-1; i++)
4302:main.c        **** 			{
4303:main.c        **** 				frameBuffer[0][i] = frameBuffer[0][i+1];
4304:main.c        **** 				frameBuffer[1][i] = frameBuffer[1][i+1];
4305:main.c        **** //				setBlue(frameBuffer[0][i], 0, i);
4306:main.c        **** //				setBlue(frameBuffer[1][i], 1, i);
4307:main.c        **** 			}
4308:main.c        **** 
4309:main.c        **** 			frameBuffer[0][i] = firstCol[0];
4310:main.c        **** 			frameBuffer[1][i] = firstCol[1];
4311:main.c        **** //			setBlue(frameBuffer[0][i], 0, i);
4312:main.c        **** //			setBlue(frameBuffer[1][i], 1, i);
4313:main.c        **** 		}
4314:main.c        **** 		counter+=16384;
4315:main.c        **** 		heartUpdate();
4316:main.c        **** 	}
4317:main.c        **** #else
4318:main.c        **** 	while(1)
4319:main.c        **** 	{
4320:main.c        **** 		heartUpdate();
4321:main.c        **** 	}
4322:main.c        **** #endif
4323:main.c        **** 
4324:main.c        **** }
 773               		.stabn	68,0,4324,.LM62-.LFBB5
 774               	.LM62:
 775 034e 8730      		cpi r24,lo8(7)
 776 0350 00F4      		brsh .L55
 777 0352 E82F      		mov r30,r24
 778 0354 F0E0      		ldi r31,lo8(0)
 779 0356 E050      		subi r30,lo8(-(CSWTCH.87))
 780 0358 F040      		sbci r31,hi8(-(CSWTCH.87))
 781 035a 00C0      		rjmp .L57
 782               	.L53:
 783 035c 8730      		cpi r24,lo8(7)
 784 035e 00F4      		brsh .L55
 785 0360 E82F      		mov r30,r24
 786 0362 F0E0      		ldi r31,lo8(0)
 787 0364 E050      		subi r30,lo8(-(CSWTCH.90))
 788 0366 F040      		sbci r31,hi8(-(CSWTCH.90))
 789               	.L57:
 790 0368 8081      		ld r24,Z
 791 036a 0895      		ret
 792               	.L55:
 793 036c 8FE3      		ldi r24,lo8(63)
 794               	.L52:
 795               		.stabs	"tetStuff.c",132,0,0,.Ltext3
 796               	.Ltext3:
 407:tetStuff.c    **** 	{
 408:tetStuff.c    **** 		case 0:
 409:tetStuff.c    **** 		case 1:
 410:tetStuff.c    **** 			switch(tetBrick)
 411:tetStuff.c    **** 			{
 412:tetStuff.c    **** 				case 1:
 413:tetStuff.c    **** 					return _R;
 414:tetStuff.c    **** 				case 2:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 99


 415:tetStuff.c    **** 					return _O;
 416:tetStuff.c    **** 				case 3:
 417:tetStuff.c    **** 					return _Y;
 418:tetStuff.c    **** 				case 4:
 419:tetStuff.c    **** 					return _G;
 420:tetStuff.c    **** 				case 5:
 421:tetStuff.c    **** 					return _C;
 422:tetStuff.c    **** 				case 6:
 423:tetStuff.c    **** 					return _B;
 424:tetStuff.c    **** 				case 7:
 425:tetStuff.c    **** 					return _M;
 426:tetStuff.c    **** 				default:	//WTF???
 427:tetStuff.c    **** 					return _W;
 428:tetStuff.c    **** 			}
 429:tetStuff.c    **** 			break;
 430:tetStuff.c    **** 		default: //Shouldn't happen...
 431:tetStuff.c    **** 			// was case1 but these colors are ugly
 432:tetStuff.c    **** 			// and cause syncing problems...
 433:tetStuff.c    **** 			switch(tetBrick)
 434:tetStuff.c    **** 			{
 435:tetStuff.c    **** 				case 1:
 436:tetStuff.c    **** 					return _r;
 437:tetStuff.c    **** 				case 2:
 438:tetStuff.c    **** 					return _g;
 439:tetStuff.c    **** 				case 3:
 440:tetStuff.c    **** 					return _b;
 441:tetStuff.c    **** 				case 4:
 442:tetStuff.c    **** 					return _c;
 443:tetStuff.c    **** 				case 5:
 444:tetStuff.c    **** 					return _m;
 445:tetStuff.c    **** 				case 6:
 446:tetStuff.c    **** 					return _y;
 447:tetStuff.c    **** 				case 7:
 448:tetStuff.c    **** 					return _k;
 449:tetStuff.c    **** 				default:	//WTF
 450:tetStuff.c    **** 					return _W;
 451:tetStuff.c    **** 			}
 452:tetStuff.c    **** //		default:
 453:tetStuff.c    **** //			return 0;
 454:tetStuff.c    **** 	}
 455:tetStuff.c    **** 
 456:tetStuff.c    **** }
 797               		.stabn	68,0,456,.LM63-.LFBB5
 798               	.LM63:
 799 036e 0895      		ret
 800               		.size	tetBrick_to_fb, .-tetBrick_to_fb
 801               	.Lscope5:
 802               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 803               		.stabd	78,0,0
 804               		.stabs	"segClear:F(0,15)",36,0,157,segClear
 805               	.global	segClear
 806               		.type	segClear, @function
 807               	segClear:
 808               		.stabd	46,0,0
 809               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext4
 810               	.Ltext4:
   1:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 100


   2:rowSegBuffer.c **** 
   3:rowSegBuffer.c **** #define NUM_SEGMENTS	68//128 //68 //128//68
   4:rowSegBuffer.c **** 
   5:rowSegBuffer.c **** //Green and blue are in the same byte...
   6:rowSegBuffer.c **** // I don't think the code will compile anymore without this.
   7:rowSegBuffer.c **** // It increases the pixel calculation from 18 cycles to 20 cycles
   8:rowSegBuffer.c **** #define GB_COMBINED TRUE
   9:rowSegBuffer.c **** 
  10:rowSegBuffer.c **** // SQUARE_SEGMENTS inserts nops in the counter-loop
  11:rowSegBuffer.c **** // such that each loop takes the equivalent time as the first load/write
  12:rowSegBuffer.c **** //  of the values...
  13:rowSegBuffer.c **** // Then, each incremet of length is equivalent to one drawable-pixel
  14:rowSegBuffer.c **** // (Later, maybe, setting this FALSE would allow for LCD pixel-resolution
  15:rowSegBuffer.c **** //  down to a single pixel, with LVDS_PRESCALER, etc. BUT, the minimum 
  16:rowSegBuffer.c **** //  width of a segment would be longer, due to higher calculation time
  17:rowSegBuffer.c **** //  at the beginning)
  18:rowSegBuffer.c **** // Another benefit of SQUARE_SEGMENTS is that more distance can be
  19:rowSegBuffer.c **** //  covered in the same count... (fewer segments necessary in memory for a
  20:rowSegBuffer.c **** //  long color-segment)
  21:rowSegBuffer.c **** // Another "benefit" is that all count values can be used,
  22:rowSegBuffer.c **** //  (less testing is necessary to make sure a pixel can be added)
  23:rowSegBuffer.c **** //  (meh...)
  24:rowSegBuffer.c **** #define SQUARE_SEGMENTS TRUE
  25:rowSegBuffer.c **** 
  26:rowSegBuffer.c **** //Segments have four values:
  27:rowSegBuffer.c **** // segment length
  28:rowSegBuffer.c **** // red	(OCR)
  29:rowSegBuffer.c **** // green	(DT)
  30:rowSegBuffer.c **** // blue	(OCR)
  31:rowSegBuffer.c **** //
  32:rowSegBuffer.c **** // To save space, and no additional instruction cycles are needed,
  33:rowSegBuffer.c **** //  combine red and length
  34:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  35:rowSegBuffer.c **** //                   \__ __/ \__ __/
  36:rowSegBuffer.c **** //								V       V
  37:rowSegBuffer.c **** //                      |       Red OCR value
  38:rowSegBuffer.c **** //                      segLength
  39:rowSegBuffer.c **** 
  40:rowSegBuffer.c **** // NOW:
  41:rowSegBuffer.c **** //  red_length bit:  7 6 5 4 3 2 1 0
  42:rowSegBuffer.c **** //                   \___ ___/ \_ _/
  43:rowSegBuffer.c **** //                       V       V
  44:rowSegBuffer.c **** //                       |       Red OCR value
  45:rowSegBuffer.c **** //                       segLength
  46:rowSegBuffer.c **** // RISK:
  47:rowSegBuffer.c **** //  At one point I was considering doubling OCR/DT values
  48:rowSegBuffer.c **** //   in able to get higher resolution...
  49:rowSegBuffer.c **** //   (more CPU cycles per pixel clock)
  50:rowSegBuffer.c **** //  That would require a significant overhaul
  51:rowSegBuffer.c **** //   and LVDS_PRESCALER has already helped...
  52:rowSegBuffer.c **** #define SEG_LENGTH_BITS 5
  53:rowSegBuffer.c **** 
  54:rowSegBuffer.c **** //#if (defined(SEG_LENGTH_BITS))
  55:rowSegBuffer.c ****  #define SEG_LENGTH_MASK 	((UPPER_BIT_MASK8(SEG_LENGTH_BITS)))
  56:rowSegBuffer.c **** //&0xff is necessary for an assembly operand to be 8-bits
  57:rowSegBuffer.c ****  #define RED_MASK 			(((~(SEG_LENGTH_MASK))&0xff))
  58:rowSegBuffer.c ****  #define SEG_COUNT_1			((UPPER_BIT_MASK8__COUNT_1(SEG_LENGTH_BITS)))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 101


  59:rowSegBuffer.c ****  #define SEG_LENGTH_SHIFT	((8-(SEG_LENGTH_BITS)))
  60:rowSegBuffer.c **** //#else
  61:rowSegBuffer.c **** // #define SEG_LENGTH_MASK (0xf0)
  62:rowSegBuffer.c **** // #define RED_MASK (~(SEG_LENGTH_MASK))
  63:rowSegBuffer.c **** //#endif
  64:rowSegBuffer.c **** 
  65:rowSegBuffer.c **** 
  66:rowSegBuffer.c **** //This seems backwards, but it's not. See SQUARE_SEGMENTS notes, above
  67:rowSegBuffer.c **** #if (defined(SQUARE_SEGMENTS) && SQUARE_SEGMENTS)
  68:rowSegBuffer.c ****  #define COUNT_INCREMENT SEG_COUNT_1 //0x10
  69:rowSegBuffer.c ****  //This is the actual length, not as shifted for storage
  70:rowSegBuffer.c ****  #define SEG_MAXLENGTH	(SEG_LENGTH_MASK >> SEG_LENGTH_SHIFT)
  71:rowSegBuffer.c **** #else
  72:rowSegBuffer.c **** #error "This probably isn't implemented anymore..."
  73:rowSegBuffer.c ****  #if (defined(GB_COMBINED) && GB_COMBINED)
  74:rowSegBuffer.c ****   #define COUNT_INCREMENT (5*SEG_COUNT_1) //0x50
  75:rowSegBuffer.c ****  #else
  76:rowSegBuffer.c ****   #define COUNT_INCREMENT (4*SEG_COUNT_1) //0x40
  77:rowSegBuffer.c ****  #endif
  78:rowSegBuffer.c **** #endif
  79:rowSegBuffer.c **** 
  80:rowSegBuffer.c **** 
  81:rowSegBuffer.c **** // Similar *might* be possible with green and blue
  82:rowSegBuffer.c **** // IF we can switch DE/Blue to /OC1A
  83:rowSegBuffer.c **** //           switch Green to OC1B
  84:rowSegBuffer.c **** //           use DTH for green -> mov, andi, andi
  85:rowSegBuffer.c **** // Not sure if this is possible
  86:rowSegBuffer.c **** // Otherwise, sharing a byte for green/blue introduces
  87:rowSegBuffer.c **** //            mov, andi, and four lsrs
  88:rowSegBuffer.c **** //            mov, andi, swap, andi... maybe not so bad...?
  89:rowSegBuffer.c **** //                       only two additional cycles (since ld is two)
  90:rowSegBuffer.c **** // the benefit with red_length is killing two birds with one stone
  91:rowSegBuffer.c **** //   andi both &='s AND tests for 0...
  92:rowSegBuffer.c **** typedef struct _NONAME_
  93:rowSegBuffer.c **** {
  94:rowSegBuffer.c **** 	uint8_t red_length;	// segLength<<3 | OCR1D
  95:rowSegBuffer.c **** #if (defined(GB_COMBINED) && GB_COMBINED)
  96:rowSegBuffer.c **** 	uint8_t green_blue;	// blue<<4 | green
  97:rowSegBuffer.c **** #else
  98:rowSegBuffer.c **** 	uint8_t green;			//DT1(Low nibble)
  99:rowSegBuffer.c **** 	uint8_t blue;			//OCR1A
 100:rowSegBuffer.c **** #endif
 101:rowSegBuffer.c **** } seg_t;
 102:rowSegBuffer.c **** 
 103:rowSegBuffer.c **** 
 104:rowSegBuffer.c **** // Was thinking about loading the last segment as black, but that doesn't
 105:rowSegBuffer.c **** // work if the last segment isn't read, due to length=0...
 106:rowSegBuffer.c **** seg_t rowSegBuffer[NUM_SEGMENTS+1];/*=
 107:rowSegBuffer.c **** {
 108:rowSegBuffer.c **** 	{(4<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3},  //White
 109:rowSegBuffer.c ****    {(8<<SEG_LENGTH_SHIFT) | 0x00, (4<<4) | 0},  //Black
 110:rowSegBuffer.c **** 	{(16<<SEG_LENGTH_SHIFT)| 0x06, (4<<4) | 0},  //Red
 111:rowSegBuffer.c **** 	{(32<<SEG_LENGTH_SHIFT) | 0x06, (6<<4) | 3}, //White
 112:rowSegBuffer.c **** 	{0,(4<<4)}                                   //Terminate
 113:rowSegBuffer.c **** };
 114:rowSegBuffer.c **** */
 115:rowSegBuffer.c **** /*=
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 102


 116:rowSegBuffer.c **** {
 117:rowSegBuffer.c **** 	{0x10,4,6},
 118:rowSegBuffer.c **** 	{0x32,4,8},
 119:rowSegBuffer.c **** 	{0x03,5,2},
 120:rowSegBuffer.c **** 	{0x00,0,0}
 121:rowSegBuffer.c **** };
 122:rowSegBuffer.c **** */
 123:rowSegBuffer.c **** 
 124:rowSegBuffer.c **** 
 125:rowSegBuffer.c **** 
 126:rowSegBuffer.c **** //See rowBuffer.c for an explanation...
 127:rowSegBuffer.c **** // The first three will probably seldom be used
 128:rowSegBuffer.c **** // The last....
 129:rowSegBuffer.c **** #define fbBlue_to_seg(fbColor) \
 130:rowSegBuffer.c **** 		((((fbColor & 0x30) | 0x40)))
 131:rowSegBuffer.c **** 		//((((fbColor & 0x30) >> 4) | 0x04)<<4) //fixed
 132:rowSegBuffer.c **** //	   (((fbColor & 0x30) << 1) | 0x40)
 133:rowSegBuffer.c **** 
 134:rowSegBuffer.c **** #define fbGreen_to_seg(fbColor) \
 135:rowSegBuffer.c **** 	   ((fbColor & 0x0C) >> 2)
 136:rowSegBuffer.c **** 
 137:rowSegBuffer.c **** #define fbRed_to_seg(fbColor) \
 138:rowSegBuffer.c **** 	   (((fbColor & 0x03) << 1) | (fbColor & 0x01))
 139:rowSegBuffer.c **** 
 140:rowSegBuffer.c **** //This gives 'red, green_blue' pairs for arguments to newSeg, etc.
 141:rowSegBuffer.c **** // It's kinda hokey to call a three-argument function with *apparently*
 142:rowSegBuffer.c **** // only two arguments, but this'll be used probably more often than
 143:rowSegBuffer.c **** // the actual function-call...
 144:rowSegBuffer.c **** // use newSegfb(length, fbColor) 
 145:rowSegBuffer.c **** //    instead of newSeg(length, fb_to_seg(fbColor))
 146:rowSegBuffer.c **** // it's just a macro, but it makes more sense
 147:rowSegBuffer.c **** #define fb_to_seg(fbColor) \
 148:rowSegBuffer.c ****   fbRed_to_seg(fbColor), (fbBlue_to_seg(fbColor) | fbGreen_to_seg(fbColor))
 149:rowSegBuffer.c **** 
 150:rowSegBuffer.c **** //Outside of rbpix_to_seg, this corresponds with the last-written segment
 151:rowSegBuffer.c **** uint8_t segPosition = 0;
 152:rowSegBuffer.c **** 
 153:rowSegBuffer.c **** 
 154:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue);
 155:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength);
 156:rowSegBuffer.c **** 
 157:rowSegBuffer.c **** void segClear(void)
 158:rowSegBuffer.c **** {
 811               		.stabn	68,0,158,.LM64-.LFBB6
 812               	.LM64:
 813               	.LFBB6:
 814               	/* prologue: function */
 815               	/* frame size = 0 */
 159:rowSegBuffer.c **** 	segPosition = 0;
 816               		.stabn	68,0,159,.LM65-.LFBB6
 817               	.LM65:
 818 0370 1092 0000 		sts segPosition,__zero_reg__
 160:rowSegBuffer.c **** 	//The important part is the null-length
 161:rowSegBuffer.c **** 	// but let's load white just in case
 162:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 819               		.stabn	68,0,162,.LM66-.LFBB6
 820               	.LM66:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 103


 821 0374 86E0      		ldi r24,lo8(6)
 822 0376 8093 0000 		sts rowSegBuffer,r24
 163:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 823               		.stabn	68,0,163,.LM67-.LFBB6
 824               	.LM67:
 825 037a 83E6      		ldi r24,lo8(99)
 826 037c 8093 0000 		sts rowSegBuffer+1,r24
 827               	/* epilogue start */
 164:rowSegBuffer.c **** }
 828               		.stabn	68,0,164,.LM68-.LFBB6
 829               	.LM68:
 830 0380 0895      		ret
 831               		.size	segClear, .-segClear
 832               	.Lscope6:
 833               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 834               		.stabd	78,0,0
 835               		.stabs	"segTerminate:F(0,15)",36,0,168,segTerminate
 836               	.global	segTerminate
 837               		.type	segTerminate, @function
 838               	segTerminate:
 839               		.stabd	46,0,0
 165:rowSegBuffer.c **** 
 166:rowSegBuffer.c **** #define rbpix_to_segTerminate segTerminate
 167:rowSegBuffer.c **** 
 168:rowSegBuffer.c **** void segTerminate(void)
 169:rowSegBuffer.c **** {
 840               		.stabn	68,0,169,.LM69-.LFBB7
 841               	.LM69:
 842               	.LFBB7:
 843               	/* prologue: function */
 844               	/* frame size = 0 */
 170:rowSegBuffer.c **** 
 171:rowSegBuffer.c **** 	//Add a new NULL-SEGMENT
 172:rowSegBuffer.c **** 	//This might appear as a stretched last pixel/segment...
 173:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 845               		.stabn	68,0,173,.LM70-.LFBB7
 846               	.LM70:
 847 0382 8091 0000 		lds r24,segPosition
 848 0386 8334      		cpi r24,lo8(67)
 849 0388 00F4      		brsh .L61
 850 038a E82F      		mov r30,r24
 851 038c F0E0      		ldi r31,lo8(0)
 852 038e EE0F      		lsl r30
 853 0390 FF1F      		rol r31
 854 0392 E050      		subi r30,lo8(-(rowSegBuffer))
 855 0394 F040      		sbci r31,hi8(-(rowSegBuffer))
 856 0396 9081      		ld r25,Z
 857 0398 987F      		andi r25,lo8(-8)
 858 039a 01F0      		breq .L63
 174:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK))
 175:rowSegBuffer.c **** 	{
 176:rowSegBuffer.c **** 		segPosition++;
 859               		.stabn	68,0,176,.LM71-.LFBB7
 860               	.LM71:
 861 039c 8F5F      		subi r24,lo8(-(1))
 862 039e 8093 0000 		sts segPosition,r24
 177:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 104


 178:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 179:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].red_length & RED_MASK;
 863               		.stabn	68,0,179,.LM72-.LFBB7
 864               	.LM72:
 865 03a2 A82F      		mov r26,r24
 866 03a4 B0E0      		ldi r27,lo8(0)
 178:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length 
 867               		.stabn	68,0,178,.LM73-.LFBB7
 868               	.LM73:
 869 03a6 FD01      		movw r30,r26
 870 03a8 EE0F      		lsl r30
 871 03aa FF1F      		rol r31
 872 03ac E050      		subi r30,lo8(-(rowSegBuffer))
 873 03ae F040      		sbci r31,hi8(-(rowSegBuffer))
 874 03b0 AA0F      		lsl r26
 875 03b2 BB1F      		rol r27
 876 03b4 A050      		subi r26,lo8(-(rowSegBuffer-2))
 877 03b6 B040      		sbci r27,hi8(-(rowSegBuffer-2))
 878 03b8 8C91      		ld r24,X
 879 03ba 8770      		andi r24,lo8(7)
 880 03bc 8083      		st Z,r24
 180:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue
 881               		.stabn	68,0,180,.LM74-.LFBB7
 882               	.LM74:
 883 03be 1196      		adiw r26,1
 884 03c0 8C91      		ld r24,X
 885 03c2 1197      		sbiw r26,1
 886 03c4 8183      		std Z+1,r24
 173:rowSegBuffer.c **** 	if((segPosition < NUM_SEGMENTS-1) 
 887               		.stabn	68,0,173,.LM75-.LFBB7
 888               	.LM75:
 889 03c6 0895      		ret
 890               	.L61:
 181:rowSegBuffer.c **** 			= rowSegBuffer[segPosition-1].green_blue;
 182:rowSegBuffer.c **** 	}
 183:rowSegBuffer.c **** 	//We're already at the last segment, so we have to nullify it
 184:rowSegBuffer.c **** 	//This might terminate the last pixel early, but is necessary.
 185:rowSegBuffer.c **** 	else if(segPosition == NUM_SEGMENTS-1)
 891               		.stabn	68,0,185,.LM76-.LFBB7
 892               	.LM76:
 893 03c8 8334      		cpi r24,lo8(67)
 894 03ca 01F4      		brne .L63
 186:rowSegBuffer.c **** 	{
 187:rowSegBuffer.c **** 		//Apparently white doesn't cause sync problems... so load it white
 188:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = fbRed_to_seg(_W);
 895               		.stabn	68,0,188,.LM77-.LFBB7
 896               	.LM77:
 897 03cc 87E0      		ldi r24,lo8(7)
 898 03ce 8093 0000 		sts rowSegBuffer+134,r24
 189:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = 
 899               		.stabn	68,0,189,.LM78-.LFBB7
 900               	.LM78:
 901 03d2 83E7      		ldi r24,lo8(115)
 902 03d4 8093 0000 		sts rowSegBuffer+135,r24
 903               	.L63:
 904 03d8 0895      		ret
 905               		.size	segTerminate, .-segTerminate
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 105


 906               	.Lscope7:
 907               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 908               		.stabd	78,0,0
 909               		.stabs	"newSeg:F(3,2)",36,0,332,newSeg
 910               		.stabs	"length:P(3,4)",64,0,332,24
 911               		.stabs	"red:P(3,2)",64,0,332,22
 912               		.stabs	"green_blue:P(3,2)",64,0,332,20
 913               	.global	newSeg
 914               		.type	newSeg, @function
 915               	newSeg:
 916               		.stabd	46,0,0
 190:rowSegBuffer.c **** 										fbBlue_to_seg(_W) | fbGreen_to_seg(_W);
 191:rowSegBuffer.c **** 	}
 192:rowSegBuffer.c **** 
 193:rowSegBuffer.c **** 	//If we got here, it's already been terminated...
 194:rowSegBuffer.c **** 	//else...
 195:rowSegBuffer.c **** }
 196:rowSegBuffer.c **** 
 197:rowSegBuffer.c **** 
 198:rowSegBuffer.c **** #define newSegfb(length, fbColor) newSeg((length), fb_to_seg(fbColor))
 199:rowSegBuffer.c **** #define addSegfb(length, fbColor) addSeg((length), fb_to_seg(fbColor))
 200:rowSegBuffer.c **** 
 201:rowSegBuffer.c **** //This is just an intermediate test, for now...
 202:rowSegBuffer.c **** // for reloading the rowbuffer to a seg-buffer.
 203:rowSegBuffer.c **** //This could easily be revised (and generalized) to be...
 204:rowSegBuffer.c **** // addSegment or addPixel
 205:rowSegBuffer.c **** void rbpix_to_seg(uint8_t rbValue, uint8_t col, uint8_t length)
 206:rowSegBuffer.c **** {
 207:rowSegBuffer.c **** 	static uint8_t last_rbValue = 0;
 208:rowSegBuffer.c **** 	//uint8_t length = 1;
 209:rowSegBuffer.c **** 
 210:rowSegBuffer.c **** 	if(col == 0)
 211:rowSegBuffer.c **** 	{
 212:rowSegBuffer.c **** 		last_rbValue = 0;
 213:rowSegBuffer.c **** 		segClear();
 214:rowSegBuffer.c **** 	}
 215:rowSegBuffer.c **** 	//Same color as last pixel...
 216:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 217:rowSegBuffer.c **** 	{
 218:rowSegBuffer.c **** 		stretchSeg(length);
 219:rowSegBuffer.c **** 		return;
 220:rowSegBuffer.c **** 	}
 221:rowSegBuffer.c **** 
 222:rowSegBuffer.c **** 	uint8_t green = rbValue & 0x03;
 223:rowSegBuffer.c **** 	uint8_t red = (rbValue & 0x1C) >> 2;
 224:rowSegBuffer.c **** 	uint8_t blue = rbValue >> 5;
 225:rowSegBuffer.c **** 
 226:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 227:rowSegBuffer.c **** 
 228:rowSegBuffer.c **** 	last_rbValue = rbValue;
 229:rowSegBuffer.c **** }
 230:rowSegBuffer.c **** 
 231:rowSegBuffer.c **** //Call this when we already know the color in the last segment is the same
 232:rowSegBuffer.c **** // so we wish to stretch the segment by additionalLength
 233:rowSegBuffer.c **** // these values are real-lengths, not as shifted for storage...
 234:rowSegBuffer.c **** // Return TRUE if the stretch was truncated...
 235:rowSegBuffer.c **** // THIS DOES NOT TEST DISPLAY_WIDTH!
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 106


 236:rowSegBuffer.c **** // DON'T FORGET to make additionalLength square before the call
 237:rowSegBuffer.c **** // if necesary....
 238:rowSegBuffer.c **** uint8_t stretchSeg(uint16_t additionalLength)
 239:rowSegBuffer.c **** {
 240:rowSegBuffer.c **** 		uint8_t oldLength=
 241:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 242:rowSegBuffer.c **** 
 243:rowSegBuffer.c **** 		if(!additionalLength)
 244:rowSegBuffer.c **** 			return FALSE;
 245:rowSegBuffer.c **** 
 246:rowSegBuffer.c **** 		//We can stretch the current segment
 247:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 248:rowSegBuffer.c **** 		{
 249:rowSegBuffer.c **** 			uint8_t maxStretch = SEG_MAXLENGTH - oldLength;
 250:rowSegBuffer.c **** 
 251:rowSegBuffer.c **** 			// Will the entire addition fit in the previous segment?
 252:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 253:rowSegBuffer.c **** 			{
 254:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 255:rowSegBuffer.c **** 					(additionalLength << SEG_LENGTH_SHIFT);
 256:rowSegBuffer.c **** 
 257:rowSegBuffer.c **** 				//Then we're done.
 258:rowSegBuffer.c **** 			//	additionalLength = 0;
 259:rowSegBuffer.c **** 			//	break;
 260:rowSegBuffer.c **** 				return FALSE;
 261:rowSegBuffer.c **** 			}
 262:rowSegBuffer.c **** 			// Nope... stretch it all the way, then later we'll make another
 263:rowSegBuffer.c **** 			else
 264:rowSegBuffer.c **** 			{
 265:rowSegBuffer.c **** 				uint8_t red = 
 266:rowSegBuffer.c **** 					rowSegBuffer[segPosition].red_length & RED_MASK;
 267:rowSegBuffer.c **** 
 268:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 269:rowSegBuffer.c **** 					red | (SEG_MAXLENGTH << SEG_LENGTH_SHIFT);
 270:rowSegBuffer.c **** 
 271:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 272:rowSegBuffer.c **** 			}
 273:rowSegBuffer.c **** 		}
 274:rowSegBuffer.c **** 
 275:rowSegBuffer.c **** 		//The current segment has been stretched and there's more remaining
 276:rowSegBuffer.c **** 		// or it was already maxed-out...
 277:rowSegBuffer.c **** 
 278:rowSegBuffer.c **** 		// We shouldn't ever get here if additionalLength = 0...
 279:rowSegBuffer.c **** 
 280:rowSegBuffer.c **** 		//But we should test to make sure there's still lenth after
 281:rowSegBuffer.c **** 		// the stretch...
 282:rowSegBuffer.c **** 		if(additionalLength)
 283:rowSegBuffer.c **** 		{
 284:rowSegBuffer.c **** 			uint8_t red =
 285:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length & RED_MASK;
 286:rowSegBuffer.c **** 
 287:rowSegBuffer.c **** 			uint8_t green_blue =
 288:rowSegBuffer.c **** 				rowSegBuffer[segPosition].green_blue;
 289:rowSegBuffer.c **** 
 290:rowSegBuffer.c **** 			uint8_t retVal;
 291:rowSegBuffer.c **** 
 292:rowSegBuffer.c **** 			//Create new segment(s) with the remaining length
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 107


 293:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 294:rowSegBuffer.c **** 
 295:rowSegBuffer.c **** 			//Then we're done...
 296:rowSegBuffer.c **** 			//additionalLength = 0;
 297:rowSegBuffer.c **** 			//break;
 298:rowSegBuffer.c **** 
 299:rowSegBuffer.c **** 			return retVal;
 300:rowSegBuffer.c **** 		}	
 301:rowSegBuffer.c **** 
 302:rowSegBuffer.c **** 		//We shouldn't ever get here...
 303:rowSegBuffer.c **** 		// Well, maybe... if additionalLength == maxStretch...?
 304:rowSegBuffer.c **** 		return FALSE;
 305:rowSegBuffer.c **** }
 306:rowSegBuffer.c **** 
 307:rowSegBuffer.c **** //This should be like newSeg, but also checks whether it can stretch
 308:rowSegBuffer.c **** // the last segment...
 309:rowSegBuffer.c **** uint8_t addSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 310:rowSegBuffer.c **** {
 311:rowSegBuffer.c **** 
 312:rowSegBuffer.c **** 	//Currently not smart enough to stretch the first segment...
 313:rowSegBuffer.c **** 	if(segPosition == 0)
 314:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 315:rowSegBuffer.c **** 
 316:rowSegBuffer.c **** 	//Can we stretch?
 317:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 318:rowSegBuffer.c **** 		&& (rowSegBuffer[segPosition].green_blue == green_blue))
 319:rowSegBuffer.c **** 			return stretchSeg(length);
 320:rowSegBuffer.c **** 	else
 321:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 322:rowSegBuffer.c **** 
 323:rowSegBuffer.c **** }
 324:rowSegBuffer.c **** 
 325:rowSegBuffer.c **** //This assumes you intend to create a new segment
 326:rowSegBuffer.c **** // it does *not* check whether the previous segment could be stretched
 327:rowSegBuffer.c **** // (it in fact, is called by stretchSeg as necessary)
 328:rowSegBuffer.c **** // Returns TRUE if it had to be truncated
 329:rowSegBuffer.c **** //  (out of segment memory, past the display edge...)
 330:rowSegBuffer.c **** // length is the real length, not shifted for storage...
 331:rowSegBuffer.c **** // THIS DOES NOT squarify, so adjust length as necessary before calling
 332:rowSegBuffer.c **** uint8_t newSeg(uint16_t length, uint8_t red, uint8_t green_blue)
 333:rowSegBuffer.c **** {
 917               		.stabn	68,0,333,.LM79-.LFBB8
 918               	.LM79:
 919               	.LFBB8:
 920               	/* prologue: function */
 921               	/* frame size = 0 */
 922               		.stabn	68,0,333,.LM80-.LFBB8
 923               	.LM80:
 924 03da 2091 0000 		lds r18,segPosition
 334:rowSegBuffer.c **** 
 335:rowSegBuffer.c **** 	//Recursion would be simpler, but we've got a limited stack.
 336:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 337:rowSegBuffer.c **** 	{
 338:rowSegBuffer.c **** 		// No more segments available...	
 339:rowSegBuffer.c **** 		// The last segment must have a length of 0
 340:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 341:rowSegBuffer.c **** 		{
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 108


 342:rowSegBuffer.c **** 			segTerminate();
 343:rowSegBuffer.c **** 			return TRUE;
 344:rowSegBuffer.c **** 		}
 345:rowSegBuffer.c **** 
 346:rowSegBuffer.c **** 		// Not yet sure how to handle display-width...
 347:rowSegBuffer.c **** 		//if(segTotal > DISPLAY_WIDTH)
 348:rowSegBuffer.c **** 		//  at least draw as much of the segment as possible...
 349:rowSegBuffer.c **** 		//  then segTerminate();
 350:rowSegBuffer.c **** 		//  and return TRUE
 351:rowSegBuffer.c **** 
 352:rowSegBuffer.c **** 		// If we've gotten this far, then we can add the segment
 353:rowSegBuffer.c **** 	
 354:rowSegBuffer.c **** 		//Check if the segment buffer is cleared...
 355:rowSegBuffer.c **** 		// then DON'T increment segPosition...
 356:rowSegBuffer.c **** 		//if(!((segPosition == 0) && 
 357:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 358:rowSegBuffer.c **** 		if(segPosition || 
 359:rowSegBuffer.c **** 			((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
 360:rowSegBuffer.c **** 				segPosition++;
 361:rowSegBuffer.c **** 
 362:rowSegBuffer.c **** 
 363:rowSegBuffer.c **** 		//Create a maxlength segment
 364:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length =
 925               		.stabn	68,0,364,.LM81-.LFBB8
 926               	.LM81:
 927 03de 562F      		mov r21,r22
 928 03e0 586F      		ori r21,lo8(-8)
 336:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 929               		.stabn	68,0,336,.LM82-.LFBB8
 930               	.LM82:
 931 03e2 00C0      		rjmp .L65
 932               	.L70:
 340:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 933               		.stabn	68,0,340,.LM83-.LFBB8
 934               	.LM83:
 935 03e4 2334      		cpi r18,lo8(67)
 936 03e6 01F4      		brne .L66
 937 03e8 2093 0000 		sts segPosition,r18
 938 03ec 00C0      		rjmp .L76
 939               	.L66:
 358:rowSegBuffer.c **** 		if(segPosition || 
 940               		.stabn	68,0,358,.LM84-.LFBB8
 941               	.LM84:
 942 03ee 2223      		tst r18
 943 03f0 01F4      		brne .L68
 944 03f2 3091 0000 		lds r19,rowSegBuffer
 945 03f6 387F      		andi r19,lo8(-8)
 946 03f8 01F0      		breq .L69
 947               	.L68:
 360:rowSegBuffer.c **** 				segPosition++;
 948               		.stabn	68,0,360,.LM85-.LFBB8
 949               	.LM85:
 950 03fa 2F5F      		subi r18,lo8(-(1))
 951               	.L69:
 952               		.stabn	68,0,364,.LM86-.LFBB8
 953               	.LM86:
 954 03fc E22F      		mov r30,r18
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 109


 955 03fe F0E0      		ldi r31,lo8(0)
 956 0400 EE0F      		lsl r30
 957 0402 FF1F      		rol r31
 958 0404 E050      		subi r30,lo8(-(rowSegBuffer))
 959 0406 F040      		sbci r31,hi8(-(rowSegBuffer))
 960 0408 5083      		st Z,r21
 365:rowSegBuffer.c **** 			red | (SEG_MAXLENGTH<<SEG_LENGTH_SHIFT);
 366:rowSegBuffer.c **** 
 367:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 961               		.stabn	68,0,367,.LM87-.LFBB8
 962               	.LM87:
 963 040a 4183      		std Z+1,r20
 368:rowSegBuffer.c **** 
 369:rowSegBuffer.c **** 		length -= SEG_MAXLENGTH;
 964               		.stabn	68,0,369,.LM88-.LFBB8
 965               	.LM88:
 966 040c 4F97      		sbiw r24,31
 967               	.L65:
 336:rowSegBuffer.c **** 	while(length >= SEG_MAXLENGTH)
 968               		.stabn	68,0,336,.LM89-.LFBB8
 969               	.LM89:
 970 040e 8F31      		cpi r24,31
 971 0410 9105      		cpc r25,__zero_reg__
 972 0412 00F4      		brsh .L70
 973 0414 2093 0000 		sts segPosition,r18
 370:rowSegBuffer.c **** 
 371:rowSegBuffer.c **** 	}
 372:rowSegBuffer.c **** 
 373:rowSegBuffer.c **** 	//We can fit whatever's left (or the whole thing) into a single segment
 374:rowSegBuffer.c **** 	// Unless, of course, there's nothing left...
 375:rowSegBuffer.c **** 	if(length > 0) //< SEG_MAXLENGTH)//Guaranteed now...
 974               		.stabn	68,0,375,.LM90-.LFBB8
 975               	.LM90:
 976 0418 0097      		sbiw r24,0
 977 041a 01F4      		brne .L71
 978 041c 80E0      		ldi r24,lo8(0)
 979 041e 0895      		ret
 980               	.L71:
 376:rowSegBuffer.c **** 	{
 377:rowSegBuffer.c **** 		//Make sure there's another segment to write to!
 378:rowSegBuffer.c **** 		if(segPosition == NUM_SEGMENTS-1)
 981               		.stabn	68,0,378,.LM91-.LFBB8
 982               	.LM91:
 983 0420 2334      		cpi r18,lo8(67)
 984 0422 01F4      		brne .L72
 985               	.L76:
 379:rowSegBuffer.c **** 		{
 380:rowSegBuffer.c **** 			segTerminate();
 986               		.stabn	68,0,380,.LM92-.LFBB8
 987               	.LM92:
 988 0424 00D0      		rcall segTerminate
 989 0426 81E0      		ldi r24,lo8(1)
 381:rowSegBuffer.c **** 			return TRUE;
 990               		.stabn	68,0,381,.LM93-.LFBB8
 991               	.LM93:
 992 0428 0895      		ret
 993               	.L72:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 110


 382:rowSegBuffer.c **** 		}
 383:rowSegBuffer.c **** 
 384:rowSegBuffer.c **** 		//if(!((segPosition == 0) &&
 385:rowSegBuffer.c **** 		//  !(rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK)))
 386:rowSegBuffer.c **** 		if(segPosition || 
 994               		.stabn	68,0,386,.LM94-.LFBB8
 995               	.LM94:
 996 042a 2223      		tst r18
 997 042c 01F4      		brne .L73
 998 042e 3091 0000 		lds r19,rowSegBuffer
 999 0432 387F      		andi r19,lo8(-8)
 1000 0434 01F0      		breq .L74
 1001               	.L73:
 387:rowSegBuffer.c **** 	     ((rowSegBuffer[segPosition].red_length & SEG_LENGTH_MASK) != 0))
 388:rowSegBuffer.c ****   				segPosition++;
 1002               		.stabn	68,0,388,.LM95-.LFBB8
 1003               	.LM95:
 1004 0436 2F5F      		subi r18,lo8(-(1))
 1005 0438 2093 0000 		sts segPosition,r18
 1006               	.L74:
 389:rowSegBuffer.c **** 
 390:rowSegBuffer.c **** 
 391:rowSegBuffer.c **** 		rowSegBuffer[segPosition].red_length = 
 1007               		.stabn	68,0,391,.LM96-.LFBB8
 1008               	.LM96:
 1009 043c E091 0000 		lds r30,segPosition
 1010 0440 F0E0      		ldi r31,lo8(0)
 1011 0442 EE0F      		lsl r30
 1012 0444 FF1F      		rol r31
 1013 0446 E050      		subi r30,lo8(-(rowSegBuffer))
 1014 0448 F040      		sbci r31,hi8(-(rowSegBuffer))
 1015 044a 880F      		lsl r24
 1016 044c 880F      		lsl r24
 1017 044e 880F      		lsl r24
 1018 0450 862B      		or r24,r22
 1019 0452 8083      		st Z,r24
 392:rowSegBuffer.c **** 			red | (length<<SEG_LENGTH_SHIFT);
 393:rowSegBuffer.c **** 
 394:rowSegBuffer.c **** 		rowSegBuffer[segPosition].green_blue = green_blue;
 1020               		.stabn	68,0,394,.LM97-.LFBB8
 1021               	.LM97:
 1022 0454 4183      		std Z+1,r20
 1023 0456 80E0      		ldi r24,lo8(0)
 395:rowSegBuffer.c **** 	}
 396:rowSegBuffer.c **** 
 397:rowSegBuffer.c **** 	return FALSE;
 398:rowSegBuffer.c **** 
 399:rowSegBuffer.c **** }
 1024               		.stabn	68,0,399,.LM98-.LFBB8
 1025               	.LM98:
 1026 0458 0895      		ret
 1027               		.size	newSeg, .-newSeg
 1028               	.Lscope8:
 1029               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 1030               		.stabd	78,0,0
 1031               		.stabs	"stretchSeg:F(3,2)",36,0,238,stretchSeg
 1032               		.stabs	"additionalLength:P(3,4)",64,0,238,24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 111


 1033               	.global	stretchSeg
 1034               		.type	stretchSeg, @function
 1035               	stretchSeg:
 1036               		.stabd	46,0,0
 239:rowSegBuffer.c **** {
 1037               		.stabn	68,0,239,.LM99-.LFBB9
 1038               	.LM99:
 1039               	.LFBB9:
 1040               	/* prologue: function */
 1041               	/* frame size = 0 */
 241:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1042               		.stabn	68,0,241,.LM100-.LFBB9
 1043               	.LM100:
 1044 045a E091 0000 		lds r30,segPosition
 1045 045e F0E0      		ldi r31,lo8(0)
 1046 0460 DF01      		movw r26,r30
 1047 0462 AA0F      		lsl r26
 1048 0464 BB1F      		rol r27
 1049 0466 A050      		subi r26,lo8(-(rowSegBuffer))
 1050 0468 B040      		sbci r27,hi8(-(rowSegBuffer))
 1051 046a 2C91      		ld r18,X
 243:rowSegBuffer.c **** 		if(!additionalLength)
 1052               		.stabn	68,0,243,.LM101-.LFBB9
 1053               	.LM101:
 1054 046c 0097      		sbiw r24,0
 1055 046e 01F0      		breq .L78
 241:rowSegBuffer.c **** 			(rowSegBuffer[segPosition].red_length >> SEG_LENGTH_SHIFT);
 1056               		.stabn	68,0,241,.LM102-.LFBB9
 1057               	.LM102:
 1058 0470 422F      		mov r20,r18
 1059 0472 4695      		lsr r20
 1060 0474 4695      		lsr r20
 1061 0476 4695      		lsr r20
 247:rowSegBuffer.c **** 		if(oldLength < SEG_MAXLENGTH)
 1062               		.stabn	68,0,247,.LM103-.LFBB9
 1063               	.LM103:
 1064 0478 4F31      		cpi r20,lo8(31)
 1065 047a 00F4      		brsh .L79
 1066               	.LBB87:
 252:rowSegBuffer.c **** 			if(additionalLength <= maxStretch)
 1067               		.stabn	68,0,252,.LM104-.LFBB9
 1068               	.LM104:
 1069 047c 3FE1      		ldi r19,lo8(31)
 1070 047e 341B      		sub r19,r20
 1071 0480 432F      		mov r20,r19
 1072 0482 50E0      		ldi r21,lo8(0)
 1073 0484 4817      		cp r20,r24
 1074 0486 5907      		cpc r21,r25
 1075 0488 00F0      		brlo .L80
 254:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length += 
 1076               		.stabn	68,0,254,.LM105-.LFBB9
 1077               	.LM105:
 1078 048a 880F      		lsl r24
 1079 048c 880F      		lsl r24
 1080 048e 880F      		lsl r24
 1081 0490 820F      		add r24,r18
 1082 0492 8C93      		st X,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 112


 1083 0494 80E0      		ldi r24,lo8(0)
 260:rowSegBuffer.c **** 				return FALSE;
 1084               		.stabn	68,0,260,.LM106-.LFBB9
 1085               	.LM106:
 1086 0496 0895      		ret
 1087               	.L80:
 1088               	.LBB88:
 268:rowSegBuffer.c **** 				rowSegBuffer[segPosition].red_length =
 1089               		.stabn	68,0,268,.LM107-.LFBB9
 1090               	.LM107:
 1091 0498 286F      		ori r18,lo8(-8)
 1092 049a 2C93      		st X,r18
 271:rowSegBuffer.c **** 				additionalLength -= maxStretch;
 1093               		.stabn	68,0,271,.LM108-.LFBB9
 1094               	.LM108:
 1095 049c 841B      		sub r24,r20
 1096 049e 950B      		sbc r25,r21
 1097               	.LBE88:
 1098               	.LBE87:
 282:rowSegBuffer.c **** 		if(additionalLength)
 1099               		.stabn	68,0,282,.LM109-.LFBB9
 1100               	.LM109:
 1101 04a0 01F0      		breq .L78
 1102               	.L79:
 1103               	.LBB89:
 293:rowSegBuffer.c **** 			retVal = newSeg(additionalLength, red, green_blue);
 1104               		.stabn	68,0,293,.LM110-.LFBB9
 1105               	.LM110:
 1106 04a2 EE0F      		lsl r30
 1107 04a4 FF1F      		rol r31
 1108 04a6 E050      		subi r30,lo8(-(rowSegBuffer))
 1109 04a8 F040      		sbci r31,hi8(-(rowSegBuffer))
 1110 04aa 6081      		ld r22,Z
 1111 04ac 6770      		andi r22,lo8(7)
 1112 04ae 4181      		ldd r20,Z+1
 1113 04b0 00D0      		rcall newSeg
 299:rowSegBuffer.c **** 			return retVal;
 1114               		.stabn	68,0,299,.LM111-.LFBB9
 1115               	.LM111:
 1116 04b2 0895      		ret
 1117               	.L78:
 1118 04b4 80E0      		ldi r24,lo8(0)
 1119               	.LBE89:
 305:rowSegBuffer.c **** }
 1120               		.stabn	68,0,305,.LM112-.LFBB9
 1121               	.LM112:
 1122 04b6 0895      		ret
 1123               		.size	stretchSeg, .-stretchSeg
 1124               		.stabs	"oldLength:r(3,2)",64,0,240,20
 1125               		.stabn	192,0,0,.LFBB9-.LFBB9
 1126               		.stabs	"retVal:r(3,2)",64,0,290,24
 1127               		.stabn	192,0,0,.LBB89-.LFBB9
 1128               		.stabn	224,0,0,.LBE89-.LFBB9
 1129               		.stabn	224,0,0,.Lscope9-.LFBB9
 1130               	.Lscope9:
 1131               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 1132               		.stabd	78,0,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 113


 1133               		.stabs	"addSeg:F(3,2)",36,0,309,addSeg
 1134               		.stabs	"length:P(3,4)",64,0,309,24
 1135               		.stabs	"red:P(3,2)",64,0,309,22
 1136               		.stabs	"green_blue:P(3,2)",64,0,309,20
 1137               	.global	addSeg
 1138               		.type	addSeg, @function
 1139               	addSeg:
 1140               		.stabd	46,0,0
 310:rowSegBuffer.c **** {
 1141               		.stabn	68,0,310,.LM113-.LFBB10
 1142               	.LM113:
 1143               	.LFBB10:
 1144               	/* prologue: function */
 1145               	/* frame size = 0 */
 313:rowSegBuffer.c **** 	if(segPosition == 0)
 1146               		.stabn	68,0,313,.LM114-.LFBB10
 1147               	.LM114:
 1148 04b8 E091 0000 		lds r30,segPosition
 1149 04bc EE23      		tst r30
 1150 04be 01F4      		brne .L84
 314:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1151               		.stabn	68,0,314,.LM115-.LFBB10
 1152               	.LM115:
 1153 04c0 00D0      		rcall newSeg
 1154 04c2 0895      		ret
 1155               	.L84:
 317:rowSegBuffer.c **** 	if(((rowSegBuffer[segPosition].red_length & RED_MASK) == red)
 1156               		.stabn	68,0,317,.LM116-.LFBB10
 1157               	.LM116:
 1158 04c4 F0E0      		ldi r31,lo8(0)
 1159 04c6 EE0F      		lsl r30
 1160 04c8 FF1F      		rol r31
 1161 04ca E050      		subi r30,lo8(-(rowSegBuffer))
 1162 04cc F040      		sbci r31,hi8(-(rowSegBuffer))
 1163 04ce 2081      		ld r18,Z
 1164 04d0 30E0      		ldi r19,lo8(0)
 1165 04d2 2770      		andi r18,lo8(7)
 1166 04d4 3070      		andi r19,hi8(7)
 1167 04d6 A62F      		mov r26,r22
 1168 04d8 B0E0      		ldi r27,lo8(0)
 1169 04da 2A17      		cp r18,r26
 1170 04dc 3B07      		cpc r19,r27
 1171 04de 01F4      		brne .L86
 1172 04e0 2181      		ldd r18,Z+1
 1173 04e2 2417      		cp r18,r20
 1174 04e4 01F4      		brne .L86
 319:rowSegBuffer.c **** 			return stretchSeg(length);
 1175               		.stabn	68,0,319,.LM117-.LFBB10
 1176               	.LM117:
 1177 04e6 00D0      		rcall stretchSeg
 1178 04e8 0895      		ret
 1179               	.L86:
 321:rowSegBuffer.c **** 		return newSeg(length, red, green_blue);
 1180               		.stabn	68,0,321,.LM118-.LFBB10
 1181               	.LM118:
 1182 04ea 00D0      		rcall newSeg
 323:rowSegBuffer.c **** }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 114


 1183               		.stabn	68,0,323,.LM119-.LFBB10
 1184               	.LM119:
 1185 04ec 0895      		ret
 1186               		.size	addSeg, .-addSeg
 1187               	.Lscope10:
 1188               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 1189               		.stabd	78,0,0
 1190               		.stabs	"rbpix_to_seg:F(0,15)",36,0,205,rbpix_to_seg
 1191               		.stabs	"rbValue:P(3,2)",64,0,205,17
 1192               		.stabs	"col:P(3,2)",64,0,205,22
 1193               		.stabs	"length:P(3,2)",64,0,205,24
 1194               	.global	rbpix_to_seg
 1195               		.type	rbpix_to_seg, @function
 1196               	rbpix_to_seg:
 1197               		.stabd	46,0,0
 206:rowSegBuffer.c **** {
 1198               		.stabn	68,0,206,.LM120-.LFBB11
 1199               	.LM120:
 1200               	.LFBB11:
 1201 04ee 1F93      		push r17
 1202               	/* prologue: function */
 1203               	/* frame size = 0 */
 1204 04f0 182F      		mov r17,r24
 1205 04f2 842F      		mov r24,r20
 210:rowSegBuffer.c **** 	if(col == 0)
 1206               		.stabn	68,0,210,.LM121-.LFBB11
 1207               	.LM121:
 1208 04f4 6623      		tst r22
 1209 04f6 01F4      		brne .L89
 212:rowSegBuffer.c **** 		last_rbValue = 0;
 1210               		.stabn	68,0,212,.LM122-.LFBB11
 1211               	.LM122:
 1212 04f8 1092 0000 		sts last_rbValue.2025,__zero_reg__
 1213               	.LBB90:
 1214               	.LBB91:
 159:rowSegBuffer.c **** 	segPosition = 0;
 1215               		.stabn	68,0,159,.LM123-.LFBB11
 1216               	.LM123:
 1217 04fc 1092 0000 		sts segPosition,__zero_reg__
 162:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 1218               		.stabn	68,0,162,.LM124-.LFBB11
 1219               	.LM124:
 1220 0500 96E0      		ldi r25,lo8(6)
 1221 0502 9093 0000 		sts rowSegBuffer,r25
 163:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 1222               		.stabn	68,0,163,.LM125-.LFBB11
 1223               	.LM125:
 1224 0506 93E6      		ldi r25,lo8(99)
 1225 0508 9093 0000 		sts rowSegBuffer+1,r25
 1226 050c 00C0      		rjmp .L90
 1227               	.L89:
 1228               	.LBE91:
 1229               	.LBE90:
 216:rowSegBuffer.c **** 	else if(segPosition && (rbValue == last_rbValue))
 1230               		.stabn	68,0,216,.LM126-.LFBB11
 1231               	.LM126:
 1232 050e 9091 0000 		lds r25,segPosition
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 115


 1233 0512 9923      		tst r25
 1234 0514 01F0      		breq .L90
 1235 0516 9091 0000 		lds r25,last_rbValue.2025
 1236 051a 1917      		cp r17,r25
 1237 051c 01F4      		brne .L90
 218:rowSegBuffer.c **** 		stretchSeg(length);
 1238               		.stabn	68,0,218,.LM127-.LFBB11
 1239               	.LM127:
 1240 051e 90E0      		ldi r25,lo8(0)
 1241 0520 00D0      		rcall stretchSeg
 219:rowSegBuffer.c **** 		return;
 1242               		.stabn	68,0,219,.LM128-.LFBB11
 1243               	.LM128:
 1244 0522 00C0      		rjmp .L92
 1245               	.L90:
 226:rowSegBuffer.c **** 	newSeg(length, red, (blue<<4) | green);
 1246               		.stabn	68,0,226,.LM129-.LFBB11
 1247               	.LM129:
 1248 0524 612F      		mov r22,r17
 1249 0526 70E0      		ldi r23,lo8(0)
 1250 0528 6C71      		andi r22,lo8(28)
 1251 052a 7070      		andi r23,hi8(28)
 1252 052c 7595      		asr r23
 1253 052e 6795      		ror r22
 1254 0530 7595      		asr r23
 1255 0532 6795      		ror r22
 1256 0534 212F      		mov r18,r17
 1257 0536 2295      		swap r18
 1258 0538 2695      		lsr r18
 1259 053a 2770      		andi r18,lo8(7)
 1260 053c 2295      		swap r18
 1261 053e 207F      		andi r18,lo8(-16)
 1262 0540 912F      		mov r25,r17
 1263 0542 9370      		andi r25,lo8(3)
 1264 0544 292B      		or r18,r25
 1265 0546 90E0      		ldi r25,lo8(0)
 1266 0548 422F      		mov r20,r18
 1267 054a 00D0      		rcall newSeg
 228:rowSegBuffer.c **** 	last_rbValue = rbValue;
 1268               		.stabn	68,0,228,.LM130-.LFBB11
 1269               	.LM130:
 1270 054c 1093 0000 		sts last_rbValue.2025,r17
 1271               	.L92:
 1272               	/* epilogue start */
 229:rowSegBuffer.c **** }
 1273               		.stabn	68,0,229,.LM131-.LFBB11
 1274               	.LM131:
 1275 0550 1F91      		pop r17
 1276 0552 0895      		ret
 1277               		.size	rbpix_to_seg, .-rbpix_to_seg
 1278               		.stabs	"last_rbValue:V(3,2)",38,0,207,last_rbValue.2025
 1279               		.stabn	192,0,0,.LFBB11-.LFBB11
 1280               		.stabn	224,0,0,.Lscope11-.LFBB11
 1281               	.Lscope11:
 1282               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 1283               		.stabd	78,0,0
 1284               		.stabs	"fb_to_rb:F(3,2)",36,0,85,fb_to_rb
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 116


 1285               		.stabs	"fbColor:P(3,2)",64,0,85,24
 1286               	.global	fb_to_rb
 1287               		.type	fb_to_rb, @function
 1288               	fb_to_rb:
 1289               		.stabd	46,0,0
 1290               		.stabs	"rowBuffer.c",132,0,0,.Ltext5
 1291               	.Ltext5:
   1:rowBuffer.c   **** // RowBuffer
   2:rowBuffer.c   **** //    An entire row is calculated and stored in the rowbuffer
   3:rowBuffer.c   **** //    before each line is displayed.
   4:rowBuffer.c   **** //    (There is not nearly enough memory for an entire frameBuffer)
   5:rowBuffer.c   **** //
   6:rowBuffer.c   **** //    A single byte is used for each drawable pixel in the row
   7:rowBuffer.c   **** //    this byte is actually a bit-mask of the OCR/DT values
   8:rowBuffer.c   **** //    so it's more of a settings-buffer
   9:rowBuffer.c   **** //    
  10:rowBuffer.c   **** //    Processing each byte and writing registers takes 14 clock cycles
  11:rowBuffer.c   **** //     so at full-speed LVDS (1 pixel per 7/8ths clock cycle)
  12:rowBuffer.c   **** //     then each drawable pixel is 16 LCD pixels wide
  13:rowBuffer.c   **** //     for a maximum resolution of 64 drawable pixels across
  14:rowBuffer.c   **** //     (thus, the row-settings-buffer is 64Bytes)
  15:rowBuffer.c   **** //    (Were the bytes not packed, and we used three bytes per drawable
  16:rowBuffer.c   **** //     pixel, each readFromSRAM*3+loadToRegister*3 pixel would be 
  17:rowBuffer.c   **** //     9 cycles... for ~100 pixels and ~300Bytes. Would it really be worth
  18:rowBuffer.c   **** //     3 times the memory for 1/3 more pixels? Probably not...
  19:rowBuffer.c   **** //     See RowSegmentBuffer for higher resolution...)
  20:rowBuffer.c   **** //
  21:rowBuffer.c   **** //   Red: (+OC1D => RX0+)
  22:rowBuffer.c   **** //    Off (0/63): OCR1D = 0
  23:rowBuffer.c   **** //    35/63:      OCR1D = 3
  24:rowBuffer.c   **** //    51/63:      OCR1D = 4   (FOUR_SHADES only)
  25:rowBuffer.c   **** //    63/63:      OCR1D >= 6
  26:rowBuffer.c   **** //   Green: (/OC1B => RX1-)          (B1,0 Active, as well as G2,1)
  27:rowBuffer.c   **** //    Off (6/63): DTL1 = 0
  28:rowBuffer.c   **** //    38-39/63:      DTL1 = 1
  29:rowBuffer.c   **** //    54-55/63:      DTL1 = 2 (FOUR_SHADES only)
  30:rowBuffer.c   **** //    62-63/63:      DTL1 = 3
  31:rowBuffer.c   **** //   Blue: (+OC1A => RX2+)               (B3,2 Active from here down)
  32:rowBuffer.c   **** //    Off (15/63):  OCR1A=4
  33:rowBuffer.c   **** //    47/63:        OCR1A=5
  34:rowBuffer.c   **** //    63/63:        OCR1A=6
  35:rowBuffer.c   **** //
  36:rowBuffer.c   **** //  For faster pixels: these values could be stored in a settingsBuffer
  37:rowBuffer.c   **** //  (instead of a frame-buffer based on color values)
  38:rowBuffer.c   **** //  we have: 
  39:rowBuffer.c   **** //                             0    1    2    3
  40:rowBuffer.c   **** //                 ColorVal:  00   01   10   11
  41:rowBuffer.c   **** //     Red (OCR1D): 0,3,4,6  000, 011, 100, 110
  42:rowBuffer.c   **** //   Green (DTL1):  0,1,2,3  000, 001, 010, 011
  43:rowBuffer.c   **** //    Blue (OCR1A): 4,5,6    100, 101, 110, 110
  44:rowBuffer.c   **** //           (I guess it could be noted that Blue's bit2 is always 1)
  45:rowBuffer.c   **** //           (also: OCR1A = 7 is totally acceptable, 
  46:rowBuffer.c   **** //                  so blueOCR=0x4|blueColor)
  47:rowBuffer.c   **** //           ( Similar can be said for Red... 7 is acceptable)
  48:rowBuffer.c   **** //  For memory space, we could fit these values directly in a single byte
  49:rowBuffer.c   **** //    Red Mask: 0x07
  50:rowBuffer.c   **** //  Green Mask: 0x14
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 117


  51:rowBuffer.c   **** //   Blue Mask: 0x60
  52:rowBuffer.c   **** //
  53:rowBuffer.c   **** //  Options: mask and shift, no extra memory
  54:rowBuffer.c   **** //           andi for red
  55:rowBuffer.c   **** //           andi for green + 3 shifts
  56:rowBuffer.c   **** //           5 shifts for blue
  57:rowBuffer.c   **** //           ... 10 cycles (12 pixels)
  58:rowBuffer.c   **** //           If green is the low two bits:
  59:rowBuffer.c   **** //           andi for green
  60:rowBuffer.c   **** //           andi for red + 2 shifts
  61:rowBuffer.c   **** //           5 shifts for blue
  62:rowBuffer.c   **** //           ... 9 cycles (11 pixels)
  63:rowBuffer.c   **** //          + 3 register writes (3 cycles) = 12cycles
  64:rowBuffer.c   **** //          + 1 SRAM read (2 cycles) = 14 cycles (16 pixels)
  65:rowBuffer.c   **** //           ALSO: 5 shifts TOTAL, usable?
  66:rowBuffer.c   **** //         (This may be outdated... and doesn't take into account
  67:rowBuffer.c   **** //          mov instructions... so see the code instead of believing this)
  68:rowBuffer.c   **** //         BUT:
  69:rowBuffer.c   **** //          64 pixels across * 64 pixels down is 4096 bytes
  70:rowBuffer.c   **** //          WAY more than my RAM
  71:rowBuffer.c   **** //          So either way we need to precalculate each row before
  72:rowBuffer.c   **** //          displaying it
  73:rowBuffer.c   **** //          Could be as simple as loading direct from program memory
  74:rowBuffer.c   **** 
  75:rowBuffer.c   **** 
  76:rowBuffer.c   **** 
  77:rowBuffer.c   **** #define LOADROW	TRUE
  78:rowBuffer.c   **** 
  79:rowBuffer.c   **** #define RB_WIDTH 64 //100
  80:rowBuffer.c   **** #define RB_HEIGHT 48
  81:rowBuffer.c   **** uint8_t rowBuffer[RB_WIDTH];
  82:rowBuffer.c   **** 
  83:rowBuffer.c   **** 
  84:rowBuffer.c   **** //Convert from a frameBuffer color to a rowBuffer setting value...
  85:rowBuffer.c   **** uint8_t fb_to_rb(uint8_t fbColor)
  86:rowBuffer.c   **** {
 1292               		.stabn	68,0,86,.LM132-.LFBB12
 1293               	.LM132:
 1294               	.LFBB12:
 1295               	/* prologue: function */
 1296               	/* frame size = 0 */
  87:rowBuffer.c   ****    uint8_t rb = 0;
  88:rowBuffer.c   **** 
  89:rowBuffer.c   ****    //rb bit: 7 6 5 4 3 2 1 0
  90:rowBuffer.c   ****    //        \_ _/ \_ _/ \ /
  91:rowBuffer.c   ****    //          V     V    V
  92:rowBuffer.c   ****    //          |     |    Green Setting
  93:rowBuffer.c   ****    //          |     Red Setting
  94:rowBuffer.c   ****    //          Blue Setting
  95:rowBuffer.c   **** 
  96:rowBuffer.c   ****    // Frame Buffer color/shade values:
  97:rowBuffer.c   ****    //fb bit: 7 6 5 4 3 2 1 0
  98:rowBuffer.c   ****    //        \ / \ / \ / \ /
  99:rowBuffer.c   ****    //         V   V   V   V
 100:rowBuffer.c   ****    //         |   |   |   Red Value (0-3)
 101:rowBuffer.c   ****    //         |   |   Green Value (0-3)
 102:rowBuffer.c   ****    //         |   Blue Value (0-3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 118


 103:rowBuffer.c   ****    //         Alpha... only partially implemented
 104:rowBuffer.c   **** 
 105:rowBuffer.c   **** #warning "This isn't at all optimized..."
 106:rowBuffer.c   ****    // Blue setting = Blue Value | 0x04
 107:rowBuffer.c   ****    uint8_t blueValue = (fbColor & 0x30) >> 4;
 1297               		.stabn	68,0,107,.LM133-.LFBB12
 1298               	.LM133:
 1299 0554 682F      		mov r22,r24
 1300 0556 70E0      		ldi r23,lo8(0)
 108:rowBuffer.c   ****    rb = (blueValue << 5) | 0x80;
 109:rowBuffer.c   **** 
 110:rowBuffer.c   ****    // Red setting = redVal << 1 | redVal & 0x01
 111:rowBuffer.c   ****    uint8_t redValue = (fbColor & 0x03);
 112:rowBuffer.c   ****    rb |= ((redValue << 1) | (redValue & 0x01)) << 2;
 1301               		.stabn	68,0,112,.LM134-.LFBB12
 1302               	.LM134:
 1303 0558 8370      		andi r24,lo8(3)
 1304 055a 90E0      		ldi r25,lo8(0)
 1305 055c 9C01      		movw r18,r24
 1306 055e 2170      		andi r18,lo8(1)
 1307 0560 3070      		andi r19,hi8(1)
 1308 0562 880F      		lsl r24
 1309 0564 991F      		rol r25
 1310 0566 282B      		or r18,r24
 1311 0568 392B      		or r19,r25
 1312 056a 220F      		lsl r18
 1313 056c 331F      		rol r19
 1314 056e 220F      		lsl r18
 1315 0570 331F      		rol r19
 1316 0572 2068      		ori r18,lo8(-128)
 1317 0574 AB01      		movw r20,r22
 1318 0576 4073      		andi r20,lo8(48)
 1319 0578 5070      		andi r21,hi8(48)
 1320 057a 440F      		lsl r20
 1321 057c 551F      		rol r21
 1322 057e 242B      		or r18,r20
 1323 0580 CB01      		movw r24,r22
 1324 0582 8C70      		andi r24,lo8(12)
 1325 0584 9070      		andi r25,hi8(12)
 1326 0586 9595      		asr r25
 1327 0588 8795      		ror r24
 1328 058a 9595      		asr r25
 1329 058c 8795      		ror r24
 113:rowBuffer.c   **** 
 114:rowBuffer.c   ****    // Green Setting = Green Value...
 115:rowBuffer.c   ****    uint8_t greenValue = (fbColor & 0x0C) >> 2;
 116:rowBuffer.c   ****    rb |= greenValue;
 117:rowBuffer.c   **** 
 118:rowBuffer.c   ****    return rb;
 119:rowBuffer.c   **** }
 1330               		.stabn	68,0,119,.LM135-.LFBB12
 1331               	.LM135:
 1332 058e 822B      		or r24,r18
 1333               	/* epilogue start */
 1334 0590 0895      		ret
 1335               		.size	fb_to_rb, .-fb_to_rb
 1336               		.stabs	"rb:r(3,2)",64,0,87,18
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 119


 1337               		.stabn	192,0,0,.LFBB12-.LFBB12
 1338               		.stabn	224,0,0,.Lscope12-.LFBB12
 1339               	.Lscope12:
 1340               		.stabs	"",36,0,0,.Lscope12-.LFBB12
 1341               		.stabd	78,0,0
 1342               		.stabs	"grabDecimal_u32:F(3,1)",36,0,104,grabDecimal_u32
 1343               		.stabs	"value:P(3,6)",64,0,104,22
 1344               		.stabs	"newVal:P(3,2)",64,0,104,20
 1345               	.global	grabDecimal_u32
 1346               		.type	grabDecimal_u32, @function
 1347               	grabDecimal_u32:
 1348               		.stabd	46,0,0
 1349               		.stabs	"main.c",132,0,0,.Ltext6
 1350               	.Ltext6:
 105:main.c        **** {
 1351               		.stabn	68,0,105,.LM136-.LFBB13
 1352               	.LM136:
 1353               	.LFBB13:
 1354 0592 4F92      		push r4
 1355 0594 5F92      		push r5
 1356 0596 6F92      		push r6
 1357 0598 7F92      		push r7
 1358 059a 8F92      		push r8
 1359 059c 9F92      		push r9
 1360 059e AF92      		push r10
 1361 05a0 BF92      		push r11
 1362 05a2 CF92      		push r12
 1363 05a4 DF92      		push r13
 1364 05a6 EF92      		push r14
 1365 05a8 FF92      		push r15
 1366 05aa 1F93      		push r17
 1367               	/* prologue: function */
 1368               	/* frame size = 0 */
 110:main.c        ****    if(newVal)
 1369               		.stabn	68,0,110,.LM137-.LFBB13
 1370               	.LM137:
 1371 05ac 4423      		tst r20
 1372 05ae 01F0      		breq .L96
 112:main.c        ****       divisor = 1000000000;
 1373               		.stabn	68,0,112,.LM138-.LFBB13
 1374               	.LM138:
 1375 05b0 20E0      		ldi r18,lo8(1000000000)
 1376 05b2 3AEC      		ldi r19,hi8(1000000000)
 1377 05b4 4AE9      		ldi r20,hlo8(1000000000)
 1378 05b6 5BE3      		ldi r21,hhi8(1000000000)
 1379 05b8 2093 0000 		sts divisor.2177,r18
 1380 05bc 3093 0000 		sts (divisor.2177)+1,r19
 1381 05c0 4093 0000 		sts (divisor.2177)+2,r20
 1382 05c4 5093 0000 		sts (divisor.2177)+3,r21
 113:main.c        ****       thisVal = value;
 1383               		.stabn	68,0,113,.LM139-.LFBB13
 1384               	.LM139:
 1385 05c8 6093 0000 		sts thisVal.2178,r22
 1386 05cc 7093 0000 		sts (thisVal.2178)+1,r23
 1387 05d0 8093 0000 		sts (thisVal.2178)+2,r24
 1388 05d4 9093 0000 		sts (thisVal.2178)+3,r25
 1389               	.L96:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 120


 120:main.c        ****    if(divisor == 0)
 1390               		.stabn	68,0,120,.LM140-.LFBB13
 1391               	.LM140:
 1392 05d8 6091 0000 		lds r22,divisor.2177
 1393 05dc 7091 0000 		lds r23,(divisor.2177)+1
 1394 05e0 8091 0000 		lds r24,(divisor.2177)+2
 1395 05e4 9091 0000 		lds r25,(divisor.2177)+3
 1396 05e8 6115      		cp r22,__zero_reg__
 1397 05ea 7105      		cpc r23,__zero_reg__
 1398 05ec 8105      		cpc r24,__zero_reg__
 1399 05ee 9105      		cpc r25,__zero_reg__
 1400 05f0 01F4      		brne .L97
 1401 05f2 8FEF      		ldi r24,lo8(-1)
 1402 05f4 00C0      		rjmp .L98
 1403               	.L97:
 1404 05f6 2091 0000 		lds r18,thisVal.2178
 1405 05fa 3091 0000 		lds r19,(thisVal.2178)+1
 1406 05fe 4091 0000 		lds r20,(thisVal.2178)+2
 1407 0602 5091 0000 		lds r21,(thisVal.2178)+3
 104:main.c        **** int8_t grabDecimal_u32(uint32_t value, uint8_t newVal)
 1408               		.stabn	68,0,104,.LM141-.LFBB13
 1409               	.LM141:
 1410 0606 8824      		clr r8
 1411 0608 9924      		clr r9
 1412 060a 5401      		movw r10,r8
 1413 060c 861A      		sub r8,r22
 1414 060e 970A      		sbc r9,r23
 1415 0610 A80A      		sbc r10,r24
 1416 0612 B90A      		sbc r11,r25
 1417 0614 10E0      		ldi r17,lo8(0)
 1418 0616 00C0      		rjmp .L99
 1419               	.L100:
 125:main.c        ****       decimal++;
 1420               		.stabn	68,0,125,.LM142-.LFBB13
 1421               	.LM142:
 1422 0618 1F5F      		subi r17,lo8(-(1))
 1423 061a A701      		movw r20,r14
 1424 061c 9601      		movw r18,r12
 1425               	.L99:
 1426 061e 6901      		movw r12,r18
 1427 0620 7A01      		movw r14,r20
 1428 0622 C80C      		add r12,r8
 1429 0624 D91C      		adc r13,r9
 1430 0626 EA1C      		adc r14,r10
 1431 0628 FB1C      		adc r15,r11
 123:main.c        ****    while(thisVal >= divisor)
 1432               		.stabn	68,0,123,.LM143-.LFBB13
 1433               	.LM143:
 1434 062a 2601      		movw r4,r12
 1435 062c 3701      		movw r6,r14
 1436 062e 460E      		add r4,r22
 1437 0630 571E      		adc r5,r23
 1438 0632 681E      		adc r6,r24
 1439 0634 791E      		adc r7,r25
 1440 0636 4616      		cp r4,r22
 1441 0638 5706      		cpc r5,r23
 1442 063a 6806      		cpc r6,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 121


 1443 063c 7906      		cpc r7,r25
 1444 063e 00F4      		brsh .L100
 1445 0640 2093 0000 		sts thisVal.2178,r18
 1446 0644 3093 0000 		sts (thisVal.2178)+1,r19
 1447 0648 4093 0000 		sts (thisVal.2178)+2,r20
 1448 064c 5093 0000 		sts (thisVal.2178)+3,r21
 133:main.c        ****    divisor /= 10;
 1449               		.stabn	68,0,133,.LM144-.LFBB13
 1450               	.LM144:
 1451 0650 2AE0      		ldi r18,lo8(10)
 1452 0652 30E0      		ldi r19,hi8(10)
 1453 0654 40E0      		ldi r20,hlo8(10)
 1454 0656 50E0      		ldi r21,hhi8(10)
 1455 0658 00D0      		rcall __udivmodsi4
 1456 065a 2093 0000 		sts divisor.2177,r18
 1457 065e 3093 0000 		sts (divisor.2177)+1,r19
 1458 0662 4093 0000 		sts (divisor.2177)+2,r20
 1459 0666 5093 0000 		sts (divisor.2177)+3,r21
 135:main.c        ****    return decimal;
 1460               		.stabn	68,0,135,.LM145-.LFBB13
 1461               	.LM145:
 1462 066a 812F      		mov r24,r17
 1463               	.L98:
 1464               	/* epilogue start */
 136:main.c        **** }
 1465               		.stabn	68,0,136,.LM146-.LFBB13
 1466               	.LM146:
 1467 066c 1F91      		pop r17
 1468 066e FF90      		pop r15
 1469 0670 EF90      		pop r14
 1470 0672 DF90      		pop r13
 1471 0674 CF90      		pop r12
 1472 0676 BF90      		pop r11
 1473 0678 AF90      		pop r10
 1474 067a 9F90      		pop r9
 1475 067c 8F90      		pop r8
 1476 067e 7F90      		pop r7
 1477 0680 6F90      		pop r6
 1478 0682 5F90      		pop r5
 1479 0684 4F90      		pop r4
 1480 0686 0895      		ret
 1481               		.size	grabDecimal_u32, .-grabDecimal_u32
 1482               		.stabs	"divisor:V(3,6)",38,0,106,divisor.2177
 1483               		.stabs	"thisVal:V(3,6)",40,0,108,thisVal.2178
 1484               		.stabs	"decimal:r(3,2)",64,0,116,17
 1485               		.stabn	192,0,0,.LFBB13-.LFBB13
 1486               		.stabn	224,0,0,.Lscope13-.LFBB13
 1487               	.Lscope13:
 1488               		.stabs	"",36,0,0,.Lscope13-.LFBB13
 1489               		.stabd	78,0,0
 1490               		.stabs	"showScore:F(0,15)",36,0,143,showScore
 1491               		.stabs	"rowNum:P(3,4)",64,0,143,28
 1492               		.stabs	"score:P(3,6)",64,0,143,20
 1493               		.stabs	"color:P(3,2)",64,0,143,16
 1494               	.global	showScore
 1495               		.type	showScore, @function
 1496               	showScore:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 122


 1497               		.stabd	46,0,0
 144:main.c        **** {
 1498               		.stabn	68,0,144,.LM147-.LFBB14
 1499               	.LM147:
 1500               	.LFBB14:
 1501 0688 4F92      		push r4
 1502 068a 5F92      		push r5
 1503 068c 6F92      		push r6
 1504 068e 7F92      		push r7
 1505 0690 9F92      		push r9
 1506 0692 AF92      		push r10
 1507 0694 BF92      		push r11
 1508 0696 CF92      		push r12
 1509 0698 DF92      		push r13
 1510 069a EF92      		push r14
 1511 069c FF92      		push r15
 1512 069e 0F93      		push r16
 1513 06a0 1F93      		push r17
 1514 06a2 CF93      		push r28
 1515 06a4 DF93      		push r29
 1516               	/* prologue: function */
 1517               	/* frame size = 0 */
 1518 06a6 EC01      		movw r28,r24
 1519 06a8 022F      		mov r16,r18
 153:main.c        **** 		if(rowNum == 0)
 1520               		.stabn	68,0,153,.LM148-.LFBB14
 1521               	.LM148:
 1522 06aa 0097      		sbiw r24,0
 1523 06ac 01F4      		brne .L103
 154:main.c        **** 			thisScore = score; // goodCount;
 1524               		.stabn	68,0,154,.LM149-.LFBB14
 1525               	.LM149:
 1526 06ae 4093 0000 		sts thisScore.2199,r20
 1527 06b2 5093 0000 		sts (thisScore.2199)+1,r21
 1528 06b6 6093 0000 		sts (thisScore.2199)+2,r22
 1529 06ba 7093 0000 		sts (thisScore.2199)+3,r23
 1530               	.L103:
 156:main.c        **** 		decimal = grabDecimal_u32(thisScore, 1);
 1531               		.stabn	68,0,156,.LM150-.LFBB14
 1532               	.LM150:
 1533 06be C090 0000 		lds r12,thisScore.2199
 1534 06c2 D090 0000 		lds r13,(thisScore.2199)+1
 1535 06c6 E090 0000 		lds r14,(thisScore.2199)+2
 1536 06ca F090 0000 		lds r15,(thisScore.2199)+3
 1537 06ce C701      		movw r24,r14
 1538 06d0 B601      		movw r22,r12
 1539 06d2 41E0      		ldi r20,lo8(1)
 1540 06d4 00D0      		rcall grabDecimal_u32
 1541 06d6 182F      		mov r17,r24
 1542               	.LBB92:
 174:main.c        **** 					charRow = getCharRow(decimal+'0', rowNum/2);
 1543               		.stabn	68,0,174,.LM151-.LFBB14
 1544               	.LM151:
 1545 06d8 CE01      		movw r24,r28
 1546 06da 9695      		lsr r25
 1547 06dc 8795      		ror r24
 1548 06de 6FE5      		ldi r22,lo8(95)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 123


 1549 06e0 70E0      		ldi r23,hi8(95)
 1550 06e2 00D0      		rcall __mulhi3
 1551 06e4 E0EE      		ldi r30,lo8(-32)
 1552 06e6 4E2E      		mov r4,r30
 1553 06e8 EFEF      		ldi r30,hi8(-32)
 1554 06ea 5E2E      		mov r5,r30
 1555 06ec 480E      		add r4,r24
 1556 06ee 591E      		adc r5,r25
 1557               	.LBE92:
 179:main.c        **** 				addSegfb(1,color);
 1558               		.stabn	68,0,179,.LM152-.LFBB14
 1559               	.LM152:
 1560 06f0 802F      		mov r24,r16
 1561 06f2 90E0      		ldi r25,lo8(0)
 1562 06f4 9C01      		movw r18,r24
 1563 06f6 2370      		andi r18,lo8(3)
 1564 06f8 3070      		andi r19,hi8(3)
 1565 06fa 220F      		lsl r18
 1566 06fc 331F      		rol r19
 1567 06fe AA24      		clr r10
 1568 0700 A394      		inc r10
 1569 0702 A022      		and r10,r16
 1570 0704 A22A      		or r10,r18
 1571 0706 0073      		andi r16,lo8(48)
 1572 0708 0064      		ori r16,lo8(64)
 1573 070a 8C70      		andi r24,lo8(12)
 1574 070c 9070      		andi r25,hi8(12)
 1575 070e 9595      		asr r25
 1576 0710 8795      		ror r24
 1577 0712 9595      		asr r25
 1578 0714 8795      		ror r24
 1579 0716 082B      		or r16,r24
 1580 0718 C0E0      		ldi r28,lo8(0)
 1581 071a D0E0      		ldi r29,hi8(0)
 1582 071c BB24      		clr r11
 1583 071e 9924      		clr r9
 1584               	.L110:
 166:main.c        **** 			if(col%8==0)
 1585               		.stabn	68,0,166,.LM153-.LFBB14
 1586               	.LM153:
 1587 0720 57E0      		ldi r21,lo8(7)
 1588 0722 652E      		mov r6,r21
 1589 0724 712C      		mov r7,__zero_reg__
 1590 0726 6C22      		and r6,r28
 1591 0728 7D22      		and r7,r29
 1592 072a 6114      		cp r6,__zero_reg__
 1593 072c 7104      		cpc r7,__zero_reg__
 1594 072e 01F4      		brne .L104
 168:main.c        **** 				if((decimal != 0) && (decimal != -1))
 1595               		.stabn	68,0,168,.LM154-.LFBB14
 1596               	.LM154:
 1597 0730 812F      		mov r24,r17
 1598 0732 8F5F      		subi r24,lo8(-(1))
 1599 0734 8230      		cpi r24,lo8(2)
 1600 0736 00F4      		brsh .L105
 171:main.c        **** 				if((decimal == -1) || (!scoreFound))
 1601               		.stabn	68,0,171,.LM155-.LFBB14
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 124


 1602               	.LM155:
 1603 0738 1F3F      		cpi r17,lo8(-1)
 1604 073a 01F0      		breq .L106
 1605 073c 9920      		tst r9
 1606 073e 01F0      		breq .L106
 1607               	.L105:
 1608               	.LBB93:
 174:main.c        **** 					charRow = getCharRow(decimal+'0', rowNum/2);
 1609               		.stabn	68,0,174,.LM156-.LFBB14
 1610               	.LM156:
 1611 0740 105D      		subi r17,lo8(-(48))
 1612 0742 F201      		movw r30,r4
 1613 0744 E10F      		add r30,r17
 1614 0746 F11D      		adc r31,__zero_reg__
 1615 0748 E050      		subi r30,lo8(-(characters))
 1616 074a F040      		sbci r31,hi8(-(characters))
 1617               	/* #APP */
 1618               	 ;  174 "main.c" 1
 1619 074c B490      		lpm r11, Z
 1620               		
 1621               	 ;  0 "" 2
 1622               	/* #NOAPP */
 1623 074e 9924      		clr r9
 1624 0750 9394      		inc r9
 1625 0752 00C0      		rjmp .L107
 1626               	.L106:
 1627 0754 BB24      		clr r11
 1628               	.L107:
 1629               	.LBE93:
 175:main.c        **** 				decimal = grabDecimal_u32(thisScore, 0);
 1630               		.stabn	68,0,175,.LM157-.LFBB14
 1631               	.LM157:
 1632 0756 C701      		movw r24,r14
 1633 0758 B601      		movw r22,r12
 1634 075a 40E0      		ldi r20,lo8(0)
 1635 075c 00D0      		rcall grabDecimal_u32
 1636 075e 182F      		mov r17,r24
 1637               	.L104:
 178:main.c        **** 			if(getbit(col%8, charRow))
 1638               		.stabn	68,0,178,.LM158-.LFBB14
 1639               	.LM158:
 1640 0760 8B2D      		mov r24,r11
 1641 0762 90E0      		ldi r25,lo8(0)
 1642 0764 00C0      		rjmp 2f
 1643 0766 9595      	1:	asr r25
 1644 0768 8795      		ror r24
 1645 076a 6A94      	2:	dec r6
 1646 076c 02F4      		brpl 1b
 1647 076e 80FF      		sbrs r24,0
 1648 0770 00C0      		rjmp .L108
 179:main.c        **** 				addSegfb(1,color);
 1649               		.stabn	68,0,179,.LM159-.LFBB14
 1650               	.LM159:
 1651 0772 81E0      		ldi r24,lo8(1)
 1652 0774 90E0      		ldi r25,hi8(1)
 1653 0776 6A2D      		mov r22,r10
 1654 0778 402F      		mov r20,r16
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 125


 1655 077a 00C0      		rjmp .L113
 1656               	.L108:
 181:main.c        **** 				addSegfb(1,_B);
 1657               		.stabn	68,0,181,.LM160-.LFBB14
 1658               	.LM160:
 1659 077c 81E0      		ldi r24,lo8(1)
 1660 077e 90E0      		ldi r25,hi8(1)
 1661 0780 60E0      		ldi r22,lo8(0)
 1662 0782 40E7      		ldi r20,lo8(112)
 1663               	.L113:
 1664 0784 00D0      		rcall addSeg
 1665 0786 2196      		adiw r28,1
 162:main.c        **** 		for(col=0; col<NUM_PSEGS-3-RACE_WIDTH_PSEGS; col++)
 1666               		.stabn	68,0,162,.LM161-.LFBB14
 1667               	.LM161:
 1668 0788 C235      		cpi r28,82
 1669 078a D105      		cpc r29,__zero_reg__
 1670 078c 01F4      		brne .L110
 1671               	/* epilogue start */
 183:main.c        **** }	
 1672               		.stabn	68,0,183,.LM162-.LFBB14
 1673               	.LM162:
 1674 078e DF91      		pop r29
 1675 0790 CF91      		pop r28
 1676 0792 1F91      		pop r17
 1677 0794 0F91      		pop r16
 1678 0796 FF90      		pop r15
 1679 0798 EF90      		pop r14
 1680 079a DF90      		pop r13
 1681 079c CF90      		pop r12
 1682 079e BF90      		pop r11
 1683 07a0 AF90      		pop r10
 1684 07a2 9F90      		pop r9
 1685 07a4 7F90      		pop r7
 1686 07a6 6F90      		pop r6
 1687 07a8 5F90      		pop r5
 1688 07aa 4F90      		pop r4
 1689 07ac 0895      		ret
 1690               		.size	showScore, .-showScore
 1691               		.stabs	"decimal:r(3,1)",64,0,148,17
 1692               		.stabs	"scoreFound:r(3,2)",64,0,149,9
 1693               		.stabs	"thisScore:V(3,6)",40,0,151,thisScore.2199
 1694               		.stabs	"charRow:r(3,2)",64,0,160,11
 1695               		.stabn	192,0,0,.LFBB14-.LFBB14
 1696               		.stabn	224,0,0,.Lscope14-.LFBB14
 1697               	.Lscope14:
 1698               		.stabs	"",36,0,0,.Lscope14-.LFBB14
 1699               		.stabd	78,0,0
 1700               		.stabs	"pll_enable:F(0,15)",36,0,1219,pll_enable
 1701               	.global	pll_enable
 1702               		.type	pll_enable, @function
 1703               	pll_enable:
 1704               		.stabd	46,0,0
1220:main.c        **** {
 1705               		.stabn	68,0,1220,.LM163-.LFBB15
 1706               	.LM163:
 1707               	.LFBB15:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 126


 1708               	/* prologue: function */
 1709               	/* frame size = 0 */
1230:main.c        ****    setbit(PLLE, PLLCSR);
 1710               		.stabn	68,0,1230,.LM164-.LFBB15
 1711               	.LM164:
 1712 07ae 89B5      		in r24,73-0x20
 1713 07b0 8260      		ori r24,lo8(2)
 1714 07b2 89BD      		out 73-0x20,r24
 1715               	.LBB94:
 1716               	.LBB95:
 1717               	.LBB96:
 1718               	.LBB97:
 1719               	.LBB98:
 1720               	.LBB99:
 1721               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext7
 1722               	.Ltext7:
   1:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 127


  42:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 128


  99:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 1723               		.stabn	68,0,105,.LM165-.LFBB15
 1724               	.LM165:
 1725 07b4 88EC      		ldi r24,lo8(200)
 1726 07b6 90E0      		ldi r25,hi8(200)
 1727               	/* #APP */
 1728               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1729 07b8 0197      		1: sbiw r24,1
 1730 07ba 01F4      		brne 1b
 1731               	 ;  0 "" 2
 1732               	/* #NOAPP */
 1733 07bc 00C0      		rjmp .L115
 1734               	.L116:
 1735               	.LBE99:
 1736               	.LBE98:
 1737               	.LBE97:
 1738               	.LBE96:
 1739               	.LBE95:
 1740               	.LBE94:
 1741               		.stabs	"main.c",132,0,0,.Ltext8
 1742               	.Ltext8:
1238:main.c        ****       asm("nop");
 1743               		.stabn	68,0,1238,.LM166-.LFBB15
 1744               	.LM166:
 1745               	/* #APP */
 1746               	 ;  1238 "main.c" 1
 1747 07be 0000      		nop
 1748               	 ;  0 "" 2
 1749               	/* #NOAPP */
 1750               	.L115:
1236:main.c        ****    while(!getbit(PLOCK, PLLCSR))
 1751               		.stabn	68,0,1236,.LM167-.LFBB15
 1752               	.LM167:
 1753 07c0 09B4      		in __tmp_reg__,73-0x20
 1754 07c2 00FE      		sbrs __tmp_reg__,0
 1755 07c4 00C0      		rjmp .L116
1241:main.c        ****    setbit(PCKE, PLLCSR);
 1756               		.stabn	68,0,1241,.LM168-.LFBB15
 1757               	.LM168:
 1758 07c6 89B5      		in r24,73-0x20
 1759 07c8 8460      		ori r24,lo8(4)
 1760 07ca 89BD      		out 73-0x20,r24
 1761               	/* epilogue start */
1243:main.c        **** }
 1762               		.stabn	68,0,1243,.LM169-.LFBB15
 1763               	.LM169:
 1764 07cc 0895      		ret
 1765               		.size	pll_enable, .-pll_enable
 1766               		.stabs	"__count:r(3,4)",64,0,138,24
 1767               		.stabn	192,0,0,.LBB98-.LFBB15
 1768               		.stabn	224,0,0,.LBE98-.LFBB15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 129


 1769               	.Lscope15:
 1770               		.stabs	"",36,0,0,.Lscope15-.LFBB15
 1771               		.stabd	78,0,0
 1772               		.stabs	"lvds_timerInit:F(0,15)",36,0,1245,lvds_timerInit
 1773               	.global	lvds_timerInit
 1774               		.type	lvds_timerInit, @function
 1775               	lvds_timerInit:
 1776               		.stabd	46,0,0
1246:main.c        **** {
 1777               		.stabn	68,0,1246,.LM170-.LFBB16
 1778               	.LM170:
 1779               	.LFBB16:
 1780               	/* prologue: function */
 1781               	/* frame size = 0 */
1252:main.c        ****    OCR1C = 6;
 1782               		.stabn	68,0,1252,.LM171-.LFBB16
 1783               	.LM171:
 1784 07ce 86E0      		ldi r24,lo8(6)
 1785 07d0 8BBD      		out 75-0x20,r24
1255:main.c        **** 	CLOCK_OCR = 3; //2; //3;
 1786               		.stabn	68,0,1255,.LM172-.LFBB16
 1787               	.LM172:
 1788 07d2 83E0      		ldi r24,lo8(3)
 1789 07d4 8CBD      		out 76-0x20,r24
1287:main.c        ****    OSCCAL = OSCCAL_VAL;
 1790               		.stabn	68,0,1287,.LM173-.LFBB16
 1791               	.LM173:
 1792 07d6 8FEF      		ldi r24,lo8(-1)
 1793 07d8 81BF      		out 81-0x20,r24
1354:main.c        **** 	pll_enable();
 1794               		.stabn	68,0,1354,.LM174-.LFBB16
 1795               	.LM174:
 1796 07da 00D0      		rcall pll_enable
1366:main.c        **** 	writeMasked(CSBITS, 
 1797               		.stabn	68,0,1366,.LM175-.LFBB16
 1798               	.LM175:
 1799 07dc 8FB5      		in r24,79-0x20
 1800 07de 807F      		andi r24,lo8(-16)
 1801 07e0 8460      		ori r24,lo8(4)
 1802 07e2 8FBD      		out 79-0x20,r24
1373:main.c        **** 	writeMasked(DTPSBITS,
 1803               		.stabn	68,0,1373,.LM176-.LFBB16
 1804               	.LM176:
 1805 07e4 8FB5      		in r24,79-0x20
 1806 07e6 8063      		ori r24,lo8(48)
 1807 07e8 8FBD      		out 79-0x20,r24
1385:main.c        **** 	setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
 1808               		.stabn	68,0,1385,.LM177-.LFBB16
 1809               	.LM177:
 1810 07ea 80B7      		in r24,80-0x20
 1811 07ec 8260      		ori r24,lo8(2)
 1812 07ee 80BF      		out 80-0x20,r24
1388:main.c        **** 	setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
 1813               		.stabn	68,0,1388,.LM178-.LFBB16
 1814               	.LM178:
 1815 07f0 80B7      		in r24,80-0x20
 1816 07f2 8160      		ori r24,lo8(1)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 130


 1817 07f4 80BF      		out 80-0x20,r24
1390:main.c        **** 	setbit(PWM1D, TCCR1C);
 1818               		.stabn	68,0,1390,.LM179-.LFBB16
 1819               	.LM179:
 1820 07f6 87B5      		in r24,71-0x20
 1821 07f8 8160      		ori r24,lo8(1)
 1822 07fa 87BD      		out 71-0x20,r24
1394:main.c        **** 	setoutPORT(PB1, PORTB);	//+OC1A, DVH/BLUE, MISO (usually heart)
 1823               		.stabn	68,0,1394,.LM180-.LFBB16
 1824               	.LM180:
 1825 07fc B99A      		sbi 55-0x20,1
1396:main.c        **** 	setoutPORT(PB2, PORTB); //-OC1B, -GREEN	 (INVERTED) SCK
 1826               		.stabn	68,0,1396,.LM181-.LFBB16
 1827               	.LM181:
 1828 07fe BA9A      		sbi 55-0x20,2
1397:main.c        **** 	setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
 1829               		.stabn	68,0,1397,.LM182-.LFBB16
 1830               	.LM182:
 1831 0800 BB9A      		sbi 55-0x20,3
1398:main.c        **** 	setoutPORT(PB5, PORTB); //+OC1D, RED
 1832               		.stabn	68,0,1398,.LM183-.LFBB16
 1833               	.LM183:
 1834 0802 BD9A      		sbi 55-0x20,5
1401:main.c        ****    writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
 1835               		.stabn	68,0,1401,.LM184-.LFBB16
 1836               	.LM184:
 1837 0804 86B5      		in r24,70-0x20
 1838 0806 8C7F      		andi r24,lo8(-4)
 1839 0808 86BD      		out 70-0x20,r24
1468:main.c        **** 	TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
 1840               		.stabn	68,0,1468,.LM185-.LFBB16
 1841               	.LM185:
 1842 080a 89E0      		ldi r24,lo8(9)
 1843 080c 87BD      		out 71-0x20,r24
1471:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
 1844               		.stabn	68,0,1471,.LM186-.LFBB16
 1845               	.LM186:
 1846 080e 83E6      		ldi r24,lo8(99)
 1847 0810 80BF      		out 80-0x20,r24
1502:main.c        ****  	Nada_init();
 1848               		.stabn	68,0,1502,.LM187-.LFBB16
 1849               	.LM187:
 1850 0812 80E3      		ldi r24,lo8(48)
 1851 0814 84BD      		out 68-0x20,r24
 1852 0816 84E0      		ldi r24,lo8(4)
 1853 0818 8DBD      		out 77-0x20,r24
 1854               	/* epilogue start */
1503:main.c        **** }
 1855               		.stabn	68,0,1503,.LM188-.LFBB16
 1856               	.LM188:
 1857 081a 0895      		ret
 1858               		.size	lvds_timerInit, .-lvds_timerInit
 1859               	.Lscope16:
 1860               		.stabs	"",36,0,0,.Lscope16-.LFBB16
 1861               		.stabd	78,0,0
 1862               		.stabs	"lcd_Init:F(0,15)",36,0,870,lcd_Init
 1863               	.global	lcd_Init
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 131


 1864               		.type	lcd_Init, @function
 1865               	lcd_Init:
 1866               		.stabd	46,0,0
 1867               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext9
 1868               	.Ltext9:
   1:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //lcdStuff 0.51ncf-git
   2:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
   3:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.51ncf-git first attempt at using git for uploading to googleCode...
   4:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        this version isn't yet used by any projects
   5:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.50ncf cleanup, colorOverride is unused...
   6:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				SMILEY -> LCD_SMILEY
   7:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf-1 loadRow unused... removal untested...
   8:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.40ncf drawPix...
   9:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-6 HSYNC_INACTIVE, etc. definable elsewhere
  10:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-5 Adding BLUE_VERT_BAR_REVERSED
  11:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-4 Adding NOTES: DON'T START WITH BLUE_DIAG_BAR
  12:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-3 T_DV and T_Vlow overrideable
  13:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-2 Not sure if I've modified it between... but here: 
  14:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        FRAME_COUNT_TO_DELAY wasn't defined, giving warnings
  15:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf-1 updateLCD() has return-values for state-switches
  16:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (VFP, VSync, VBP, DE)
  17:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        ACTUALLY, that's unnecessary... state-transitions can be
  18:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        determined by vSync and dataEnable...
  19:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.30ncf Haven't been keeping these backed up regularly...
  20:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        More toward realtime adjustable timing values
  21:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        V Front Porch now occurs at the beginning of the frame, instead
  22:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        of at the end...
  23:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  24:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.20ncf More Timing Value experiment preparation... 
  25:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-3ish looking into reloading methods for e.g. experimenting with
  26:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          timing values: sdramThing2.0-7
  27:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          How to "move" timing-values around data which needn't be
  28:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          changed...
  29:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-andsomemore
  30:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Added MAKELONG to fix integer overflow warnings
  31:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Revised it from "... + MAKELONG" to "MAKELONG(...)"
  32:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          (The +MAKELONG version is lost in the ether... if you *really*
  33:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //           want it, there's a localized version in sdramThing2.0-6)
  34:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf-1ish - Adding HSYNC_COUNT_FRAME_COMPLETE
  35:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               Removal of LVDS_PRESCALER stuff...
  36:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //0.10ncf - Stolen from LCDdirectLVDS/54-moreColorStuff/main.c
  37:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Removal of LCDdirectLVDS-specific stuff...
  38:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //				A little bit of rewriting of notes to be more generalized
  39:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          All delay_cyc references replaced with delay_Dots,
  40:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //					math changed accordingly...
  41:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  42:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  43:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I hereby declare this FPD-Link simulation technique to forever be called
  44:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  PW-BANGing
  45:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  46:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o 0.10ncf-4: (sdramThing2.0v8-28)
  47:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DON'T START WITH BLUE_DIAG_BAR
  48:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Unless you want to be depressed
  49:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Good Starting Point DE_BLUE
  50:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  51:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  52:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 132


  53:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //new notes a/o 0.10ncf-3ish:
  54:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The basic idea is that timing is something that needs to be experimented
  55:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // with, often... so, for cases where LCD timing/drawing data is loaded
  56:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // beforehand (e.g. sdramThing2.0-7), it would be nice not to have to
  57:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // reload *all* the data, only to change the necessary timing data
  58:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  59:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Neglecting the SDRAM for a second, we have essentially:
  60:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (The exact placement is not necessarily in order... e.g. DH_DOTS could
  61:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  be at the end of a row, or at the beginning... VSYNC rows could be at
  62:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  the top, or at the bottom.....)
  63:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (See also notes "Here's how it worked pre-lvds:", which actually are a
  64:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   bit off, e.g. I don't think VSYNC L->H was delayed by DE_TIME after
  65:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Hsync)
  66:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
  67:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS + HD_DOTS + DH_DOTS = "Horizontal Blank Time"
  68:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (This "front/back" thing always confused me...
  69:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DH_DOTS is *in front of* Hsync as far as *time* is concerned...
  70:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  i.e. looking at a 'scope trace... But something about reading left-to-
  71:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  right causes me to feel like "front" is the furthest to the right
  72:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  which would be *later* in time... weird.
  73:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
  74:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
  75:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |--|<--H_LOW_DOTS                       "Horiz Front Porch"
  76:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  |--|<--HD_DOTS="Horiz Back Porch"    |<---->|<--DH_DOTS
  77:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .      |
  78:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<............................................./
  79:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |  .  .                                 .    
  80:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        v  v  .                                 .      
  81:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V _______________________________________________  \ VSYNC Rows
  82:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  83:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_Vlow times)
  84:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .
  85:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .      "Vsync Back Porch"
  86:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  87:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  88:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_VD times)
  89:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .                                 .         "Vbp should be
  90:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              v                                 v          static"
  91:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************
  92:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  93:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
  94:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
  95:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
  96:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
  97:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *<------ DE_ACTIVE_DOTS --------->*        (Repeat V_COUNT
  98:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *         =1024 times)
  99:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     .   Displayed Pixels
 100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *      .                          *
 101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
 104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE ______||______   /
 106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              *                                 *
 107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              ***********************************      
 108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                      "Vsync Front Porch"
 109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /V 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 133


 110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     /H |__|
 111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DE _______________________________________________  /  T_DV times)
 112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #warning "TODO Maybe: LCDdirectLVDS (which so far is the only version which synced with such low re
 115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Front vs. Back porches....
 117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   If I were to draw a car driving down a street... 
 118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I would draw it with its front to the right, driving to the right...
 119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       _____/\________     \O/
 121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ...|__   _________   __\     |
 122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...\_/         \_/       / \							//
 123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person is *in front of* the car... which means the car has not yet
 125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   arrived at the person, but will soon... 
 126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (later in time, not *before* in time)
 127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This is my logic...
 128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So The "Horizontal Front Porch", to me, should be to the RIGHT of the
 129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Horizontal Sync Pulse...
 130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But that ain't how it is (unless I've confused myself into a circle
 131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   where my logic is actually right, and I just think it's wrong?)
 132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   
 133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  By the logic that the front porch occurs *before* the sync pulse,
 134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ... I suppose we could think of a person in front of a house... it
 135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   makes more sense, anyhow, since it's a porch in front of a house, 
 136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   not person in front of a car.
 137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The person's walking into the house, crosses the *front*-porch 
 138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   *before* enterring the doorway. If he continues walking all the way
 139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   through the house and out the back-door, he'll be crossing the *back*
 140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   porch later in time...
 141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Right, so the logic makes sense... but for some reason I have to run 
 143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  through this whole diatribe every time I see the terms.
 144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Heh, and even after going through it, the damned thing seems backwards.
 145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Probably because I drew it with the front-porch to the right side...)
 146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (AND THEN there's the issue that it seems to me like the front-porch
 147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the left of the drawing-area whereas the back-porch
 148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   should be to the right of it... rather than to the HSYNC pulse)
 149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Anyways, all that drawing was to figure out where to position this
 152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in memory, such that it would be the least processing-effort to modify
 153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // timing values for testing... (because loading the SDRAM's free-running 
 154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // data takes ~20minutes!)
 155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Options LTN, IDT, or TESTVALS
 159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDT display *still* doesn't sync... maybe my H/V signals aren't right
 160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DISPLAY
 161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY TESTVALS //LTN //TESTVALS //IDT //LTN
 162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //oldNote:
 165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TODO: Between OSCCAL_VAL and FRAME_UPDATE_DELAY
 166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it seems the speed (at least for the LTN) isn't so important after all
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 134


 167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This could be used to my advantage...
 168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Maybe bump OSCCAL_VAL all the way up, but use a slower "bit-rate"
 169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Thus, pixels could be skinnier, thus higher-resolution.
 170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Or more instructions could be used for the same resolution
 171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   allowing, e.g. sprites from program-memory, without necessitating a
 172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   large (or any?) frame-buffer...
 173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This would normally be 0 for the highest-speed frame-refresh possible
 176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // However, increasing this value can slow the frame-refresh rate
 177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if desired
 178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. 50000 causes it to refresh ~ every few seconds
 179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (durn-near the limit for how long the LCD will retain an image)
 180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The benefit being that it doesn't flicker at annoying rates for
 181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  stationary images
 182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  worth exploring...
 183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This may be highly dependent on the screen capabilities...
 184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   of course, this sorta thing is undocumented
 185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   it just has to be experimented with
 186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, it may be quite hard on the Liquid Crystals, since they'd 
 187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   likely be driven DC... not sure what the long term effects are.
 188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This could be a hell of a lot more sophisticated...
 189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // e.g. refresh after a frameBuffer change
 190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      refresh based on a seconds-timer
 191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ...
 192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AS-IS: Does refreshes completely independent of the frame-buffer
 193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      if it's too slow, some images may be missed completely.
 194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      This is not true for FRAME_SYNC TRUE (below)
 195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (and it's not really useful anymore with FRAME_SYNC)
 196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // a/o sdramThing2.0, this is not really relevent...
 197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	if the frame needs updating, just stop free-running, right?
 198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 	well, doing-so might cause issues, since the LVDS clock will not be
 199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    running... this is a TBD
 200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define FRAME_UPDATE_DELAY 0//5000//50000 //2000 //5000 //20000 //50000
 201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //New Idea:
 204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Disable the Hsync timer interrupt after the frame completes
 205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and reenable elsewhere...
 206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (It seems pixels changing from one shade to another take an
 207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate step halfway between)
 208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Thus, two updates then a pause might clear that up)
 209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Duh... it doesn't clear that up, because the fastest refresh rate
 210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   is the same...)
 211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (but it is an interesting effect)
 212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Double-Duh... I was using a slow refresh with FRAME_UPDATE_DELAY)
 213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Reworded: Having several frame refreshes before a pause helps to
 214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  "solidify" the color changes... especially the sharp changes 
 215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (e.g. yellow<->black)
 216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Side Note: I saw this effect on a regular (NON-LVDS) TFT display 
 217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   in LCDdirect that was only connected such that R, G, and B were each
 218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   either full-off or full-on, i.e. all Red bits were connected to a
 219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   single output pin (full on when 1, full off when 0).
 220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   I hadn't attributed it to improper refresh synchronization
 221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   as the refresh rate was too fast to see... That's a handy way to get
 222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   intermediate shades/colors without refresh-flicker from pulsing them!)
 223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  connected with each color 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 135


 224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  0 means no delay (except FRAME_UPDATE_DELAY) via interrupt disabling
 225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  If you WANT this effect (for intermediate shades?) 
 226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   set FRAME_COUNT_TO_DELAY to 1
 227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Then, each change of color will (apparently) result in a value halfway
 228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between the old color and the new color
 229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Not sure whether it's an electrical problem, but these half-shades 
 230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   appear dithered, sometimes ugilly, sometimes it's nice. I guess it
 231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   depends on the goal...
 232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FRAME_COUNT_TO_DELAY 2//7//1//5//2//3
 233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //A/O v13: Using the Samsung LTN display, instead of the IDTech IAXG
 236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN appears to be content with my pseudo-LVDS scheme.
 237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IAXG has never unblanked
 238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Even though suitable timings were found with SwitchResX
 239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Maybe due to psuedo-LVDS
 240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            slight timing issues // It probably doesn't work with all cases...
 241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Definitely with drawPix/Images...(RC oscillator variances?)
 242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            glitches when switching LVDS states 
 243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 (thought I had that figured out, originally)
 244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      The fact the LTN appears to recognize the signalling suggests the
 245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG would be worth further exploration...
 246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         Unfortunately, the CCFT blew out my inverter
 247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        And I must have put it back together incorrectly
 248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (backlight filters out of order or flipped?)
 249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        (which actually makes for some very interesting
 250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         visuals, but hard to develop with)
 251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      IAXG: uses DE, V, and H
 252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             At low pixel-clock DE is active for fewer pixels...
 253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              Last Tested: 680 was full-screen
 254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             Nice because it increases the frame-rate!
 255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      LTN:  uses DE only
 256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The idea is to use FastPWM with the PLL to implement 64-85Mbits/sec
 259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (the PLL on the Tiny861 supposedly maxes out at 85MHz)
 260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (Though I am currently running with OSCAL set to the highest frequency
 261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   and the PLL seems to be syncing at about 128MHz)
 262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (New Note, a/o sdramThing2.0v5... it's kinda ironic that I was able to
 263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   run it at 128MHz with nothing more than an AVR and some gates...
 264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   seeing as how sdramThing has been fidgetty just running at 8MHz
 265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Anyways, an eventual goal is to run at 133MHz+, using basically
 266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   nothing more than the SDRAM itself for timing and refreshes...
 267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   would allow for full resolution and full color-depth)
 268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Wiring:
 273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Many iterations of AVR->Differential "LVDS" circuitry resulted in the
 274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   simplest of all:
 275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Believe it or not, the XOR is a standard TTL LS-series XOR: 74LS86
 277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Specifically: TI SN74LS86N from 1980 (the only XOR in my collection)
 278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's spec'd to run from 4.5-5.5V, and its propagation delays and slew
 279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     rates aren't really spec'd to be good enough for 128MHz pixel clock
 280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     yet it's working...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 136


 281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Further, the output voltages are right in the LVDS range,
 282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     IIRC (last I 'scoped) around 1.5V High and 1.0V Low
 283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (Don't forget the LCD has a 100ohm resistor between
 284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         RXinN/clk+ and RXinN/clk-)
 285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   It's probably best to use two XORs from the same chip for a single
 287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    LVDS channel, since different chips may have slightly different
 288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    characteristics. 
 289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   The entire circuit, thus, requires TWO 74LS86's 
 291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (four XORs apiece, two per LVDS channel, 8-total)
 292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              VCC3V3   VCC3V3
 295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                           ______________
 296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---\ \-_                        |  LCD (1 channel
 297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |       of 4)
 298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk-  | ----.
 299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   AVR, etc.         | |    _-                      |     |
 300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3.3V TTL >---+---/ /___-                        |     \ 100
 301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   output       |                                   |     /
 302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     \ ohms
 303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |                                   |     /
 304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                `---\ \-_                        |     |
 305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    -                      |     |
 306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | | XOR   >------> RXinN/clk+  | ----'
 307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                     | |    _-                      |
 308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                +---/ /___-                        |
 309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                |        |                          |
 310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //               GND      GND
 311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Also used: The TTL 74AHC series...
 314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    I found some one-gang 74AHC1G32 and 74AHC1G86's on an old iBook
 315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     motherboard. (An OR and an XOR, respectively). These are spec'd for
 316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     3.3V operation, and faster. The output voltages appear OK for LVDS
 317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (with a 100ohm load in the LCD)
 318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NOTE: Since I only had enough of these 1-gang devices for two LVDS
 320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     channels, I had to implement Red and Green with the LS 
 321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     before switching all channels to the LS... Using different chips
 322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (specifically, different TYPES of chips) for different channels
 323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     caused timing issues: Since the AHC is faster, the clock and Blue
 324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     signals are synchronized, but the red and green signals were shifted
 325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     a bit or two (resulting in "Black" appearing green)
 326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  For other circuits attempted, see oldNotes.txt
 328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (and boy there were many, involving voltage dividers, AC coupling,
 329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      reference voltages, BJT differential amplifiers... I doubt I 
 330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      documented them all, or even most. Whoda thunk the simplest, 
 331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      especially under- AND over-spec'd--timing, supply voltage, and
 332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      output voltage--would be the one...?)
 333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LVDS/FPD-Link timing:
 335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |<--- (LCDdirectLVDS: "pixel") --->|
 337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Timer1:   |<-- One Timer1 Cycle (OCR1C=6) -->|
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 137


 338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TCNT:     |  0   1    2    3    4    5    6  |  0   1    2    3    
 339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____               |____.____.____.____
 340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXclk+:   /         |         \    .    .    /         |         \ //
 341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |            |         |
 342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // One Pixel: |         |<--- One FPD-Link Pixel Cycle --->|
 343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Blue/DVH" |____ ____v____ ____ ____v____ ____|____ ____
 345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin2:    X B3 X B2 X DE X /V X /H X B5 X B4 X B3 X B2 X ...
 346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^  ^ | 
 347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<--Not Blue-->|         |
 348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |                                  |
 349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Green"    |____ ____v____ ____v____ ____ ____|____ ____
 350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin1:    X G2 X G1 X B1 X B0 X G5 X G4 X G3 X G2 X G1 X ...
 351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^ ^  |  
 352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<------->|-Not Green    |
 353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // "Red"      |____ ____v____v____ ____ ____ ____|____ ____
 355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  RXin0:    X R1 X R0 X G0 X R5 X R4 X R3 X R2 X R1 X R0 X ...
 356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            | ^^     
 357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |         |<-->|-Not Red
 358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Of course: The "Not Green/Red" bits above are least-significant-bits
 360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              and basically have little/no visible effect
 361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Implementations/prospects:
 364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowBuffer.c (more like row-settings-buffer)
 365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     calculate a row's worth of pixels before drawing that row
 366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (uses packed color settings in a single byte per drawable pixel)
 367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     64 drawable pixels across, regardless of LVDS speed
 368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * For faster pixels: these settings values could be stored 
 369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     in individual bytes. Gives about 1/3 more pixels at 3x the memory
 370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     (not implemented)
 371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  * rowSegBuffer.c
 372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     also calculates an entire row before drawing it
 373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     instead of storing pixels, store "segments"
 374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     i.e. each segment is defined by a color value and a length
 375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Number of segments is limited only by memory...
 376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      e.g. 64 segments per row (max) is 64*3Bytes
 377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Three bytes for color, and *really simple* packing for seg-length
 378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      BUT: at slow LVDS speeds, the resolution of these segments could be
 379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       as high as one LCD pixel.
 380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      possibly: at *really* low LVDS speeds we could be 64*2Bytes
 381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      (with packing)
 382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      Actually: Using GB_COMBINED gives 2Bytes per segment
 383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      only adds two clock cycles to each "pixel", so probably worth it
 384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   In Any Case: There's not enough RAM for a full frame
 386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          64 pixels across * 64 pixels down is 4096 bytes
 387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          So whatever method, we need to precalculate each row before
 388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          displaying it
 389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          Could be as simple as loading direct from program memory
 390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Since low-bits are barely visible, their effect is neglected.
 393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 138


 395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE/V/H Timing (LCDdirectLVDS):
 396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |  0   1    2    3    4    5    6       All: set @ 0
 399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            |____.____.____.____                         OCR1C = 6 
 400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Clock:    /                   \    .    .    /         Complementary-
 401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                             Output Mode
 402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                          required for DT
 403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Signal:    B3   B2   DE   /V   /H   B5   B4 | B3
 404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____ ____ ____ ____ ____ ____|____    
 405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE:      X B3 X B2 /    .    .    \ B5 X B4 X B3 X    
 406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state2                      |    
 407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_BLUE: >|    DT=X, OCR=0
 408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                         Watch the transition!! -------^
 409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DE_NORM: >_________/\_________|    DT=2, OCR=4
 410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DC_DISABLED:
 411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   maxBlue: >\____|		DT=0, OCR=5
 412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             See below for more blue settings...
 413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____      ____ ____|____ 
 415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H (only): X xx X xx \    /    \    / xx X xx X xx X    
 416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state1              | 
 417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\______________|    DT=3, OCR=3
 418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DC_DISABLED:
 419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Not much can be done...
 420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____           ____ ____ ____|____ 
 422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/o H:  X xx X xx \    .    /    \ xx X xx X xx X
 423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state3              |
 424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\_________|    DT=4, OCR=4 (+?)
 425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >___________________/\____|		DT=4, OCR=5
 427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____                ____ ____|____ 
 429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V w/ H:   X xx X xx \    .    .    / xx X xx X xx X
 430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state4          | 
 431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >__________________________________|    DT=X, OCR=0
 432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             TransitionWatch!!! -------^
 433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                             Shouldn't matter... DT from no-edge
 434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >\________________________|		DT=0, OCR=1
 436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ____ ____      ____ ____ ____ ____|____ 
 438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada:     X xx X xx \    /    .    \ xx X xx X xx X    
 439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   state0                  |     
 440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\_________|    DT=3, OCR=4 (+?)
 441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DC_DISABLED:
 442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //            >______________/\____|		DT=3, OCR=5
 443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //So far this is the only case I've seen:
 445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Vsync
 446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_ACTIVE
 447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_ACTIVE		0
 448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef VSYNC_INACTIVE
 450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VSYNC_INACTIVE	1
 451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 139


 452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // /Hsync
 453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_ACTIVE
 454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_ACTIVE		0
 455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HSYNC_INACTIVE
 457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_INACTIVE	1
 458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE (active high)
 460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_ACTIVE
 461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_ACTIVE			1
 462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DE_INACTIVE
 464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DE_INACTIVE		0
 465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HERE!
 468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Transitions: OLD!!!!! WRONG!!!!
 473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (are they? There're several additional transitions, now, for one.)
 474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The idea is to reduce the number of instructions between each
 475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS "state."
 476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  These are implemented below in the case:
 477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    "#else //NOT FULL_INIT_TESTS"
 478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Since each instruction takes *longer than* a single pixel
 479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    two instructions would *at best* occur on two consecutive pixels
 480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Thus, there's likely to be a transition-glitch
 481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (e.g. old OCR value with new DT value)
 482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Note that the new DT values are implemented at the next corresponding
 483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    edge after the DT-write instruction completes
 484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for +OC1A/DT1H, when TCNT is reset to 0)
 485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    (for -OC1A/DT1L, when TCNT passes OCR1A)
 486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    New OCR values are delayed until the next TCNT reset to 0
 487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Initial:
 489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada					DT=2  NADA_OCR = (3<=OCR<(=?)6)
 490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	H			OCR=2
 492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H		->	Nada		OCR=NADA_OCR
 493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  
 494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	V			DT=3
 495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	V+H		OCR=0
 496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V+H	->	V			OCR=NADA_OCR
 497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V		->	Nada		DT=2
 498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Nada	->	DE			DT=1
 500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  DE	->	Nada		DT=2
 501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(REMOVE_DC) && REMOVE_DC)
 504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=5; }
 505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Unused, normally...
 507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()       { DT1=(4<<4);  OCR1A=5; }
 508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()      { DT1=0;       OCR1A=1; }
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 140


 509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()       { DT1=(3<<4);  OCR1A=3; }
 510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()      { DT1=(2<<4);  OCR1A=4; }
 511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()		 { DT1=0;       OCR1A=5; }
 512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else //!REMOVE_DC
 514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Nada init
 515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Nada_init()         { DT1=(3<<4); OCR1A=4; }
 516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Unused, normally...
 518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Vsync_init()			{ DT1=(4<<4);	OCR1A=4; }
 519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define VplusH_init()		{ DT1=0;			OCR1A=0; }
 520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hsync_init()			{ DT1=(3<<4);	OCR1A=3; }
 521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #define DE_init()				{ DT1=(2<<4);	OCR1A=4; } //...SHOULD BE
 522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEonly_init()			{ DT1=(2<<4);  OCR1A=4; }
 523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DEblue_init()			{ DT1=0;       OCR1A=6; }
 524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define DE_init()				{ DT1=(1<<4);	OCR1A=2; } //Works with DE_ONLY
 525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define DE_init()				{ DT1=0;			OCR1A=0xff; }	//DE_BLUE
 526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //REMOVE_DC
 527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define FULL_INIT_TESTS TRUE
 530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Display is DE-Only (doesn't use H/Vsync)
 532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Shouldn't be necessary to select this if it is,
 533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since DE timing is the same either way
 534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // but I want to test whether a single-bit is being detected
 535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. maybe the rise/fall-times of the output aren't fast enough for a
 536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  single bit, which might explain why the other display didn't work)
 537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //These are just examples... the project should define them:
 538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
 539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(DE_ONLY_DISPLAY) && DE_ONLY_DISPLAY)
 540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()      Nada_init()
 541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()    Nada_init()
 542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()    Nada_init()
 543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()      Nada_init()
 544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()      Nada_init()
 545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()      Nada_init()
 546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()     DE_init()
 547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DE_init()
 548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if(DE_BLUE)
 550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "DE_BLUE is true, but not implemented with DE_ONLY_DISPLAY"
 551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "...The display should be blank"
 552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
 553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Use full initialization of each LVDS state
 554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (might not be good during transitions, but should guarantee
 555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  steady-state, in case my transitions aren't correct...)
 556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (defined(FULL_INIT_TESTS) && FULL_INIT_TESTS)
 557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()		Vsync_init()
 558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync()		VplusH_init()
 559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH()		Vsync_init()
 560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()		Nada_init()
 561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()		Hsync_init()
 562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()		Nada_init()
 563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()		DEonly_init()
 564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly()	DEblue_init()
 565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()		Nada_init()
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 141


 566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()		Nada_init()
 567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else	//NOT FULL_INIT_TESTS
 570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromNada()   { DT1=(4<<4); }
 571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromNada()   { DT1=(4<<4); OCR1A=5; } //Leave two bits high
 572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 																	 //for easy-scoping
 573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 						//Three would be nicer, but I'm pretty sure OCR=TOP=ON
 574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define VplusH_fromVsync() { OCR1A=0; }
 575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Vsync_fromVplusH() { OCR1A=4; }
 576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Vsync_fromVplusH() { OCR1A=5; }				//Extra bits for scoping
 577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define Nada_fromVsync()   { DT1=(3<<4); }
 578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromVsync()   { DT1=(3<<4); OCR1A=4; } //scoping...
 579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Hsync_fromNada()   { OCR1A=3; }
 580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromHsync()   { OCR1A=4; }
 581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEblue()	{ DT1=(3<<4); OCR1A=4; }
 583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define Nada_fromDEonly()	{ DT1=(3<<4); }
 584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEonly_fromNada()	{ DT1=(2<<4); }
 585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromNada()	{ OCR1A=0xff; }
 586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DEblue_fromDEonly() { OCR1A=0xff; }
 587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //End Of FULL_INIT_TESTS
 589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // The typical patterns look like this (not at all to scale):
 594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   ----______------------------------------------------______-- V
 595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      --_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_--_ H
 597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ....
 598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      __________-__-__-__-__-__-__-__-__-__-__________________  DE
 599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 
 600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             ^^^^\														//blah
 601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //             1234 5?
 602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Pixels are sent during DE High (basically all the CPU will be used here)
 603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Ideally, 
 604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  there won't be any glitches when changing from one state to another
 605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Init (pre 1):
 607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DeadTimerRising=1
 608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  The states are:
 610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Not necessarily accurate, just looking into necessary changes)
 611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (from Vsync L->H)
 612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1  NothingActive (long, No DE, VporchFrontTimes)
 614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2  Hsync
 616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3  NothingActive (short)
 618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4  DE
 620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5  NothingActive(?)
 622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 142


 623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7  Repeat 2-5 for each row
 624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8  NothingActive (long, No DE, VporchBackTimes)
 626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9  V w/o H
 628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   10 V w/  H
 630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   11 Repeat 9-10 for Vsync time...
 632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Here's how it worked pre-lvds:
 635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HSYNC, VSYNC, and DE refer to the actual pins
 636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In the LVDS setup, there're modes corresponding to each pin-combination
 637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Timer Interrupt:
 639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  loadData:
 640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC active
 641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC Low delay
 642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   HSYNC inactive
 643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   if(dataEnable)
 644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE active
 645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     Send row data
 646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    DE inactive
 647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  //Prep for next interrupt
 648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  switch(hsyncCount++)
 649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync H->L (active)
 650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    1:
 651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC active
 653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Vsync L->H (inactive)
 654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_Vlow:
 655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          VSYNC inactive
 656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Start of frame
 657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_VD +(T_Vlow):
 658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=TRUE
 659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //All rows have been displayed
 660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    V_COUNT +(T_VD+T_Vlow):
 661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          dataEnable=FALSE
 662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    //Frame Complete
 663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    T_DV +(V_COUNT+T_VD+T_Vlow): 
 664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          hsyncCount=0
 665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(dataEnable)
 666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Use the remaining time to load the next row to memory
 667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  So:
 669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC active
 679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE (not necessary?)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 143


 680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
 682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||
 688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|
 689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 VSYNC inactive
 691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
 694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=TRUE
 703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 708:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 709:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 710:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||      |        |
 711:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|      ^--------^
 712:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |
 713:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 dataEnable=FALSE
 714:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 715:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 716:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's basically just:
 717:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // if(hsyncCount == NUM_HYSYNCS_PER_FRAME)
 718:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 719:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 720:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 721:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 722:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 723:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 724:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 725:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 726:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 727:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |        ||  .   |        |                      .
 728:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DETIME^--------^|  .   ^--------^                      .
 729:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 |  .                                   .
 730:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                 hsyncCount=0 (repeat from Interrupt0)  .
 731:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 732:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 733:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 734:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 735:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 736:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 144


 737:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ESPECIALLY THIS FIRST STATE.
 738:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V Front Porch originally (and in these drawings) occurred at the end
 739:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // of the frame...
 740:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // More logically, it now starts at the beginning of the frame
 741:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (Also removing this initial "glitch" of a single interrupt with
 742:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  NothingActive)
 743:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 744:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // THESE STATES ARE NO LONGER ACCURATE (a/o 0.30, for certain)
 745:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOW to compare with LVDS states:
 746:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 747:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Interrupt0       End
 748:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  Interrupt1
 749:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v
 750:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 751:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 752:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |_____________________________________ ...
 753:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 754:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 755:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- V w/o H  \ These two toggle until
 756:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- V w/ H   / next LCD state...
 757:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 758:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- V w/o H > Intermediate change of state
 759:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 760:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From Previous State (?)
 761:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         /
 762:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 763:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 764:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_Vlow   End
 765:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 766:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 767:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 768:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ ...
 769:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V _____________| ...
 770:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^          ^   ^ ^
 771:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | |
 772:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   | +--- NothingActive  \ These two toggle until
 773:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |   +----- H_Only         / next LCD state...
 774:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          |
 775:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |          +--------- NothingActive > Intermediate change of state
 776:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |
 777:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- V w/o H   \ From previous state
 778:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- V w/ H    /
 779:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 780:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 781:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_VD   End  InterruptT_VD+1
 782:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |  |            End
 783:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v  v            v
 784:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 785:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ____________________||_______||____ ...
 786:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 787:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^              ^ ^^        ^ 
 788:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        |
 789:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | ||        +--- NothingActive  \  These four
 790:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | |+------------ DE              | cycle until
 791:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              | +------------- NothingActive   | next LCD state...
 792:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |              +--------------- H_Only  ^      /
 793:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |                                       |
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 145


 794:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +----- NothingActive  \ From previous   |
 795:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +------- H_Only         / state           +-This intermediate state
 796:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                may not be necessary
 797:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                                                (IAXG01 shows 160 dots!)
 798:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 799:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 800:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 801:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptV_COUNT  End
 802:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             |
 803:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v
 804:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 805:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___||______________________________________ ...
 806:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V 
 807:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^^        ^    ^ ^
 808:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | |
 809:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    | +--- NothingActive \  These two toggle
 810:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |    +----- H_Only        /  until next LCD state
 811:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        |
 812:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | ||        +---- NothingActive \ 								//blah
 813:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |+------------- DE             |  From previous state
 814:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +-------------- NothingActive  |
 815:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +---------------- H_Only        /
 816:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 817:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This isn't really a state, it's essentially just:
 818:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  if(hsyncCount == NUM_HSYNCS_PER_FRAME)
 819:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    hsyncCount = 0;
 820:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .....................................
 821:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    .                                   .
 822:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //InterruptT_DV   End .Interrupt0                         .
 823:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    |             | .|                                  .
 824:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    v             v .v                                  .
 825:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H |_||_||_|
 826:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE ___________________________________________________ .
 827:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V |____________________ .
 828:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    ^ ^             .                                   .
 829:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | |             .....................................
 830:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    | +--- NothingActive \											//blah
 831:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    +----- H_Only        / From previous state...
 832:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 833:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 834:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 835:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  LVDS State transitions:
 836:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   1 H_Only
 837:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   2 NothingActive
 838:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 839:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   3 V w/o H
 840:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   4 V w/ H
 841:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    
 842:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 3,4)
 843:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 844:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   5 V w/o H
 845:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 846:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   6 NothingActive
 847:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   7 H_Only
 848:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 849:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (repeat 6,7)
 850:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 146


 851:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   8 NothingActive
 852:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 853:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   9 H_Only
 854:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  10 NothingActive
 855:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  11 DE
 856:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  12 NothingActive
 857:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 858:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 9-12)
 859:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 860:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  13 H_Only
 861:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  14 NothingActive
 862:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 863:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (repeat 13-14)
 864:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 865:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   These should be reviewed to determine which changes are necessary
 866:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   between each state...
 867:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (the fewer changes, the less likely we'll glitch...?)
 868:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 869:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 870:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void lcd_Init(void)
 871:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1869               		.stabn	68,0,871,.LM189-.LFBB17
 1870               	.LM189:
 1871               	.LFBB17:
 1872               	/* prologue: function */
 1873               	/* frame size = 0 */
 872:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  	Nada_init();
 1874               		.stabn	68,0,872,.LM190-.LFBB17
 1875               	.LM190:
 1876 081c 80E3      		ldi r24,lo8(48)
 1877 081e 84BD      		out 68-0x20,r24
 1878 0820 84E0      		ldi r24,lo8(4)
 1879 0822 8DBD      		out 77-0x20,r24
 1880               	/* epilogue start */
 873:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 1881               		.stabn	68,0,873,.LM191-.LFBB17
 1882               	.LM191:
 1883 0824 0895      		ret
 1884               		.size	lcd_Init, .-lcd_Init
 1885               	.Lscope17:
 1886               		.stabs	"",36,0,0,.Lscope17-.LFBB17
 1887               		.stabd	78,0,0
 1888               		.stabs	"updateLCD:F(3,2)",36,0,1165,updateLCD
 1889               	.global	updateLCD
 1890               		.type	updateLCD, @function
 1891               	updateLCD:
 1892               		.stabd	46,0,0
 874:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 875:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 876:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TESTVALS	0
 877:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define LTN 1
 878:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define IDT 2
 879:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 880:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 881:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //TIMING:
 882:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Measurements below (in microseconds) are referring to preLVDS
 883:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  There may be other such old-notes...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 147


 884:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 885:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 886:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        |<--T_Hhigh-->| |<-T_Hlow
 887:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    __   _____________   ____________  3.6V
 888:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H    |_|             |_|           _  0V
 889:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 890:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Data Enable
 891:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Only active when there's valid pixel data
 892:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       (For a dual-pixel 1024x768 display:
 893:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //         for 512 of the 717 clocks in HSYNC-active)
 894:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       Low during Vsync... (~720us)
 895:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
 896:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 897:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech display: 136 dots
 898:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //2-136+
 899:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech, last used: 40
 900:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Last used 8
 901:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN: 1072<=1344<=1500 clocks per line, 1024DE... Hsync unused
 902:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // SEE Hlow_Delay() notes if this value is large!
 903:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 904:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef H_LOW_DOTS
 905:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 906:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	8
 907:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 908:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS   40//8//1//40 //30 //2//136
 909:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 910:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define H_LOW_DOTS	100//0 //LTN doesn't use H_LOW (DE-only)
 911:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 							  // And having a value here increases codesize
 912:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 913:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 914:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 915:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //H is set low immediately upon entry of the timer interrupt
 916:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // its low-time is controlled via nops
 917:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (so if HLow is long for a particular display, this might need revising)
 918:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 919:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if((!defined(HLOW_DELAY_OVERRIDE) || !HLOW_DELAY_OVERRIDE) \
 920:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		                                         && !defined(Hlow_Delay))
 921:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define Hlow_Delay() \
 922:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	delay_Dots(H_LOW_DOTS)
 923:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 924:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 925:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 926:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 927:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 928:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //This was found expermentally with SwitchResX
 929:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 680
 930:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (IDTech had some oddities regarding slow pixel-clocks, where pixels
 931:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  would be repeated, regardless of the pixel-clock, thus, for slow clocks
 932:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  it has the effect of *stretching* the image, thus 680 "pixels" across
 933:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  instead of its 1024 *physical* pixels)
 934:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 1024
 935:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Oddly: For the LTN, this doesn't seem to affect the horizontal
 936:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //        it does, however, affect the vertical(!)
 937:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // If I recall Correctly, this is used only for setting the timer interrupt
 938:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  rate...
 939:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 940:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 148


 941:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 942:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	680 //1024 //800 //920 //943 //812 //472 //1024
 943:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 944:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DE_ACTIVE_DOTS	1024
 945:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 946:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 947:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 948:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Blank Time: HD_DOTS + H_LOW + DH_DOTS
 949:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  90-320+
 950:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Horizontal Total Time: 1206<=1344<=2047
 951:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // ... but Total = Blank + Pixels, so 90+1024 != 1206
 952:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Excess waits should be thrown in DH (since that's between interrupts)
 953:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //T_HD is the time from H inactivated to DE activated
 954:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka H back-porch: 1-160+
 955:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //IDTech Last Used: 50
 956:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN last used 5
 957:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 958:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_DOTS
 959:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 960:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 5
 961:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 962:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS	50 //5 //0//20//5 //50 //30 //1 //160
 963:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 964:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_DOTS 50//5
 965:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 966:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 967:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 968:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef HD_Delay
 969:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define HD_Delay()	delay_Dots(HD_DOTS)
 970:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 971:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 972:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think this was just a mistake. This change to delay_Dots a/o 0.10ncf
 973:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (untested in LCDdirectLVDS)
 974:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //delay_cyc(HD_DOTS)
 975:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 976:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 977:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is the number of CPU cycles between DE->L and Horiz->L
 978:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is just used in calculating the OCR value...
 979:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // aka H Front Porch: 0-24+
 980:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 24
 981:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 46
 982:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 1072-1024-1-1 = 46
 983:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef DH_DOTS
 984:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
 985:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	46
 986:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
 987:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	24 //46 //480//6//12//24 //46 //24 //122//30 //0 //24
 988:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
 989:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define DH_DOTS	0//1000//100//46
 990:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 991:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
 992:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
 993:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       |
 994:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       v
 995:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      T_DH
 996:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ||    |<-T_DE->|  |  |<--T_HD (Hsync->DE)
 997:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H   __.  ____________  .___________
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 149


 998:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      .|_|  .        .|_|  .
 999:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _.     .________.     .___________
1000:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |_____| 512clk |_____|
1001:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //      ^              ^
1002:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //       \___________   \                        (just avoiding \ warning)
1003:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                   \  |     768 Hsyncs
1004:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                    v v
1005:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _             _ _ _ _ _ _ _ _ _ _ 
1006:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   |___________| | | | | | | | | | |______
1007:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1008:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // one Hsync = T_HD+T_DH+T_Hlow+T_DE = 19.865us
1009:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1010:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync back porch: 7-29-63 "Vbp should be static"
1011:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 29
1012:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1013:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //LTN Frame: 772<=806<=1000 lines...
1014:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1015:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_VD
1016:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1017:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1018:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1019:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define  T_VD 29 //3//29 //7 //29
1020:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1021:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_VD 3
1022:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1023:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1024:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1025:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //aka V-sync front porch: 1-3+
1026:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 3
1027:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN last used 3
1028:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_DV
1029:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1030:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1031:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1032:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3//3 //1 //3
1033:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1034:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_DV 3
1035:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1036:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1037:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1038:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //1-6+ (1 is used by the first switch-case...)
1039:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 6
1040:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // LTN Last used 16
1041:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // 772 - 768 - 1 - 1 = 2
1042:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef T_Vlow
1043:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
1044:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 16
1045:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1046:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow	6 //16//6 //2 //6
1047:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1048:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define T_Vlow 32
1049:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1050:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1051:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1052:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // IDTech Last Used: 768
1053:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #ifndef V_COUNT
1054:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (DISPLAY == LTN)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 150


1055:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1056:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == IDT)
1057:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define V_COUNT	768
1058:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #elif (DISPLAY == TESTVALS)
1059:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #if (LVDS_PRESCALER == 8)
1060:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define V_COUNT 768
1061:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #else
1062:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  #define V_COUNT	(768*2/3)
1063:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #endif
1064:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1065:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1066:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1067:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                       
1068:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      |           
1069:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                      V           
1070:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              |<-T_DV>|           |<-T_VD-->|
1071:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .       .           .         .
1072:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _____________||__.   124us   .____||___________________
1073:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V           .   ||  |___________|    ||   .
1074:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _ _ _|| _ _ _ _ _ _ _ _ _ ||_ _ _ _ _ _ _ _ _ _ _
1075:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H   | | | | | | ||| | | | | | | | | ||| | | | | | | | | | |
1076:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //              .   ||                   ||   .
1077:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _ _ _ _ _.   ||       720us       ||   ._ _ _ _ _ _ _ _ _
1078:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE   | | | | |___||___________________||___| | | | | | | | |
1079:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                  ||                   ||
1080:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1081:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        1
1082:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        |
1083:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                        v               
1084:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     _________________   ___________________   _____________
1085:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  V                   |_|                   |_|
1086:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  H  |||||||||||||||||||||||||||||||||||||||||||||||||||||||
1087:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE  ||||||||||||||||_____|||||||||||||||||_____||||||||||||
1088:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          ^
1089:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          |
1090:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //                          2
1091:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1092:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1093:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1094:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define HSYNC_COUNT_FRAME_COMPLETE  \
1095:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY)
1096:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_DV = 3
1097:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // V_COUNT = 768 
1098:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_VD = 3
1099:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // T_Vlow = 32
1100:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // FRAME_UPDATE_DELAY = 0
1101:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 806
1102:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1103:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(FRAME_UPDATE_DELAY != 0)
1104:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "FRAME_UPDATE_DELAY is no longer implemented..."
1105:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1106:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1107:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1108:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#if(HSYNC_COUNT_FRAME_COMPLETE & 0x01)
1109:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // #warning "Total vertical lines might need to be even!"
1110:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //This should be fixed...
1111:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#endif
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 151


1112:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1113:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1114:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_HSYNC \
1115:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1116:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // H_LOW_DOTS = 100
1117:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // HD_DOTS = 50 
1118:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DE_ACTIVE_DOTS = 1024
1119:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DH_DOTS = 0
1120:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 1174
1121:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1122:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1123:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define MAKELONG (0L)
1124:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1125:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DOT_COUNT_PER_FRAME \
1126:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  ((MAKELONG(HSYNC_COUNT_FRAME_COMPLETE)) * (MAKELONG(DOT_COUNT_PER_HSYNC)))
1127:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // TOTAL = 946,244
1128:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1129:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Hlow_Delay 		H_LOW_DOTS
1130:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //HD_Delay			HD_DOTS	
1131:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DE_ACTIVE_DOTS
1132:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //DH_DOTS
1133:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1134:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1135:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1136:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1137:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable) \
1138:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1139:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1140:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1141:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t dataEnable = 0;
1142:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t vSync = 0;
1143:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint16_t hsyncCount = 0;
1144:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1145:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //frameCount=0 can be used in main to detect whether we've completed a 
1146:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  a frame AND its FRAME_UPDATE_DELAY
1147:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(FRAME_COUNT_TO_DELAY) && (FRAME_COUNT_TO_DELAY != 0))
1148:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t frameCount = 0;
1149:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1150:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1151:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*
1152:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1153:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum) \
1154:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	__attribute__((__always_inline__));
1155:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
1156:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1157:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Returns TRUE when the frame is complete
1158:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Should send nada (and maybe hsyncs?) thereafter(?)
1159:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // In sdramThing2.0, when this returns TRUE, the SDRAM loading is complete
1160:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // EXCEPT: the final HD_Dots' FR_READ/ACTIVATE commands will point to a
1161:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  non-existent "next" Hsync... these commands need to be rewritten to
1162:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  point to the "first" Hsync. This is handled in sdramThing2.0's code
1163:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Used to be:
1164:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //SIGNAL(TIMER0_COMPA_vect)
1165:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** uint8_t updateLCD(void)
1166:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
 1893               		.stabn	68,0,1166,.LM192-.LFBB18
 1894               	.LM192:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 152


 1895               	.LFBB18:
 1896               	/* prologue: function */
 1897               	/* frame size = 0 */
1167:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	uint8_t frameComplete = FALSE;
1168:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1169:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//static uint8_t frameCount = 0;
1170:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1171:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1172:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	while(TCNT0L != 7){};
1173:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This won't work... who knows how many cycles interrupt-entry will be
1174:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Above should fix that...
1175:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//I think this was just an indicator for scope triggering...
1176:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// not relevent for 
1177:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	setpinPORT(PB2, PORTB);
1178:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	clrpinPORT(PB2, PORTB);
1179:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1180:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1181:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Hsync and Actually draw the pixels... (when DE is active)
1182:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This takes a LONG time and will occupy most of the CPU...
1183:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... IN THIS INTERRUPT
1184:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
1185:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
 1898               		.stabn	68,0,1185,.LM193-.LFBB18
 1899               	.LM193:
 1900 0826 2091 0000 		lds r18,dataEnable
 1901               	.LBB100:
 1902               	.LBB101:
1186:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
1188:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
1190:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1191:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//V Front Porch, begins with initLCD
1192:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1193:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync H->L (Begin V-Sync)
1194:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_DV:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
1196:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
1199:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1200:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync L->H (Begin V Back Porch)
1201:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_Vlow + T_DV:
1202:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	if(hfm_nextOutput(&modulator))
1203:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 0xff;
1204:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	else
1205:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//		colorOverride = 7;
1206:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
1209:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1210:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Start of frame (DE active)
1211:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case T_VD +(T_Vlow + T_DV):
1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1214:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// All rows have been displayed
1215:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Return to V Front Porch
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 153


1216:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		case V_COUNT +(T_VD + T_Vlow + T_DV):
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
1218:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//	break;
1219:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Frame complete
1220:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//case HSYNC_COUNT_FRAME_COMPLETE:
1221:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
1223:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(FRAME_COUNT_TO_DELAY != 0)
1224:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			//static uint8_t frameCount = 0;
1225:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameCount++;
1226:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
1227:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1228:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				frameCount = 0;
1229:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
1230:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				//timer_compareMatchIntDisable(0, OUT_CHANNELA);
1231:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1232:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1233:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			
1234:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
1235:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // Yeah, guess that makes sense... Must be Nada...
1236:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			frameComplete = TRUE;
1237:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1238:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		default:
1239:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
1240:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1241:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1242:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1243:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 // (defined(LOADROW) && LOADROW)
1244:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Load the next row into the row(seg)buffer
1245:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//data is enabled after T_VD+T_Vlow...
1246:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
1247:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		loadRow(hsyncCount - (T_VD+T_Vlow));
1248:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1249:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1250:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//This note was written long before the above was commented-out...
1251:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//So...?
1252:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// Here is where loadRow used to be called
1253:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// it has been moved to oldNotes.txt, but it would make more sense
1254:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to look at LCDdirectLVDS <25 or LCDdirect
1255:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// loadRow used the time between DE inactive and the next Hsync
1256:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// to load a row to a row-buffer (as opposed to a frame-buffer)
1257:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus, DE could gain more pixels because there would be fewer
1258:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// calculations to determine the memory location to write from
1259:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// This effect has since been minimized
1260:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// BUT loadRow might be necessary for program-memory-based images...
1261:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1262:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	return frameComplete;
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1264:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1265:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1266:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //See LCDdirectLVDS for an example...
1267:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // basically it loads a single row into a buffer for the next dateEnable
1268:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  (either the row-buffer or the row-segment-buffer) 
1269:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This has been *greatly* reduced, is not at all functional, just
1270:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // to give an idea of loadRow's purpose.
1271:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(LOADROW) && LOADROW)
1272:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadRow(uint16_t rowNum)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 154


1273:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1274:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//e.g....
1275:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	tet_drawRow(rbRowNum, rowBuffer);
1276:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1277:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...	
1278:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	rowBuffer[i] = fb_to_rb(colorVal);
1279:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1280:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//and...
1281:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	if((rbRowNum >= SMILE_TOP_ROW) &&
1282:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			(rbRowNum < (SMILE_HEIGHT+SMILE_TOP_ROW)))
1283:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	{
1284:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			for(i=0; i<FB_WIDTH; i++)
1285:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			{
1286:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          	temp=pgm_readImageByte(pimage, rbRowNum-SMILE_TOP_ROW, i);
1287:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				if(!(temp & 0xC0))
1288:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					rowBuffer[i+SMILE_SHIFT] = fb_to_rb(temp);
1289:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			}
1290:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	}
1291:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1292:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	life_drawRow(rbRowNum, &(rowBuffer[RB_WIDTH-LIFE_WIDTH]));
1293:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1294:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//HORIZONTAL_COLOR_BARS
1295:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	for(i=0; i<RB_WIDTH; i++)
1296:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowBuffer[i] = fb_to_rb(rowNum);
1297:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1298:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Good for syncing to have white on both borders...
1299:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	newSeg(1, 0x06, (6<<4) | 3);
1300:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	
1301:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1302:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //LOAD_ROW
1303:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1304:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1305:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Including inactive pixel-clocks (timing)
1306:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // DotCount per row...
1307:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  TOTAL_CYC_COUNT was used for the timer-interrupt in LCDdirectLVDS
1308:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  This was DOTS_TO_CYC(DISPLAY_DOT_COUNT) + ROW_CALCULATION_CYCS
1309:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  ROW_CALCULATION_CYCS was 50,000 (!!!)
1310:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   DOTS_TO_CYC(dots), last-used, was dots*7 (LVDS_PRESCALER nullified /8)
1311:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   So, the overall dot-count per row was... 
1312:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     DISPLAY_DOT_COUNT + ROW_CALCULATION_DOTS
1313:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     where ROW_CALCULATION_DOTS = 50,000cyc/7 = 7142 dots
1314:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //     So... the overall dot-count per row was *MUCH* longer than usual
1315:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  Pretty certain there's not nearly enough memory to simulate that
1316:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (in sdramThing2.0)
1317:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   But It does suggest that it would be worthwhile to try to stretch
1318:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   the rows as much as possible...
1319:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   During this time, NADA is sent normally, (V=H, H=H, DE=L)
1320:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //    Or Vsync (V=L, H=H, DE=L)
1321:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   Maybe something could be simulated with PWM again, if necessary...
1322:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //   (Certainly not at full-speed)
1323:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_DOT_COUNT \
1324:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(H_LOW_DOTS + HD_DOTS + DE_ACTIVE_DOTS + DH_DOTS)
1325:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1326:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1327:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1328:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_Hlow_CYC 1//8 //(T_Halow_REAL*3)
1329:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_Hlow_CYC DOTS_TO_CYC(H_LOW_DOTS)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 155


1330:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1331:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DE_CYC	DOTS_TO_CYC(DE_ACTIVE_DOTS)
1332:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1333:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define T_HD_CYC 1//3//(T_HD_REAL*3)
1334:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_HD_CYC	DOTS_TO_CYC(HD_DOTS)
1335:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1336:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define T_DH_CYC	DOTS_TO_CYC(DH_DOTS)
1337:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1338:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1339:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1340:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1341:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1342:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void init_timer0Hsync(void)
1343:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1344:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//T_HD + T_DH + T_low + T_DE
1345:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// For the original system, 19.865us = 695 dot-clocks
1346:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// We'd need to take advantage of the 16-bit timer
1347:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  OCR1A may not be written properly (with a temporary high-byte)
1348:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//  ... not sure.
1349:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// TIMER0 DOES NOT HAVE CTC MODE in 16-bit mode
1350:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1351:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This is a hack, for testing syncability with long row-calculations
1352:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // before actually drawing it... e.g. loading from program memory
1353:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // This value needs to be larger than the calculation time
1354:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // otherwise, it seems, syncing isn't stable
1355:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // BUT THIS IS A HACK, has nothing to do with actual calculation time
1356:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // And for slow LVDS or whatnot, this may be unnecessarily HUGE
1357:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1358:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define DISPLAY_CYC_COUNT	(DOTS_TO_CYC(DISPLAY_DOT_COUNT))
1359:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC)
1360:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1361:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOTE that with longer ROW_CALCULATION_CYCS, lines can be repeated...
1362:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // apparently an effect of the display, definitely not a code-thing
1363:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // in which case the vertical resolution decreases
1364:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // though, this could be used to advantage... 
1365:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // (e.g. more processing time outside the drawing interrupts?)
1366:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // NOTE that if the value is too small and calculations take longer in some
1367:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // lines than others (?), those lines may repeat, or syncing could be off
1368:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (LVDS_PRESCALER == 8)
1369:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 1//20
1370:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS (50000) //0 //(70000) //(100000)
1371:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1372:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //#define ROW_CALCULATION_DELAY 9//7//5//2//1//10
1373:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define ROW_CALCULATION_CYCS	(8*DISPLAY_CYC_COUNT)
1374:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1375:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1376:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define TOTAL_CYC_COUNT \
1377:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	(ROW_CALCULATION_CYCS + DISPLAY_CYC_COUNT)
1378:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //	(ROW_CALCULATION_DELAY * (T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC))
1379:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //#define TOTAL_CYC_COUNT 2000
1380:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TOTAL_CYC_COUNT > 255)
1381:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Adding +7 causes it to round up (hopefully)
1382:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+7)/8)
1383:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV	CLKDIV8
1384:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+7)/8: Timer0 CLKDIV8"
1385:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS > 255)
1386:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+63)/64: Timer0 CLKDIV64"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 156


1387:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+63)/64)
1388:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_CLKDIV CLKDIV64
1389:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #if (TIMER0_TCNTS > 255)
1390:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+255)/256: Timer0 CLKDIV256"
1391:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_TCNTS ((TOTAL_CYC_COUNT+255)/256)
1392:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #define TIMER0_CLKDIV CLKDIV256
1393:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #if (TIMER0_TCNTS > 255)
1394:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#warning "TIMER0_TCNTS = (TOTAL_CYC_COUNT+1023)/1024: Timer0 CLKDIV1024"
1395:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_TCNTS ((TOTAL_CYC_COUNT+1023)/1024)
1396:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		#define TIMER0_CLKDIV	CLKDIV1024
1397:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	 #endif
1398:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #endif
1399:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1400:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (TIMER0_TCNTS == 0)
1401:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "TIMER0_OCRVAL == 0"
1402:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1403:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1404:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_TCNTS TOTAL_CYC_COUNT
1405:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_CLKDIV CLKDIV1
1406:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1407:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1408:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (defined(SLOW_EVERYTHING_TEST) && SLOW_EVERYTHING_TEST)
1409:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //For testing, I want to see the pulses with the 'scope
1410:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Unless the timer is divisible by 7 the pulses will not align with the
1411:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // timer overflow...
1412:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //but shit... it's running at clkdiv8 so each TCNT is 64 bits!
1413:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // but this shouldn't matter for visualizing, that's only ~10 pixel clocks
1414:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // and we'll only start visualizing *after* the extra TCNTs...
1415:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  //Since the timer counts from 0 to (and including) OCR1A
1416:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  // Add one to this test...
1417:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if (((TIMER0_TCNTS + 1) % 7) == 0)
1418:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 1) % 7 == 0"
1419:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS"
1420:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS)
1421:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1422:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 2) % 7) == 0)
1423:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 2) % 7 == 0"
1424:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 1"
1425:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 1)
1426:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1427:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 3) % 7) == 0)
1428:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 3) % 7 == 0"
1429:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 2"
1430:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 2)
1431:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1432:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 4) % 7) == 0)
1433:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 4) % 7 == 0"
1434:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 3"
1435:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 3)
1436:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1437:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 5) % 7) == 0)
1438:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 5) % 7 == 0"
1439:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 4"
1440:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 4)
1441:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1442:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS + 6) % 7) == 0)
1443:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS + 6) % 7 == 0"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 157


1444:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS + 5"
1445:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS + 5)
1446:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1447:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #elif (((TIMER0_TCNTS) % 7) == 0)
1448:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "(TIMER0_TCNTS) % 7 == 0"
1449:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #warning "   so... TIMER0_OCRVAL = TIMER0_TCNTS - 1"
1450:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #define TIMER0_OCRVAL (TIMER0_TCNTS - 1)
1451:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1452:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else
1453:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****   #error "WTF?"
1454:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1455:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else
1456:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #define TIMER0_OCRVAL (TIMER0_TCNTS-1)
1457:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1458:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1459:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (TIMER0_OCRVAL > 255)
1460:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #error "Despite all my efforts, TIMER0_OCRVAL is *still* > 255!"
1461:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1462:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1463:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
1464:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
1465:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
1466:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
1467:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1468:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1469:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #define fullBlue()	DEblue_init()
1470:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1471:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1472:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1473:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //Either use one of the ones here, or define your own...
1474:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is the drawable row number on the LCD...
1475:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //static __inline__ void drawPix(uint16_t rowNum);
1476:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1477:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1478:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ \
1479:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum) \
1480:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	  __attribute__((__always_inline__));
1481:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1482:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if (!defined(ROW_SEG_BUFFER) || !ROW_SEG_BUFFER)
1483:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //drawPix loads each pixel individually... It doesn't use a for-loop
1484:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // since that would take away from actual pixel-drawing time...
1485:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // I think it's been removed... but here's a (non-functional) example...
1486:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1487:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1488:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+1));	 
1489:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+2));	 
1490:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+3)); 
1491:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1492:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+61));
1493:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+62));
1494:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	writeColor(*(color+63));
1495:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// WriteColor writes the pixel *after* the calculations...
1496:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// thus the pixel appears basically after writeColor completes
1497:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	// These nops assure the 64th pixel is fully-displayed before exitting
1498:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
1499:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	...
1500:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	asm("nop");
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 158


1501:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1502:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** /*		reg[17] = colorBuffer[rowNum][17];                         
1503:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[17]);                         
1504:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1505:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[20] = colorBuffer[rowNum][20];                         
1506:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[20]);  
1507:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		
1508:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//REPEATING to fill screen... (delayDots = 342 worked prior to this)
1509:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[0] = colorBuffer[rowNum][0];
1510:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[0]);
1511:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		...
1512:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		reg[10] = colorBuffer[rowNum][10];
1513:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(reg[10]);
1514:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** */
1515:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Display the rest as black...
1516:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		writeColor(0);
1517:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1518:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #else		//ROW_SEG_BUFFER
1519:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void drawPix(uint8_t rowNum)
1520:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1521:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1522:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (0<<COM1B1) | (1<<COM1B0)
1523:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	         | (1<<PWM1A) | (1<<PWM1B) );
1524:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1525:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		drawSegs();
1526:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1527:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1528:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DE->Nada transition expects fullBlue...
1529:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Also helps to show the edge of the DE timing...
1530:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1531:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1532:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1533:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1534:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          
1535:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Among the things that don't make sense...
1536:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// This appears to go into affect BEFORE delay_cyc (?)
1537:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// as, without a pull-up resistor on the /OC1B output, 
1538:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// green seems to be floating between the last pixel and the
1539:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// delay_cyc (!)
1540:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Disable complementary-output for Green 
1541:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1542:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
1543:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1544:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<COM1B1) | (0<<COM1B0)
1545:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****          | (1<<PWM1A) | (1<<PWM1B) );
1546:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1547:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		fullBlue();
1548:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1549:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif //0
1550:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1551:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1552:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1553:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //          G) groovy little spiral...
1554:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //
1555:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1556:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1557:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 159


1558:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Enable complementary-output for Green (on /OC1B, where CLK is OC1B)
1559:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1560:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 				   | (0<<COM1B1) | (1<<COM1B0)
1561:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 					| (1<<PWM1A) | (1<<PWM1B) );
1562:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1563:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1564:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8 early... appears to be syncing on Blue signal
1565:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // thus we get diagonal data including Hsync (colored in red) along the
1566:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // as a diagonal stripe at the right
1567:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_DIAG_BAR) && BLUE_DIAG_BAR)
1568:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1569:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1570:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t blueCyc = DOTS_TO_CYC(rowNum);
1571:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//uint16_t notBlueCyc = DOTS_TO_CYC(DE_ACTIVE_DOTS)-blueCyc;
1572:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t blueDots = rowNum;
1573:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		uint16_t notBlueDots = DE_ACTIVE_DOTS - blueDots;
1574:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1575:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1576:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(notBlueCyc);
1577:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(notBlueDots);
1578:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(notBlueDots);
1579:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1580:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(blueCyc);
1581:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(blueDots);
1582:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(blueDots);
1583:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1584:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1585:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1586:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1587:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-31ish: LooksPromising, but delayed
1588:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // also LVDS bit-shifts causing vertical striping
1589:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR) && BLUE_VERT_BAR)
1590:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1591:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1592:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromNada();
1593:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1594:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1595:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1596:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1597:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1598:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1599:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1600:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1601:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1602:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1603:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1604:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //a/o sdramThing2.0v8-32 nogo... syncs at end of blue instead of Hsync
1605:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_VERT_BAR_REVERSED) && BLUE_VERT_BAR_REVERSED)
1606:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1607:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1608:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1609:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)/3);
1610:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS/3);
1611:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS/3);
1612:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1613:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS)*2/3);
1614:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 160


1615:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - DE_ACTIVE_DOTS/3);
1616:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
1617:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1618:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1619:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1620:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1621:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(DE_BLUE) && DE_BLUE)
1622:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1623:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1624:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1625:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
1626:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//delay_Dots(DE_ACTIVE_DOTS);
1627:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS);
1628:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1629:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1630:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1631:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1632:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if(defined(BLUE_BORDER) && (BLUE_BORDER!=0))
1633:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** static __inline__ void drawPix(uint16_t rowNum)
1634:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1635:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromNada();
1636:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1637:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEonly_fromDEblue();
1638:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(DE_ACTIVE_DOTS - BLUE_BORDER*2);
1639:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DEblue_fromDEonly();
1640:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		DE_DotDelay(BLUE_BORDER);
1641:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEblue();
1642:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
1643:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1644:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1645:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0
1646:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //NOT BLUE_DIAG_BAR, BLUE_VERT_BAR, NOR DE_BLUE
1647:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #if ( defined(COLOR_BAR_SCROLL) && COLOR_BAR_SCROLL)
1648:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		if(rowNum <= 256)
1649:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=0;
1650:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		else
1651:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			rowNum=1;
1652:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #else //NOT COLOR_BAR_SCROLL... drawPix...
1653:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//#warning "see 'shouldBe' here..."
1654:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Should be:
1655:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		rowNum = rowNum*FB_HEIGHT/V_COUNT;
1656:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//rowNum = rowNum / (768/FB_HEIGHT);
1657:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #endif
1658:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1659:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//DEonly_fromNada();
1660:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       drawPix(rowNum);
1661:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Nada_init();
1662:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****  #warning "THIS ISN'T SAFE"
1663:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		Nada_fromDEonly();
1664:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//Drawing Methods...
1665:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1666:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #if 0 //(defined(CLOCK_INSENSITIVITY_TESTING) && CLOCK_INSENSITIVITY_TESTING)
1667:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//!!! Not sure what the state is at this point...
1668:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// could be any DE+Blue level, or could be NADA...
1669:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Nada: DT1=3, still leaves one bit for clocking, might be OK
1670:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1671:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       //Disable complementary-output for Green 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 161


1672:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//  (on /OC1B, where CLK is OC1B)
1673:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		// Since Nada, V, and H DT's might be bad for clocking.
1674:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
1675:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<COM1B1) | (0<<COM1B0)
1676:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****                | (1<<PWM1A) | (1<<PWM1B) );
1677:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1678:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1679:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//colorOverride removed in LVDS, revisit LCDdirect50
1680:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** #endif
1681:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1682:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1683:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1684:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // AND HERE!!!
1685:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1686:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** // rowNum is only used when DE is active...
1687:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** //  and should be 0 at *drawn row* 0
1688:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** void loadData(uint16_t rowNum, uint8_t dataEnable)
1689:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** {
1690:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	//H Active pulse...
1691:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(vSync)
 1903               		.stabn	68,0,1691,.LM194-.LFBB18
 1904               	.LM194:
 1905 082a 8091 0000 		lds r24,vSync
 1906 082e 8823      		tst r24
 1907 0830 01F0      		breq .L123
1692:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1693:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 		//Vsync_fromNada() is called at the end of the last interupt
1694:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       VplusH_fromVsync();
 1908               		.stabn	68,0,1694,.LM195-.LFBB18
 1909               	.LM195:
 1910 0832 1DBC      		out 77-0x20,__zero_reg__
 1911               	.LBB102:
 1912               	.LBB103:
 1913               	.LBB104:
 1914               	.LBB105:
 1915               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext10
 1916               	.Ltext10:
 1917               		.stabn	68,0,105,.LM196-.LFBB18
 1918               	.LM196:
 1919 0834 8FEA      		ldi r24,lo8(175)
 1920 0836 90E0      		ldi r25,hi8(175)
 1921               	/* #APP */
 1922               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1923 0838 0197      		1: sbiw r24,1
 1924 083a 01F4      		brne 1b
 1925               	 ;  0 "" 2
 1926               	/* #NOAPP */
 1927               	.LBE105:
 1928               	.LBE104:
 1929               	.LBE103:
 1930               	.LBE102:
 1931               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext11
 1932               	.Ltext11:
1695:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1696:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Vsync_fromVplusH();
 1933               		.stabn	68,0,1696,.LM197-.LFBB18
 1934               	.LM197:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 162


 1935 083c 85E0      		ldi r24,lo8(5)
 1936 083e 00C0      		rjmp .L134
 1937               	.L123:
1697:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1698:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1699:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    else
1700:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    {
1701:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hsync_fromNada();
 1938               		.stabn	68,0,1701,.LM198-.LFBB18
 1939               	.LM198:
 1940 0840 83E0      		ldi r24,lo8(3)
 1941 0842 8DBD      		out 77-0x20,r24
 1942               	.LBB106:
 1943               	.LBB107:
 1944               	.LBB108:
 1945               	.LBB109:
 1946               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext12
 1947               	.Ltext12:
 1948               		.stabn	68,0,105,.LM199-.LFBB18
 1949               	.LM199:
 1950 0844 8FEA      		ldi r24,lo8(175)
 1951 0846 90E0      		ldi r25,hi8(175)
 1952               	/* #APP */
 1953               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1954 0848 0197      		1: sbiw r24,1
 1955 084a 01F4      		brne 1b
 1956               	 ;  0 "" 2
 1957               	/* #NOAPP */
 1958               	.LBE109:
 1959               	.LBE108:
 1960               	.LBE107:
 1961               	.LBE106:
 1962               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext13
 1963               	.Ltext13:
1702:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Hlow_Delay();
1703:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       Nada_fromHsync();
 1964               		.stabn	68,0,1703,.LM200-.LFBB18
 1965               	.LM200:
 1966 084c 84E0      		ldi r24,lo8(4)
 1967               	.L134:
 1968 084e 8DBD      		out 77-0x20,r24
 1969               	.LBB110:
 1970               	.LBB111:
 1971               	.LBB112:
 1972               	.LBB113:
 1973               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h",132,0,0,.Ltext14
 1974               	.Ltext14:
 1975               		.stabn	68,0,105,.LM201-.LFBB18
 1976               	.LM201:
 1977 0850 88E5      		ldi r24,lo8(88)
 1978 0852 90E0      		ldi r25,hi8(88)
 1979               	/* #APP */
 1980               	 ;  105 "/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/util/delay_basic.h" 1
 1981 0854 0197      		1: sbiw r24,1
 1982 0856 01F4      		brne 1b
 1983               	 ;  0 "" 2
 1984               	/* #NOAPP */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 163


 1985               	.LBE113:
 1986               	.LBE112:
 1987               	.LBE111:
 1988               	.LBE110:
 1989               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext15
 1990               	.Ltext15:
1704:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****       HD_Delay();
1705:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    }
1706:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 
1707:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c ****    if(dataEnable)
 1991               		.stabn	68,0,1707,.LM202-.LFBB18
 1992               	.LM202:
 1993 0858 2223      		tst r18
 1994 085a 01F4      		brne .+2
 1995 085c 00C0      		rjmp .L125
 1996               	.LBB114:
 1997               	.LBB115:
 1998               		.stabs	"main.c",132,0,0,.Ltext16
 1999               	.Ltext16:
3762:main.c        **** 	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 2000               		.stabn	68,0,3762,.LM203-.LFBB18
 2001               	.LM203:
 2002 085e 83E5      		ldi r24,lo8(83)
 2003 0860 80BF      		out 80-0x20,r24
 2004               	.LBB116:
 2005               	.LBB117:
 2006               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext17
 2007               	.Ltext17:
 400:rowSegBuffer.c **** 
 401:rowSegBuffer.c **** 
 402:rowSegBuffer.c **** static __inline__ \
 403:rowSegBuffer.c **** void drawSegs(void) \
 404:rowSegBuffer.c **** 	__attribute__((__always_inline__));
 405:rowSegBuffer.c **** 
 406:rowSegBuffer.c **** 
 407:rowSegBuffer.c **** void drawSegs(void)
 408:rowSegBuffer.c **** {
 409:rowSegBuffer.c **** #warning "This might need to be modified such that DE is active *with* the first pixel... and compl
 410:rowSegBuffer.c **** 	//Declared volatile *just in case* I decide to use it after the asm...
 411:rowSegBuffer.c **** 	// (as modified by the asm)
 412:rowSegBuffer.c **** 	volatile uint8_t *byteptr = &(rowSegBuffer[0].red_length);
 413:rowSegBuffer.c **** 
 414:rowSegBuffer.c **** 	//These should only be used in the asm...
 415:rowSegBuffer.c **** 	// declaring them here, instead of using specific registers in asm
 416:rowSegBuffer.c **** 	// should help assure that those registers aren't clobbered
 417:rowSegBuffer.c **** 	// if used elsewhere
 418:rowSegBuffer.c **** 	//volatile uint8_t r=0, rl=0, g=0, b=0;
 419:rowSegBuffer.c **** 
 420:rowSegBuffer.c **** 	//uint8_t r, rl, g, b;
 421:rowSegBuffer.c **** 
 422:rowSegBuffer.c **** 	//Basic idea:
 423:rowSegBuffer.c **** 
 424:rowSegBuffer.c **** 	//do{
 425:rowSegBuffer.c **** 	//  red_length = rowSegBuffer[n].red_length;
 426:rowSegBuffer.c **** 	//  green      = rowSegBuffer[n].green;
 427:rowSegBuffer.c **** 	//  blue       = rowSegBuffer[n].blue;
 428:rowSegBuffer.c **** 	//  
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 164


 429:rowSegBuffer.c **** 	//  OCR1D = red_length&0x0f;
 430:rowSegBuffer.c **** 	//  DT1   = green;
 431:rowSegBuffer.c **** 	//  OCR1A = blue;
 432:rowSegBuffer.c **** 	//
 433:rowSegBuffer.c **** 	//  red_length &= 0xf0;
 434:rowSegBuffer.c **** 	//  if(!red_length)
 435:rowSegBuffer.c **** 	//     break;
 436:rowSegBuffer.c **** 	//
 437:rowSegBuffer.c **** 	//  while(red_length)
 438:rowSegBuffer.c **** 	//		red_length -= 0x10;
 439:rowSegBuffer.c **** 	// } while(1);
 440:rowSegBuffer.c **** 
 441:rowSegBuffer.c **** 	//This looks like it should work...
 442:rowSegBuffer.c **** 	// but there are some oddities
 443:rowSegBuffer.c **** 	// in this case, registers are loaded such that andi can't be used
 444:rowSegBuffer.c **** 	// but and can... thus it's a few instructions larger...
 445:rowSegBuffer.c **** 	/*
 446:rowSegBuffer.c **** 	do
 447:rowSegBuffer.c **** 	{
 448:rowSegBuffer.c **** 		rl = *(byteptr++);
 449:rowSegBuffer.c **** 		r = rl;
 450:rowSegBuffer.c **** 		r &= 0x0f;
 451:rowSegBuffer.c **** 		g = *(byteptr++);
 452:rowSegBuffer.c **** 		b = *(byteptr++);
 453:rowSegBuffer.c **** 
 454:rowSegBuffer.c **** 		//just testing pushes and pops...
 455:rowSegBuffer.c **** 		// apparently the optimizer realizes which registers are in use
 456:rowSegBuffer.c **** 		// in the (only) call to drawSegs() and doesn't bother to push the
 457:rowSegBuffer.c **** 		// the rest...
 458:rowSegBuffer.c **** //		drawSegs();
 459:rowSegBuffer.c **** 		OCR1D = r;
 460:rowSegBuffer.c **** 		DT1 = g;
 461:rowSegBuffer.c **** 		OCR1A = b;
 462:rowSegBuffer.c **** 
 463:rowSegBuffer.c **** 		rl &= 0xf0;
 464:rowSegBuffer.c **** 
 465:rowSegBuffer.c **** 		if(!rl)
 466:rowSegBuffer.c **** 			break;
 467:rowSegBuffer.c **** 
 468:rowSegBuffer.c **** 		while(rl)
 469:rowSegBuffer.c **** 			rl -= 0x10;
 470:rowSegBuffer.c **** 	} while(1);
 471:rowSegBuffer.c **** */
 472:rowSegBuffer.c **** 
 473:rowSegBuffer.c **** 	//LoadNext:
 474:rowSegBuffer.c **** 	//  ld   Rredlength, Z+	(Red|length)								2
 475:rowSegBuffer.c **** 	//  ld   Rgreen, Z+	(Green)											2
 476:rowSegBuffer.c **** 	//  ld   Rblue, Z+	(Blue)											2
 477:rowSegBuffer.c **** 	//	 mov  Rred, Rredlength												1
 478:rowSegBuffer.c **** 	//  andi Rred, 0x0f				//Remove length from Rred		1
 479:rowSegBuffer.c **** 	//  out  OCR1D, Rred														1
 480:rowSegBuffer.c **** 	//  out  DT1, Rgreen														1
 481:rowSegBuffer.c **** 	//  out  OCR1A, Rblue													1
 482:rowSegBuffer.c **** 
 483:rowSegBuffer.c **** 	//  andi Rredlength, 0xf0		//Remove red from length		1
 484:rowSegBuffer.c **** 	//  breq Done						// if length==0, we're done	1 2
 485:rowSegBuffer.c **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 165


 486:rowSegBuffer.c **** 	//Counter:
 487:rowSegBuffer.c **** 	//  subi Rlength, 0x10			//Subtract 0x10 each time...	1
 488:rowSegBuffer.c **** 	//  breq LoadNext					// if length==0, next segment	1 2
 489:rowSegBuffer.c **** 	//  rjmp Counter					// else, next counter loop    2
 490:rowSegBuffer.c **** 
 491:rowSegBuffer.c **** 	//Done:
 492:rowSegBuffer.c **** 
 493:rowSegBuffer.c **** 	// Thus, minimum inter-pixel time is 16 clock cycles
 494:rowSegBuffer.c **** 	// (14 for the last one)
 495:rowSegBuffer.c **** 	// This cannot be reuced by using a separate byte for red and length
 496:rowSegBuffer.c **** 	// because the mov and andi in LoadNext would be replaced by a ld
 497:rowSegBuffer.c **** 
 498:rowSegBuffer.c **** 	// To make the counter take longer between each count,
 499:rowSegBuffer.c **** 	// decrement it by a smaller number...
 500:rowSegBuffer.c **** 
 501:rowSegBuffer.c **** //	drawSegs();
 502:rowSegBuffer.c **** /*
 503:rowSegBuffer.c **** __asm__ __volatile__
 504:rowSegBuffer.c **** 	(
 505:rowSegBuffer.c **** 	"LoadNext_%=: \n\t"
 506:rowSegBuffer.c **** 	 	"ld %1, %a0+ ; \n\t"		//%a1 refers to XYZ whichever is selected
 507:rowSegBuffer.c **** 		"mov %2, %1 ; \n\t"		// Load R (+length)
 508:rowSegBuffer.c **** 		"andi %2, 0x0f ; \n\t"	//Remove length from Rred
 509:rowSegBuffer.c **** 		"ld %3, %a0+ ; \n\t"		//Load G	
 510:rowSegBuffer.c **** 		"ld %4, %a0+ ; \n\t"		//Load B
 511:rowSegBuffer.c **** 		"out %5, %2 ; \n\t"	// Write OCR1D (Red)
 512:rowSegBuffer.c **** 		"out %6, %3 ; \n\t"		// Write DT1 (Green)
 513:rowSegBuffer.c **** 		"out %7, %4 ; \n\t"	// Write OCR1A (Blue)
 514:rowSegBuffer.c **** 
 515:rowSegBuffer.c **** 		"andi %1, 0xf0 ; \n\t"	// Remove red from length
 516:rowSegBuffer.c **** 		"breq Done_%= ; \n\t"		// if length==0 from the start, we're done
 517:rowSegBuffer.c **** 
 518:rowSegBuffer.c **** 	"Counter_%=: \n\t"
 519:rowSegBuffer.c **** 		"subi %1, 0x10 ; \n\t"	//Decrement the counter by 0x10
 520:rowSegBuffer.c **** 		"breq LoadNext_%= ; \n\t"	// if we've decremented to 0, next segment
 521:rowSegBuffer.c **** 
 522:rowSegBuffer.c **** 	"Done_%=: \n\t"
 523:rowSegBuffer.c **** 		:								//No output register...
 524:rowSegBuffer.c **** 		: "e" (byteptr),			//byteptr: %0, r/w and assigned to X,Y,orZ
 525:rowSegBuffer.c **** 		  "d"  (rl),				//rl: %1, andi and subi will be used
 526:rowSegBuffer.c **** 		  "d"  (r),					//r: %2, andi will be used
 527:rowSegBuffer.c **** 		  "r"  (g),					//g: %3
 528:rowSegBuffer.c **** 		  "r"  (b),					//b: %4
 529:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1D)), //OCR1D: %5
 530:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(DT1)),	//DT1: %6
 531:rowSegBuffer.c **** 		  "I"  (_SFR_IO_ADDR(OCR1A))	//OCR1A %7
 532:rowSegBuffer.c **** 	);
 533:rowSegBuffer.c **** */
 534:rowSegBuffer.c **** 
 535:rowSegBuffer.c **** __asm__ __volatile__
 2008               		.stabn	68,0,535,.LM204-.LFBB18
 2009               	.LM204:
 2010 0862 E0E0      		ldi r30,lo8(rowSegBuffer)
 2011 0864 F0E0      		ldi r31,hi8(rowSegBuffer)
 2012               	/* #APP */
 2013               	 ;  535 "rowSegBuffer.c" 1
 2014               		LoadNext_1193: 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 166


 2015 0866 4191      		ld r20, Z+ ; 
 2016 0868 542F      		mov r21, r20 ; 
 2017 086a 5770      		andi r21, 7 ; 
 2018 086c 6191      		ld r22, Z+ ; 
 2019 086e 762F      		mov r23, r22 ; 
 2020 0870 6F70      		andi r22, 0x0f ; 
 2021 0872 7295      		swap r23 ; 
 2022 0874 7F70      		andi r23, 0x0f 
 2023 0876 5ABD      		out 42, r21 ; 
 2024 0878 64BD      		out 36, r22 ; 
 2025 087a 7DBD      		out 45, r23 ; 
 2026 087c 487F      		andi r20, 248 ; 
 2027 087e 01F0      		breq Done_1193 ; 
 2028 0880 0000      		nop ; 
 2029 0882 0000      		nop ; 
 2030               		Counter_1193: 
 2031 0884 4850      		subi r20, 8 ; 
 2032 0886 01F0      		breq LoadNext_1193 ; 
 2033 0888 0000      		nop ; 
 2034 088a 0000      		nop ; 
 2035 088c 0000      		nop ; 
 2036 088e 0000      		nop ; 
 2037 0890 0000      		nop ; 
 2038 0892 0000      		nop ; 
 2039 0894 0000      		nop ; 
 2040 0896 0000      		nop ; 
 2041 0898 0000      		nop ; 
 2042 089a 0000      		nop ; 
 2043 089c 0000      		nop ; 
 2044 089e 0000      		nop ; 
 2045 08a0 0000      		nop ; 
 2046 08a2 0000      		nop ; 
 2047 08a4 0000      		nop ; 
 2048 08a6 0000      		nop ; 
 2049 08a8 00C0      		rjmp Counter_1193 ; 
 2050               		Done_1193: 
 2051               		
 2052               	 ;  0 "" 2
 2053               	/* #NOAPP */
 2054               	.LBE117:
 2055               	.LBE116:
 2056               		.stabs	"main.c",132,0,0,.Ltext18
 2057               	.Ltext18:
3806:main.c        **** 		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
 2058               		.stabn	68,0,3806,.LM205-.LFBB18
 2059               	.LM205:
 2060 08aa 83E6      		ldi r24,lo8(99)
 2061 08ac 80BF      		out 80-0x20,r24
3810:main.c        **** 		fullBlue();
 2062               		.stabn	68,0,3810,.LM206-.LFBB18
 2063               	.LM206:
 2064 08ae 14BC      		out 68-0x20,__zero_reg__
 2065 08b0 86E0      		ldi r24,lo8(6)
 2066 08b2 8DBD      		out 77-0x20,r24
3811:main.c        **** 		Nada_fromDEonly();
 2067               		.stabn	68,0,3811,.LM207-.LFBB18
 2068               	.LM207:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 167


 2069 08b4 80E3      		ldi r24,lo8(48)
 2070 08b6 84BD      		out 68-0x20,r24
 2071               	.L125:
 2072               	.LBE115:
 2073               	.LBE114:
 2074               	.LBE101:
 2075               	.LBE100:
 2076               		.stabs	"_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c",132,0,0,.Ltext19
 2077               	.Ltext19:
1187:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	hsyncCount++;
 2078               		.stabn	68,0,1187,.LM208-.LFBB18
 2079               	.LM208:
 2080 08b8 8091 0000 		lds r24,hsyncCount
 2081 08bc 9091 0000 		lds r25,(hsyncCount)+1
 2082 08c0 0196      		adiw r24,1
 2083 08c2 9093 0000 		sts (hsyncCount)+1,r25
 2084 08c6 8093 0000 		sts hsyncCount,r24
1189:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 	switch(hsyncCount)
 2085               		.stabn	68,0,1189,.LM209-.LFBB18
 2086               	.LM209:
 2087 08ca 8332      		cpi r24,35
 2088 08cc 9105      		cpc r25,__zero_reg__
 2089 08ce 01F0      		breq .L128
 2090 08d0 8432      		cpi r24,36
 2091 08d2 9105      		cpc r25,__zero_reg__
 2092 08d4 00F4      		brsh .L131
 2093 08d6 8330      		cpi r24,3
 2094 08d8 9105      		cpc r25,__zero_reg__
 2095 08da 01F4      		brne .L135
 2096 08dc 00C0      		rjmp .L138
 2097               	.L131:
 2098 08de 8632      		cpi r24,38
 2099 08e0 9105      		cpc r25,__zero_reg__
 2100 08e2 01F0      		breq .L129
 2101 08e4 23E0      		ldi r18,hi8(806)
 2102 08e6 8632      		cpi r24,lo8(806)
 2103 08e8 9207      		cpc r25,r18
 2104 08ea 01F4      		brne .L135
 2105 08ec 00C0      		rjmp .L139
 2106               	.L138:
1195:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 2107               		.stabn	68,0,1195,.LM210-.LFBB18
 2108               	.LM210:
 2109 08ee 1092 0000 		sts dataEnable,__zero_reg__
1197:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = TRUE;
 2110               		.stabn	68,0,1197,.LM211-.LFBB18
 2111               	.LM211:
 2112 08f2 81E0      		ldi r24,lo8(1)
 2113 08f4 8093 0000 		sts vSync,r24
1198:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Vsync_fromNada();
 2114               		.stabn	68,0,1198,.LM212-.LFBB18
 2115               	.LM212:
 2116 08f8 80E4      		ldi r24,lo8(64)
 2117 08fa 84BD      		out 68-0x20,r24
 2118 08fc 85E0      		ldi r24,lo8(5)
 2119 08fe 00C0      		rjmp .L136
 2120               	.L128:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 168


1207:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			vSync = FALSE;
 2121               		.stabn	68,0,1207,.LM213-.LFBB18
 2122               	.LM213:
 2123 0900 1092 0000 		sts vSync,__zero_reg__
1208:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			Nada_fromVsync();
 2124               		.stabn	68,0,1208,.LM214-.LFBB18
 2125               	.LM214:
 2126 0904 80E3      		ldi r24,lo8(48)
 2127 0906 84BD      		out 68-0x20,r24
 2128 0908 84E0      		ldi r24,lo8(4)
 2129               	.L136:
 2130 090a 8DBD      		out 77-0x20,r24
 2131 090c 00C0      		rjmp .L135
 2132               	.L129:
1212:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = TRUE;
 2133               		.stabn	68,0,1212,.LM215-.LFBB18
 2134               	.LM215:
 2135 090e 81E0      		ldi r24,lo8(1)
 2136 0910 8093 0000 		sts dataEnable,r24
 2137               	.L135:
 2138 0914 80E0      		ldi r24,lo8(0)
1213:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			break;
 2139               		.stabn	68,0,1213,.LM216-.LFBB18
 2140               	.LM216:
 2141 0916 0895      		ret
 2142               	.L139:
1217:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			dataEnable = FALSE;
 2143               		.stabn	68,0,1217,.LM217-.LFBB18
 2144               	.LM217:
 2145 0918 1092 0000 		sts dataEnable,__zero_reg__
1222:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** 			hsyncCount = 0;
 2146               		.stabn	68,0,1222,.LM218-.LFBB18
 2147               	.LM218:
 2148 091c 1092 0000 		sts (hsyncCount)+1,__zero_reg__
 2149 0920 1092 0000 		sts hsyncCount,__zero_reg__
 2150 0924 81E0      		ldi r24,lo8(1)
1263:_commonCode_localized/lcdStuff/0.51ncf-git/lcdStuff.c **** }
 2151               		.stabn	68,0,1263,.LM219-.LFBB18
 2152               	.LM219:
 2153 0926 0895      		ret
 2154               		.size	updateLCD, .-updateLCD
 2155               		.stabs	"frameComplete:r(3,2)",64,0,1167,24
 2156               		.stabn	192,0,0,.LFBB18-.LFBB18
 2157               		.stabs	"__count:r(3,4)",64,0,1567,24
 2158               		.stabn	192,0,0,.LBB104-.LFBB18
 2159               		.stabn	224,0,0,.LBE104-.LFBB18
 2160               		.stabs	"__count:r(3,4)",64,0,1567,24
 2161               		.stabn	192,0,0,.LBB108-.LFBB18
 2162               		.stabn	224,0,0,.LBE108-.LFBB18
 2163               		.stabs	"__count:r(3,4)",64,0,1567,24
 2164               		.stabn	192,0,0,.LBB112-.LFBB18
 2165               		.stabn	224,0,0,.LBE112-.LFBB18
 2166               		.stabn	224,0,0,.Lscope18-.LFBB18
 2167               	.Lscope18:
 2168               		.stabs	"",36,0,0,.Lscope18-.LFBB18
 2169               		.stabd	78,0,0
 2170               		.stabs	"init_timer0Hsync:F(0,15)",36,0,2972,init_timer0Hsync
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 169


 2171               	.global	init_timer0Hsync
 2172               		.type	init_timer0Hsync, @function
 2173               	init_timer0Hsync:
 2174               		.stabd	46,0,0
 2175               		.stabs	"main.c",132,0,0,.Ltext20
 2176               	.Ltext20:
2973:main.c        **** {
 2177               		.stabn	68,0,2973,.LM220-.LFBB19
 2178               	.LM220:
 2179               	.LFBB19:
 2180               	/* prologue: function */
 2181               	/* frame size = 0 */
3093:main.c        ****    OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
 2182               		.stabn	68,0,3093,.LM221-.LFBB19
 2183               	.LM221:
 2184 0928 83EE      		ldi r24,lo8(-29)
 2185 092a 83BB      		out 51-0x20,r24
3094:main.c        **** 	timer_setWGM(0, WGM_CLR_ON_COMPARE);
 2186               		.stabn	68,0,3094,.LM222-.LFBB19
 2187               	.LM222:
 2188 092c 80E0      		ldi r24,lo8(0)
 2189 092e 62E0      		ldi r22,lo8(2)
 2190 0930 00D0      		rcall timer_setWGM
3095:main.c        ****    timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
 2191               		.stabn	68,0,3095,.LM223-.LFBB19
 2192               	.LM223:
 2193 0932 80E0      		ldi r24,lo8(0)
 2194 0934 68E0      		ldi r22,lo8(8)
 2195 0936 00D0      		rcall timer_selectDivisor
3096:main.c        ****    timer_compareMatchIntEnable(0, OUT_CHANNELA);
 2196               		.stabn	68,0,3096,.LM224-.LFBB19
 2197               	.LM224:
 2198 0938 80E0      		ldi r24,lo8(0)
 2199 093a 60E0      		ldi r22,lo8(0)
 2200 093c 41E0      		ldi r20,lo8(1)
 2201 093e 00D0      		rcall timer_compareMatchIntSetup
 2202               	/* epilogue start */
3097:main.c        **** }
 2203               		.stabn	68,0,3097,.LM225-.LFBB19
 2204               	.LM225:
 2205 0940 0895      		ret
 2206               		.size	init_timer0Hsync, .-init_timer0Hsync
 2207               	.Lscope19:
 2208               		.stabs	"",36,0,0,.Lscope19-.LFBB19
 2209               		.stabd	78,0,0
 2210               		.stabs	"main:F(0,1)",36,0,4077,main
 2211               	.global	main
 2212               		.type	main, @function
 2213               	main:
 2214               		.stabd	46,0,0
4078:main.c        **** {
 2215               		.stabn	68,0,4078,.LM226-.LFBB20
 2216               	.LM226:
 2217               	.LFBB20:
 2218               	/* prologue: function */
 2219               	/* frame size = 0 */
4081:main.c        **** 	adc_takeInput(6);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 170


 2220               		.stabn	68,0,4081,.LM227-.LFBB20
 2221               	.LM227:
 2222 0942 86E0      		ldi r24,lo8(6)
 2223 0944 00D0      		rcall adc_takeInput
4082:main.c        **** 	adc_init();
 2224               		.stabn	68,0,4082,.LM228-.LFBB20
 2225               	.LM228:
 2226 0946 00D0      		rcall adc_init
4083:main.c        **** 	adc_select(6);
 2227               		.stabn	68,0,4083,.LM229-.LFBB20
 2228               	.LM229:
 2229 0948 86E0      		ldi r24,lo8(6)
 2230 094a 00D0      		rcall adc_select
4086:main.c        **** 	tetInit(7);
 2231               		.stabn	68,0,4086,.LM230-.LFBB20
 2232               	.LM230:
 2233 094c 87E0      		ldi r24,lo8(7)
 2234 094e 00D0      		rcall tetInit
4088:main.c        **** 	init_timer0Hsync();
 2235               		.stabn	68,0,4088,.LM231-.LFBB20
 2236               	.LM231:
 2237 0950 00D0      		rcall init_timer0Hsync
4095:main.c        **** 	lvds_timerInit();
 2238               		.stabn	68,0,4095,.LM232-.LFBB20
 2239               	.LM232:
 2240 0952 00D0      		rcall lvds_timerInit
4118:main.c        **** 	setoutPORT(PA0, PORTA);
 2241               		.stabn	68,0,4118,.LM233-.LFBB20
 2242               	.LM233:
 2243 0954 D09A      		sbi 58-0x20,0
4119:main.c        **** 	setoutPORT(PA1, PORTA);
 2244               		.stabn	68,0,4119,.LM234-.LFBB20
 2245               	.LM234:
 2246 0956 D19A      		sbi 58-0x20,1
4121:main.c        **** 	setoutPORT(PA2, PORTA);
 2247               		.stabn	68,0,4121,.LM235-.LFBB20
 2248               	.LM235:
 2249 0958 D29A      		sbi 58-0x20,2
4122:main.c        **** 	setoutPORT(PA3, PORTA);
 2250               		.stabn	68,0,4122,.LM236-.LFBB20
 2251               	.LM236:
 2252 095a D39A      		sbi 58-0x20,3
 2253               	.L145:
4219:main.c        **** 		if(frameCount==0 && !getbit(OCIE0A, T0_TIMSK))
 2254               		.stabn	68,0,4219,.LM237-.LFBB20
 2255               	.LM237:
 2256 095c 8091 0000 		lds r24,frameCount
 2257 0960 8823      		tst r24
 2258 0962 01F4      		brne .L143
 2259               	.L148:
 2260 0964 89B7      		in r24,89-0x20
 2261 0966 8071      		andi r24,lo8(16)
 2262 0968 01F4      		brne .L148
4273:main.c        **** 			timer_compareMatchIntEnable(0, OUT_CHANNELA);
 2263               		.stabn	68,0,4273,.LM238-.LFBB20
 2264               	.LM238:
 2265 096a 60E0      		ldi r22,lo8(0)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 171


 2266 096c 41E0      		ldi r20,lo8(1)
 2267 096e 00D0      		rcall timer_compareMatchIntSetup
 2268 0970 00C0      		rjmp .L145
 2269               	.L143:
 2270               	.L150:
 2271 0972 00C0      		rjmp .L150
 2272               		.size	main, .-main
 2273               	.Lscope20:
 2274               		.stabs	"",36,0,0,.Lscope20-.LFBB20
 2275               		.stabd	78,0,0
 2276               		.stabs	"__vector_14:F(0,15)",36,0,1984,__vector_14
 2277               	.global	__vector_14
 2278               		.type	__vector_14, @function
 2279               	__vector_14:
 2280               		.stabd	46,0,0
1985:main.c        **** {
 2281               		.stabn	68,0,1985,.LM239-.LFBB21
 2282               	.LM239:
 2283               	.LFBB21:
 2284 0974 1F92      		push __zero_reg__
 2285 0976 0F92      		push r0
 2286 0978 0FB6      		in r0,__SREG__
 2287 097a 0F92      		push r0
 2288 097c 1124      		clr __zero_reg__
 2289 097e 4F92      		push r4
 2290 0980 5F92      		push r5
 2291 0982 6F92      		push r6
 2292 0984 7F92      		push r7
 2293 0986 8F92      		push r8
 2294 0988 9F92      		push r9
 2295 098a AF92      		push r10
 2296 098c BF92      		push r11
 2297 098e CF92      		push r12
 2298 0990 DF92      		push r13
 2299 0992 EF92      		push r14
 2300 0994 FF92      		push r15
 2301 0996 0F93      		push r16
 2302 0998 1F93      		push r17
 2303 099a 2F93      		push r18
 2304 099c 3F93      		push r19
 2305 099e 4F93      		push r20
 2306 09a0 5F93      		push r21
 2307 09a2 6F93      		push r22
 2308 09a4 7F93      		push r23
 2309 09a6 8F93      		push r24
 2310 09a8 9F93      		push r25
 2311 09aa AF93      		push r26
 2312 09ac BF93      		push r27
 2313 09ae EF93      		push r30
 2314 09b0 FF93      		push r31
 2315 09b2 DF93      		push r29
 2316 09b4 CF93      		push r28
 2317 09b6 CDB7      		in r28,__SP_L__
 2318 09b8 DEB7      		in r29,__SP_H__
 2319 09ba AD97      		sbiw r28,45
 2320 09bc DEBF      		out __SP_H__, r29
 2321 09be CDBF      		out __SP_L__, r28
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 172


 2322               	/* prologue: Signal */
 2323               	/* frame size = 45 */
1997:main.c        **** 	if(updateLCD())
 2324               		.stabn	68,0,1997,.LM240-.LFBB21
 2325               	.LM240:
 2326 09c0 00D0      		rcall updateLCD
 2327 09c2 8823      		tst r24
 2328 09c4 01F0      		breq .L152
2001:main.c        **** 			frameCount++;
 2329               		.stabn	68,0,2001,.LM241-.LFBB21
 2330               	.LM241:
 2331 09c6 8091 0000 		lds r24,frameCount.2371
 2332 09ca 8F5F      		subi r24,lo8(-(1))
 2333 09cc 8093 0000 		sts frameCount.2371,r24
2002:main.c        **** 			if(frameCount == FRAME_COUNT_TO_DELAY)
 2334               		.stabn	68,0,2002,.LM242-.LFBB21
 2335               	.LM242:
 2336 09d0 8230      		cpi r24,lo8(2)
 2337 09d2 01F4      		brne .L152
2004:main.c        **** 				frameCount = 0;
 2338               		.stabn	68,0,2004,.LM243-.LFBB21
 2339               	.LM243:
 2340 09d4 1092 0000 		sts frameCount.2371,__zero_reg__
2005:main.c        **** 				timer_compareMatchIntSetup(0, OUT_CHANNELA, FALSE);
 2341               		.stabn	68,0,2005,.LM244-.LFBB21
 2342               	.LM244:
 2343 09d8 80E0      		ldi r24,lo8(0)
 2344 09da 60E0      		ldi r22,lo8(0)
 2345 09dc 40E0      		ldi r20,lo8(0)
 2346 09de 00D0      		rcall timer_compareMatchIntSetup
 2347               	.L152:
2014:main.c        **** 	if((hsyncCount >= T_VD+T_Vlow) && (hsyncCount < T_VD+T_Vlow+V_COUNT))
 2348               		.stabn	68,0,2014,.LM245-.LFBB21
 2349               	.LM245:
 2350 09e0 0091 0000 		lds r16,hsyncCount
 2351 09e4 1091 0000 		lds r17,(hsyncCount)+1
 2352 09e8 0352      		subi r16,lo8(-(-35))
 2353 09ea 1040      		sbci r17,hi8(-(-35))
 2354 09ec 33E0      		ldi r19,hi8(768)
 2355 09ee 0030      		cpi r16,lo8(768)
 2356 09f0 1307      		cpc r17,r19
 2357 09f2 00F0      		brlo .+2
 2358 09f4 00C0      		rjmp .L194
 2359               	.LBB124:
 2360               	.LBB125:
2232:main.c        **** 	adc_startConversion();
 2361               		.stabn	68,0,2232,.LM246-.LFBB21
 2362               	.LM246:
 2363 09f6 00D0      		rcall adc_startConversion
 2364 09f8 00C0      		rjmp .L154
 2365               	.L155:
2234:main.c        **** 		asm("nop;");
 2366               		.stabn	68,0,2234,.LM247-.LFBB21
 2367               	.LM247:
 2368               	/* #APP */
 2369               	 ;  2234 "main.c" 1
 2370 09fa 0000      		nop;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 173


 2371               	 ;  0 "" 2
 2372               	/* #NOAPP */
 2373               	.L154:
2233:main.c        **** 	while(adc_isBusy())
 2374               		.stabn	68,0,2233,.LM248-.LFBB21
 2375               	.LM248:
 2376 09fc 00D0      		rcall adc_isBusy
 2377 09fe 8823      		tst r24
 2378 0a00 01F4      		brne .L155
2235:main.c        **** 	racerPseg = (adc_getValue()>>2)+5;
 2379               		.stabn	68,0,2235,.LM249-.LFBB21
 2380               	.LM249:
 2381 0a02 00D0      		rcall adc_getValue
 2382 0a04 4C01      		movw r8,r24
 2383 0a06 9694      		lsr r9
 2384 0a08 8794      		ror r8
 2385 0a0a 9694      		lsr r9
 2386 0a0c 8794      		ror r8
 2387 0a0e 45E0      		ldi r20,lo8(5)
 2388 0a10 50E0      		ldi r21,hi8(5)
 2389 0a12 840E      		add r8,r20
 2390 0a14 951E      		adc r9,r21
 2391 0a16 54E6      		ldi r21,lo8(356)
 2392 0a18 8516      		cp r8,r21
 2393 0a1a 51E0      		ldi r21,hi8(356)
 2394 0a1c 9506      		cpc r9,r21
 2395 0a1e 04F0      		brlt .L156
 2396 0a20 A3E6      		ldi r26,lo8(355)
 2397 0a22 8A2E      		mov r8,r26
 2398 0a24 A1E0      		ldi r26,hi8(355)
 2399 0a26 9A2E      		mov r9,r26
 2400               	.L156:
 2401               	.LBB126:
 2402               	.LBB127:
 2403               		.stabs	"rowSegBuffer.c",132,0,0,.Ltext21
 2404               	.Ltext21:
 159:rowSegBuffer.c **** 	segPosition = 0;
 2405               		.stabn	68,0,159,.LM250-.LFBB21
 2406               	.LM250:
 2407 0a28 1092 0000 		sts segPosition,__zero_reg__
 162:rowSegBuffer.c **** 	rowSegBuffer[segPosition].red_length = 6;
 2408               		.stabn	68,0,162,.LM251-.LFBB21
 2409               	.LM251:
 2410 0a2c 86E0      		ldi r24,lo8(6)
 2411 0a2e 8093 0000 		sts rowSegBuffer,r24
 163:rowSegBuffer.c **** 	rowSegBuffer[segPosition].green_blue = (6<<4) | 3;
 2412               		.stabn	68,0,163,.LM252-.LFBB21
 2413               	.LM252:
 2414 0a32 83E6      		ldi r24,lo8(99)
 2415 0a34 8093 0000 		sts rowSegBuffer+1,r24
 2416               	.LBE127:
 2417               	.LBE126:
 2418               		.stabs	"main.c",132,0,0,.Ltext22
 2419               	.Ltext22:
2240:main.c        **** 	addSegfb(1, _W);
 2420               		.stabn	68,0,2240,.LM253-.LFBB21
 2421               	.LM253:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 174


 2422 0a38 81E0      		ldi r24,lo8(1)
 2423 0a3a 90E0      		ldi r25,hi8(1)
 2424 0a3c 67E0      		ldi r22,lo8(7)
 2425 0a3e 43E7      		ldi r20,lo8(115)
 2426 0a40 00D0      		rcall addSeg
2252:main.c        **** 	uint8_t thisPosition = thisTrackRow + (trackPosition? TRACK_LENGTH : 0);
 2427               		.stabn	68,0,2252,.LM254-.LFBB21
 2428               	.LM254:
 2429 0a42 8091 0000 		lds r24,trackPosition.2391
 2430 0a46 8823      		tst r24
 2431 0a48 01F4      		brne .+2
 2432 0a4a 00C0      		rjmp .L157
 2433 0a4c 28E1      		ldi r18,lo8(24)
 2434 0a4e 90E0      		ldi r25,lo8(0)
 2435               	.L193:
2279:main.c        **** 	  {0,_W}, {0,_W}, {0,_W}, {0,_W}, {0,_W} };
 2436               		.stabn	68,0,2279,.LM255-.LFBB21
 2437               	.LM255:
 2438 0a50 DE01      		movw r26,r28
 2439 0a52 1196      		adiw r26,1
 2440 0a54 E0E0      		ldi r30,lo8(C.60.2448)
 2441 0a56 F0E0      		ldi r31,hi8(C.60.2448)
 2442 0a58 8DE2      		ldi r24,lo8(45)
 2443               	.L158:
 2444 0a5a 0190      		ld r0,Z+
 2445 0a5c 0D92      		st X+,r0
 2446 0a5e 8150      		subi r24,lo8(-(-1))
 2447 0a60 01F4      		brne .L158
2301:main.c        **** 	if(rowNum%TRACK_ROWS == 0) //(V_COUNT/TRACK_LENGTH) == 0)
 2448               		.stabn	68,0,2301,.LM256-.LFBB21
 2449               	.LM256:
 2450 0a62 A801      		movw r20,r16
 2451 0a64 4F71      		andi r20,lo8(31)
 2452 0a66 5070      		andi r21,hi8(31)
 2453 0a68 4115      		cp r20,__zero_reg__
 2454 0a6a 5105      		cpc r21,__zero_reg__
 2455 0a6c 01F0      		breq .+2
 2456 0a6e 00C0      		rjmp .L159
2251:main.c        **** 	uint8_t thisTrackRow = rowNum/TRACK_ROWS; //(V_COUNT/TRACK_LENGTH);
 2457               		.stabn	68,0,2251,.LM257-.LFBB21
 2458               	.LM257:
 2459 0a70 A801      		movw r20,r16
 2460 0a72 F5E0      		ldi r31,5
 2461 0a74 5695      	1:	lsr r21
 2462 0a76 4795      		ror r20
 2463 0a78 FA95      		dec r31
 2464 0a7a 01F4      		brne 1b
 2465 0a7c F42E      		mov r15,r20
2253:main.c        **** 	uint8_t nextPosition = thisTrackRow + (trackPosition? 0 : TRACK_LENGTH);
 2466               		.stabn	68,0,2253,.LM258-.LFBB21
 2467               	.LM258:
 2468 0a7e D92E      		mov r13,r25
 2469 0a80 D40E      		add r13,r20
 2470               	.LBB128:
2303:main.c        **** 		prevNextPosition = nextPosition - 1;
 2471               		.stabn	68,0,2303,.LM259-.LFBB21
 2472               	.LM259:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 175


 2473 0a82 ED2C      		mov r14,r13
 2474 0a84 EA94      		dec r14
2304:main.c        **** 		if(prevNextPosition < 0)
 2475               		.stabn	68,0,2304,.LM260-.LFBB21
 2476               	.LM260:
 2477 0a86 E7FE      		sbrs r14,7
 2478 0a88 00C0      		rjmp .L160
 2479 0a8a EFE2      		ldi r30,lo8(47)
 2480 0a8c EE2E      		mov r14,r30
 2481               	.L160:
 2482               	.LBE128:
2252:main.c        **** 	uint8_t thisPosition = thisTrackRow + (trackPosition? TRACK_LENGTH : 0);
 2483               		.stabn	68,0,2252,.LM261-.LFBB21
 2484               	.LM261:
 2485 0a8e F20E      		add r15,r18
 2486               	.LBB129:
2307:main.c        **** 		prevThisPosition = thisPosition - 1;
 2487               		.stabn	68,0,2307,.LM262-.LFBB21
 2488               	.LM262:
 2489 0a90 CF2C      		mov r12,r15
 2490 0a92 CA94      		dec r12
2308:main.c        **** 		if(prevThisPosition < 0)
 2491               		.stabn	68,0,2308,.LM263-.LFBB21
 2492               	.LM263:
 2493 0a94 C7FE      		sbrs r12,7
 2494 0a96 00C0      		rjmp .L161
 2495 0a98 7FE2      		ldi r23,lo8(47)
 2496 0a9a C72E      		mov r12,r23
 2497               	.L161:
2315:main.c        **** 		nextTrackPseg = sineRaw8(racerTheta) + -(INT8_MIN);
 2498               		.stabn	68,0,2315,.LM264-.LFBB21
 2499               	.LM264:
 2500 0a9c 8091 0000 		lds r24,racerTheta.2413
 2501 0aa0 9091 0000 		lds r25,(racerTheta.2413)+1
 2502 0aa4 00D0      		rcall sineRaw8
2316:main.c        **** 		racerTheta+=level;
 2503               		.stabn	68,0,2316,.LM265-.LFBB21
 2504               	.LM265:
 2505 0aa6 9091 0000 		lds r25,level.2412
 2506 0aaa 2091 0000 		lds r18,racerTheta.2413
 2507 0aae 3091 0000 		lds r19,(racerTheta.2413)+1
 2508 0ab2 290F      		add r18,r25
 2509 0ab4 311D      		adc r19,__zero_reg__
 2510 0ab6 3093 0000 		sts (racerTheta.2413)+1,r19
 2511 0aba 2093 0000 		sts racerTheta.2413,r18
2317:main.c        **** 		if(racerTheta >= SINE_2PI)
 2512               		.stabn	68,0,2317,.LM266-.LFBB21
 2513               	.LM266:
 2514 0abe 62E0      		ldi r22,hi8(512)
 2515 0ac0 2030      		cpi r18,lo8(512)
 2516 0ac2 3607      		cpc r19,r22
 2517 0ac4 04F0      		brlt .L162
2318:main.c        **** 			racerTheta-=SINE_2PI;
 2518               		.stabn	68,0,2318,.LM267-.LFBB21
 2519               	.LM267:
 2520 0ac6 2050      		subi r18,lo8(-(-512))
 2521 0ac8 3240      		sbci r19,hi8(-(-512))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 176


 2522 0aca 3093 0000 		sts (racerTheta.2413)+1,r19
 2523 0ace 2093 0000 		sts racerTheta.2413,r18
 2524               	.L162:
2337:main.c        **** 		raceTrack[nextPosition] = nextTrackPseg;
 2525               		.stabn	68,0,2337,.LM268-.LFBB21
 2526               	.LM268:
 2527 0ad2 9927      		clr r25
 2528 0ad4 87FD      		sbrc r24,7
 2529 0ad6 9095      		com r25
 2530 0ad8 8058      		subi r24,lo8(-(128))
 2531 0ada 9F4F      		sbci r25,hi8(-(128))
 2532 0adc ED2D      		mov r30,r13
 2533 0ade F0E0      		ldi r31,lo8(0)
 2534 0ae0 EE0F      		lsl r30
 2535 0ae2 FF1F      		rol r31
 2536 0ae4 E050      		subi r30,lo8(-(raceTrack.2392))
 2537 0ae6 F040      		sbci r31,hi8(-(raceTrack.2392))
 2538 0ae8 9183      		std Z+1,r25
 2539 0aea 8083      		st Z,r24
2339:main.c        **** 		thisIS = raceTrack[prevThisPosition];
 2540               		.stabn	68,0,2339,.LM269-.LFBB21
 2541               	.LM269:
 2542 0aec EC2D      		mov r30,r12
 2543 0aee FF27      		clr r31
 2544 0af0 E7FD      		sbrc r30,7
 2545 0af2 F095      		com r31
 2546 0af4 EE0F      		lsl r30
 2547 0af6 FF1F      		rol r31
 2548 0af8 E050      		subi r30,lo8(-(raceTrack.2392))
 2549 0afa F040      		sbci r31,hi8(-(raceTrack.2392))
 2550 0afc 2081      		ld r18,Z
 2551 0afe 3181      		ldd r19,Z+1
 2552 0b00 3093 0000 		sts (thisIS.2410)+1,r19
 2553 0b04 2093 0000 		sts thisIS.2410,r18
2340:main.c        **** 		nextIS = raceTrack[prevNextPosition];
 2554               		.stabn	68,0,2340,.LM270-.LFBB21
 2555               	.LM270:
 2556 0b08 EE2D      		mov r30,r14
 2557 0b0a FF27      		clr r31
 2558 0b0c E7FD      		sbrc r30,7
 2559 0b0e F095      		com r31
 2560 0b10 EE0F      		lsl r30
 2561 0b12 FF1F      		rol r31
 2562 0b14 E050      		subi r30,lo8(-(raceTrack.2392))
 2563 0b16 F040      		sbci r31,hi8(-(raceTrack.2392))
 2564 0b18 6081      		ld r22,Z
 2565 0b1a 7181      		ldd r23,Z+1
 2566 0b1c 7093 0000 		sts (nextIS.2411)+1,r23
 2567 0b20 6093 0000 		sts nextIS.2411,r22
2343:main.c        **** 		if(raceTrack[nextPosition] > nextIS)
 2568               		.stabn	68,0,2343,.LM271-.LFBB21
 2569               	.LM271:
 2570 0b24 6817      		cp r22,r24
 2571 0b26 7907      		cpc r23,r25
 2572 0b28 00F4      		brsh .L163
2345:main.c        **** 			nextTrackGrowing = TRUE;
 2573               		.stabn	68,0,2345,.LM272-.LFBB21
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 177


 2574               	.LM272:
 2575 0b2a 41E0      		ldi r20,lo8(1)
 2576 0b2c 4093 0000 		sts nextTrackGrowing.2400,r20
2346:main.c        **** 			nextHFMdist = raceTrack[nextPosition] - nextIS;
 2577               		.stabn	68,0,2346,.LM273-.LFBB21
 2578               	.LM273:
 2579 0b30 A82F      		mov r26,r24
 2580 0b32 A61B      		sub r26,r22
 2581 0b34 6A2F      		mov r22,r26
 2582 0b36 00C0      		rjmp .L164
 2583               	.L163:
2350:main.c        **** 			nextTrackGrowing = FALSE;
 2584               		.stabn	68,0,2350,.LM274-.LFBB21
 2585               	.LM274:
 2586 0b38 1092 0000 		sts nextTrackGrowing.2400,__zero_reg__
2351:main.c        **** 			nextHFMdist = nextIS - raceTrack[nextPosition];
 2587               		.stabn	68,0,2351,.LM275-.LFBB21
 2588               	.LM275:
 2589 0b3c 681B      		sub r22,r24
 2590               	.L164:
2354:main.c        **** 		if(raceTrack[thisPosition] > thisIS)
 2591               		.stabn	68,0,2354,.LM276-.LFBB21
 2592               	.LM276:
 2593 0b3e EF2D      		mov r30,r15
 2594 0b40 F0E0      		ldi r31,lo8(0)
 2595 0b42 EE0F      		lsl r30
 2596 0b44 FF1F      		rol r31
 2597 0b46 E050      		subi r30,lo8(-(raceTrack.2392))
 2598 0b48 F040      		sbci r31,hi8(-(raceTrack.2392))
 2599 0b4a C080      		ld r12,Z
 2600 0b4c D180      		ldd r13,Z+1
 2601 0b4e 2C15      		cp r18,r12
 2602 0b50 3D05      		cpc r19,r13
 2603 0b52 00F4      		brsh .L165
2356:main.c        **** 			thisTrackGrowing = TRUE;
 2604               		.stabn	68,0,2356,.LM277-.LFBB21
 2605               	.LM277:
 2606 0b54 81E0      		ldi r24,lo8(1)
 2607 0b56 8093 0000 		sts thisTrackGrowing.2399,r24
2357:main.c        **** 			thisHFMdist = raceTrack[thisPosition] - thisIS;
 2608               		.stabn	68,0,2357,.LM278-.LFBB21
 2609               	.LM278:
 2610 0b5a C21A      		sub r12,r18
 2611 0b5c 00C0      		rjmp .L166
 2612               	.L165:
2361:main.c        **** 			thisTrackGrowing = FALSE;
 2613               		.stabn	68,0,2361,.LM279-.LFBB21
 2614               	.LM279:
 2615 0b5e 1092 0000 		sts thisTrackGrowing.2399,__zero_reg__
2362:main.c        **** 			thisHFMdist = thisIS - raceTrack[thisPosition];
 2616               		.stabn	68,0,2362,.LM280-.LFBB21
 2617               	.LM280:
 2618 0b62 B22F      		mov r27,r18
 2619 0b64 BC19      		sub r27,r12
 2620 0b66 CB2E      		mov r12,r27
 2621               	.L166:
2365:main.c        **** 		hfm_setup(&nextSmoothingHFM, nextHFMdist, TRACK_ROWS);
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 178


 2622               		.stabn	68,0,2365,.LM281-.LFBB21
 2623               	.LM281:
 2624 0b68 80E0      		ldi r24,lo8(nextSmoothingHFM.2398)
 2625 0b6a 90E0      		ldi r25,hi8(nextSmoothingHFM.2398)
 2626 0b6c 40E2      		ldi r20,lo8(32)
 2627 0b6e 00D0      		rcall hfm_setup
2367:main.c        **** 		hfm_setup(&thisSmoothingHFM, thisHFMdist, TRACK_ROWS);
 2628               		.stabn	68,0,2367,.LM282-.LFBB21
 2629               	.LM282:
 2630 0b70 80E0      		ldi r24,lo8(thisSmoothingHFM.2397)
 2631 0b72 90E0      		ldi r25,hi8(thisSmoothingHFM.2397)
 2632 0b74 6C2D      		mov r22,r12
 2633 0b76 40E2      		ldi r20,lo8(32)
 2634 0b78 00D0      		rcall hfm_setup
 2635               	.L159:
 2636               	.LBE129:
2371:main.c        **** 	if(thisTrackGrowing)//raceTrack[thisPosition] > raceTrack[prevThisPosition])
 2637               		.stabn	68,0,2371,.LM283-.LFBB21
 2638               	.LM283:
 2639 0b7a 8091 0000 		lds r24,thisTrackGrowing.2399
 2640 0b7e E090 0000 		lds r14,thisIS.2410
 2641 0b82 F090 0000 		lds r15,(thisIS.2410)+1
 2642 0b86 8823      		tst r24
 2643 0b88 01F0      		breq .L167
2372:main.c        **** 		thisIS += hfm_nextOutput(&thisSmoothingHFM);
 2644               		.stabn	68,0,2372,.LM284-.LFBB21
 2645               	.LM284:
 2646 0b8a 80E0      		ldi r24,lo8(thisSmoothingHFM.2397)
 2647 0b8c 90E0      		ldi r25,hi8(thisSmoothingHFM.2397)
 2648 0b8e 00D0      		rcall hfm_nextOutput
 2649 0b90 E80E      		add r14,r24
 2650 0b92 F11C      		adc r15,__zero_reg__
 2651 0b94 00C0      		rjmp .L197
 2652               	.L167:
2374:main.c        **** 		thisIS -= hfm_nextOutput(&thisSmoothingHFM);
 2653               		.stabn	68,0,2374,.LM285-.LFBB21
 2654               	.LM285:
 2655 0b96 80E0      		ldi r24,lo8(thisSmoothingHFM.2397)
 2656 0b98 90E0      		ldi r25,hi8(thisSmoothingHFM.2397)
 2657 0b9a 00D0      		rcall hfm_nextOutput
 2658 0b9c E81A      		sub r14,r24
 2659 0b9e F108      		sbc r15,__zero_reg__
 2660               	.L197:
 2661 0ba0 F092 0000 		sts (thisIS.2410)+1,r15
 2662 0ba4 E092 0000 		sts thisIS.2410,r14
2376:main.c        **** 	if(nextTrackGrowing)//raceTrack[nextPosition] > raceTrack[prevNextPosition])
 2663               		.stabn	68,0,2376,.LM286-.LFBB21
 2664               	.LM286:
 2665 0ba8 8091 0000 		lds r24,nextTrackGrowing.2400
 2666 0bac E090 0000 		lds r14,nextIS.2411
 2667 0bb0 F090 0000 		lds r15,(nextIS.2411)+1
 2668 0bb4 8823      		tst r24
 2669 0bb6 01F0      		breq .L169
2377:main.c        **** 		nextIS += hfm_nextOutput(&nextSmoothingHFM);
 2670               		.stabn	68,0,2377,.LM287-.LFBB21
 2671               	.LM287:
 2672 0bb8 80E0      		ldi r24,lo8(nextSmoothingHFM.2398)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 179


 2673 0bba 90E0      		ldi r25,hi8(nextSmoothingHFM.2398)
 2674 0bbc 00D0      		rcall hfm_nextOutput
 2675 0bbe E80E      		add r14,r24
 2676 0bc0 F11C      		adc r15,__zero_reg__
 2677 0bc2 00C0      		rjmp .L198
 2678               	.L169:
2379:main.c        **** 		nextIS -= hfm_nextOutput(&nextSmoothingHFM);
 2679               		.stabn	68,0,2379,.LM288-.LFBB21
 2680               	.LM288:
 2681 0bc4 80E0      		ldi r24,lo8(nextSmoothingHFM.2398)
 2682 0bc6 90E0      		ldi r25,hi8(nextSmoothingHFM.2398)
 2683 0bc8 00D0      		rcall hfm_nextOutput
 2684 0bca E81A      		sub r14,r24
 2685 0bcc F108      		sbc r15,__zero_reg__
 2686               	.L198:
 2687 0bce F092 0000 		sts (nextIS.2411)+1,r15
 2688 0bd2 E092 0000 		sts nextIS.2411,r14
2381:main.c        **** 	if(thisIS < nextIS)
 2689               		.stabn	68,0,2381,.LM289-.LFBB21
 2690               	.LM289:
 2691 0bd6 8091 0000 		lds r24,thisIS.2410
 2692 0bda 9091 0000 		lds r25,(thisIS.2410)+1
 2693 0bde 2091 0000 		lds r18,nextIS.2411
 2694 0be2 3091 0000 		lds r19,(nextIS.2411)+1
 2695 0be6 8217      		cp r24,r18
 2696 0be8 9307      		cpc r25,r19
 2697 0bea 00F4      		brsh .L171
2383:main.c        **** 		addSegIS(thisIS, bgColor);
 2698               		.stabn	68,0,2383,.LM290-.LFBB21
 2699               	.LM290:
 2700 0bec 9A83      		std Y+2,r25
 2701 0bee 8983      		std Y+1,r24
 2702 0bf0 ECE3      		ldi r30,lo8(60)
 2703 0bf2 EB83      		std Y+3,r30
2386:main.c        **** 		if(nextIS < thisIS + raceWidth)
 2704               		.stabn	68,0,2386,.LM291-.LFBB21
 2705               	.LM291:
 2706 0bf4 AC01      		movw r20,r24
 2707 0bf6 405F      		subi r20,lo8(-(16))
 2708 0bf8 5F4F      		sbci r21,hi8(-(16))
 2709 0bfa 2417      		cp r18,r20
 2710 0bfc 3507      		cpc r19,r21
 2711 0bfe 00F4      		brsh .L172
2388:main.c        **** 			addSegIS(nextIS - thisIS, THIS_COLOR);
 2712               		.stabn	68,0,2388,.LM292-.LFBB21
 2713               	.LM292:
 2714 0c00 F901      		movw r30,r18
 2715 0c02 E81B      		sub r30,r24
 2716 0c04 F90B      		sbc r31,r25
 2717 0c06 FB87      		std Y+11,r31
 2718 0c08 EA87      		std Y+10,r30
 2719 0c0a 6CE0      		ldi r22,lo8(12)
 2720 0c0c 6C87      		std Y+12,r22
2389:main.c        **** 			addSegIS(thisIS + raceWidth - nextIS, OVERLAP_COLOR);
 2721               		.stabn	68,0,2389,.LM293-.LFBB21
 2722               	.LM293:
 2723 0c0e 421B      		sub r20,r18
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 180


 2724 0c10 530B      		sbc r21,r19
 2725 0c12 5C8B      		std Y+20,r21
 2726 0c14 4B8B      		std Y+19,r20
 2727 0c16 4FE0      		ldi r20,lo8(15)
 2728 0c18 4D8B      		std Y+21,r20
2390:main.c        **** 			addSegIS(nextIS - thisIS, NEXT_COLOR);
 2729               		.stabn	68,0,2390,.LM294-.LFBB21
 2730               	.LM294:
 2731 0c1a FD8F      		std Y+29,r31
 2732 0c1c EC8F      		std Y+28,r30
 2733 0c1e 00C0      		rjmp .L199
 2734               	.L172:
2395:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
 2735               		.stabn	68,0,2395,.LM295-.LFBB21
 2736               	.LM295:
 2737 0c20 60E1      		ldi r22,lo8(16)
 2738 0c22 70E0      		ldi r23,hi8(16)
 2739 0c24 7B87      		std Y+11,r23
 2740 0c26 6A87      		std Y+10,r22
 2741 0c28 4CE0      		ldi r20,lo8(12)
 2742 0c2a 4C87      		std Y+12,r20
2396:main.c        **** 			addSegIS(nextIS - thisIS - raceWidth, bgColor);
 2743               		.stabn	68,0,2396,.LM296-.LFBB21
 2744               	.LM296:
 2745 0c2c A901      		movw r20,r18
 2746 0c2e 4051      		subi r20,lo8(-(-16))
 2747 0c30 5040      		sbci r21,hi8(-(-16))
 2748 0c32 481B      		sub r20,r24
 2749 0c34 590B      		sbc r21,r25
 2750 0c36 5C8B      		std Y+20,r21
 2751 0c38 4B8B      		std Y+19,r20
 2752 0c3a ED8B      		std Y+21,r30
2397:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
 2753               		.stabn	68,0,2397,.LM297-.LFBB21
 2754               	.LM297:
 2755 0c3c 7D8F      		std Y+29,r23
 2756 0c3e 6C8F      		std Y+28,r22
 2757               	.L199:
 2758 0c40 83E0      		ldi r24,lo8(3)
 2759 0c42 8E8F      		std Y+30,r24
2401:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-nextIS-raceWidth, bgColor);
 2760               		.stabn	68,0,2401,.LM298-.LFBB21
 2761               	.LM298:
 2762 0c44 8827      		clr r24
 2763 0c46 9927      		clr r25
 2764 0c48 821B      		sub r24,r18
 2765 0c4a 930B      		sbc r25,r19
 2766 0c4c 8050      		subi r24,lo8(-(256))
 2767 0c4e 9F4F      		sbci r25,hi8(-(256))
 2768 0c50 9EA3      		std Y+38,r25
 2769 0c52 8DA3      		std Y+37,r24
 2770 0c54 00C0      		rjmp .L201
 2771               	.L171:
2404:main.c        **** 	else if(thisIS > nextIS)
 2772               		.stabn	68,0,2404,.LM299-.LFBB21
 2773               	.LM299:
 2774 0c56 2817      		cp r18,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 181


 2775 0c58 3907      		cpc r19,r25
 2776 0c5a 00F4      		brsh .L175
2406:main.c        **** 		addSegIS(nextIS, bgColor);
 2777               		.stabn	68,0,2406,.LM300-.LFBB21
 2778               	.LM300:
 2779 0c5c 3A83      		std Y+2,r19
 2780 0c5e 2983      		std Y+1,r18
 2781 0c60 ECE3      		ldi r30,lo8(60)
 2782 0c62 EB83      		std Y+3,r30
2409:main.c        **** 		if(thisIS < nextIS + raceWidth)
 2783               		.stabn	68,0,2409,.LM301-.LFBB21
 2784               	.LM301:
 2785 0c64 A901      		movw r20,r18
 2786 0c66 405F      		subi r20,lo8(-(16))
 2787 0c68 5F4F      		sbci r21,hi8(-(16))
 2788 0c6a 8417      		cp r24,r20
 2789 0c6c 9507      		cpc r25,r21
 2790 0c6e 00F4      		brsh .L176
2411:main.c        **** 			addSegIS(thisIS - nextIS, NEXT_COLOR);
 2791               		.stabn	68,0,2411,.LM302-.LFBB21
 2792               	.LM302:
 2793 0c70 BC01      		movw r22,r24
 2794 0c72 621B      		sub r22,r18
 2795 0c74 730B      		sbc r23,r19
 2796 0c76 9B01      		movw r18,r22
 2797 0c78 7B87      		std Y+11,r23
 2798 0c7a 6A87      		std Y+10,r22
 2799 0c7c 63E0      		ldi r22,lo8(3)
 2800 0c7e 6C87      		std Y+12,r22
2412:main.c        **** 			addSegIS(nextIS + raceWidth - thisIS, OVERLAP_COLOR);
 2801               		.stabn	68,0,2412,.LM303-.LFBB21
 2802               	.LM303:
 2803 0c80 481B      		sub r20,r24
 2804 0c82 590B      		sbc r21,r25
 2805 0c84 5C8B      		std Y+20,r21
 2806 0c86 4B8B      		std Y+19,r20
 2807 0c88 4FE0      		ldi r20,lo8(15)
 2808 0c8a 4D8B      		std Y+21,r20
2413:main.c        **** 			addSegIS(thisIS - nextIS, THIS_COLOR);
 2809               		.stabn	68,0,2413,.LM304-.LFBB21
 2810               	.LM304:
 2811 0c8c 3D8F      		std Y+29,r19
 2812 0c8e 2C8F      		std Y+28,r18
 2813 0c90 00C0      		rjmp .L200
 2814               	.L176:
2418:main.c        **** 			addSegIS(raceWidth, NEXT_COLOR);
 2815               		.stabn	68,0,2418,.LM305-.LFBB21
 2816               	.LM305:
 2817 0c92 60E1      		ldi r22,lo8(16)
 2818 0c94 70E0      		ldi r23,hi8(16)
 2819 0c96 7B87      		std Y+11,r23
 2820 0c98 6A87      		std Y+10,r22
 2821 0c9a 43E0      		ldi r20,lo8(3)
 2822 0c9c 4C87      		std Y+12,r20
2419:main.c        **** 			addSegIS(thisIS - nextIS - raceWidth, bgColor);
 2823               		.stabn	68,0,2419,.LM306-.LFBB21
 2824               	.LM306:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 182


 2825 0c9e AC01      		movw r20,r24
 2826 0ca0 4051      		subi r20,lo8(-(-16))
 2827 0ca2 5040      		sbci r21,hi8(-(-16))
 2828 0ca4 421B      		sub r20,r18
 2829 0ca6 530B      		sbc r21,r19
 2830 0ca8 5C8B      		std Y+20,r21
 2831 0caa 4B8B      		std Y+19,r20
 2832 0cac ED8B      		std Y+21,r30
2420:main.c        **** 			addSegIS(raceWidth, THIS_COLOR);
 2833               		.stabn	68,0,2420,.LM307-.LFBB21
 2834               	.LM307:
 2835 0cae 7D8F      		std Y+29,r23
 2836 0cb0 6C8F      		std Y+28,r22
 2837               	.L200:
 2838 0cb2 2CE0      		ldi r18,lo8(12)
 2839 0cb4 2E8F      		std Y+30,r18
2424:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
 2840               		.stabn	68,0,2424,.LM308-.LFBB21
 2841               	.LM308:
 2842 0cb6 2227      		clr r18
 2843 0cb8 3327      		clr r19
 2844 0cba 281B      		sub r18,r24
 2845 0cbc 390B      		sbc r19,r25
 2846 0cbe 2050      		subi r18,lo8(-(256))
 2847 0cc0 3F4F      		sbci r19,hi8(-(256))
 2848 0cc2 3EA3      		std Y+38,r19
 2849 0cc4 2DA3      		std Y+37,r18
 2850               	.L201:
 2851 0cc6 8CE3      		ldi r24,lo8(60)
 2852 0cc8 8FA3      		std Y+39,r24
 2853 0cca 00C0      		rjmp .L174
 2854               	.L175:
2429:main.c        **** 		addSegIS(thisIS, bgColor);
 2855               		.stabn	68,0,2429,.LM309-.LFBB21
 2856               	.LM309:
 2857 0ccc 9A83      		std Y+2,r25
 2858 0cce 8983      		std Y+1,r24
 2859 0cd0 4CE3      		ldi r20,lo8(60)
 2860 0cd2 4B83      		std Y+3,r20
2431:main.c        **** 		addSegIS(raceWidth, OVERLAP_COLOR);
 2861               		.stabn	68,0,2431,.LM310-.LFBB21
 2862               	.LM310:
 2863 0cd4 20E1      		ldi r18,lo8(16)
 2864 0cd6 30E0      		ldi r19,hi8(16)
 2865 0cd8 3B87      		std Y+11,r19
 2866 0cda 2A87      		std Y+10,r18
 2867 0cdc 2FE0      		ldi r18,lo8(15)
 2868 0cde 2C87      		std Y+12,r18
2433:main.c        **** 		addSegIS(RACE_WIDTH_PSEGS-thisIS-raceWidth, bgColor);
 2869               		.stabn	68,0,2433,.LM311-.LFBB21
 2870               	.LM311:
 2871 0ce0 2227      		clr r18
 2872 0ce2 3327      		clr r19
 2873 0ce4 281B      		sub r18,r24
 2874 0ce6 390B      		sbc r19,r25
 2875 0ce8 2050      		subi r18,lo8(-(256))
 2876 0cea 3F4F      		sbci r19,hi8(-(256))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 183


 2877 0cec 3C8B      		std Y+20,r19
 2878 0cee 2B8B      		std Y+19,r18
 2879 0cf0 4D8B      		std Y+21,r20
 2880               	.L174:
 2881 0cf2 6E01      		movw r12,r28
 2882 0cf4 0894      		sec
 2883 0cf6 C11C      		adc r12,__zero_reg__
 2884 0cf8 D11C      		adc r13,__zero_reg__
 2885 0cfa F601      		movw r30,r12
 2886 0cfc 20E0      		ldi r18,lo8(0)
 2887 0cfe 30E0      		ldi r19,hi8(0)
 2888 0d00 6624      		clr r6
 2889 0d02 7724      		clr r7
 2890 0d04 80E0      		ldi r24,lo8(0)
 2891 0d06 90E0      		ldi r25,hi8(0)
 2892               	.L181:
2446:main.c        **** 		isSegTrackPos += is[isSeg].length;
 2893               		.stabn	68,0,2446,.LM312-.LFBB21
 2894               	.LM312:
 2895 0d08 E080      		ld r14,Z
 2896 0d0a F180      		ldd r15,Z+1
 2897 0d0c 8E0D      		add r24,r14
 2898 0d0e 9F1D      		adc r25,r15
 2899 0d10 5901      		movw r10,r18
 2900 0d12 0894      		sec
 2901 0d14 A11C      		adc r10,__zero_reg__
 2902 0d16 B11C      		adc r11,__zero_reg__
2449:main.c        **** 		if((isSegTrackPos >= (uint16_t)racerPseg))
 2903               		.stabn	68,0,2449,.LM313-.LFBB21
 2904               	.LM313:
 2905 0d18 8815      		cp r24,r8
 2906 0d1a 9905      		cpc r25,r9
 2907 0d1c 00F0      		brlo .L178
 2908               	.LBB130:
2453:main.c        **** 			is[isSeg].length = racerPseg - oldTrackPos;
 2909               		.stabn	68,0,2453,.LM314-.LFBB21
 2910               	.LM314:
 2911 0d1e C901      		movw r24,r18
 2912 0d20 63E0      		ldi r22,lo8(3)
 2913 0d22 70E0      		ldi r23,hi8(3)
 2914 0d24 00D0      		rcall __mulhi3
 2915 0d26 2E01      		movw r4,r28
 2916 0d28 0894      		sec
 2917 0d2a 411C      		adc r4,__zero_reg__
 2918 0d2c 511C      		adc r5,__zero_reg__
 2919 0d2e F201      		movw r30,r4
 2920 0d30 E80F      		add r30,r24
 2921 0d32 F91F      		adc r31,r25
 2922 0d34 8618      		sub r8,r6
 2923 0d36 9708      		sbc r9,r7
 2924 0d38 9182      		std Z+1,r9
 2925 0d3a 8082      		st Z,r8
2454:main.c        **** 			is[isSeg+1].length = 1;
 2926               		.stabn	68,0,2454,.LM315-.LFBB21
 2927               	.LM315:
 2928 0d3c C501      		movw r24,r10
 2929 0d3e 63E0      		ldi r22,lo8(3)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 184


 2930 0d40 70E0      		ldi r23,hi8(3)
 2931 0d42 00D0      		rcall __mulhi3
 2932 0d44 840D      		add r24,r4
 2933 0d46 951D      		adc r25,r5
 2934 0d48 41E0      		ldi r20,lo8(1)
 2935 0d4a 50E0      		ldi r21,hi8(1)
 2936 0d4c DC01      		movw r26,r24
 2937 0d4e 1196      		adiw r26,1
 2938 0d50 5C93      		st X,r21
 2939 0d52 4E93      		st -X,r20
2455:main.c        **** 			is[isSeg+1].color = _K;
 2940               		.stabn	68,0,2455,.LM316-.LFBB21
 2941               	.LM316:
 2942 0d54 1296      		adiw r26,2
 2943 0d56 1C92      		st X,__zero_reg__
2457:main.c        **** 			is[isSeg+2].length = oldLength - is[isSeg].length; //- 1;
 2944               		.stabn	68,0,2457,.LM317-.LFBB21
 2945               	.LM317:
 2946 0d58 C901      		movw r24,r18
 2947 0d5a 0296      		adiw r24,2
 2948 0d5c 63E0      		ldi r22,lo8(3)
 2949 0d5e 70E0      		ldi r23,hi8(3)
 2950 0d60 00D0      		rcall __mulhi3
 2951 0d62 D201      		movw r26,r4
 2952 0d64 A80F      		add r26,r24
 2953 0d66 B91F      		adc r27,r25
 2954 0d68 8081      		ld r24,Z
 2955 0d6a 9181      		ldd r25,Z+1
 2956 0d6c E81A      		sub r14,r24
 2957 0d6e F90A      		sbc r15,r25
 2958 0d70 1196      		adiw r26,1
 2959 0d72 FC92      		st X,r15
 2960 0d74 EE92      		st -X,r14
2458:main.c        **** 			is[isSeg+2].color = is[isSeg].color;
 2961               		.stabn	68,0,2458,.LM318-.LFBB21
 2962               	.LM318:
 2963 0d76 8281      		ldd r24,Z+2
 2964 0d78 1296      		adiw r26,2
 2965 0d7a 8C93      		st X,r24
 2966 0d7c 1297      		sbiw r26,2
2459:main.c        **** 			if((is[isSeg].color != THIS_COLOR) && (is[isSeg].color != OVERLAP_COLOR))
 2967               		.stabn	68,0,2459,.LM319-.LFBB21
 2968               	.LM319:
 2969 0d7e 8281      		ldd r24,Z+2
 2970 0d80 8C30      		cpi r24,lo8(12)
 2971 0d82 01F0      		breq .L179
 2972 0d84 8F30      		cpi r24,lo8(15)
 2973 0d86 01F0      		breq .L179
 2974 0d88 8824      		clr r8
 2975 0d8a 8394      		inc r8
 2976 0d8c 00C0      		rjmp .L180
 2977               	.L178:
 2978 0d8e 9501      		movw r18,r10
 2979 0d90 3396      		adiw r30,3
 2980               	.LBE130:
2444:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
 2981               		.stabn	68,0,2444,.LM320-.LFBB21
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 185


 2982               	.LM320:
 2983 0d92 2F30      		cpi r18,15
 2984 0d94 3105      		cpc r19,__zero_reg__
 2985 0d96 01F0      		breq .L179
 2986 0d98 3C01      		movw r6,r24
 2987 0d9a 00C0      		rjmp .L181
 2988               	.L179:
 2989 0d9c 8824      		clr r8
 2990               	.L180:
1984:main.c        **** SIGNAL(TIMER0_COMPA_vect)
 2991               		.stabn	68,0,1984,.LM321-.LFBB21
 2992               	.LM321:
 2993 0d9e 8EE2      		ldi r24,lo8(46)
 2994 0da0 E82E      		mov r14,r24
 2995 0da2 F12C      		mov r15,__zero_reg__
 2996 0da4 EC0E      		add r14,r28
 2997 0da6 FD1E      		adc r15,r29
 2998               	.L184:
2470:main.c        **** 		if(is[isSeg].length == 0)
 2999               		.stabn	68,0,2470,.LM322-.LFBB21
 3000               	.LM322:
 3001 0da8 F601      		movw r30,r12
 3002 0daa 8081      		ld r24,Z
 3003 0dac 9181      		ldd r25,Z+1
 3004 0dae 0097      		sbiw r24,0
 3005 0db0 01F0      		breq .L182
2472:main.c        **** 		if(outOfTrack && (is[isSeg].color==BG_COLOR))
 3006               		.stabn	68,0,2472,.LM323-.LFBB21
 3007               	.LM323:
 3008 0db2 8820      		tst r8
 3009 0db4 01F0      		breq .L183
 3010 0db6 2281      		ldd r18,Z+2
 3011 0db8 2C33      		cpi r18,lo8(60)
 3012 0dba 01F4      		brne .L183
2473:main.c        **** 			addSegfb(is[isSeg].length, BG_BAD_COLOR);
 3013               		.stabn	68,0,2473,.LM324-.LFBB21
 3014               	.LM324:
 3015 0dbc 67E0      		ldi r22,lo8(7)
 3016 0dbe 40E7      		ldi r20,lo8(112)
 3017 0dc0 00C0      		rjmp .L202
 3018               	.L183:
2475:main.c        **** 			addSegfb(is[isSeg].length, is[isSeg].color);
 3019               		.stabn	68,0,2475,.LM325-.LFBB21
 3020               	.LM325:
 3021 0dc2 D601      		movw r26,r12
 3022 0dc4 1296      		adiw r26,2
 3023 0dc6 4C91      		ld r20,X
 3024 0dc8 242F      		mov r18,r20
 3025 0dca 30E0      		ldi r19,lo8(0)
 3026 0dcc F901      		movw r30,r18
 3027 0dce E370      		andi r30,lo8(3)
 3028 0dd0 F070      		andi r31,hi8(3)
 3029 0dd2 EE0F      		lsl r30
 3030 0dd4 FF1F      		rol r31
 3031 0dd6 642F      		mov r22,r20
 3032 0dd8 6170      		andi r22,lo8(1)
 3033 0dda 6E2B      		or r22,r30
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 186


 3034 0ddc 4073      		andi r20,lo8(48)
 3035 0dde 4064      		ori r20,lo8(64)
 3036 0de0 2C70      		andi r18,lo8(12)
 3037 0de2 3070      		andi r19,hi8(12)
 3038 0de4 3595      		asr r19
 3039 0de6 2795      		ror r18
 3040 0de8 3595      		asr r19
 3041 0dea 2795      		ror r18
 3042 0dec 422B      		or r20,r18
 3043               	.L202:
 3044 0dee 00D0      		rcall addSeg
 3045               	.L182:
 3046 0df0 E3E0      		ldi r30,lo8(3)
 3047 0df2 F0E0      		ldi r31,hi8(3)
 3048 0df4 CE0E      		add r12,r30
 3049 0df6 DF1E      		adc r13,r31
2468:main.c        **** 	for(isSeg = 0; isSeg<IS_SEGS; isSeg++)
 3050               		.stabn	68,0,2468,.LM326-.LFBB21
 3051               	.LM326:
 3052 0df8 CE14      		cp r12,r14
 3053 0dfa DF04      		cpc r13,r15
 3054 0dfc 01F4      		brne .L184
2481:main.c        **** 	if(outOfTrack)
 3055               		.stabn	68,0,2481,.LM327-.LFBB21
 3056               	.LM327:
 3057 0dfe 8820      		tst r8
 3058 0e00 01F0      		breq .L185
2482:main.c        **** 		badCount++;
 3059               		.stabn	68,0,2482,.LM328-.LFBB21
 3060               	.LM328:
 3061 0e02 8091 0000 		lds r24,badCount.2428
 3062 0e06 9091 0000 		lds r25,(badCount.2428)+1
 3063 0e0a A091 0000 		lds r26,(badCount.2428)+2
 3064 0e0e B091 0000 		lds r27,(badCount.2428)+3
 3065 0e12 0196      		adiw r24,1
 3066 0e14 A11D      		adc r26,__zero_reg__
 3067 0e16 B11D      		adc r27,__zero_reg__
 3068 0e18 8093 0000 		sts badCount.2428,r24
 3069 0e1c 9093 0000 		sts (badCount.2428)+1,r25
 3070 0e20 A093 0000 		sts (badCount.2428)+2,r26
 3071 0e24 B093 0000 		sts (badCount.2428)+3,r27
 3072 0e28 00C0      		rjmp .L186
 3073               	.L185:
2484:main.c        **** 		goodCount++;
 3074               		.stabn	68,0,2484,.LM329-.LFBB21
 3075               	.LM329:
 3076 0e2a 8091 0000 		lds r24,goodCount.2429
 3077 0e2e 9091 0000 		lds r25,(goodCount.2429)+1
 3078 0e32 A091 0000 		lds r26,(goodCount.2429)+2
 3079 0e36 B091 0000 		lds r27,(goodCount.2429)+3
 3080 0e3a 0196      		adiw r24,1
 3081 0e3c A11D      		adc r26,__zero_reg__
 3082 0e3e B11D      		adc r27,__zero_reg__
 3083 0e40 8093 0000 		sts goodCount.2429,r24
 3084 0e44 9093 0000 		sts (goodCount.2429)+1,r25
 3085 0e48 A093 0000 		sts (goodCount.2429)+2,r26
 3086 0e4c B093 0000 		sts (goodCount.2429)+3,r27
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 187


 3087               	.L186:
2487:main.c        **** 	addSegfb(1, _B);
 3088               		.stabn	68,0,2487,.LM330-.LFBB21
 3089               	.LM330:
 3090 0e50 81E0      		ldi r24,lo8(1)
 3091 0e52 90E0      		ldi r25,hi8(1)
 3092 0e54 60E0      		ldi r22,lo8(0)
 3093 0e56 40E7      		ldi r20,lo8(112)
 3094 0e58 00D0      		rcall addSeg
2490:main.c        **** 	uint8_t percentage = goodCount*100/(badCount+goodCount);
 3095               		.stabn	68,0,2490,.LM331-.LFBB21
 3096               	.LM331:
 3097 0e5a C090 0000 		lds r12,goodCount.2429
 3098 0e5e D090 0000 		lds r13,(goodCount.2429)+1
 3099 0e62 E090 0000 		lds r14,(goodCount.2429)+2
 3100 0e66 F090 0000 		lds r15,(goodCount.2429)+3
 3101 0e6a 8090 0000 		lds r8,badCount.2428
 3102 0e6e 9090 0000 		lds r9,(badCount.2428)+1
 3103 0e72 A090 0000 		lds r10,(badCount.2428)+2
 3104 0e76 B090 0000 		lds r11,(badCount.2428)+3
 3105 0e7a C701      		movw r24,r14
 3106 0e7c B601      		movw r22,r12
 3107 0e7e 24E6      		ldi r18,lo8(100)
 3108 0e80 30E0      		ldi r19,hi8(100)
 3109 0e82 40E0      		ldi r20,hlo8(100)
 3110 0e84 50E0      		ldi r21,hhi8(100)
 3111 0e86 00D0      		rcall __mulsi3
 3112 0e88 A501      		movw r20,r10
 3113 0e8a 9401      		movw r18,r8
 3114 0e8c 2C0D      		add r18,r12
 3115 0e8e 3D1D      		adc r19,r13
 3116 0e90 4E1D      		adc r20,r14
 3117 0e92 5F1D      		adc r21,r15
 3118 0e94 00D0      		rcall __udivmodsi4
2493:main.c        **** 	if((percentage > 50) && (goodCount - lastLevelUpdate > V_COUNT*3))
 3119               		.stabn	68,0,2493,.LM332-.LFBB21
 3120               	.LM332:
 3121 0e96 2333      		cpi r18,lo8(51)
 3122 0e98 00F0      		brlo .L187
 3123 0e9a 8091 0000 		lds r24,lastLevelUpdate.2431
 3124 0e9e 9091 0000 		lds r25,(lastLevelUpdate.2431)+1
 3125 0ea2 A091 0000 		lds r26,(lastLevelUpdate.2431)+2
 3126 0ea6 B091 0000 		lds r27,(lastLevelUpdate.2431)+3
 3127 0eaa B701      		movw r22,r14
 3128 0eac A601      		movw r20,r12
 3129 0eae 481B      		sub r20,r24
 3130 0eb0 590B      		sbc r21,r25
 3131 0eb2 6A0B      		sbc r22,r26
 3132 0eb4 7B0B      		sbc r23,r27
 3133 0eb6 DB01      		movw r26,r22
 3134 0eb8 CA01      		movw r24,r20
 3135 0eba 8130      		cpi r24,lo8(2305)
 3136 0ebc 59E0      		ldi r21,hi8(2305)
 3137 0ebe 9507      		cpc r25,r21
 3138 0ec0 50E0      		ldi r21,hlo8(2305)
 3139 0ec2 A507      		cpc r26,r21
 3140 0ec4 50E0      		ldi r21,hhi8(2305)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 188


 3141 0ec6 B507      		cpc r27,r21
 3142 0ec8 00F0      		brlo .L187
2495:main.c        **** 		lastLevelUpdate = goodCount;
 3143               		.stabn	68,0,2495,.LM333-.LFBB21
 3144               	.LM333:
 3145 0eca C092 0000 		sts lastLevelUpdate.2431,r12
 3146 0ece D092 0000 		sts (lastLevelUpdate.2431)+1,r13
 3147 0ed2 E092 0000 		sts (lastLevelUpdate.2431)+2,r14
 3148 0ed6 F092 0000 		sts (lastLevelUpdate.2431)+3,r15
2496:main.c        **** 		level++;
 3149               		.stabn	68,0,2496,.LM334-.LFBB21
 3150               	.LM334:
 3151 0eda 8091 0000 		lds r24,level.2412
 3152 0ede 8F5F      		subi r24,lo8(-(1))
 3153 0ee0 8093 0000 		sts level.2412,r24
 3154               	.L187:
2499:main.c        **** 	if((rowNum>=6) && (rowNum < 22))
 3155               		.stabn	68,0,2499,.LM335-.LFBB21
 3156               	.LM335:
 3157 0ee4 C801      		movw r24,r16
 3158 0ee6 0697      		sbiw r24,6
 3159 0ee8 8031      		cpi r24,16
 3160 0eea 9105      		cpc r25,__zero_reg__
 3161 0eec 00F4      		brsh .L188
2500:main.c        **** 		showScore(rowNum-6, level, _C);
 3162               		.stabn	68,0,2500,.LM336-.LFBB21
 3163               	.LM336:
 3164 0eee 4091 0000 		lds r20,level.2412
 3165 0ef2 50E0      		ldi r21,lo8(0)
 3166 0ef4 60E0      		ldi r22,lo8(0)
 3167 0ef6 70E0      		ldi r23,hi8(0)
 3168 0ef8 2CE3      		ldi r18,lo8(60)
 3169 0efa 00C0      		rjmp .L203
 3170               	.L188:
2502:main.c        **** 	else if((rowNum>=24) && (rowNum <40))
 3171               		.stabn	68,0,2502,.LM337-.LFBB21
 3172               	.LM337:
 3173 0efc C801      		movw r24,r16
 3174 0efe 4897      		sbiw r24,24
 3175 0f00 8031      		cpi r24,16
 3176 0f02 9105      		cpc r25,__zero_reg__
 3177 0f04 00F4      		brsh .L190
2503:main.c        **** 		showScore(rowNum-24, goodCount, _G);
 3178               		.stabn	68,0,2503,.LM338-.LFBB21
 3179               	.LM338:
 3180 0f06 B701      		movw r22,r14
 3181 0f08 A601      		movw r20,r12
 3182 0f0a 2CE0      		ldi r18,lo8(12)
 3183 0f0c 00C0      		rjmp .L203
 3184               	.L190:
2504:main.c        **** 	else if((rowNum >= 42) && rowNum < 58)
 3185               		.stabn	68,0,2504,.LM339-.LFBB21
 3186               	.LM339:
 3187 0f0e C801      		movw r24,r16
 3188 0f10 8A97      		sbiw r24,42
 3189 0f12 8031      		cpi r24,16
 3190 0f14 9105      		cpc r25,__zero_reg__
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 189


 3191 0f16 00F4      		brsh .L191
2505:main.c        **** 		showScore(rowNum-42, badCount, _R);
 3192               		.stabn	68,0,2505,.LM340-.LFBB21
 3193               	.LM340:
 3194 0f18 B501      		movw r22,r10
 3195 0f1a A401      		movw r20,r8
 3196 0f1c 23E0      		ldi r18,lo8(3)
 3197 0f1e 00C0      		rjmp .L203
 3198               	.L191:
2506:main.c        **** 	else if((rowNum >= 60) && (rowNum < 76))
 3199               		.stabn	68,0,2506,.LM341-.LFBB21
 3200               	.LM341:
 3201 0f20 C801      		movw r24,r16
 3202 0f22 CC97      		sbiw r24,60
 3203 0f24 8031      		cpi r24,16
 3204 0f26 9105      		cpc r25,__zero_reg__
 3205 0f28 00F4      		brsh .L189
2507:main.c        **** 		showScore(rowNum-60, percentage, _Y);
 3206               		.stabn	68,0,2507,.LM342-.LFBB21
 3207               	.LM342:
 3208 0f2a 422F      		mov r20,r18
 3209 0f2c 50E0      		ldi r21,lo8(0)
 3210 0f2e 60E0      		ldi r22,lo8(0)
 3211 0f30 70E0      		ldi r23,hi8(0)
 3212 0f32 2FE0      		ldi r18,lo8(15)
 3213               	.L203:
 3214 0f34 00D0      		rcall showScore
 3215               	.L189:
2510:main.c        **** 	addSegfb(NUM_PSEGS-2-RACE_WIDTH_PSEGS, _B);
 3216               		.stabn	68,0,2510,.LM343-.LFBB21
 3217               	.LM343:
 3218 0f36 83E5      		ldi r24,lo8(83)
 3219 0f38 90E0      		ldi r25,hi8(83)
 3220 0f3a 60E0      		ldi r22,lo8(0)
 3221 0f3c 40E7      		ldi r20,lo8(112)
 3222 0f3e 00D0      		rcall addSeg
2512:main.c        **** 	addSegfb(1, _W);
 3223               		.stabn	68,0,2512,.LM344-.LFBB21
 3224               	.LM344:
 3225 0f40 81E0      		ldi r24,lo8(1)
 3226 0f42 90E0      		ldi r25,hi8(1)
 3227 0f44 67E0      		ldi r22,lo8(7)
 3228 0f46 43E7      		ldi r20,lo8(115)
 3229 0f48 00D0      		rcall addSeg
2513:main.c        **** 	segTerminate();
 3230               		.stabn	68,0,2513,.LM345-.LFBB21
 3231               	.LM345:
 3232 0f4a 00D0      		rcall segTerminate
2515:main.c        **** 	if(rowNum >= V_COUNT-1)
 3233               		.stabn	68,0,2515,.LM346-.LFBB21
 3234               	.LM346:
 3235 0f4c 62E0      		ldi r22,hi8(767)
 3236 0f4e 0F3F      		cpi r16,lo8(767)
 3237 0f50 1607      		cpc r17,r22
 3238 0f52 01F4      		brne .L194
2516:main.c        **** 		trackPosition = !trackPosition;
 3239               		.stabn	68,0,2516,.LM347-.LFBB21
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 190


 3240               	.LM347:
 3241 0f54 80E0      		ldi r24,lo8(0)
 3242 0f56 9091 0000 		lds r25,trackPosition.2391
 3243 0f5a 9923      		tst r25
 3244 0f5c 01F4      		brne .L192
 3245 0f5e 81E0      		ldi r24,lo8(1)
 3246               	.L192:
 3247 0f60 8093 0000 		sts trackPosition.2391,r24
 3248 0f64 00C0      		rjmp .L194
 3249               	.L157:
 3250               	.LBE125:
 3251               	.LBE124:
2026:main.c        **** }
 3252               		.stabn	68,0,2026,.LM348-.LFBB21
 3253               	.LM348:
 3254 0f66 20E0      		ldi r18,lo8(0)
 3255 0f68 98E1      		ldi r25,lo8(24)
 3256 0f6a 00C0      		rjmp .L193
 3257               	.L194:
 3258               	/* epilogue start */
 3259 0f6c AD96      		adiw r28,45
 3260 0f6e DEBF      		out __SP_H__, r29
 3261 0f70 CDBF      		out __SP_L__, r28
 3262 0f72 CF91      		pop r28
 3263 0f74 DF91      		pop r29
 3264 0f76 FF91      		pop r31
 3265 0f78 EF91      		pop r30
 3266 0f7a BF91      		pop r27
 3267 0f7c AF91      		pop r26
 3268 0f7e 9F91      		pop r25
 3269 0f80 8F91      		pop r24
 3270 0f82 7F91      		pop r23
 3271 0f84 6F91      		pop r22
 3272 0f86 5F91      		pop r21
 3273 0f88 4F91      		pop r20
 3274 0f8a 3F91      		pop r19
 3275 0f8c 2F91      		pop r18
 3276 0f8e 1F91      		pop r17
 3277 0f90 0F91      		pop r16
 3278 0f92 FF90      		pop r15
 3279 0f94 EF90      		pop r14
 3280 0f96 DF90      		pop r13
 3281 0f98 CF90      		pop r12
 3282 0f9a BF90      		pop r11
 3283 0f9c AF90      		pop r10
 3284 0f9e 9F90      		pop r9
 3285 0fa0 8F90      		pop r8
 3286 0fa2 7F90      		pop r7
 3287 0fa4 6F90      		pop r6
 3288 0fa6 5F90      		pop r5
 3289 0fa8 4F90      		pop r4
 3290 0faa 0F90      		pop r0
 3291 0fac 0FBE      		out __SREG__,r0
 3292 0fae 0F90      		pop r0
 3293 0fb0 1F90      		pop __zero_reg__
 3294 0fb2 1895      		reti
 3295               		.size	__vector_14, .-__vector_14
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 191


 3296               		.stabs	"frameCount:V(3,2)",38,0,1986,frameCount.2371
 3297               		.stabn	192,0,0,.LFBB21-.LFBB21
 3298               		.stabs	"thisTrackRow:r(3,2)",64,0,2251,15
 3299               		.stabs	"thisPosition:r(3,2)",64,0,2252,15
 3300               		.stabs	"nextPosition:r(3,2)",64,0,2253,13
 3301               		.stabs	"outOfTrack:r(3,2)",64,0,2267,8
 3302               		.stabs	"_IST_BLAH_:T(0,16)",128,0,0,0
 3303               		.stabs	"intermediateSeg_t:t(0,17)",128,0,2272,0
 3304               		.stabs	"is:(0,18)=ar(0,19)=r(0,19);0;0177777;;0;14;(0,17)",128,0,2276,1
 3305               		.stabs	"prevNextPosition:r(3,1)",64,0,2293,14
 3306               		.stabs	"prevThisPosition:r(3,1)",64,0,2294,12
 3307               		.stabs	"oldTrackPos:r(3,4)",64,0,2441,24
 3308               		.stabs	"percentage:r(3,2)",64,0,2490,18
 3309               		.stabn	192,0,0,.LBB125-.LFBB21
 3310               		.stabs	"nextHFMdist:r(3,2)",64,0,2341,22
 3311               		.stabs	"thisHFMdist:r(3,2)",64,0,2341,12
 3312               		.stabn	192,0,0,.LBB128-.LFBB21
 3313               		.stabn	224,0,0,.LBE128-.LFBB21
 3314               		.stabs	"nextHFMdist:r(3,2)",64,0,2341,22
 3315               		.stabs	"thisHFMdist:r(3,2)",64,0,2341,12
 3316               		.stabn	192,0,0,.LBB129-.LFBB21
 3317               		.stabn	224,0,0,.LBE129-.LFBB21
 3318               		.stabn	224,0,0,.LBE125-.LFBB21
 3319               		.stabn	224,0,0,.Lscope21-.LFBB21
 3320               	.Lscope21:
 3321               		.stabs	"",36,0,0,.Lscope21-.LFBB21
 3322               		.stabd	78,0,0
 3323               	.global	header
 3324               		.section	.progmem.data,"a",@progbits
 3325               		.type	header, @object
 3326               		.size	header, 36
 3327               	header:
 3328 0000 4C43 4464 		.string	"LCDdirectLVDS59 2013-12-11 20:43:10"
 3328      6972 6563 
 3328      744C 5644 
 3328      5335 3920 
 3328      3230 3133 
 3329               	.global	characters
 3330               		.type	characters, @object
 3331               		.size	characters, 760
 3332               	characters:
 3333 0024 00        		.byte	0
 3334 0025 0C        		.byte	12
 3335 0026 36        		.byte	54
 3336 0027 36        		.byte	54
 3337 0028 0C        		.byte	12
 3338 0029 00        		.byte	0
 3339 002a 1C        		.byte	28
 3340 002b 06        		.byte	6
 3341 002c 18        		.byte	24
 3342 002d 06        		.byte	6
 3343 002e 00        		.byte	0
 3344 002f 00        		.byte	0
 3345 0030 00        		.byte	0
 3346 0031 00        		.byte	0
 3347 0032 00        		.byte	0
 3348 0033 60        		.byte	96
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 192


 3349 0034 1E        		.byte	30
 3350 0035 0C        		.byte	12
 3351 0036 1E        		.byte	30
 3352 0037 1E        		.byte	30
 3353 0038 38        		.byte	56
 3354 0039 3F        		.byte	63
 3355 003a 1C        		.byte	28
 3356 003b 3F        		.byte	63
 3357 003c 1E        		.byte	30
 3358 003d 1E        		.byte	30
 3359 003e 00        		.byte	0
 3360 003f 00        		.byte	0
 3361 0040 18        		.byte	24
 3362 0041 00        		.byte	0
 3363 0042 06        		.byte	6
 3364 0043 1E        		.byte	30
 3365 0044 3E        		.byte	62
 3366 0045 0C        		.byte	12
 3367 0046 3F        		.byte	63
 3368 0047 3C        		.byte	60
 3369 0048 3F        		.byte	63
 3370 0049 7F        		.byte	127
 3371 004a 7F        		.byte	127
 3372 004b 3C        		.byte	60
 3373 004c 33        		.byte	51
 3374 004d 1E        		.byte	30
 3375 004e 78        		.byte	120
 3376 004f 67        		.byte	103
 3377 0050 0F        		.byte	15
 3378 0051 63        		.byte	99
 3379 0052 63        		.byte	99
 3380 0053 1C        		.byte	28
 3381 0054 3F        		.byte	63
 3382 0055 1E        		.byte	30
 3383 0056 3F        		.byte	63
 3384 0057 1E        		.byte	30
 3385 0058 3F        		.byte	63
 3386 0059 33        		.byte	51
 3387 005a 33        		.byte	51
 3388 005b 63        		.byte	99
 3389 005c 63        		.byte	99
 3390 005d 33        		.byte	51
 3391 005e 7F        		.byte	127
 3392 005f 1E        		.byte	30
 3393 0060 03        		.byte	3
 3394 0061 1E        		.byte	30
 3395 0062 08        		.byte	8
 3396 0063 00        		.byte	0
 3397 0064 0C        		.byte	12
 3398 0065 00        		.byte	0
 3399 0066 07        		.byte	7
 3400 0067 00        		.byte	0
 3401 0068 38        		.byte	56
 3402 0069 00        		.byte	0
 3403 006a 1C        		.byte	28
 3404 006b 00        		.byte	0
 3405 006c 07        		.byte	7
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 193


 3406 006d 0C        		.byte	12
 3407 006e 18        		.byte	24
 3408 006f 07        		.byte	7
 3409 0070 0E        		.byte	14
 3410 0071 00        		.byte	0
 3411 0072 00        		.byte	0
 3412 0073 00        		.byte	0
 3413 0074 00        		.byte	0
 3414 0075 00        		.byte	0
 3415 0076 00        		.byte	0
 3416 0077 00        		.byte	0
 3417 0078 08        		.byte	8
 3418 0079 00        		.byte	0
 3419 007a 00        		.byte	0
 3420 007b 00        		.byte	0
 3421 007c 00        		.byte	0
 3422 007d 00        		.byte	0
 3423 007e 00        		.byte	0
 3424 007f 38        		.byte	56
 3425 0080 18        		.byte	24
 3426 0081 07        		.byte	7
 3427 0082 6E        		.byte	110
 3428 0083 00        		.byte	0
 3429 0084 1E        		.byte	30
 3430 0085 36        		.byte	54
 3431 0086 36        		.byte	54
 3432 0087 3E        		.byte	62
 3433 0088 63        		.byte	99
 3434 0089 36        		.byte	54
 3435 008a 06        		.byte	6
 3436 008b 0C        		.byte	12
 3437 008c 0C        		.byte	12
 3438 008d 66        		.byte	102
 3439 008e 0C        		.byte	12
 3440 008f 00        		.byte	0
 3441 0090 00        		.byte	0
 3442 0091 00        		.byte	0
 3443 0092 30        		.byte	48
 3444 0093 33        		.byte	51
 3445 0094 0F        		.byte	15
 3446 0095 33        		.byte	51
 3447 0096 33        		.byte	51
 3448 0097 3C        		.byte	60
 3449 0098 03        		.byte	3
 3450 0099 06        		.byte	6
 3451 009a 33        		.byte	51
 3452 009b 33        		.byte	51
 3453 009c 33        		.byte	51
 3454 009d 00        		.byte	0
 3455 009e 00        		.byte	0
 3456 009f 0C        		.byte	12
 3457 00a0 00        		.byte	0
 3458 00a1 0C        		.byte	12
 3459 00a2 33        		.byte	51
 3460 00a3 63        		.byte	99
 3461 00a4 1E        		.byte	30
 3462 00a5 66        		.byte	102
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 194


 3463 00a6 66        		.byte	102
 3464 00a7 36        		.byte	54
 3465 00a8 46        		.byte	70
 3466 00a9 46        		.byte	70
 3467 00aa 66        		.byte	102
 3468 00ab 33        		.byte	51
 3469 00ac 0C        		.byte	12
 3470 00ad 30        		.byte	48
 3471 00ae 66        		.byte	102
 3472 00af 06        		.byte	6
 3473 00b0 77        		.byte	119
 3474 00b1 67        		.byte	103
 3475 00b2 36        		.byte	54
 3476 00b3 66        		.byte	102
 3477 00b4 33        		.byte	51
 3478 00b5 66        		.byte	102
 3479 00b6 33        		.byte	51
 3480 00b7 2D        		.byte	45
 3481 00b8 33        		.byte	51
 3482 00b9 33        		.byte	51
 3483 00ba 63        		.byte	99
 3484 00bb 63        		.byte	99
 3485 00bc 33        		.byte	51
 3486 00bd 33        		.byte	51
 3487 00be 06        		.byte	6
 3488 00bf 06        		.byte	6
 3489 00c0 18        		.byte	24
 3490 00c1 1C        		.byte	28
 3491 00c2 00        		.byte	0
 3492 00c3 0C        		.byte	12
 3493 00c4 00        		.byte	0
 3494 00c5 06        		.byte	6
 3495 00c6 00        		.byte	0
 3496 00c7 30        		.byte	48
 3497 00c8 00        		.byte	0
 3498 00c9 36        		.byte	54
 3499 00ca 00        		.byte	0
 3500 00cb 06        		.byte	6
 3501 00cc 00        		.byte	0
 3502 00cd 00        		.byte	0
 3503 00ce 06        		.byte	6
 3504 00cf 0C        		.byte	12
 3505 00d0 00        		.byte	0
 3506 00d1 00        		.byte	0
 3507 00d2 00        		.byte	0
 3508 00d3 00        		.byte	0
 3509 00d4 00        		.byte	0
 3510 00d5 00        		.byte	0
 3511 00d6 00        		.byte	0
 3512 00d7 0C        		.byte	12
 3513 00d8 00        		.byte	0
 3514 00d9 00        		.byte	0
 3515 00da 00        		.byte	0
 3516 00db 00        		.byte	0
 3517 00dc 00        		.byte	0
 3518 00dd 00        		.byte	0
 3519 00de 0C        		.byte	12
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 195


 3520 00df 18        		.byte	24
 3521 00e0 0C        		.byte	12
 3522 00e1 3B        		.byte	59
 3523 00e2 00        		.byte	0
 3524 00e3 1E        		.byte	30
 3525 00e4 36        		.byte	54
 3526 00e5 7F        		.byte	127
 3527 00e6 03        		.byte	3
 3528 00e7 33        		.byte	51
 3529 00e8 1C        		.byte	28
 3530 00e9 03        		.byte	3
 3531 00ea 06        		.byte	6
 3532 00eb 18        		.byte	24
 3533 00ec 3C        		.byte	60
 3534 00ed 0C        		.byte	12
 3535 00ee 00        		.byte	0
 3536 00ef 00        		.byte	0
 3537 00f0 00        		.byte	0
 3538 00f1 18        		.byte	24
 3539 00f2 3B        		.byte	59
 3540 00f3 0C        		.byte	12
 3541 00f4 30        		.byte	48
 3542 00f5 30        		.byte	48
 3543 00f6 36        		.byte	54
 3544 00f7 1F        		.byte	31
 3545 00f8 03        		.byte	3
 3546 00f9 30        		.byte	48
 3547 00fa 33        		.byte	51
 3548 00fb 33        		.byte	51
 3549 00fc 0C        		.byte	12
 3550 00fd 0C        		.byte	12
 3551 00fe 06        		.byte	6
 3552 00ff 3F        		.byte	63
 3553 0100 18        		.byte	24
 3554 0101 30        		.byte	48
 3555 0102 7B        		.byte	123
 3556 0103 33        		.byte	51
 3557 0104 66        		.byte	102
 3558 0105 03        		.byte	3
 3559 0106 66        		.byte	102
 3560 0107 16        		.byte	22
 3561 0108 16        		.byte	22
 3562 0109 03        		.byte	3
 3563 010a 33        		.byte	51
 3564 010b 0C        		.byte	12
 3565 010c 30        		.byte	48
 3566 010d 36        		.byte	54
 3567 010e 06        		.byte	6
 3568 010f 7F        		.byte	127
 3569 0110 6F        		.byte	111
 3570 0111 63        		.byte	99
 3571 0112 66        		.byte	102
 3572 0113 33        		.byte	51
 3573 0114 66        		.byte	102
 3574 0115 07        		.byte	7
 3575 0116 0C        		.byte	12
 3576 0117 33        		.byte	51
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 196


 3577 0118 33        		.byte	51
 3578 0119 63        		.byte	99
 3579 011a 36        		.byte	54
 3580 011b 33        		.byte	51
 3581 011c 19        		.byte	25
 3582 011d 06        		.byte	6
 3583 011e 0C        		.byte	12
 3584 011f 18        		.byte	24
 3585 0120 36        		.byte	54
 3586 0121 00        		.byte	0
 3587 0122 18        		.byte	24
 3588 0123 1E        		.byte	30
 3589 0124 3E        		.byte	62
 3590 0125 1E        		.byte	30
 3591 0126 30        		.byte	48
 3592 0127 1E        		.byte	30
 3593 0128 06        		.byte	6
 3594 0129 6E        		.byte	110
 3595 012a 36        		.byte	54
 3596 012b 0E        		.byte	14
 3597 012c 1E        		.byte	30
 3598 012d 66        		.byte	102
 3599 012e 0C        		.byte	12
 3600 012f 37        		.byte	55
 3601 0130 1F        		.byte	31
 3602 0131 1E        		.byte	30
 3603 0132 3B        		.byte	59
 3604 0133 6E        		.byte	110
 3605 0134 1B        		.byte	27
 3606 0135 3E        		.byte	62
 3607 0136 3E        		.byte	62
 3608 0137 33        		.byte	51
 3609 0138 33        		.byte	51
 3610 0139 63        		.byte	99
 3611 013a 63        		.byte	99
 3612 013b 33        		.byte	51
 3613 013c 3F        		.byte	63
 3614 013d 0C        		.byte	12
 3615 013e 18        		.byte	24
 3616 013f 0C        		.byte	12
 3617 0140 00        		.byte	0
 3618 0141 00        		.byte	0
 3619 0142 0C        		.byte	12
 3620 0143 00        		.byte	0
 3621 0144 36        		.byte	54
 3622 0145 1E        		.byte	30
 3623 0146 18        		.byte	24
 3624 0147 6E        		.byte	110
 3625 0148 00        		.byte	0
 3626 0149 06        		.byte	6
 3627 014a 18        		.byte	24
 3628 014b FF        		.byte	-1
 3629 014c 3F        		.byte	63
 3630 014d 00        		.byte	0
 3631 014e 3F        		.byte	63
 3632 014f 00        		.byte	0
 3633 0150 0C        		.byte	12
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 197


 3634 0151 3F        		.byte	63
 3635 0152 0C        		.byte	12
 3636 0153 1C        		.byte	28
 3637 0154 1C        		.byte	28
 3638 0155 33        		.byte	51
 3639 0156 30        		.byte	48
 3640 0157 1F        		.byte	31
 3641 0158 18        		.byte	24
 3642 0159 1E        		.byte	30
 3643 015a 3E        		.byte	62
 3644 015b 0C        		.byte	12
 3645 015c 0C        		.byte	12
 3646 015d 03        		.byte	3
 3647 015e 00        		.byte	0
 3648 015f 30        		.byte	48
 3649 0160 18        		.byte	24
 3650 0161 7B        		.byte	123
 3651 0162 33        		.byte	51
 3652 0163 3E        		.byte	62
 3653 0164 03        		.byte	3
 3654 0165 66        		.byte	102
 3655 0166 1E        		.byte	30
 3656 0167 1E        		.byte	30
 3657 0168 03        		.byte	3
 3658 0169 3F        		.byte	63
 3659 016a 0C        		.byte	12
 3660 016b 30        		.byte	48
 3661 016c 1E        		.byte	30
 3662 016d 06        		.byte	6
 3663 016e 6B        		.byte	107
 3664 016f 7B        		.byte	123
 3665 0170 63        		.byte	99
 3666 0171 3E        		.byte	62
 3667 0172 33        		.byte	51
 3668 0173 3E        		.byte	62
 3669 0174 1C        		.byte	28
 3670 0175 0C        		.byte	12
 3671 0176 33        		.byte	51
 3672 0177 33        		.byte	51
 3673 0178 6B        		.byte	107
 3674 0179 1C        		.byte	28
 3675 017a 1E        		.byte	30
 3676 017b 0C        		.byte	12
 3677 017c 06        		.byte	6
 3678 017d 18        		.byte	24
 3679 017e 18        		.byte	24
 3680 017f 63        		.byte	99
 3681 0180 00        		.byte	0
 3682 0181 00        		.byte	0
 3683 0182 30        		.byte	48
 3684 0183 66        		.byte	102
 3685 0184 33        		.byte	51
 3686 0185 3E        		.byte	62
 3687 0186 33        		.byte	51
 3688 0187 0F        		.byte	15
 3689 0188 33        		.byte	51
 3690 0189 6E        		.byte	110
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 198


 3691 018a 0C        		.byte	12
 3692 018b 18        		.byte	24
 3693 018c 36        		.byte	54
 3694 018d 0C        		.byte	12
 3695 018e 7F        		.byte	127
 3696 018f 33        		.byte	51
 3697 0190 33        		.byte	51
 3698 0191 66        		.byte	102
 3699 0192 33        		.byte	51
 3700 0193 36        		.byte	54
 3701 0194 03        		.byte	3
 3702 0195 0C        		.byte	12
 3703 0196 33        		.byte	51
 3704 0197 33        		.byte	51
 3705 0198 63        		.byte	99
 3706 0199 36        		.byte	54
 3707 019a 33        		.byte	51
 3708 019b 19        		.byte	25
 3709 019c 07        		.byte	7
 3710 019d 00        		.byte	0
 3711 019e 38        		.byte	56
 3712 019f 00        		.byte	0
 3713 01a0 00        		.byte	0
 3714 01a1 0C        		.byte	12
 3715 01a2 00        		.byte	0
 3716 01a3 7F        		.byte	127
 3717 01a4 30        		.byte	48
 3718 01a5 0C        		.byte	12
 3719 01a6 3B        		.byte	59
 3720 01a7 00        		.byte	0
 3721 01a8 06        		.byte	6
 3722 01a9 18        		.byte	24
 3723 01aa 3C        		.byte	60
 3724 01ab 0C        		.byte	12
 3725 01ac 00        		.byte	0
 3726 01ad 00        		.byte	0
 3727 01ae 00        		.byte	0
 3728 01af 06        		.byte	6
 3729 01b0 37        		.byte	55
 3730 01b1 0C        		.byte	12
 3731 01b2 06        		.byte	6
 3732 01b3 30        		.byte	48
 3733 01b4 7F        		.byte	127
 3734 01b5 30        		.byte	48
 3735 01b6 33        		.byte	51
 3736 01b7 0C        		.byte	12
 3737 01b8 33        		.byte	51
 3738 01b9 30        		.byte	48
 3739 01ba 00        		.byte	0
 3740 01bb 00        		.byte	0
 3741 01bc 06        		.byte	6
 3742 01bd 3F        		.byte	63
 3743 01be 18        		.byte	24
 3744 01bf 0C        		.byte	12
 3745 01c0 7B        		.byte	123
 3746 01c1 3F        		.byte	63
 3747 01c2 66        		.byte	102
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 199


 3748 01c3 03        		.byte	3
 3749 01c4 66        		.byte	102
 3750 01c5 16        		.byte	22
 3751 01c6 16        		.byte	22
 3752 01c7 73        		.byte	115
 3753 01c8 33        		.byte	51
 3754 01c9 0C        		.byte	12
 3755 01ca 33        		.byte	51
 3756 01cb 36        		.byte	54
 3757 01cc 46        		.byte	70
 3758 01cd 63        		.byte	99
 3759 01ce 73        		.byte	115
 3760 01cf 63        		.byte	99
 3761 01d0 06        		.byte	6
 3762 01d1 3B        		.byte	59
 3763 01d2 1E        		.byte	30
 3764 01d3 38        		.byte	56
 3765 01d4 0C        		.byte	12
 3766 01d5 33        		.byte	51
 3767 01d6 33        		.byte	51
 3768 01d7 7F        		.byte	127
 3769 01d8 36        		.byte	54
 3770 01d9 0C        		.byte	12
 3771 01da 46        		.byte	70
 3772 01db 06        		.byte	6
 3773 01dc 30        		.byte	48
 3774 01dd 18        		.byte	24
 3775 01de 00        		.byte	0
 3776 01df 00        		.byte	0
 3777 01e0 00        		.byte	0
 3778 01e1 3E        		.byte	62
 3779 01e2 66        		.byte	102
 3780 01e3 03        		.byte	3
 3781 01e4 33        		.byte	51
 3782 01e5 3F        		.byte	63
 3783 01e6 06        		.byte	6
 3784 01e7 33        		.byte	51
 3785 01e8 66        		.byte	102
 3786 01e9 0C        		.byte	12
 3787 01ea 18        		.byte	24
 3788 01eb 1E        		.byte	30
 3789 01ec 0C        		.byte	12
 3790 01ed 6B        		.byte	107
 3791 01ee 33        		.byte	51
 3792 01ef 33        		.byte	51
 3793 01f0 66        		.byte	102
 3794 01f1 33        		.byte	51
 3795 01f2 36        		.byte	54
 3796 01f3 1E        		.byte	30
 3797 01f4 0C        		.byte	12
 3798 01f5 33        		.byte	51
 3799 01f6 33        		.byte	51
 3800 01f7 6B        		.byte	107
 3801 01f8 1C        		.byte	28
 3802 01f9 33        		.byte	51
 3803 01fa 0C        		.byte	12
 3804 01fb 0C        		.byte	12
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 200


 3805 01fc 18        		.byte	24
 3806 01fd 0C        		.byte	12
 3807 01fe 00        		.byte	0
 3808 01ff 00        		.byte	0
 3809 0200 00        		.byte	0
 3810 0201 00        		.byte	0
 3811 0202 36        		.byte	54
 3812 0203 1F        		.byte	31
 3813 0204 66        		.byte	102
 3814 0205 33        		.byte	51
 3815 0206 00        		.byte	0
 3816 0207 0C        		.byte	12
 3817 0208 0C        		.byte	12
 3818 0209 66        		.byte	102
 3819 020a 0C        		.byte	12
 3820 020b 0E        		.byte	14
 3821 020c 00        		.byte	0
 3822 020d 0C        		.byte	12
 3823 020e 03        		.byte	3
 3824 020f 33        		.byte	51
 3825 0210 0C        		.byte	12
 3826 0211 33        		.byte	51
 3827 0212 33        		.byte	51
 3828 0213 30        		.byte	48
 3829 0214 33        		.byte	51
 3830 0215 33        		.byte	51
 3831 0216 06        		.byte	6
 3832 0217 33        		.byte	51
 3833 0218 18        		.byte	24
 3834 0219 0C        		.byte	12
 3835 021a 0E        		.byte	14
 3836 021b 0C        		.byte	12
 3837 021c 00        		.byte	0
 3838 021d 0C        		.byte	12
 3839 021e 00        		.byte	0
 3840 021f 03        		.byte	3
 3841 0220 33        		.byte	51
 3842 0221 66        		.byte	102
 3843 0222 66        		.byte	102
 3844 0223 36        		.byte	54
 3845 0224 46        		.byte	70
 3846 0225 06        		.byte	6
 3847 0226 66        		.byte	102
 3848 0227 33        		.byte	51
 3849 0228 0C        		.byte	12
 3850 0229 33        		.byte	51
 3851 022a 66        		.byte	102
 3852 022b 66        		.byte	102
 3853 022c 63        		.byte	99
 3854 022d 63        		.byte	99
 3855 022e 36        		.byte	54
 3856 022f 06        		.byte	6
 3857 0230 1E        		.byte	30
 3858 0231 36        		.byte	54
 3859 0232 33        		.byte	51
 3860 0233 0C        		.byte	12
 3861 0234 33        		.byte	51
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 201


 3862 0235 1E        		.byte	30
 3863 0236 77        		.byte	119
 3864 0237 63        		.byte	99
 3865 0238 0C        		.byte	12
 3866 0239 63        		.byte	99
 3867 023a 06        		.byte	6
 3868 023b 60        		.byte	96
 3869 023c 18        		.byte	24
 3870 023d 00        		.byte	0
 3871 023e 00        		.byte	0
 3872 023f 00        		.byte	0
 3873 0240 33        		.byte	51
 3874 0241 66        		.byte	102
 3875 0242 33        		.byte	51
 3876 0243 33        		.byte	51
 3877 0244 03        		.byte	3
 3878 0245 06        		.byte	6
 3879 0246 3E        		.byte	62
 3880 0247 66        		.byte	102
 3881 0248 0C        		.byte	12
 3882 0249 18        		.byte	24
 3883 024a 36        		.byte	54
 3884 024b 0C        		.byte	12
 3885 024c 63        		.byte	99
 3886 024d 33        		.byte	51
 3887 024e 33        		.byte	51
 3888 024f 3E        		.byte	62
 3889 0250 3E        		.byte	62
 3890 0251 06        		.byte	6
 3891 0252 30        		.byte	48
 3892 0253 2C        		.byte	44
 3893 0254 33        		.byte	51
 3894 0255 1E        		.byte	30
 3895 0256 7F        		.byte	127
 3896 0257 36        		.byte	54
 3897 0258 3E        		.byte	62
 3898 0259 26        		.byte	38
 3899 025a 0C        		.byte	12
 3900 025b 18        		.byte	24
 3901 025c 0C        		.byte	12
 3902 025d 00        		.byte	0
 3903 025e 00        		.byte	0
 3904 025f 0C        		.byte	12
 3905 0260 00        		.byte	0
 3906 0261 36        		.byte	54
 3907 0262 0C        		.byte	12
 3908 0263 63        		.byte	99
 3909 0264 6E        		.byte	110
 3910 0265 00        		.byte	0
 3911 0266 18        		.byte	24
 3912 0267 06        		.byte	6
 3913 0268 00        		.byte	0
 3914 0269 00        		.byte	0
 3915 026a 0C        		.byte	12
 3916 026b 00        		.byte	0
 3917 026c 0C        		.byte	12
 3918 026d 01        		.byte	1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 202


 3919 026e 1E        		.byte	30
 3920 026f 3F        		.byte	63
 3921 0270 3F        		.byte	63
 3922 0271 1E        		.byte	30
 3923 0272 30        		.byte	48
 3924 0273 1E        		.byte	30
 3925 0274 1E        		.byte	30
 3926 0275 06        		.byte	6
 3927 0276 1E        		.byte	30
 3928 0277 0E        		.byte	14
 3929 0278 0C        		.byte	12
 3930 0279 0C        		.byte	12
 3931 027a 18        		.byte	24
 3932 027b 00        		.byte	0
 3933 027c 06        		.byte	6
 3934 027d 0C        		.byte	12
 3935 027e 1E        		.byte	30
 3936 027f 33        		.byte	51
 3937 0280 3F        		.byte	63
 3938 0281 3C        		.byte	60
 3939 0282 3F        		.byte	63
 3940 0283 7F        		.byte	127
 3941 0284 0F        		.byte	15
 3942 0285 7C        		.byte	124
 3943 0286 33        		.byte	51
 3944 0287 1E        		.byte	30
 3945 0288 1E        		.byte	30
 3946 0289 67        		.byte	103
 3947 028a 7F        		.byte	127
 3948 028b 63        		.byte	99
 3949 028c 63        		.byte	99
 3950 028d 1C        		.byte	28
 3951 028e 0F        		.byte	15
 3952 028f 38        		.byte	56
 3953 0290 67        		.byte	103
 3954 0291 1E        		.byte	30
 3955 0292 1E        		.byte	30
 3956 0293 3F        		.byte	63
 3957 0294 0C        		.byte	12
 3958 0295 63        		.byte	99
 3959 0296 63        		.byte	99
 3960 0297 1E        		.byte	30
 3961 0298 7F        		.byte	127
 3962 0299 1E        		.byte	30
 3963 029a 40        		.byte	64
 3964 029b 1E        		.byte	30
 3965 029c 00        		.byte	0
 3966 029d 00        		.byte	0
 3967 029e 00        		.byte	0
 3968 029f 6E        		.byte	110
 3969 02a0 3D        		.byte	61
 3970 02a1 1E        		.byte	30
 3971 02a2 6E        		.byte	110
 3972 02a3 1E        		.byte	30
 3973 02a4 0F        		.byte	15
 3974 02a5 30        		.byte	48
 3975 02a6 67        		.byte	103
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 203


 3976 02a7 1E        		.byte	30
 3977 02a8 1B        		.byte	27
 3978 02a9 67        		.byte	103
 3979 02aa 1E        		.byte	30
 3980 02ab 63        		.byte	99
 3981 02ac 33        		.byte	51
 3982 02ad 1E        		.byte	30
 3983 02ae 06        		.byte	6
 3984 02af 30        		.byte	48
 3985 02b0 0F        		.byte	15
 3986 02b1 1F        		.byte	31
 3987 02b2 18        		.byte	24
 3988 02b3 6E        		.byte	110
 3989 02b4 0C        		.byte	12
 3990 02b5 36        		.byte	54
 3991 02b6 63        		.byte	99
 3992 02b7 30        		.byte	48
 3993 02b8 3F        		.byte	63
 3994 02b9 38        		.byte	56
 3995 02ba 18        		.byte	24
 3996 02bb 07        		.byte	7
 3997 02bc 00        		.byte	0
 3998 02bd 00        		.byte	0
 3999 02be 00        		.byte	0
 4000 02bf 00        		.byte	0
 4001 02c0 00        		.byte	0
 4002 02c1 00        		.byte	0
 4003 02c2 00        		.byte	0
 4004 02c3 00        		.byte	0
 4005 02c4 00        		.byte	0
 4006 02c5 00        		.byte	0
 4007 02c6 00        		.byte	0
 4008 02c7 00        		.byte	0
 4009 02c8 00        		.byte	0
 4010 02c9 06        		.byte	6
 4011 02ca 00        		.byte	0
 4012 02cb 00        		.byte	0
 4013 02cc 00        		.byte	0
 4014 02cd 00        		.byte	0
 4015 02ce 00        		.byte	0
 4016 02cf 00        		.byte	0
 4017 02d0 00        		.byte	0
 4018 02d1 00        		.byte	0
 4019 02d2 00        		.byte	0
 4020 02d3 00        		.byte	0
 4021 02d4 00        		.byte	0
 4022 02d5 00        		.byte	0
 4023 02d6 00        		.byte	0
 4024 02d7 00        		.byte	0
 4025 02d8 06        		.byte	6
 4026 02d9 00        		.byte	0
 4027 02da 00        		.byte	0
 4028 02db 00        		.byte	0
 4029 02dc 00        		.byte	0
 4030 02dd 00        		.byte	0
 4031 02de 00        		.byte	0
 4032 02df 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 204


 4033 02e0 00        		.byte	0
 4034 02e1 00        		.byte	0
 4035 02e2 00        		.byte	0
 4036 02e3 00        		.byte	0
 4037 02e4 00        		.byte	0
 4038 02e5 00        		.byte	0
 4039 02e6 00        		.byte	0
 4040 02e7 00        		.byte	0
 4041 02e8 00        		.byte	0
 4042 02e9 00        		.byte	0
 4043 02ea 00        		.byte	0
 4044 02eb 00        		.byte	0
 4045 02ec 00        		.byte	0
 4046 02ed 00        		.byte	0
 4047 02ee 00        		.byte	0
 4048 02ef 00        		.byte	0
 4049 02f0 00        		.byte	0
 4050 02f1 00        		.byte	0
 4051 02f2 00        		.byte	0
 4052 02f3 00        		.byte	0
 4053 02f4 00        		.byte	0
 4054 02f5 00        		.byte	0
 4055 02f6 00        		.byte	0
 4056 02f7 00        		.byte	0
 4057 02f8 00        		.byte	0
 4058 02f9 00        		.byte	0
 4059 02fa 00        		.byte	0
 4060 02fb 00        		.byte	0
 4061 02fc FF        		.byte	-1
 4062 02fd 00        		.byte	0
 4063 02fe 00        		.byte	0
 4064 02ff 00        		.byte	0
 4065 0300 00        		.byte	0
 4066 0301 00        		.byte	0
 4067 0302 00        		.byte	0
 4068 0303 00        		.byte	0
 4069 0304 1F        		.byte	31
 4070 0305 00        		.byte	0
 4071 0306 00        		.byte	0
 4072 0307 0E        		.byte	14
 4073 0308 00        		.byte	0
 4074 0309 00        		.byte	0
 4075 030a 00        		.byte	0
 4076 030b 00        		.byte	0
 4077 030c 00        		.byte	0
 4078 030d 0F        		.byte	15
 4079 030e 78        		.byte	120
 4080 030f 00        		.byte	0
 4081 0310 00        		.byte	0
 4082 0311 00        		.byte	0
 4083 0312 00        		.byte	0
 4084 0313 00        		.byte	0
 4085 0314 00        		.byte	0
 4086 0315 00        		.byte	0
 4087 0316 1F        		.byte	31
 4088 0317 00        		.byte	0
 4089 0318 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 205


 4090 0319 00        		.byte	0
 4091 031a 00        		.byte	0
 4092 031b 00        		.byte	0
 4093               	.global	pieceNum
 4094               	.global	pieceNum
 4095               		.section .bss
 4096               		.type	pieceNum, @object
 4097               		.size	pieceNum, 1
 4098               	pieceNum:
 4099 0000 00        		.skip 1,0
 4100               	.global	pieceOrientation
 4101               	.global	pieceOrientation
 4102               		.type	pieceOrientation, @object
 4103               		.size	pieceOrientation, 1
 4104               	pieceOrientation:
 4105 0001 00        		.skip 1,0
 4106               	.global	pieceTopRow
 4107               	.global	pieceTopRow
 4108               		.type	pieceTopRow, @object
 4109               		.size	pieceTopRow, 1
 4110               	pieceTopRow:
 4111 0002 00        		.skip 1,0
 4112               	.global	pieceLeftCol
 4113               	.global	pieceLeftCol
 4114               		.type	pieceLeftCol, @object
 4115               		.size	pieceLeftCol, 1
 4116               	pieceLeftCol:
 4117 0003 00        		.skip 1,0
 4118               	.global	tetColorScheme
 4119               	.global	tetColorScheme
 4120               		.type	tetColorScheme, @object
 4121               		.size	tetColorScheme, 1
 4122               	tetColorScheme:
 4123 0004 00        		.skip 1,0
 4124               	.global	pgm_tetPiece
 4125               		.section	.progmem.data
 4126               		.type	pgm_tetPiece, @object
 4127               		.size	pgm_tetPiece, 56
 4128               	pgm_tetPiece:
 4129 031c F000      		.word	240
 4130 031e 2222      		.word	8738
 4131 0320 F000      		.word	240
 4132 0322 2222      		.word	8738
 4133 0324 600C      		.word	3168
 4134 0326 6402      		.word	612
 4135 0328 600C      		.word	3168
 4136 032a 6402      		.word	612
 4137 032c C006      		.word	1728
 4138 032e 408C      		.word	-29632
 4139 0330 C006      		.word	1728
 4140 0332 408C      		.word	-29632
 4141 0334 E004      		.word	1248
 4142 0336 C404      		.word	1220
 4143 0338 E400      		.word	228
 4144 033a 6404      		.word	1124
 4145 033c E008      		.word	2272
 4146 033e 4C04      		.word	1100
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 206


 4147 0340 E200      		.word	226
 4148 0342 4406      		.word	1604
 4149 0344 E002      		.word	736
 4150 0346 440C      		.word	3140
 4151 0348 E800      		.word	232
 4152 034a 4604      		.word	1094
 4153 034c 6006      		.word	1632
 4154 034e 6006      		.word	1632
 4155 0350 6006      		.word	1632
 4156 0352 6006      		.word	1632
 4157               	.global	segPosition
 4158               	.global	segPosition
 4159               		.section .bss
 4160               		.type	segPosition, @object
 4161               		.size	segPosition, 1
 4162               	segPosition:
 4163 0005 00        		.skip 1,0
 4164               	.global	dataEnable
 4165               	.global	dataEnable
 4166               		.type	dataEnable, @object
 4167               		.size	dataEnable, 1
 4168               	dataEnable:
 4169 0006 00        		.skip 1,0
 4170               	.global	vSync
 4171               	.global	vSync
 4172               		.type	vSync, @object
 4173               		.size	vSync, 1
 4174               	vSync:
 4175 0007 00        		.skip 1,0
 4176               	.global	hsyncCount
 4177               	.global	hsyncCount
 4178               		.type	hsyncCount, @object
 4179               		.size	hsyncCount, 2
 4180               	hsyncCount:
 4181 0008 0000      		.skip 2,0
 4182               	.global	frameCount
 4183               	.global	frameCount
 4184               		.type	frameCount, @object
 4185               		.size	frameCount, 1
 4186               	frameCount:
 4187 000a 00        		.skip 1,0
 4188               	.global	pgm_image1
 4189               		.section	.progmem.data
 4190               		.type	pgm_image1, @object
 4191               		.size	pgm_image1, 256
 4192               	pgm_image1:
 4193 0354 C0        		.byte	-64
 4194 0355 C0        		.byte	-64
 4195 0356 C0        		.byte	-64
 4196 0357 C0        		.byte	-64
 4197 0358 C0        		.byte	-64
 4198 0359 00        		.byte	0
 4199 035a 00        		.byte	0
 4200 035b 00        		.byte	0
 4201 035c 00        		.byte	0
 4202 035d 00        		.byte	0
 4203 035e 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 207


 4204 035f C0        		.byte	-64
 4205 0360 C0        		.byte	-64
 4206 0361 C0        		.byte	-64
 4207 0362 C0        		.byte	-64
 4208 0363 C0        		.byte	-64
 4209 0364 C0        		.byte	-64
 4210 0365 C0        		.byte	-64
 4211 0366 C0        		.byte	-64
 4212 0367 00        		.byte	0
 4213 0368 00        		.byte	0
 4214 0369 0F        		.byte	15
 4215 036a 0F        		.byte	15
 4216 036b 0F        		.byte	15
 4217 036c 0F        		.byte	15
 4218 036d 0F        		.byte	15
 4219 036e 0F        		.byte	15
 4220 036f 00        		.byte	0
 4221 0370 00        		.byte	0
 4222 0371 C0        		.byte	-64
 4223 0372 C0        		.byte	-64
 4224 0373 C0        		.byte	-64
 4225 0374 C0        		.byte	-64
 4226 0375 C0        		.byte	-64
 4227 0376 00        		.byte	0
 4228 0377 00        		.byte	0
 4229 0378 0F        		.byte	15
 4230 0379 0F        		.byte	15
 4231 037a 0F        		.byte	15
 4232 037b 0F        		.byte	15
 4233 037c 0F        		.byte	15
 4234 037d 0F        		.byte	15
 4235 037e 0F        		.byte	15
 4236 037f 0F        		.byte	15
 4237 0380 00        		.byte	0
 4238 0381 00        		.byte	0
 4239 0382 C0        		.byte	-64
 4240 0383 C0        		.byte	-64
 4241 0384 C0        		.byte	-64
 4242 0385 00        		.byte	0
 4243 0386 00        		.byte	0
 4244 0387 0F        		.byte	15
 4245 0388 0F        		.byte	15
 4246 0389 0F        		.byte	15
 4247 038a 0F        		.byte	15
 4248 038b 0F        		.byte	15
 4249 038c 0F        		.byte	15
 4250 038d 0F        		.byte	15
 4251 038e 0F        		.byte	15
 4252 038f 0F        		.byte	15
 4253 0390 0F        		.byte	15
 4254 0391 00        		.byte	0
 4255 0392 00        		.byte	0
 4256 0393 C0        		.byte	-64
 4257 0394 C0        		.byte	-64
 4258 0395 00        		.byte	0
 4259 0396 0F        		.byte	15
 4260 0397 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 208


 4261 0398 0F        		.byte	15
 4262 0399 00        		.byte	0
 4263 039a 0F        		.byte	15
 4264 039b 0F        		.byte	15
 4265 039c 0F        		.byte	15
 4266 039d 0F        		.byte	15
 4267 039e 00        		.byte	0
 4268 039f 0F        		.byte	15
 4269 03a0 0F        		.byte	15
 4270 03a1 0F        		.byte	15
 4271 03a2 00        		.byte	0
 4272 03a3 C0        		.byte	-64
 4273 03a4 00        		.byte	0
 4274 03a5 0F        		.byte	15
 4275 03a6 0F        		.byte	15
 4276 03a7 0F        		.byte	15
 4277 03a8 00        		.byte	0
 4278 03a9 00        		.byte	0
 4279 03aa 00        		.byte	0
 4280 03ab 0F        		.byte	15
 4281 03ac 0F        		.byte	15
 4282 03ad 00        		.byte	0
 4283 03ae 00        		.byte	0
 4284 03af 00        		.byte	0
 4285 03b0 0F        		.byte	15
 4286 03b1 0F        		.byte	15
 4287 03b2 0F        		.byte	15
 4288 03b3 00        		.byte	0
 4289 03b4 00        		.byte	0
 4290 03b5 0F        		.byte	15
 4291 03b6 0F        		.byte	15
 4292 03b7 0F        		.byte	15
 4293 03b8 0F        		.byte	15
 4294 03b9 00        		.byte	0
 4295 03ba 0F        		.byte	15
 4296 03bb 0F        		.byte	15
 4297 03bc 0F        		.byte	15
 4298 03bd 0F        		.byte	15
 4299 03be 00        		.byte	0
 4300 03bf 0F        		.byte	15
 4301 03c0 0F        		.byte	15
 4302 03c1 0F        		.byte	15
 4303 03c2 0F        		.byte	15
 4304 03c3 00        		.byte	0
 4305 03c4 00        		.byte	0
 4306 03c5 0F        		.byte	15
 4307 03c6 0F        		.byte	15
 4308 03c7 0F        		.byte	15
 4309 03c8 0F        		.byte	15
 4310 03c9 0F        		.byte	15
 4311 03ca 0F        		.byte	15
 4312 03cb 0F        		.byte	15
 4313 03cc 0F        		.byte	15
 4314 03cd 0F        		.byte	15
 4315 03ce 0F        		.byte	15
 4316 03cf 0F        		.byte	15
 4317 03d0 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 209


 4318 03d1 0F        		.byte	15
 4319 03d2 0F        		.byte	15
 4320 03d3 00        		.byte	0
 4321 03d4 00        		.byte	0
 4322 03d5 0F        		.byte	15
 4323 03d6 0F        		.byte	15
 4324 03d7 0F        		.byte	15
 4325 03d8 0F        		.byte	15
 4326 03d9 0F        		.byte	15
 4327 03da 0F        		.byte	15
 4328 03db 0F        		.byte	15
 4329 03dc 0F        		.byte	15
 4330 03dd 0F        		.byte	15
 4331 03de 0F        		.byte	15
 4332 03df 0F        		.byte	15
 4333 03e0 0F        		.byte	15
 4334 03e1 0F        		.byte	15
 4335 03e2 0F        		.byte	15
 4336 03e3 00        		.byte	0
 4337 03e4 00        		.byte	0
 4338 03e5 0F        		.byte	15
 4339 03e6 0F        		.byte	15
 4340 03e7 00        		.byte	0
 4341 03e8 00        		.byte	0
 4342 03e9 0F        		.byte	15
 4343 03ea 0F        		.byte	15
 4344 03eb 0F        		.byte	15
 4345 03ec 0F        		.byte	15
 4346 03ed 0F        		.byte	15
 4347 03ee 0F        		.byte	15
 4348 03ef 00        		.byte	0
 4349 03f0 00        		.byte	0
 4350 03f1 0F        		.byte	15
 4351 03f2 0F        		.byte	15
 4352 03f3 00        		.byte	0
 4353 03f4 00        		.byte	0
 4354 03f5 0F        		.byte	15
 4355 03f6 0F        		.byte	15
 4356 03f7 0F        		.byte	15
 4357 03f8 00        		.byte	0
 4358 03f9 00        		.byte	0
 4359 03fa 0F        		.byte	15
 4360 03fb 0F        		.byte	15
 4361 03fc 0F        		.byte	15
 4362 03fd 0F        		.byte	15
 4363 03fe 00        		.byte	0
 4364 03ff 00        		.byte	0
 4365 0400 0F        		.byte	15
 4366 0401 0F        		.byte	15
 4367 0402 0F        		.byte	15
 4368 0403 00        		.byte	0
 4369 0404 C0        		.byte	-64
 4370 0405 00        		.byte	0
 4371 0406 0F        		.byte	15
 4372 0407 0F        		.byte	15
 4373 0408 0F        		.byte	15
 4374 0409 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 210


 4375 040a 00        		.byte	0
 4376 040b 00        		.byte	0
 4377 040c 00        		.byte	0
 4378 040d 00        		.byte	0
 4379 040e 00        		.byte	0
 4380 040f 0F        		.byte	15
 4381 0410 0F        		.byte	15
 4382 0411 0F        		.byte	15
 4383 0412 00        		.byte	0
 4384 0413 C0        		.byte	-64
 4385 0414 C0        		.byte	-64
 4386 0415 00        		.byte	0
 4387 0416 00        		.byte	0
 4388 0417 0F        		.byte	15
 4389 0418 0F        		.byte	15
 4390 0419 0F        		.byte	15
 4391 041a 0F        		.byte	15
 4392 041b 0F        		.byte	15
 4393 041c 0F        		.byte	15
 4394 041d 0F        		.byte	15
 4395 041e 0F        		.byte	15
 4396 041f 0F        		.byte	15
 4397 0420 0F        		.byte	15
 4398 0421 00        		.byte	0
 4399 0422 00        		.byte	0
 4400 0423 C0        		.byte	-64
 4401 0424 C0        		.byte	-64
 4402 0425 C0        		.byte	-64
 4403 0426 00        		.byte	0
 4404 0427 00        		.byte	0
 4405 0428 0F        		.byte	15
 4406 0429 0F        		.byte	15
 4407 042a 0F        		.byte	15
 4408 042b 0F        		.byte	15
 4409 042c 0F        		.byte	15
 4410 042d 0F        		.byte	15
 4411 042e 0F        		.byte	15
 4412 042f 0F        		.byte	15
 4413 0430 00        		.byte	0
 4414 0431 00        		.byte	0
 4415 0432 C0        		.byte	-64
 4416 0433 C0        		.byte	-64
 4417 0434 C0        		.byte	-64
 4418 0435 C0        		.byte	-64
 4419 0436 C0        		.byte	-64
 4420 0437 00        		.byte	0
 4421 0438 00        		.byte	0
 4422 0439 0F        		.byte	15
 4423 043a 0F        		.byte	15
 4424 043b 0F        		.byte	15
 4425 043c 0F        		.byte	15
 4426 043d 0F        		.byte	15
 4427 043e 0F        		.byte	15
 4428 043f 00        		.byte	0
 4429 0440 00        		.byte	0
 4430 0441 C0        		.byte	-64
 4431 0442 C0        		.byte	-64
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 211


 4432 0443 C0        		.byte	-64
 4433 0444 C0        		.byte	-64
 4434 0445 C0        		.byte	-64
 4435 0446 C0        		.byte	-64
 4436 0447 C0        		.byte	-64
 4437 0448 C0        		.byte	-64
 4438 0449 00        		.byte	0
 4439 044a 00        		.byte	0
 4440 044b 00        		.byte	0
 4441 044c 00        		.byte	0
 4442 044d 00        		.byte	0
 4443 044e 00        		.byte	0
 4444 044f C0        		.byte	-64
 4445 0450 C0        		.byte	-64
 4446 0451 C0        		.byte	-64
 4447 0452 C0        		.byte	-64
 4448 0453 C0        		.byte	-64
 4449               	.global	pgm_image2
 4450               		.type	pgm_image2, @object
 4451               		.size	pgm_image2, 256
 4452               	pgm_image2:
 4453 0454 C0        		.byte	-64
 4454 0455 C0        		.byte	-64
 4455 0456 C0        		.byte	-64
 4456 0457 C0        		.byte	-64
 4457 0458 C0        		.byte	-64
 4458 0459 00        		.byte	0
 4459 045a 00        		.byte	0
 4460 045b 00        		.byte	0
 4461 045c 00        		.byte	0
 4462 045d 00        		.byte	0
 4463 045e 00        		.byte	0
 4464 045f C0        		.byte	-64
 4465 0460 C0        		.byte	-64
 4466 0461 C0        		.byte	-64
 4467 0462 C0        		.byte	-64
 4468 0463 C0        		.byte	-64
 4469 0464 C0        		.byte	-64
 4470 0465 C0        		.byte	-64
 4471 0466 C0        		.byte	-64
 4472 0467 00        		.byte	0
 4473 0468 00        		.byte	0
 4474 0469 0F        		.byte	15
 4475 046a 0F        		.byte	15
 4476 046b 0F        		.byte	15
 4477 046c 0F        		.byte	15
 4478 046d 0F        		.byte	15
 4479 046e 0F        		.byte	15
 4480 046f 00        		.byte	0
 4481 0470 00        		.byte	0
 4482 0471 C0        		.byte	-64
 4483 0472 C0        		.byte	-64
 4484 0473 C0        		.byte	-64
 4485 0474 C0        		.byte	-64
 4486 0475 C0        		.byte	-64
 4487 0476 00        		.byte	0
 4488 0477 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 212


 4489 0478 0F        		.byte	15
 4490 0479 0F        		.byte	15
 4491 047a 0F        		.byte	15
 4492 047b 0F        		.byte	15
 4493 047c 0F        		.byte	15
 4494 047d 0F        		.byte	15
 4495 047e 0F        		.byte	15
 4496 047f 0F        		.byte	15
 4497 0480 00        		.byte	0
 4498 0481 00        		.byte	0
 4499 0482 C0        		.byte	-64
 4500 0483 C0        		.byte	-64
 4501 0484 C0        		.byte	-64
 4502 0485 00        		.byte	0
 4503 0486 00        		.byte	0
 4504 0487 0F        		.byte	15
 4505 0488 0F        		.byte	15
 4506 0489 0F        		.byte	15
 4507 048a 0F        		.byte	15
 4508 048b 0F        		.byte	15
 4509 048c 0F        		.byte	15
 4510 048d 0F        		.byte	15
 4511 048e 0F        		.byte	15
 4512 048f 0F        		.byte	15
 4513 0490 0F        		.byte	15
 4514 0491 00        		.byte	0
 4515 0492 00        		.byte	0
 4516 0493 C0        		.byte	-64
 4517 0494 C0        		.byte	-64
 4518 0495 00        		.byte	0
 4519 0496 0F        		.byte	15
 4520 0497 0F        		.byte	15
 4521 0498 0F        		.byte	15
 4522 0499 00        		.byte	0
 4523 049a 0F        		.byte	15
 4524 049b 0F        		.byte	15
 4525 049c 0F        		.byte	15
 4526 049d 0F        		.byte	15
 4527 049e 0F        		.byte	15
 4528 049f 0F        		.byte	15
 4529 04a0 0F        		.byte	15
 4530 04a1 0F        		.byte	15
 4531 04a2 00        		.byte	0
 4532 04a3 C0        		.byte	-64
 4533 04a4 00        		.byte	0
 4534 04a5 0F        		.byte	15
 4535 04a6 0F        		.byte	15
 4536 04a7 0F        		.byte	15
 4537 04a8 00        		.byte	0
 4538 04a9 00        		.byte	0
 4539 04aa 00        		.byte	0
 4540 04ab 0F        		.byte	15
 4541 04ac 0F        		.byte	15
 4542 04ad 00        		.byte	0
 4543 04ae 0F        		.byte	15
 4544 04af 0F        		.byte	15
 4545 04b0 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 213


 4546 04b1 0F        		.byte	15
 4547 04b2 0F        		.byte	15
 4548 04b3 00        		.byte	0
 4549 04b4 00        		.byte	0
 4550 04b5 0F        		.byte	15
 4551 04b6 0F        		.byte	15
 4552 04b7 0F        		.byte	15
 4553 04b8 0F        		.byte	15
 4554 04b9 00        		.byte	0
 4555 04ba 0F        		.byte	15
 4556 04bb 0F        		.byte	15
 4557 04bc 0F        		.byte	15
 4558 04bd 0F        		.byte	15
 4559 04be 00        		.byte	0
 4560 04bf 00        		.byte	0
 4561 04c0 0F        		.byte	15
 4562 04c1 0F        		.byte	15
 4563 04c2 0F        		.byte	15
 4564 04c3 00        		.byte	0
 4565 04c4 00        		.byte	0
 4566 04c5 0F        		.byte	15
 4567 04c6 0F        		.byte	15
 4568 04c7 0F        		.byte	15
 4569 04c8 0F        		.byte	15
 4570 04c9 0F        		.byte	15
 4571 04ca 0F        		.byte	15
 4572 04cb 0F        		.byte	15
 4573 04cc 0F        		.byte	15
 4574 04cd 0F        		.byte	15
 4575 04ce 0F        		.byte	15
 4576 04cf 0F        		.byte	15
 4577 04d0 0F        		.byte	15
 4578 04d1 0F        		.byte	15
 4579 04d2 0F        		.byte	15
 4580 04d3 00        		.byte	0
 4581 04d4 00        		.byte	0
 4582 04d5 0F        		.byte	15
 4583 04d6 0F        		.byte	15
 4584 04d7 0F        		.byte	15
 4585 04d8 0F        		.byte	15
 4586 04d9 0F        		.byte	15
 4587 04da 0F        		.byte	15
 4588 04db 0F        		.byte	15
 4589 04dc 0F        		.byte	15
 4590 04dd 0F        		.byte	15
 4591 04de 0F        		.byte	15
 4592 04df 0F        		.byte	15
 4593 04e0 0F        		.byte	15
 4594 04e1 0F        		.byte	15
 4595 04e2 0F        		.byte	15
 4596 04e3 00        		.byte	0
 4597 04e4 00        		.byte	0
 4598 04e5 0F        		.byte	15
 4599 04e6 0F        		.byte	15
 4600 04e7 00        		.byte	0
 4601 04e8 00        		.byte	0
 4602 04e9 0F        		.byte	15
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 214


 4603 04ea 0F        		.byte	15
 4604 04eb 0F        		.byte	15
 4605 04ec 0F        		.byte	15
 4606 04ed 0F        		.byte	15
 4607 04ee 0F        		.byte	15
 4608 04ef 00        		.byte	0
 4609 04f0 00        		.byte	0
 4610 04f1 0F        		.byte	15
 4611 04f2 0F        		.byte	15
 4612 04f3 00        		.byte	0
 4613 04f4 00        		.byte	0
 4614 04f5 0F        		.byte	15
 4615 04f6 0F        		.byte	15
 4616 04f7 0F        		.byte	15
 4617 04f8 00        		.byte	0
 4618 04f9 00        		.byte	0
 4619 04fa 0F        		.byte	15
 4620 04fb 0F        		.byte	15
 4621 04fc 0F        		.byte	15
 4622 04fd 0F        		.byte	15
 4623 04fe 00        		.byte	0
 4624 04ff 00        		.byte	0
 4625 0500 0F        		.byte	15
 4626 0501 0F        		.byte	15
 4627 0502 0F        		.byte	15
 4628 0503 00        		.byte	0
 4629 0504 C0        		.byte	-64
 4630 0505 00        		.byte	0
 4631 0506 0F        		.byte	15
 4632 0507 0F        		.byte	15
 4633 0508 0F        		.byte	15
 4634 0509 00        		.byte	0
 4635 050a 00        		.byte	0
 4636 050b 00        		.byte	0
 4637 050c 00        		.byte	0
 4638 050d 00        		.byte	0
 4639 050e 00        		.byte	0
 4640 050f 0F        		.byte	15
 4641 0510 0F        		.byte	15
 4642 0511 0F        		.byte	15
 4643 0512 00        		.byte	0
 4644 0513 C0        		.byte	-64
 4645 0514 C0        		.byte	-64
 4646 0515 00        		.byte	0
 4647 0516 00        		.byte	0
 4648 0517 0F        		.byte	15
 4649 0518 0F        		.byte	15
 4650 0519 0F        		.byte	15
 4651 051a 00        		.byte	0
 4652 051b 03        		.byte	3
 4653 051c 00        		.byte	0
 4654 051d 03        		.byte	3
 4655 051e 00        		.byte	0
 4656 051f 0F        		.byte	15
 4657 0520 0F        		.byte	15
 4658 0521 00        		.byte	0
 4659 0522 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 215


 4660 0523 C0        		.byte	-64
 4661 0524 C0        		.byte	-64
 4662 0525 C0        		.byte	-64
 4663 0526 00        		.byte	0
 4664 0527 00        		.byte	0
 4665 0528 0F        		.byte	15
 4666 0529 0F        		.byte	15
 4667 052a 00        		.byte	0
 4668 052b 03        		.byte	3
 4669 052c 03        		.byte	3
 4670 052d 03        		.byte	3
 4671 052e 00        		.byte	0
 4672 052f 0F        		.byte	15
 4673 0530 00        		.byte	0
 4674 0531 00        		.byte	0
 4675 0532 C0        		.byte	-64
 4676 0533 C0        		.byte	-64
 4677 0534 C0        		.byte	-64
 4678 0535 C0        		.byte	-64
 4679 0536 C0        		.byte	-64
 4680 0537 00        		.byte	0
 4681 0538 00        		.byte	0
 4682 0539 0F        		.byte	15
 4683 053a 0F        		.byte	15
 4684 053b 00        		.byte	0
 4685 053c 00        		.byte	0
 4686 053d 00        		.byte	0
 4687 053e 0F        		.byte	15
 4688 053f 00        		.byte	0
 4689 0540 00        		.byte	0
 4690 0541 C0        		.byte	-64
 4691 0542 C0        		.byte	-64
 4692 0543 C0        		.byte	-64
 4693 0544 C0        		.byte	-64
 4694 0545 C0        		.byte	-64
 4695 0546 C0        		.byte	-64
 4696 0547 C0        		.byte	-64
 4697 0548 C0        		.byte	-64
 4698 0549 00        		.byte	0
 4699 054a 00        		.byte	0
 4700 054b 00        		.byte	0
 4701 054c 00        		.byte	0
 4702 054d 00        		.byte	0
 4703 054e 00        		.byte	0
 4704 054f C0        		.byte	-64
 4705 0550 C0        		.byte	-64
 4706 0551 C0        		.byte	-64
 4707 0552 C0        		.byte	-64
 4708 0553 C0        		.byte	-64
 4709               		.lcomm frameCount.2371,1
 4710               		.lcomm racerTheta.2413,2
 4711               		.lcomm lastLevelUpdate.2431,4
 4712               		.lcomm goodCount.2429,4
 4713               		.lcomm badCount.2428,4
 4714               		.data
 4715               		.type	level.2412, @object
 4716               		.size	level.2412, 1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 216


 4717               	level.2412:
 4718 0000 01        		.byte	1
 4719               		.lcomm nextIS.2411,2
 4720               		.lcomm thisIS.2410,2
 4721               		.lcomm nextTrackGrowing.2400,1
 4722               		.lcomm thisTrackGrowing.2399,1
 4723               		.lcomm nextSmoothingHFM.2398,6
 4724               		.lcomm thisSmoothingHFM.2397,6
 4725               		.lcomm raceTrack.2392,96
 4726               		.lcomm trackPosition.2391,1
 4727               		.type	C.60.2448, @object
 4728               		.size	C.60.2448, 45
 4729               	C.60.2448:
 4730 0001 0000      		.word	0
 4731 0003 3F        		.byte	63
 4732 0004 0000      		.word	0
 4733 0006 3F        		.byte	63
 4734 0007 0000      		.word	0
 4735 0009 3F        		.byte	63
 4736 000a 0000      		.word	0
 4737 000c 3F        		.byte	63
 4738 000d 0000      		.word	0
 4739 000f 3F        		.byte	63
 4740 0010 0000      		.word	0
 4741 0012 3F        		.byte	63
 4742 0013 0000      		.word	0
 4743 0015 3F        		.byte	63
 4744 0016 0000      		.word	0
 4745 0018 3F        		.byte	63
 4746 0019 0000      		.word	0
 4747 001b 3F        		.byte	63
 4748 001c 0000      		.word	0
 4749 001e 3F        		.byte	63
 4750 001f 0000      		.word	0
 4751 0021 3F        		.byte	63
 4752 0022 0000      		.word	0
 4753 0024 3F        		.byte	63
 4754 0025 0000      		.word	0
 4755 0027 3F        		.byte	63
 4756 0028 0000      		.word	0
 4757 002a 3F        		.byte	63
 4758 002b 0000      		.word	0
 4759 002d 3F        		.byte	63
 4760               		.lcomm thisScore.2199,4
 4761               		.lcomm thisVal.2178,4
 4762               		.type	divisor.2177, @object
 4763               		.size	divisor.2177, 4
 4764               	divisor.2177:
 4765 002e 00        		.byte	0
 4766 002f CA        		.byte	-54
 4767 0030 9A        		.byte	-102
 4768 0031 3B        		.byte	59
 4769               		.lcomm last_rbValue.2025,1
 4770               		.lcomm newPieceHitCount.1823,1
 4771               		.lcomm callCount.1822,1
 4772               		.comm tetRow,72,1
 4773               		.comm rowSegBuffer,138,1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 217


 4774               		.comm rowBuffer,64,1
 4775               		.comm pimage,2,1
 4776               		.type	CSWTCH.87, @object
 4777               		.size	CSWTCH.87, 7
 4778               	CSWTCH.87:
 4779 0032 03        		.byte	3
 4780 0033 07        		.byte	7
 4781 0034 0F        		.byte	15
 4782 0035 0C        		.byte	12
 4783 0036 3C        		.byte	60
 4784 0037 30        		.byte	48
 4785 0038 33        		.byte	51
 4786               		.type	CSWTCH.90, @object
 4787               		.size	CSWTCH.90, 7
 4788               	CSWTCH.90:
 4789 0039 01        		.byte	1
 4790 003a 04        		.byte	4
 4791 003b 10        		.byte	16
 4792 003c 14        		.byte	20
 4793 003d 11        		.byte	17
 4794 003e 05        		.byte	5
 4795 003f 15        		.byte	21
 4796               		.stabs	"header:G(0,20)=ar(0,19);0;35;(3,2)",32,0,16,0
 4797               		.stabs	"characters:G(0,21)=ar(0,19);0;7;(0,22)=ar(0,19);0;94;(3,2)",32,0,30,0
 4798               		.stabs	"pgm_tetPiece:G(0,23)=ar(0,19);0;6;(0,24)=ar(0,19);0;3;(3,4)",32,0,473,0
 4799               		.stabs	"tetRow:G(0,25)=ar(0,19);0;17;(3,6)",32,0,37,0
 4800               		.stabs	"pieceNum:G(3,2)",32,0,76,0
 4801               		.stabs	"pieceOrientation:G(3,2)",32,0,77,0
 4802               		.stabs	"pieceTopRow:G(3,2)",32,0,79,0
 4803               		.stabs	"pieceLeftCol:G(3,2)",32,0,80,0
 4804               		.stabs	"tetColorScheme:G(3,2)",32,0,399,0
 4805               		.stabs	"rowSegBuffer:G(0,26)=ar(0,19);0;68;(13,2)",32,0,106,0
 4806               		.stabs	"segPosition:G(3,2)",32,0,151,0
 4807               		.stabs	"rowBuffer:G(0,27)=ar(0,19);0;63;(3,2)",32,0,81,0
 4808               		.stabs	"pimage:G(0,28)=*(3,2)",32,0,1957,0
 4809               		.stabs	"dataEnable:G(3,2)",32,0,1141,0
 4810               		.stabs	"vSync:G(3,2)",32,0,1142,0
 4811               		.stabs	"hsyncCount:G(3,4)",32,0,1143,0
 4812               		.stabs	"frameCount:G(3,2)",32,0,1148,0
 4813               		.stabs	"pgm_image1:G(0,29)=ar(0,19);0;255;(3,2)",32,0,3927,0
 4814               		.stabs	"pgm_image2:G(0,29)",32,0,3993,0
 4815               		.text
 4816               		.stabs	"",100,0,0,.Letext0
 4817               	.Letext0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 218


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2      *ABS*:0000003f __SREG__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:3      *ABS*:0000003e __SP_H__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4      *ABS*:0000003d __SP_L__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:6      *ABS*:00000001 __zero_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:116    .text:00000000 getTetBrick
                            *COM*:00000048 tetRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:167    .text:00000036 setTetBrick
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:251    .text:000000b2 tetInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:321    .text:000000f0 tetUpdate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4769   .bss:00000096 newPieceHitCount.1823
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4104   .bss:00000001 pieceOrientation
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4116   .bss:00000003 pieceLeftCol
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4110   .bss:00000002 pieceTopRow
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4770   .bss:00000097 callCount.1822
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4098   .bss:00000000 pieceNum
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4128   .progmem.data:0000031c pgm_tetPiece
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:754    .text:00000340 tetBrick_to_fb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4122   .bss:00000004 tetColorScheme
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4778   .data:00000032 CSWTCH.87
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4788   .data:00000039 CSWTCH.90
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:807    .text:00000370 segClear
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4162   .bss:00000005 segPosition
                            *COM*:0000008a rowSegBuffer
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:838    .text:00000382 segTerminate
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:915    .text:000003da newSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1035   .text:0000045a stretchSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1139   .text:000004b8 addSeg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1196   .text:000004ee rbpix_to_seg
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4761   .bss:00000095 last_rbValue.2025
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1288   .text:00000554 fb_to_rb
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1347   .text:00000592 grabDecimal_u32
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4764   .data:0000002e divisor.2177
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4760   .bss:00000091 thisVal.2178
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1496   .text:00000688 showScore
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4726   .bss:0000008d thisScore.2199
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:3332   .progmem.data:00000024 characters
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1703   .text:000007ae pll_enable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1775   .text:000007ce lvds_timerInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1865   .text:0000081c lcd_Init
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:1891   .text:00000826 updateLCD
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4168   .bss:00000006 dataEnable
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4174   .bss:00000007 vSync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2014   .text:00000866 LoadNext_1193
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2050   .text:000008aa Done_1193
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2030   .text:00000884 Counter_1193
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4180   .bss:00000008 hsyncCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2173   .text:00000928 init_timer0Hsync
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2213   .text:00000942 main
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4186   .bss:0000000a frameCount
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:2279   .text:00000974 __vector_14
                             .bss:0000000b frameCount.2371
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4725   .bss:0000008c trackPosition.2391
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4729   .data:00000001 C.60.2448
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4709   .bss:0000000c racerTheta.2413
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s 			page 219


/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4717   .data:00000000 level.2412
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4724   .bss:0000002c raceTrack.2392
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4719   .bss:0000001c thisIS.2410
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4713   .bss:0000001a nextIS.2411
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4720   .bss:0000001e nextTrackGrowing.2400
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4721   .bss:0000001f thisTrackGrowing.2399
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4722   .bss:00000020 nextSmoothingHFM.2398
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4723   .bss:00000026 thisSmoothingHFM.2397
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4712   .bss:00000016 badCount.2428
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4711   .bss:00000012 goodCount.2429
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4710   .bss:0000000e lastLevelUpdate.2431
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:3327   .progmem.data:00000000 header
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4192   .progmem.data:00000354 pgm_image1
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc6z7jtP.s:4452   .progmem.data:00000454 pgm_image2
                            *COM*:00000040 rowBuffer
                            *COM*:00000002 pimage

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulhi3
__udivmodsi4
timer_setWGM
timer_selectDivisor
timer_compareMatchIntSetup
adc_takeInput
adc_init
adc_select
adc_startConversion
adc_isBusy
adc_getValue
sineRaw8
hfm_setup
hfm_nextOutput
__mulsi3
