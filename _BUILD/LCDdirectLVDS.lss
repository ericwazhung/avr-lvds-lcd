
_BUILD/LCDdirectLVDS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d4a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00000d4a  00000dde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001f  00800066  00800066  00000de4  2**0
                  ALLOC
  3 .stab         000033cc  00000000  00000000  00000de4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001a51  00000000  00000000  000041b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00005c01  2**0
                  CONTENTS, READONLY
  6 .debug_info   000004b0  00000000  00000000  00005c12  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000470  00000000  00000000  000060c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001d  00000000  00000000  00006532  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001a3  00000000  00000000  0000654f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	25 c2       	rjmp	.+1098   	; 0x44c <__ctors_end>
   2:	3f c2       	rjmp	.+1150   	; 0x482 <__bad_interrupt>
   4:	3e c2       	rjmp	.+1148   	; 0x482 <__bad_interrupt>
   6:	3d c2       	rjmp	.+1146   	; 0x482 <__bad_interrupt>
   8:	3c c2       	rjmp	.+1144   	; 0x482 <__bad_interrupt>
   a:	3b c2       	rjmp	.+1142   	; 0x482 <__bad_interrupt>
   c:	3a c2       	rjmp	.+1140   	; 0x482 <__bad_interrupt>
   e:	39 c2       	rjmp	.+1138   	; 0x482 <__bad_interrupt>
  10:	38 c2       	rjmp	.+1136   	; 0x482 <__bad_interrupt>
  12:	37 c2       	rjmp	.+1134   	; 0x482 <__bad_interrupt>
  14:	36 c2       	rjmp	.+1132   	; 0x482 <__bad_interrupt>
  16:	35 c2       	rjmp	.+1130   	; 0x482 <__bad_interrupt>
  18:	34 c2       	rjmp	.+1128   	; 0x482 <__bad_interrupt>
  1a:	33 c2       	rjmp	.+1126   	; 0x482 <__bad_interrupt>
  1c:	fc c5       	rjmp	.+3064   	; 0xc16 <__vector_14>
  1e:	31 c2       	rjmp	.+1122   	; 0x482 <__bad_interrupt>
  20:	30 c2       	rjmp	.+1120   	; 0x482 <__bad_interrupt>
  22:	2f c2       	rjmp	.+1118   	; 0x482 <__bad_interrupt>
  24:	2e c2       	rjmp	.+1116   	; 0x482 <__bad_interrupt>

00000026 <__trampolines_end>:
  26:	00 00       	nop
  28:	92 01       	movw	r18, r4
  2a:	24 03       	mulsu	r18, r20
  2c:	b6 04       	cpc	r11, r6
  2e:	48 06       	cpc	r4, r24
  30:	d9 07       	cpc	r29, r25
  32:	6a 09       	sbc	r22, r10
  34:	fb 0a       	sbc	r15, r27
  36:	8c 0c       	add	r8, r12
  38:	1c 0e       	add	r1, r28
  3a:	ab 0f       	add	r26, r27
  3c:	3a 11       	cpse	r19, r10
  3e:	c8 12       	cpse	r12, r24
  40:	55 14       	cp	r5, r5
  42:	e2 15       	cp	r30, r2
  44:	6e 17       	cp	r22, r30
  46:	f9 18       	sub	r15, r9
  48:	82 1a       	sub	r8, r18
  4a:	0b 1c       	adc	r0, r11
  4c:	93 1d       	adc	r25, r3
  4e:	1a 1f       	adc	r17, r26
  50:	9f 20       	and	r9, r15
  52:	23 22       	and	r2, r19
  54:	a6 23       	and	r26, r22
  56:	28 25       	eor	r18, r8
  58:	a8 26       	eor	r10, r24
  5a:	26 28       	or	r2, r6
  5c:	a3 29       	or	r26, r3
  5e:	1f 2b       	or	r17, r31
  60:	99 2c       	mov	r9, r9
  62:	11 2e       	mov	r1, r17
  64:	87 2f       	mov	r24, r23
  66:	fb 30       	cpi	r31, 0x0B	; 11
  68:	6e 32       	cpi	r22, 0x2E	; 46
  6a:	df 33       	cpi	r29, 0x3F	; 63
  6c:	4d 35       	cpi	r20, 0x5D	; 93
  6e:	ba 36       	cpi	r27, 0x6A	; 106
  70:	24 38       	cpi	r18, 0x84	; 132
  72:	8c 39       	cpi	r24, 0x9C	; 156
  74:	f2 3a       	cpi	r31, 0xA2	; 162
  76:	56 3c       	cpi	r21, 0xC6	; 198
  78:	b8 3d       	cpi	r27, 0xD8	; 216
  7a:	17 3f       	cpi	r17, 0xF7	; 247
  7c:	73 40       	sbci	r23, 0x03	; 3
  7e:	ce 41       	sbci	r28, 0x1E	; 30
  80:	25 43       	sbci	r18, 0x35	; 53
  82:	7a 44       	sbci	r23, 0x4A	; 74
  84:	cd 45       	sbci	r28, 0x5D	; 93
  86:	1c 47       	sbci	r17, 0x7C	; 124
  88:	69 48       	sbci	r22, 0x89	; 137
  8a:	b4 49       	sbci	r27, 0x94	; 148
  8c:	fb 4a       	sbci	r31, 0xAB	; 171
  8e:	3f 4c       	sbci	r19, 0xCF	; 207
  90:	81 4d       	sbci	r24, 0xD1	; 209
  92:	bf 4e       	sbci	r27, 0xEF	; 239
  94:	fb 4f       	sbci	r31, 0xFB	; 251
  96:	33 51       	subi	r19, 0x13	; 19
  98:	68 52       	subi	r22, 0x28	; 40
  9a:	9b 53       	subi	r25, 0x3B	; 59
  9c:	c9 54       	subi	r28, 0x49	; 73
  9e:	f5 55       	subi	r31, 0x55	; 85
  a0:	1d 57       	subi	r17, 0x7D	; 125
  a2:	42 58       	subi	r20, 0x82	; 130
  a4:	64 59       	subi	r22, 0x94	; 148
  a6:	82 5a       	subi	r24, 0xA2	; 162
  a8:	9c 5b       	subi	r25, 0xBC	; 188
  aa:	b3 5c       	subi	r27, 0xC3	; 195
  ac:	c7 5d       	subi	r28, 0xD7	; 215
  ae:	d7 5e       	subi	r29, 0xE7	; 231
  b0:	e3 5f       	subi	r30, 0xF3	; 243
  b2:	eb 60       	ori	r30, 0x0B	; 11
  b4:	f0 61       	ori	r31, 0x10	; 16
  b6:	f1 62       	ori	r31, 0x21	; 33
  b8:	ee 63       	ori	r30, 0x3E	; 62
  ba:	e8 64       	ori	r30, 0x48	; 72
  bc:	dd 65       	ori	r29, 0x5D	; 93
  be:	cf 66       	ori	r28, 0x6F	; 111
  c0:	bc 67       	ori	r27, 0x7C	; 124
  c2:	a6 68       	ori	r26, 0x86	; 134
  c4:	8b 69       	ori	r24, 0x9B	; 155
  c6:	6d 6a       	ori	r22, 0xAD	; 173
  c8:	4a 6b       	ori	r20, 0xBA	; 186
  ca:	23 6c       	ori	r18, 0xC3	; 195
  cc:	f8 6c       	ori	r31, 0xC8	; 200
  ce:	c9 6d       	ori	r28, 0xD9	; 217
  d0:	96 6e       	ori	r25, 0xE6	; 230
  d2:	5e 6f       	ori	r21, 0xFE	; 254
  d4:	22 70       	andi	r18, 0x02	; 2
  d6:	e2 70       	andi	r30, 0x02	; 2
  d8:	9d 71       	andi	r25, 0x1D	; 29
  da:	54 72       	andi	r21, 0x24	; 36
  dc:	07 73       	andi	r16, 0x37	; 55
  de:	b5 73       	andi	r27, 0x35	; 53
  e0:	5f 74       	andi	r21, 0x4F	; 79
  e2:	04 75       	andi	r16, 0x54	; 84
  e4:	a5 75       	andi	r26, 0x55	; 85
  e6:	41 76       	andi	r20, 0x61	; 97
  e8:	d8 76       	andi	r29, 0x68	; 104
  ea:	6b 77       	andi	r22, 0x7B	; 123
  ec:	fa 77       	andi	r31, 0x7A	; 122
  ee:	84 78       	andi	r24, 0x84	; 132
  f0:	09 79       	andi	r16, 0x99	; 153
  f2:	89 79       	andi	r24, 0x99	; 153
  f4:	05 7a       	andi	r16, 0xA5	; 165
  f6:	7c 7a       	andi	r23, 0xAC	; 172
  f8:	ee 7a       	andi	r30, 0xAE	; 174
  fa:	5c 7b       	andi	r21, 0xBC	; 188
  fc:	c5 7b       	andi	r28, 0xB5	; 181
  fe:	29 7c       	andi	r18, 0xC9	; 201
 100:	88 7c       	andi	r24, 0xC8	; 200
 102:	e3 7c       	andi	r30, 0xC3	; 195
 104:	39 7d       	andi	r19, 0xD9	; 217
 106:	89 7d       	andi	r24, 0xD9	; 217
 108:	d5 7d       	andi	r29, 0xD5	; 213
 10a:	1d 7e       	andi	r17, 0xED	; 237
 10c:	5f 7e       	andi	r21, 0xEF	; 239
 10e:	9c 7e       	andi	r25, 0xEC	; 236
 110:	d5 7e       	andi	r29, 0xE5	; 229
 112:	09 7f       	andi	r16, 0xF9	; 249
 114:	37 7f       	andi	r19, 0xF7	; 247
 116:	61 7f       	andi	r22, 0xF1	; 241
 118:	86 7f       	andi	r24, 0xF6	; 246
 11a:	a6 7f       	andi	r26, 0xF6	; 246
 11c:	c1 7f       	andi	r28, 0xF1	; 241
 11e:	d8 7f       	andi	r29, 0xF8	; 248
 120:	e9 7f       	andi	r30, 0xF9	; 249
 122:	f5 7f       	andi	r31, 0xF5	; 245
 124:	fd 7f       	andi	r31, 0xFD	; 253
 126:	ff 7f       	andi	r31, 0xFF	; 255

00000128 <characters>:
 128:	00 0c 36 36 0c 00 1c 06 18 06 00 00 00 00 00 60     ..66...........`
 138:	1e 0c 1e 1e 38 3f 1c 3f 1e 1e 00 00 18 00 06 1e     ....8?.?........
 148:	3e 0c 3f 3c 3f 7f 7f 3c 33 1e 78 67 0f 63 63 1c     >.?<?..<3.xg.cc.
 158:	3f 1e 3f 1e 3f 33 33 63 63 33 7f 1e 03 1e 08 00     ?.?.?33cc3......
 168:	0c 00 07 00 38 00 1c 00 07 0c 18 07 0e 00 00 00     ....8...........
 178:	00 00 00 00 08 00 00 00 00 00 00 38 18 07 6e 0e     ...........8..n.
 188:	00 1e 36 36 3e 63 36 06 0c 0c 66 0c 00 00 00 30     ..66>c6...f....0
 198:	33 0f 33 33 3c 03 06 33 33 33 00 00 0c 00 0c 33     3.33<..333.....3
 1a8:	63 1e 66 66 36 46 46 66 33 0c 30 66 06 77 67 36     c.ff6FFf3.0f.wg6
 1b8:	66 33 66 33 2d 33 33 63 63 33 33 06 06 18 1c 00     f3f3-33cc33.....
 1c8:	0c 00 06 00 30 00 36 00 06 00 00 06 0c 00 00 00     ....0.6.........
 1d8:	00 00 00 00 0c 00 00 00 00 00 00 0c 18 0c 3b 13     ..............;.
 1e8:	00 1e 36 7f 03 33 1c 03 06 18 3c 0c 00 00 00 18     ..6..3....<.....
 1f8:	3b 0c 30 30 36 1f 03 30 33 33 0c 0c 06 3f 18 30     ;.006..033...?.0
 208:	7b 33 66 03 66 16 16 03 33 0c 30 36 06 7f 6f 63     {3f.f...3.06..oc
 218:	66 33 66 07 0c 33 33 63 36 33 19 06 0c 18 36 00     f3f..33c63....6.
 228:	18 1e 3e 1e 30 1e 06 6e 36 0e 1e 66 0c 37 1f 1e     ..>.0..n6..f.7..
 238:	3b 6e 1b 3e 3e 33 33 63 63 33 3f 0c 18 0c 00 39     ;n.>>33cc3?....9
 248:	00 0c 00 36 1e 18 6e 00 06 18 ff 3f 00 3f 00 0c     ...6..n....?.?..
 258:	3f 0c 1c 1c 33 30 1f 18 1e 3e 0c 0c 03 00 30 18     ?...30...>....0.
 268:	7b 33 3e 03 66 1e 1e 03 3f 0c 30 1e 06 6b 7b 63     {3>.f...?.0..k{c
 278:	3e 33 3e 1c 0c 33 33 6b 1c 1e 0c 06 18 18 63 00     >3>..33k......c.
 288:	00 30 66 33 3e 33 0f 33 6e 0c 18 36 0c 7f 33 33     .0f3>3.3n..6..33
 298:	66 33 36 03 0c 33 33 63 36 33 19 07 00 38 00 69     f36..33c63...8.i
 2a8:	00 0c 00 7f 30 0c 3b 00 06 18 3c 0c 00 00 00 06     ....0.;...<.....
 2b8:	37 0c 06 30 7f 30 33 0c 33 30 00 00 06 3f 18 0c     7..0.03.30...?..
 2c8:	7b 3f 66 03 66 16 16 73 33 0c 33 36 46 63 73 63     {?f.f..s3.36Fcsc
 2d8:	06 3b 1e 38 0c 33 33 7f 36 0c 46 06 30 18 00 00     .;.8.33.6.F.0...
 2e8:	00 3e 66 03 33 3f 06 33 66 0c 18 1e 0c 6b 33 33     .>f.3?.3f....k33
 2f8:	66 33 36 1e 0c 33 33 6b 1c 33 0c 0c 18 0c 00 0e     f36..33k.3......
 308:	00 00 00 36 1f 66 33 00 0c 0c 66 0c 0e 00 0c 03     ...6.f3...f.....
 318:	33 0c 33 33 30 33 33 06 33 18 0c 0e 0c 00 0c 00     3.33033.3.......
 328:	03 33 66 66 36 46 06 66 33 0c 33 66 66 63 63 36     .3ff6F.f3.3ffcc6
 338:	06 1e 36 33 0c 33 1e 77 63 0c 63 06 60 18 00 00     ..63.3.wc.c.`...
 348:	00 33 66 33 33 03 06 3e 66 0c 18 36 0c 63 33 33     .3f33..>f..6.c33
 358:	3e 3e 06 30 2c 33 1e 7f 36 3e 26 0c 18 0c 00 f3     >>.0,3..6>&.....
 368:	00 0c 00 36 0c 63 6e 00 18 06 00 00 0c 00 0c 01     ...6.cn.........
 378:	1e 3f 3f 1e 30 1e 1e 06 1e 0e 0c 0c 18 00 06 0c     .??.0...........
 388:	1e 33 3f 3c 3f 7f 0f 7c 33 1e 1e 67 7f 63 63 1c     .3?<?..|3..g.cc.
 398:	0f 38 67 1e 1e 3f 0c 63 63 1e 7f 1e 40 1e 00 00     .8g..?.cc...@...
 3a8:	00 6e 3d 1e 6e 1e 0f 30 67 1e 1b 67 1e 63 33 1e     .n=.n..0g..g.c3.
 3b8:	06 30 0f 1f 18 6e 0c 36 63 30 3f 38 18 07 00 46     .0...n.6c0?8...F
 3c8:	00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00     ................
 3d8:	00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 00     ................
 3e8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
 3f8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff     ................
 408:	00 00 00 00 00 00 00 1f 00 00 0e 00 00 00 00 00     ................
 418:	0f 78 00 00 00 00 00 00 00 1f 00 00 00 00 00 f4     .x..............

00000428 <header>:
 428:	4c 43 44 64 69 72 65 63 74 4c 56 44 53 39 35 20     LCDdirectLVDS95 
 438:	32 30 31 34 2d 30 37 2d 31 32 20 30 38 3a 34 34     2014-07-12 08:44
 448:	3a 32 33 00                                         :23.

0000044c <__ctors_end>:
 44c:	11 24       	eor	r1, r1
 44e:	1f be       	out	0x3f, r1	; 63
 450:	cf e5       	ldi	r28, 0x5F	; 95
 452:	d2 e0       	ldi	r29, 0x02	; 2
 454:	de bf       	out	0x3e, r29	; 62
 456:	cd bf       	out	0x3d, r28	; 61

00000458 <__do_copy_data>:
 458:	10 e0       	ldi	r17, 0x00	; 0
 45a:	a0 e6       	ldi	r26, 0x60	; 96
 45c:	b0 e0       	ldi	r27, 0x00	; 0
 45e:	ea e4       	ldi	r30, 0x4A	; 74
 460:	fd e0       	ldi	r31, 0x0D	; 13
 462:	02 c0       	rjmp	.+4      	; 0x468 <__do_copy_data+0x10>
 464:	05 90       	lpm	r0, Z+
 466:	0d 92       	st	X+, r0
 468:	a6 36       	cpi	r26, 0x66	; 102
 46a:	b1 07       	cpc	r27, r17
 46c:	d9 f7       	brne	.-10     	; 0x464 <__do_copy_data+0xc>

0000046e <__do_clear_bss>:
 46e:	10 e0       	ldi	r17, 0x00	; 0
 470:	a6 e6       	ldi	r26, 0x66	; 102
 472:	b0 e0       	ldi	r27, 0x00	; 0
 474:	01 c0       	rjmp	.+2      	; 0x478 <.do_clear_bss_start>

00000476 <.do_clear_bss_loop>:
 476:	1d 92       	st	X+, r1

00000478 <.do_clear_bss_start>:
 478:	a5 38       	cpi	r26, 0x85	; 133
 47a:	b1 07       	cpc	r27, r17
 47c:	e1 f7       	brne	.-8      	; 0x476 <.do_clear_bss_loop>
 47e:	13 d4       	rcall	.+2086   	; 0xca6 <main>
 480:	62 c4       	rjmp	.+2244   	; 0xd46 <_exit>

00000482 <__bad_interrupt>:
 482:	be cd       	rjmp	.-1156   	; 0x0 <__vectors>

00000484 <hfm_setPower>:
// This needs to be set, initially! 
//   either init it in the hfm variable declaration
//   or use hfm_setup (ideal)
// however, sometimes it needs to be variable, thus hfm_setup (above)
void hfm_setPower(hfm_t	*modulator, uint8_t power)
{
 484:	fc 01       	movw	r30, r24
	//Don't allow power values > 1, otherwise who knows what'll happen...
	//(This is probably unnecessary, but whatev)
	//It's not, actually, if power's greater than maxPower, the values never reset
	// This is trouble, e.g. in heartbeat, where modulator.power is read
	if(power <= (modulator->maxPower))
 486:	82 81       	ldd	r24, Z+2	; 0x02
 488:	86 17       	cp	r24, r22
 48a:	10 f0       	brcs	.+4      	; 0x490 <hfm_setPower+0xc>
		modulator->power = power;
 48c:	63 83       	std	Z+3, r22	; 0x03
 48e:	08 95       	ret
	else
		modulator->power = modulator->maxPower;
 490:	82 81       	ldd	r24, Z+2	; 0x02
 492:	83 83       	std	Z+3, r24	; 0x03
 494:	08 95       	ret

00000496 <hfm_setup>:
//Mainly just for setting up the maxPower (divisor)
// [can] use hfm_setPower otherwise...
// can't tell how to get away without using hfm_setup once
void hfm_setup(hfm_t *modulator, uint8_t power, uint8_t maxPower)
{
	modulator->desiredSum = 0;
 496:	fc 01       	movw	r30, r24
 498:	11 82       	std	Z+1, r1	; 0x01
 49a:	10 82       	st	Z, r1
	modulator->maxPower = maxPower;
 49c:	42 83       	std	Z+2, r20	; 0x02
	hfm_setPower(modulator, power);
 49e:	f2 cf       	rjmp	.-28     	; 0x484 <hfm_setPower>

000004a0 <hfm_nextOutput>:
}

//Returns 0 if the "output" should be "off" in this cycle
//		  1 if the "output" should be "on"  in this cycle
uint8_t hfm_nextOutput(hfm_t *modulator)
{
 4a0:	fc 01       	movw	r30, r24
	// IF desired == 255, we want it never to clr...
	//		but running will be 0 the first time
	//		and we'll therefore if... set == good
	//		and later we'll runningSum == desiredSum (above) 
	//    and reset and if again
	if(modulator->desiredSum > 0)
 4a2:	80 81       	ld	r24, Z
 4a4:	91 81       	ldd	r25, Z+1	; 0x01
 4a6:	18 16       	cp	r1, r24
 4a8:	19 06       	cpc	r1, r25
 4aa:	4c f4       	brge	.+18     	; 0x4be <hfm_nextOutput+0x1e>
	{
		(modulator->desiredSum) -= (modulator->maxPower); //0xff;
 4ac:	80 81       	ld	r24, Z
 4ae:	91 81       	ldd	r25, Z+1	; 0x01
 4b0:	22 81       	ldd	r18, Z+2	; 0x02
 4b2:	82 1b       	sub	r24, r18
 4b4:	91 09       	sbc	r25, r1
 4b6:	91 83       	std	Z+1, r25	; 0x01
 4b8:	80 83       	st	Z, r24
		toReturn = TRUE;
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	01 c0       	rjmp	.+2      	; 0x4c0 <hfm_nextOutput+0x20>
	}
	else	//avg == desired is handled at the start... (except 0-case which works here too)
	{
		//Don't modify runningSum, wait until desiredSum catches up...
		toReturn = FALSE;
 4be:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	(modulator->desiredSum) += (modulator->power);
 4c0:	20 81       	ld	r18, Z
 4c2:	31 81       	ldd	r19, Z+1	; 0x01
 4c4:	93 81       	ldd	r25, Z+3	; 0x03
 4c6:	29 0f       	add	r18, r25
 4c8:	31 1d       	adc	r19, r1
 4ca:	31 83       	std	Z+1, r19	; 0x01
 4cc:	20 83       	st	Z, r18
		modulator->runningSum = 0;
		modulator->desiredSum = 0;
	}
*/	
	return toReturn;
}
 4ce:	08 95       	ret

000004d0 <timer_selectDivisor>:
 #else
	uint8_t csbits;
  #if defined(CSOBS)
	if(timerNum == 0 || timerNum == 1 || timerNum == 3)//IS_CSTYP(timerNum) || IS_CSOBS(timerNum))
  #else
	if(IS_CSTYP(timerNum))
 4d0:	82 30       	cpi	r24, 0x02	; 2
 4d2:	08 f5       	brcc	.+66     	; 0x516 <timer_selectDivisor+0x46>
  #endif
	{
		switch(clockDiv)
 4d4:	66 30       	cpi	r22, 0x06	; 6
 4d6:	79 f0       	breq	.+30     	; 0x4f6 <timer_selectDivisor+0x26>
 4d8:	30 f4       	brcc	.+12     	; 0x4e6 <timer_selectDivisor+0x16>
 4da:	66 23       	and	r22, r22
 4dc:	51 f0       	breq	.+20     	; 0x4f2 <timer_selectDivisor+0x22>
 4de:	63 30       	cpi	r22, 0x03	; 3
 4e0:	d1 f4       	brne	.+52     	; 0x516 <timer_selectDivisor+0x46>
		{
			case CLKDIV1:
				csbits = CSTYP_DIV1;	
				break;
			case CLKDIV8:
				csbits = CSTYP_DIV8;
 4e2:	92 e0       	ldi	r25, 0x02	; 2
 4e4:	0b c0       	rjmp	.+22     	; 0x4fc <timer_selectDivisor+0x2c>
	if(timerNum == 0 || timerNum == 1 || timerNum == 3)//IS_CSTYP(timerNum) || IS_CSOBS(timerNum))
  #else
	if(IS_CSTYP(timerNum))
  #endif
	{
		switch(clockDiv)
 4e6:	68 30       	cpi	r22, 0x08	; 8
 4e8:	41 f0       	breq	.+16     	; 0x4fa <timer_selectDivisor+0x2a>
 4ea:	6a 30       	cpi	r22, 0x0A	; 10
 4ec:	a1 f4       	brne	.+40     	; 0x516 <timer_selectDivisor+0x46>
				break;
			case CLKDIV256:
				csbits = CSTYP_DIV256;	
				break;
			case CLKDIV1024:
				csbits = CSTYP_DIV1024; 
 4ee:	95 e0       	ldi	r25, 0x05	; 5
				break;
 4f0:	05 c0       	rjmp	.+10     	; 0x4fc <timer_selectDivisor+0x2c>
  #endif
	{
		switch(clockDiv)
		{
			case CLKDIV1:
				csbits = CSTYP_DIV1;	
 4f2:	91 e0       	ldi	r25, 0x01	; 1
 4f4:	03 c0       	rjmp	.+6      	; 0x4fc <timer_selectDivisor+0x2c>
				break;
			case CLKDIV8:
				csbits = CSTYP_DIV8;
				break;
			case CLKDIV64:
				csbits = CSTYP_DIV64;	
 4f6:	93 e0       	ldi	r25, 0x03	; 3
				break;
 4f8:	01 c0       	rjmp	.+2      	; 0x4fc <timer_selectDivisor+0x2c>
			case CLKDIV256:
				csbits = CSTYP_DIV256;	
 4fa:	94 e0       	ldi	r25, 0x04	; 4
	}
  #endif
	else 
		return 1;	

	switch(timerNum)
 4fc:	81 30       	cpi	r24, 0x01	; 1
 4fe:	29 f0       	breq	.+10     	; 0x50a <timer_selectDivisor+0x3a>
	{
		//Assume Timer0 and Timer1 exist (see setWGM)
		case 0:
			writeMasked(csbits, CSMASK, T0_CSReg);
 500:	83 b7       	in	r24, 0x33	; 51
 502:	88 7f       	andi	r24, 0xF8	; 248
 504:	89 2b       	or	r24, r25
 506:	83 bf       	out	0x33, r24	; 51
 508:	04 c0       	rjmp	.+8      	; 0x512 <timer_selectDivisor+0x42>
			break;
		case 1:
			writeMasked(csbits, CSMASK, T1_CSReg);
 50a:	8f b5       	in	r24, 0x2f	; 47
 50c:	88 7f       	andi	r24, 0xF8	; 248
 50e:	89 2b       	or	r24, r25
 510:	8f bd       	out	0x2f, r24	; 47
		default:
			return 1;
			break;
	}
	
	return 0;
 512:	80 e0       	ldi	r24, 0x00	; 0
		case 0:
			writeMasked(csbits, CSMASK, T0_CSReg);
			break;
		case 1:
			writeMasked(csbits, CSMASK, T1_CSReg);
			break;
 514:	08 95       	ret
						return 1;	
				}
				else
					return 1;
			  #else
				return 1;
 516:	81 e0       	ldi	r24, 0x01	; 1
			break;
	}
	
	return 0;
 #endif
}
 518:	08 95       	ret

0000051a <timer_setWGM>:
//	wgmLb *= 0xff;
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
 51a:	64 30       	cpi	r22, 0x04	; 4
 51c:	d0 f4       	brcc	.+52     	; 0x552 <timer_setWGM+0x38>
		return 1;
	
	switch(timerNum)
 51e:	88 23       	and	r24, r24
 520:	19 f0       	breq	.+6      	; 0x528 <timer_setWGM+0xe>
 522:	81 30       	cpi	r24, 0x01	; 1
 524:	49 f0       	breq	.+18     	; 0x538 <timer_setWGM+0x1e>
 526:	15 c0       	rjmp	.+42     	; 0x552 <timer_setWGM+0x38>
 #ifdef _AVR_IOTNx61_H_
			//TinyX61s' Timer0 is an exception...
			// It only has WGM00, which serves the same functionality as
			// most others' WGM01 (when their WGM00 == 0)
			// (No PWM)
			if(wgmLb)
 528:	60 fd       	sbrc	r22, 0
 52a:	13 c0       	rjmp	.+38     	; 0x552 <timer_setWGM+0x38>
#if(!defined(TIMER_SETWGM_UNUSED) || !TIMER_SETWGM_UNUSED)
uint8_t timer_setWGM(uint8_t timerNum, uint8_t wgm)
{
#if(!defined(__AVR_AT90PWM161__))
	uint8_t wgmLb = getbit(0, wgm);
	uint8_t wgmHb = getbit(1, wgm);
 52c:	66 95       	lsr	r22
			// (No PWM)
			if(wgmLb)
				return 1;

			//Whatever .stab is, this single change reduces it by 36Bytes
			writebit(WGM00, T0_WGMReg, wgmHb);
 52e:	11 f0       	breq	.+4      	; 0x534 <timer_setWGM+0x1a>
 530:	a8 9a       	sbi	0x15, 0	; 21
 532:	0d c0       	rjmp	.+26     	; 0x54e <timer_setWGM+0x34>
 534:	a8 98       	cbi	0x15, 0	; 21
 536:	0b c0       	rjmp	.+22     	; 0x54e <timer_setWGM+0x34>
//			wgmLb=0;
//			wgmHb=0;
//			if(wgm == WGM_PHASE_PWM)
//				wgmLb = 0xff;

			switch(wgm)
 538:	61 30       	cpi	r22, 0x01	; 1
 53a:	19 f4       	brne	.+6      	; 0x542 <timer_setWGM+0x28>
					wgmHb = 0;
					break;
			}

			//NOTE: TinyX61s' WGM bits are both in TCCR1D (very unusual)
			writebit(WGM10, TCCR1D, wgmLb);
 53c:	86 b5       	in	r24, 0x26	; 38
 53e:	81 60       	ori	r24, 0x01	; 1
 540:	02 c0       	rjmp	.+4      	; 0x546 <timer_setWGM+0x2c>
 542:	86 b5       	in	r24, 0x26	; 38
 544:	8e 7f       	andi	r24, 0xFE	; 254
 546:	86 bd       	out	0x26, r24	; 38
			writebit(WGM11, TCCR1D, wgmHb);
 548:	86 b5       	in	r24, 0x26	; 38
 54a:	8d 7f       	andi	r24, 0xFD	; 253
 54c:	86 bd       	out	0x26, r24	; 38
		default:
			return 1;
			break;
	}
	
	return 0;
 54e:	80 e0       	ldi	r24, 0x00	; 0
 550:	08 95       	ret
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
		return 1;
 552:	81 e0       	ldi	r24, 0x01	; 1
 554:	08 95       	ret

00000556 <timer_init>:

//Roughly equivalent to the ol' Init_timerX(clkDiv, wgm)
//Return 0 if no error...
#if (!defined(TIMER_INIT_UNUSED) || !TIMER_INIT_UNUSED)
uint8_t timer_init(uint8_t timerNum, uint8_t clockDiv, uint8_t wgm)
{
 556:	cf 93       	push	r28
 558:	df 93       	push	r29
 55a:	c8 2f       	mov	r28, r24
 55c:	d6 2f       	mov	r29, r22
	//set the waveform mode
	ERR_HANDLE_NUM(1,				\
 55e:	64 2f       	mov	r22, r20
 560:	dc df       	rcall	.-72     	; 0x51a <timer_setWGM>
 562:	88 23       	and	r24, r24
 564:	11 f0       	breq	.+4      	; 0x56a <timer_init+0x14>
 566:	80 61       	ori	r24, 0x10	; 16
 568:	08 c0       	rjmp	.+16     	; 0x57a <timer_init+0x24>
		timer_setWGM(timerNum, wgm)	);

	//select the clock
	ERR_HANDLE_NUM(2,							\
 56a:	6d 2f       	mov	r22, r29
 56c:	8c 2f       	mov	r24, r28
 56e:	b0 df       	rcall	.-160    	; 0x4d0 <timer_selectDivisor>
 570:	88 23       	and	r24, r24
 572:	11 f0       	breq	.+4      	; 0x578 <timer_init+0x22>
 574:	80 62       	ori	r24, 0x20	; 32
 576:	01 c0       	rjmp	.+2      	; 0x57a <timer_init+0x24>
		timer_selectDivisor(timerNum, clockDiv)	);
		
	return 0;
 578:	80 e0       	ldi	r24, 0x00	; 0
}
 57a:	df 91       	pop	r29
 57c:	cf 91       	pop	r28
 57e:	08 95       	ret

00000580 <timer_compareMatchIntSetup>:
uint8_t timer_compareMatchIntSetup(uint8_t timerNum, uint8_t outputChannel,
	  												uint8_t enable)
{
	uint8_t channelNum;

	if(timerNum >= MAXTIMERS)
 580:	84 30       	cpi	r24, 0x04	; 4
 582:	08 f0       	brcs	.+2      	; 0x586 <timer_compareMatchIntSetup+0x6>
 584:	42 c0       	rjmp	.+132    	; 0x60a <timer_compareMatchIntSetup+0x8a>
		return 1;

	if(outputChannel >= 2) //MAXCHANNELSPERTIMER)
 586:	62 30       	cpi	r22, 0x02	; 2
 588:	08 f0       	brcs	.+2      	; 0x58c <timer_compareMatchIntSetup+0xc>
 58a:	41 c0       	rjmp	.+130    	; 0x60e <timer_compareMatchIntSetup+0x8e>
		return 2;

	//writebit (used later) does not currently handle TRUE and FALSE properly, just 0 and 1...
	// this should be fixed now...
	if(enable)
 58c:	91 e0       	ldi	r25, 0x01	; 1
 58e:	41 11       	cpse	r20, r1
 590:	01 c0       	rjmp	.+2      	; 0x594 <timer_compareMatchIntSetup+0x14>
 592:	90 e0       	ldi	r25, 0x00	; 0
		enable = 1;
	
	//For the sake of our brute-force switch statement...
	//Combine the timer number and channel into a single variable...
	//The high nibble contains the timer number, and the low contains the channel number (A=0,B=1)
	channelNum = (timerNum<<4) + outputChannel;
 594:	82 95       	swap	r24
 596:	80 7f       	andi	r24, 0xF0	; 240
 598:	86 0f       	add	r24, r22

	//Don't clear interrupts before disabling this one, or that defeats the purpose!
	// But do clear so we don't get unexpected overflows on init
	if(enable)
 59a:	99 23       	and	r25, r25
 59c:	09 f0       	breq	.+2      	; 0x5a0 <timer_compareMatchIntSetup+0x20>
		cli();
 59e:	f8 94       	cli
	
	switch(channelNum)
 5a0:	81 30       	cpi	r24, 0x01	; 1
 5a2:	81 f0       	breq	.+32     	; 0x5c4 <timer_compareMatchIntSetup+0x44>
 5a4:	28 f0       	brcs	.+10     	; 0x5b0 <timer_compareMatchIntSetup+0x30>
 5a6:	80 31       	cpi	r24, 0x10	; 16
 5a8:	b9 f0       	breq	.+46     	; 0x5d8 <timer_compareMatchIntSetup+0x58>
 5aa:	81 31       	cpi	r24, 0x11	; 17
 5ac:	f9 f0       	breq	.+62     	; 0x5ec <timer_compareMatchIntSetup+0x6c>
 5ae:	31 c0       	rjmp	.+98     	; 0x612 <timer_compareMatchIntSetup+0x92>
			break;
	   #endif
	   #if defined(OCIE0A)
		case 0x00:
//			setbit(OCIE0A, T0_TIMSK);
			writebit(OCIE0A, T0_TIMSK, enable);
 5b0:	89 b7       	in	r24, 0x39	; 57
 5b2:	99 23       	and	r25, r25
 5b4:	11 f0       	breq	.+4      	; 0x5ba <timer_compareMatchIntSetup+0x3a>
 5b6:	80 61       	ori	r24, 0x10	; 16
 5b8:	01 c0       	rjmp	.+2      	; 0x5bc <timer_compareMatchIntSetup+0x3c>
 5ba:	8f 7e       	andi	r24, 0xEF	; 239
 5bc:	89 bf       	out	0x39, r24	; 57
			// My OCD bit me in the ass, this was set to TIMSK by mistake(?)
			setbit(OCF0A, T0_TIFR);
 5be:	88 b7       	in	r24, 0x38	; 56
 5c0:	80 61       	ori	r24, 0x10	; 16
 5c2:	1d c0       	rjmp	.+58     	; 0x5fe <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE0B)
		case 0x01:
//			setbit(OCIE0B, T0_TIMSK);
			writebit(OCIE0B, T0_TIMSK, enable);
 5c4:	89 b7       	in	r24, 0x39	; 57
 5c6:	99 23       	and	r25, r25
 5c8:	11 f0       	breq	.+4      	; 0x5ce <timer_compareMatchIntSetup+0x4e>
 5ca:	88 60       	ori	r24, 0x08	; 8
 5cc:	01 c0       	rjmp	.+2      	; 0x5d0 <timer_compareMatchIntSetup+0x50>
 5ce:	87 7f       	andi	r24, 0xF7	; 247
 5d0:	89 bf       	out	0x39, r24	; 57
			// As was this...
			setbit(OCF0B, T0_TIFR);
 5d2:	88 b7       	in	r24, 0x38	; 56
 5d4:	88 60       	ori	r24, 0x08	; 8
 5d6:	13 c0       	rjmp	.+38     	; 0x5fe <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE1A)
		case 0x10:
//			setbit(OCIE1A, T1_TIMSK);
			writebit(OCIE1A, T1_TIMSK, enable);
 5d8:	89 b7       	in	r24, 0x39	; 57
 5da:	99 23       	and	r25, r25
 5dc:	11 f0       	breq	.+4      	; 0x5e2 <timer_compareMatchIntSetup+0x62>
 5de:	80 64       	ori	r24, 0x40	; 64
 5e0:	01 c0       	rjmp	.+2      	; 0x5e4 <timer_compareMatchIntSetup+0x64>
 5e2:	8f 7b       	andi	r24, 0xBF	; 191
 5e4:	89 bf       	out	0x39, r24	; 57
			setbit(OCF1A, T1_TIFR);
 5e6:	88 b7       	in	r24, 0x38	; 56
 5e8:	80 64       	ori	r24, 0x40	; 64
 5ea:	09 c0       	rjmp	.+18     	; 0x5fe <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE1B)
		case 0x11:
//			setbit(OCIE1B, T1_TIMSK);
			writebit(OCIE1B, T1_TIMSK, enable);
 5ec:	89 b7       	in	r24, 0x39	; 57
 5ee:	99 23       	and	r25, r25
 5f0:	11 f0       	breq	.+4      	; 0x5f6 <timer_compareMatchIntSetup+0x76>
 5f2:	80 62       	ori	r24, 0x20	; 32
 5f4:	01 c0       	rjmp	.+2      	; 0x5f8 <timer_compareMatchIntSetup+0x78>
 5f6:	8f 7d       	andi	r24, 0xDF	; 223
 5f8:	89 bf       	out	0x39, r24	; 57
			setbit(OCF1B, T1_TIFR);
 5fa:	88 b7       	in	r24, 0x38	; 56
 5fc:	80 62       	ori	r24, 0x20	; 32
 5fe:	88 bf       	out	0x38, r24	; 56
			break;
	}
	
	//Don't reenable interrupts here if disabling... just leave them as they were....
	// but do enable for init...
	if(enable)
 600:	99 23       	and	r25, r25
 602:	41 f0       	breq	.+16     	; 0x614 <timer_compareMatchIntSetup+0x94>
		sei();
 604:	78 94       	sei
	
	return 0;
 606:	90 e0       	ldi	r25, 0x00	; 0
 608:	05 c0       	rjmp	.+10     	; 0x614 <timer_compareMatchIntSetup+0x94>
	  												uint8_t enable)
{
	uint8_t channelNum;

	if(timerNum >= MAXTIMERS)
		return 1;
 60a:	91 e0       	ldi	r25, 0x01	; 1
 60c:	03 c0       	rjmp	.+6      	; 0x614 <timer_compareMatchIntSetup+0x94>

	if(outputChannel >= 2) //MAXCHANNELSPERTIMER)
		return 2;
 60e:	92 e0       	ldi	r25, 0x02	; 2
 610:	01 c0       	rjmp	.+2      	; 0x614 <timer_compareMatchIntSetup+0x94>
			setbit(OCF3B, T3_TIFR);
			break;
	   #endif
	  #endif
		default:
			return 3;
 612:	93 e0       	ldi	r25, 0x03	; 3
	// but do enable for init...
	if(enable)
		sei();
	
	return 0;
}
 614:	89 2f       	mov	r24, r25
 616:	08 95       	ret

00000618 <setHeartRate>:

void setHeartRate(uint8_t rate)
{
//	heartRate = rate;
	
	if(rate == 0)
 618:	81 11       	cpse	r24, r1
 61a:	01 c0       	rjmp	.+2      	; 0x61e <setHeartRate+0x6>
		rate = 1;
 61c:	81 e0       	ldi	r24, 0x01	; 1
		
    heartStepTime = (HEARTSTEPTIME/rate);
 61e:	28 2f       	mov	r18, r24
 620:	30 e0       	ldi	r19, 0x00	; 0
 622:	40 e0       	ldi	r20, 0x00	; 0
 624:	50 e0       	ldi	r21, 0x00	; 0
 626:	60 ee       	ldi	r22, 0xE0	; 224
 628:	79 e7       	ldi	r23, 0x79	; 121
 62a:	80 e0       	ldi	r24, 0x00	; 0
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	55 d3       	rcall	.+1706   	; 0xcda <__udivmodsi4>
 630:	20 93 61 00 	sts	0x0061, r18
 634:	30 93 62 00 	sts	0x0062, r19
 638:	40 93 63 00 	sts	0x0063, r20
 63c:	50 93 64 00 	sts	0x0064, r21
 640:	08 95       	ret

00000642 <getHeartRate>:

#if (!defined(HEART_GETRATE_UNUSED) || !HEART_GETRATE_UNUSED)
//This function takes about 20 bytes
uint8_t getHeartRate(void)
{
	 return (uint8_t)(HEARTSTEPTIME/heartStepTime);
 642:	20 91 61 00 	lds	r18, 0x0061
 646:	30 91 62 00 	lds	r19, 0x0062
 64a:	40 91 63 00 	lds	r20, 0x0063
 64e:	50 91 64 00 	lds	r21, 0x0064
 652:	60 ee       	ldi	r22, 0xE0	; 224
 654:	79 e7       	ldi	r23, 0x79	; 121
 656:	80 e0       	ldi	r24, 0x00	; 0
 658:	90 e0       	ldi	r25, 0x00	; 0
 65a:	3f d3       	rcall	.+1662   	; 0xcda <__udivmodsi4>
 65c:	82 2f       	mov	r24, r18
}
 65e:	08 95       	ret

00000660 <heartClear>:
 #endif
#endif

void heartClear(void)
{
	hfm_setPower(&heartModulator, 0);
 660:	60 e0       	ldi	r22, 0x00	; 0
 662:	81 e8       	ldi	r24, 0x81	; 129
 664:	90 e0       	ldi	r25, 0x00	; 0
 666:	0e cf       	rjmp	.-484    	; 0x484 <hfm_setPower>

00000668 <init_heartBeat>:
	//DDR = H,out
	setoutVar(heartBeatPin, heartPIN);
#else
void init_heartBeat(void)
{
	clrpinPORT(HEART_PINNUM, HEART_PINPORT);
 668:	de 98       	cbi	0x1b, 6	; 27
	setoutPORT(HEART_PINNUM, HEART_PINPORT);
 66a:	d6 9a       	sbi	0x1a, 6	; 26
#endif



//	hfm_setPower(&heartModulator, 0);
	hfm_setup(&heartModulator, 0, HEART_MAXBRIGHT);
 66c:	4f ef       	ldi	r20, 0xFF	; 255
 66e:	60 e0       	ldi	r22, 0x00	; 0
 670:	81 e8       	ldi	r24, 0x81	; 129
 672:	90 e0       	ldi	r25, 0x00	; 0
 674:	10 df       	rcall	.-480    	; 0x496 <hfm_setup>
//	heartRate = rate;
	
	if(rate == 0)
		rate = 1;
		
    heartStepTime = (HEARTSTEPTIME/rate);
 676:	80 ee       	ldi	r24, 0xE0	; 224
 678:	99 e7       	ldi	r25, 0x79	; 121
 67a:	a0 e0       	ldi	r26, 0x00	; 0
 67c:	b0 e0       	ldi	r27, 0x00	; 0
 67e:	80 93 61 00 	sts	0x0061, r24
 682:	90 93 62 00 	sts	0x0062, r25
 686:	a0 93 63 00 	sts	0x0063, r26
 68a:	b0 93 64 00 	sts	0x0064, r27
	init_dmsTimer();
 #endif

#elif(defined(HEART_TCNTER_UPDATES_AND_INIT) && \
		HEART_TCNTER_UPDATES_AND_INIT)
	tcnter_init();
 68e:	f6 c0       	rjmp	.+492    	; 0x87c <tcnter_init>

00000690 <set_heartBlink>:
uint8_t heartBlink = 0;
//#define TOGGLETIME	(250*DMS_MS)

void set_heartBlink(uint8_t count)
{
	heartBlink = count;
 690:	80 93 66 00 	sts	0x0066, r24
 694:	08 95       	ret

00000696 <heartUpdate>:
#endif

//This function takes about 186 bytes
// Really?! Or is hfm not compiled if it's not used?
uint8_t heartUpdate(void)
{	
 696:	0f 93       	push	r16
 698:	1f 93       	push	r17
	static dms6sec_t lastTime = 0;
 #elif ( _HEART_TCNTER_ )
	static myTcnter_t lastTime = 0;

  #if (HEART_TCNTER_UPDATES_AND_INIT)
	tcnter_update();
 69a:	44 d1       	rcall	.+648    	; 0x924 <tcnter_update>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
 69c:	80 91 77 00 	lds	r24, 0x0077
 6a0:	90 91 78 00 	lds	r25, 0x0078
 6a4:	a0 91 79 00 	lds	r26, 0x0079
 6a8:	b0 91 7a 00 	lds	r27, 0x007A
 6ac:	40 91 6d 00 	lds	r20, 0x006D
 6b0:	50 91 6e 00 	lds	r21, 0x006E
 6b4:	60 91 6f 00 	lds	r22, 0x006F
 6b8:	70 91 70 00 	lds	r23, 0x0070
 6bc:	84 1b       	sub	r24, r20
 6be:	95 0b       	sbc	r25, r21
 6c0:	a6 0b       	sbc	r26, r22
 6c2:	b7 0b       	sbc	r27, r23

   if(thisDelta >= deltaTime)
 6c4:	40 91 61 00 	lds	r20, 0x0061
 6c8:	50 91 62 00 	lds	r21, 0x0062
 6cc:	60 91 63 00 	lds	r22, 0x0063
 6d0:	70 91 64 00 	lds	r23, 0x0064
 6d4:	84 17       	cp	r24, r20
 6d6:	95 07       	cpc	r25, r21
 6d8:	a6 07       	cpc	r26, r22
 6da:	b7 07       	cpc	r27, r23
 6dc:	68 f1       	brcs	.+90     	; 0x738 <heartUpdate+0xa2>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
 6de:	80 91 77 00 	lds	r24, 0x0077
 6e2:	90 91 78 00 	lds	r25, 0x0078
 6e6:	a0 91 79 00 	lds	r26, 0x0079
 6ea:	b0 91 7a 00 	lds	r27, 0x007A
 6ee:	80 93 6d 00 	sts	0x006D, r24
 6f2:	90 93 6e 00 	sts	0x006E, r25
 6f6:	a0 93 6f 00 	sts	0x006F, r26
 6fa:	b0 93 70 00 	sts	0x0070, r27
#if (!defined(_WDT_DISABLE_) || !_WDT_DISABLE_)
	//Woot! Saved two bytes!
	wdt_reset();
#endif

	desired = (uint8_t)(heartModulator.power);
 6fe:	80 91 84 00 	lds	r24, 0x0084

	desired += direction;
 702:	60 91 60 00 	lds	r22, 0x0060
 706:	77 27       	eor	r23, r23
 708:	67 fd       	sbrc	r22, 7
 70a:	70 95       	com	r23
 70c:	68 0f       	add	r22, r24
 70e:	71 1d       	adc	r23, r1
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
 710:	6f 3f       	cpi	r22, 0xFF	; 255
 712:	71 05       	cpc	r23, r1
 714:	34 f0       	brlt	.+12     	; 0x722 <heartUpdate+0x8c>
	{
		desired = HEART_MAXBRIGHT;
		direction = -1;
 716:	8f ef       	ldi	r24, 0xFF	; 255
 718:	80 93 60 00 	sts	0x0060, r24
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
	{
		desired = HEART_MAXBRIGHT;
 71c:	6f ef       	ldi	r22, 0xFF	; 255
 71e:	70 e0       	ldi	r23, 0x00	; 0
 720:	08 c0       	rjmp	.+16     	; 0x732 <heartUpdate+0x9c>
		direction = -1;
	}	

	if(desired <= 0)
 722:	16 16       	cp	r1, r22
 724:	17 06       	cpc	r1, r23
 726:	2c f0       	brlt	.+10     	; 0x732 <heartUpdate+0x9c>
	{
		desired = 0;
		direction = +1;
 728:	81 e0       	ldi	r24, 0x01	; 1
 72a:	80 93 60 00 	sts	0x0060, r24
		direction = -1;
	}	

	if(desired <= 0)
	{
		desired = 0;
 72e:	60 e0       	ldi	r22, 0x00	; 0
 730:	70 e0       	ldi	r23, 0x00	; 0
//	dms6sec_t currentTime;
	
//	currentTime = dmsGetTime();

	if(heart_isItTime(&lastTime, heartStepTime, HEART_PRECISE))
		hfm_setPower(&heartModulator, getNextDesired());
 732:	81 e8       	ldi	r24, 0x81	; 129
 734:	90 e0       	ldi	r25, 0x00	; 0
 736:	a6 de       	rcall	.-692    	; 0x484 <hfm_setPower>
	//determine whether the LED should be on or off based on the HFM
	// return TRUE if the pin is available as an input
	uint8_t ledVal;

#if (!defined(HEART_BLINK_UNUSED) || !HEART_BLINK_UNUSED)
	if(heartBlink)
 738:	80 91 66 00 	lds	r24, 0x0066
 73c:	88 23       	and	r24, r24
 73e:	09 f4       	brne	.+2      	; 0x742 <heartUpdate+0xac>
 740:	83 c0       	rjmp	.+262    	; 0x848 <heartUpdate+0x1b2>
 742:	98 2f       	mov	r25, r24
 744:	9f 70       	andi	r25, 0x0F	; 15
	

	uint8_t thisNibble = heartBlink;

	//If both nibbles are filled, process them as specified
	if((heartBlink & 0xf0) && (heartBlink & 0x0f))
 746:	28 2f       	mov	r18, r24
 748:	20 7f       	andi	r18, 0xF0	; 240
 74a:	31 f0       	breq	.+12     	; 0x758 <heartUpdate+0xc2>
 74c:	91 11       	cpse	r25, r1
 74e:	07 c0       	rjmp	.+14     	; 0x75e <heartUpdate+0xc8>
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
		highNibble = 0;
	else if(heartBlink & 0xf0)
		highNibble = 1;
 750:	21 e0       	ldi	r18, 0x01	; 1
 752:	20 93 6c 00 	sts	0x006C, r18
 756:	03 c0       	rjmp	.+6      	; 0x75e <heartUpdate+0xc8>
	{	//Fall through and toggle...
	}
	//Otherwise just process the one that's filled
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
 758:	91 11       	cpse	r25, r1
		highNibble = 0;
 75a:	10 92 6c 00 	sts	0x006C, r1
	else if(heartBlink & 0xf0)
		highNibble = 1;

	//Fill the appropriate nibble for blinking...
	if(highNibble)
 75e:	e0 91 6c 00 	lds	r30, 0x006C
 762:	ee 23       	and	r30, r30
 764:	19 f0       	breq	.+6      	; 0x76c <heartUpdate+0xd6>
		thisNibble = (thisNibble & 0xf0) >> 4;
 766:	82 95       	swap	r24
 768:	8f 70       	andi	r24, 0x0F	; 15
 76a:	01 c0       	rjmp	.+2      	; 0x76e <heartUpdate+0xd8>
	else
		thisNibble = (thisNibble & 0x0f);
 76c:	89 2f       	mov	r24, r25

#if(HEART_USES_TIMER)
	//Blink the proper number of times
	if((toggleCount>>1) < thisNibble)
 76e:	40 91 6b 00 	lds	r20, 0x006B
 772:	94 2f       	mov	r25, r20
 774:	96 95       	lsr	r25
 776:	00 91 67 00 	lds	r16, 0x0067
 77a:	10 91 68 00 	lds	r17, 0x0068
 77e:	20 91 69 00 	lds	r18, 0x0069
 782:	30 91 6a 00 	lds	r19, 0x006A
 786:	98 17       	cp	r25, r24
 788:	30 f5       	brcc	.+76     	; 0x7d6 <heartUpdate+0x140>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
 78a:	80 91 77 00 	lds	r24, 0x0077
 78e:	90 91 78 00 	lds	r25, 0x0078
 792:	a0 91 79 00 	lds	r26, 0x0079
 796:	b0 91 7a 00 	lds	r27, 0x007A
 79a:	80 1b       	sub	r24, r16
 79c:	91 0b       	sbc	r25, r17
 79e:	a2 0b       	sbc	r26, r18
 7a0:	b3 0b       	sbc	r27, r19

   if(thisDelta >= deltaTime)
 7a2:	80 32       	cpi	r24, 0x20	; 32
 7a4:	91 4a       	sbci	r25, 0xA1	; 161
 7a6:	a7 40       	sbci	r26, 0x07	; 7
 7a8:	b1 05       	cpc	r27, r1
 7aa:	08 f4       	brcc	.+2      	; 0x7ae <heartUpdate+0x118>
 7ac:	48 c0       	rjmp	.+144    	; 0x83e <heartUpdate+0x1a8>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
 7ae:	80 91 77 00 	lds	r24, 0x0077
 7b2:	90 91 78 00 	lds	r25, 0x0078
 7b6:	a0 91 79 00 	lds	r26, 0x0079
 7ba:	b0 91 7a 00 	lds	r27, 0x007A
 7be:	80 93 67 00 	sts	0x0067, r24
 7c2:	90 93 68 00 	sts	0x0068, r25
 7c6:	a0 93 69 00 	sts	0x0069, r26
 7ca:	b0 93 6a 00 	sts	0x006A, r27
	{
		if(heart_isItTime(&lastToggleTime, TOGGLETIME, HEART_PRECISE))
			toggleCount++;
 7ce:	4f 5f       	subi	r20, 0xFF	; 255
 7d0:	40 93 6b 00 	sts	0x006B, r20
 7d4:	34 c0       	rjmp	.+104    	; 0x83e <heartUpdate+0x1a8>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
 7d6:	40 91 77 00 	lds	r20, 0x0077
 7da:	50 91 78 00 	lds	r21, 0x0078
 7de:	60 91 79 00 	lds	r22, 0x0079
 7e2:	70 91 7a 00 	lds	r23, 0x007A
 7e6:	40 1b       	sub	r20, r16
 7e8:	51 0b       	sbc	r21, r17
 7ea:	62 0b       	sbc	r22, r18
 7ec:	73 0b       	sbc	r23, r19
	}
	else if(heart_isItTime(&lastToggleTime, 
 7ee:	80 e0       	ldi	r24, 0x00	; 0
 7f0:	99 e0       	ldi	r25, 0x09	; 9
 7f2:	ad e3       	ldi	r26, 0x3D	; 61
 7f4:	b0 e0       	ldi	r27, 0x00	; 0
 7f6:	0e 2e       	mov	r0, r30
 7f8:	04 c0       	rjmp	.+8      	; 0x802 <heartUpdate+0x16c>
 7fa:	88 0f       	add	r24, r24
 7fc:	99 1f       	adc	r25, r25
 7fe:	aa 1f       	adc	r26, r26
 800:	bb 1f       	adc	r27, r27
 802:	0a 94       	dec	r0
 804:	d2 f7       	brpl	.-12     	; 0x7fa <heartUpdate+0x164>

   if(thisDelta >= deltaTime)
 806:	48 17       	cp	r20, r24
 808:	59 07       	cpc	r21, r25
 80a:	6a 07       	cpc	r22, r26
 80c:	7b 07       	cpc	r23, r27
 80e:	b8 f0       	brcs	.+46     	; 0x83e <heartUpdate+0x1a8>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
 810:	80 91 77 00 	lds	r24, 0x0077
 814:	90 91 78 00 	lds	r25, 0x0078
 818:	a0 91 79 00 	lds	r26, 0x0079
 81c:	b0 91 7a 00 	lds	r27, 0x007A
 820:	80 93 67 00 	sts	0x0067, r24
 824:	90 93 68 00 	sts	0x0068, r25
 828:	a0 93 69 00 	sts	0x0069, r26
 82c:	b0 93 6a 00 	sts	0x006A, r27
						((((uint32_t)TOGGLETIME) * 8)<<(highNibble)),
						HEART_PRECISE))
	{
		toggleCount = 0;
 830:	10 92 6b 00 	sts	0x006B, r1
		//Only valid if both nibbles are filled (see above)
		highNibble = !highNibble;
 834:	81 e0       	ldi	r24, 0x01	; 1
 836:	e1 11       	cpse	r30, r1
 838:	80 e0       	ldi	r24, 0x00	; 0
 83a:	80 93 6c 00 	sts	0x006C, r24
		//Only valid if both nibbles are filled (see above)
		highNibble = !highNibble;
	}
#endif
	//(actually, the new value, at this point... but will be the last soon)
	return !getbit(0, toggleCount);
 83e:	80 91 6b 00 	lds	r24, 0x006B
 842:	80 95       	com	r24
 844:	81 70       	andi	r24, 0x01	; 1
 846:	03 c0       	rjmp	.+6      	; 0x84e <heartUpdate+0x1b8>
 #endif
		//ledVal = blinkHeart((dms6sec_t)currentTime);
	}
	else
#endif
		ledVal = hfm_nextOutput(&heartModulator);
 848:	81 e8       	ldi	r24, 0x81	; 129
 84a:	90 e0       	ldi	r25, 0x00	; 0
 84c:	29 de       	rcall	.-942    	; 0x4a0 <hfm_nextOutput>

	if(ledVal)
 84e:	88 23       	and	r24, r24
 850:	21 f0       	breq	.+8      	; 0x85a <heartUpdate+0x1c4>
			setoutVar(heartBeatPin, heartPIN);
			setpinVar(heartBeatPin, heartPIN);
		}
#else
 #if (HEART_LEDCONNECTION == LED_DIRECT_HIGH)
		setinPORT(HEART_PINNUM, HEART_PINPORT);
 852:	d6 98       	cbi	0x1a, 6	; 26
		setpuPORT(HEART_PINNUM, HEART_PINPORT);
 854:	de 9a       	sbi	0x1b, 6	; 27
		setpinPORT(HEART_PINNUM, HEART_PINPORT);
 #else
	#error "Not Handled..."
 #endif
#endif
		return TRUE;
 856:	81 e0       	ldi	r24, 0x01	; 1
 858:	03 c0       	rjmp	.+6      	; 0x860 <heartUpdate+0x1ca>
		//PORT = L
		clrpinVar(heartBeatPin, heartPIN);
		//DDR = H,out
		setoutVar(heartBeatPin, heartPIN);
#else
		clrpinPORT(HEART_PINNUM, HEART_PINPORT);
 85a:	de 98       	cbi	0x1b, 6	; 27
		setoutPORT(HEART_PINNUM, HEART_PINPORT);
 85c:	d6 9a       	sbi	0x1a, 6	; 26
#endif
		return FALSE;
 85e:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 860:	1f 91       	pop	r17
 862:	0f 91       	pop	r16
 864:	08 95       	ret

00000866 <heartPinInputPoll>:
	   asm("nop;");
	}

	pinState = getpinVar(heartBeatPin, heartPIN);
#else
	setinPORT(HEART_PINNUM, HEART_PINPORT);
 866:	d6 98       	cbi	0x1a, 6	; 26
	setpuPORT(HEART_PINNUM, HEART_PINPORT);
 868:	de 9a       	sbi	0x1b, 6	; 27
 86a:	8f ef       	ldi	r24, 0xFF	; 255
	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
 86c:	00 00       	nop
 86e:	81 50       	subi	r24, 0x01	; 1
	setinPORT(HEART_PINNUM, HEART_PINPORT);
	setpuPORT(HEART_PINNUM, HEART_PINPORT);

	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
 870:	e9 f7       	brne	.-6      	; 0x86c <heartPinInputPoll+0x6>
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
	}

	pinState = getpinPORT(HEART_PINNUM, HEART_PINPORT);
 872:	89 b3       	in	r24, 0x19	; 25
	// to assure valid/safe values of PORT and DDR...
	//Return the pin to the heartbeat
//	setoutVar(heartBeatPin, heartPIN);

	return pinState;
}
 874:	86 fb       	bst	r24, 6
 876:	88 27       	eor	r24, r24
 878:	80 f9       	bld	r24, 0
 87a:	08 95       	ret

0000087c <tcnter_init>:
	//What if the timer is 16bit (do they default as such?)
	timer_setWGM(TCNTER_AVRTIMER_NUM, WGM_NORMAL); //Necessary?
	timer_selectDivisor(TCNTER_AVRTIMER_NUM, TCNTER_AVRTIMER_CLKDIV);
#endif

	tcnter_lastTcnt = TCNTER_SOURCE_VAR;
 87c:	82 b7       	in	r24, 0x32	; 50
 87e:	80 93 76 00 	sts	0x0076, r24
	tcnter_myTcnter = 0;
 882:	10 92 77 00 	sts	0x0077, r1
 886:	10 92 78 00 	sts	0x0078, r1
 88a:	10 92 79 00 	sts	0x0079, r1
 88e:	10 92 7a 00 	sts	0x007A, r1
 892:	08 95       	ret

00000894 <tcnter_overflowUpdate>:
// (and after the actual overflow)... and therefore could be called at
// slightly different (+/-) times WRT the actual overflow...
TCNTER_INLINEABLE
void tcnter_overflowUpdate(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;
 894:	e2 b7       	in	r30, 0x32	; 50
	tcnter_compare_t deltaTcnt;


	//If tcnter_update() has been called inbetween, just treat this like a
	//normal tcnter_update()	
	if(tcnter_updatesSinceOverflowUpdate)
 896:	40 91 72 00 	lds	r20, 0x0072
 89a:	50 91 73 00 	lds	r21, 0x0073
 89e:	60 91 74 00 	lds	r22, 0x0074
 8a2:	70 91 75 00 	lds	r23, 0x0075
 8a6:	8e 2f       	mov	r24, r30
 8a8:	90 e0       	ldi	r25, 0x00	; 0
 8aa:	45 2b       	or	r20, r21
 8ac:	46 2b       	or	r20, r22
 8ae:	47 2b       	or	r20, r23
 8b0:	71 f0       	breq	.+28     	; 0x8ce <tcnter_overflowUpdate+0x3a>
	{
		//wrap-around can be handled here...
		// (This shouldn't happen, right? Since overflowUpdate is called?)
		if(thisTcnt < tcnter_lastTcnt)
 8b2:	40 91 76 00 	lds	r20, 0x0076
 8b6:	e4 17       	cp	r30, r20
 8b8:	18 f4       	brcc	.+6      	; 0x8c0 <tcnter_overflowUpdate+0x2c>
			deltaTcnt = (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
 8ba:	2f ed       	ldi	r18, 0xDF	; 223
 8bc:	30 e0       	ldi	r19, 0x00	; 0
 8be:	02 c0       	rjmp	.+4      	; 0x8c4 <tcnter_overflowUpdate+0x30>
		else
			deltaTcnt = 0;
 8c0:	20 e0       	ldi	r18, 0x00	; 0
 8c2:	30 e0       	ldi	r19, 0x00	; 0

		deltaTcnt += (tcnter_compare_t)thisTcnt
						- (tcnter_compare_t)tcnter_lastTcnt;
 8c4:	84 1b       	sub	r24, r20
 8c6:	91 09       	sbc	r25, r1
		if(thisTcnt < tcnter_lastTcnt)
			deltaTcnt = (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
		else
			deltaTcnt = 0;

		deltaTcnt += (tcnter_compare_t)thisTcnt
 8c8:	82 0f       	add	r24, r18
 8ca:	93 1f       	adc	r25, r19
 8cc:	06 c0       	rjmp	.+12     	; 0x8da <tcnter_overflowUpdate+0x46>
		deltaTcnt = TCNTER_SOURCE_OVERFLOW_VAL;

		//This should probably be small, e.g. +-1 WRT the last overflowUpdate
		// since it likely occurs in the overflow interrupt.
		deltaTcnt += (tcnter_compare_t)thisTcnt
						- (tcnter_compare_t)tcnter_lastOverflowTcnt;
 8ce:	20 91 71 00 	lds	r18, 0x0071
 8d2:	82 1b       	sub	r24, r18
 8d4:	91 09       	sbc	r25, r1
		//Any error will be subtracted later...
		deltaTcnt = TCNTER_SOURCE_OVERFLOW_VAL;

		//This should probably be small, e.g. +-1 WRT the last overflowUpdate
		// since it likely occurs in the overflow interrupt.
		deltaTcnt += (tcnter_compare_t)thisTcnt
 8d6:	81 52       	subi	r24, 0x21	; 33
 8d8:	9f 4f       	sbci	r25, 0xFF	; 255

	}


	//Add the delta to myTcnter
	tcnter_myTcnter += deltaTcnt;
 8da:	40 91 77 00 	lds	r20, 0x0077
 8de:	50 91 78 00 	lds	r21, 0x0078
 8e2:	60 91 79 00 	lds	r22, 0x0079
 8e6:	70 91 7a 00 	lds	r23, 0x007A
 8ea:	aa 27       	eor	r26, r26
 8ec:	97 fd       	sbrc	r25, 7
 8ee:	a0 95       	com	r26
 8f0:	ba 2f       	mov	r27, r26
 8f2:	84 0f       	add	r24, r20
 8f4:	95 1f       	adc	r25, r21
 8f6:	a6 1f       	adc	r26, r22
 8f8:	b7 1f       	adc	r27, r23
 8fa:	80 93 77 00 	sts	0x0077, r24
 8fe:	90 93 78 00 	sts	0x0078, r25
 902:	a0 93 79 00 	sts	0x0079, r26
 906:	b0 93 7a 00 	sts	0x007A, r27
	
	//And prep for the next call...
	tcnter_updatesSinceOverflowUpdate = 0;
 90a:	10 92 72 00 	sts	0x0072, r1
 90e:	10 92 73 00 	sts	0x0073, r1
 912:	10 92 74 00 	sts	0x0074, r1
 916:	10 92 75 00 	sts	0x0075, r1
	tcnter_lastTcnt = thisTcnt;
 91a:	e0 93 76 00 	sts	0x0076, r30
	tcnter_lastOverflowTcnt = thisTcnt;
 91e:	e0 93 71 00 	sts	0x0071, r30
 922:	08 95       	ret

00000924 <tcnter_update>:
//  (how could it take *more* instructions?!)
//   trying to shuffle registers?
//TCNTER_INLINEABLE
void tcnter_update(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;	//e.g. TCNT0
 924:	22 b7       	in	r18, 0x32	; 50
	
	tcnter_compare_t deltaTcnt = (tcnter_compare_t)thisTcnt 
										- (tcnter_compare_t)tcnter_lastTcnt;
 926:	30 91 76 00 	lds	r19, 0x0076
//TCNTER_INLINEABLE
void tcnter_update(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;	//e.g. TCNT0
	
	tcnter_compare_t deltaTcnt = (tcnter_compare_t)thisTcnt 
 92a:	82 2f       	mov	r24, r18
 92c:	90 e0       	ldi	r25, 0x00	; 0
 92e:	83 1b       	sub	r24, r19
 930:	91 09       	sbc	r25, r1
	// and update() is called after, at TCNT=1
	// update won't increment, and the updatesSinceOverflow, if allowed to
	// be incremented, would indicate to overflowUpdate that it should treat
	// the next overflow as a normal update, which may well occur at, again,
	// TCNT=1, which would result in a non-advancement at all.
	if(thisTcnt == tcnter_lastOverflowTcnt)
 932:	40 91 71 00 	lds	r20, 0x0071
 936:	24 17       	cp	r18, r20
 938:	91 f1       	breq	.+100    	; 0x99e <tcnter_update+0x7a>
		return;

	tcnter_updatesSinceOverflowUpdate++;
 93a:	40 91 72 00 	lds	r20, 0x0072
 93e:	50 91 73 00 	lds	r21, 0x0073
 942:	60 91 74 00 	lds	r22, 0x0074
 946:	70 91 75 00 	lds	r23, 0x0075
 94a:	4f 5f       	subi	r20, 0xFF	; 255
 94c:	5f 4f       	sbci	r21, 0xFF	; 255
 94e:	6f 4f       	sbci	r22, 0xFF	; 255
 950:	7f 4f       	sbci	r23, 0xFF	; 255
 952:	40 93 72 00 	sts	0x0072, r20
 956:	50 93 73 00 	sts	0x0073, r21
 95a:	60 93 74 00 	sts	0x0074, r22
 95e:	70 93 75 00 	sts	0x0075, r23
#endif
	
	// Handle wrap-around...
	if (thisTcnt < tcnter_lastTcnt)
 962:	23 17       	cp	r18, r19
 964:	10 f4       	brcc	.+4      	; 0x96a <tcnter_update+0x46>
		deltaTcnt += (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
 966:	81 52       	subi	r24, 0x21	; 33
 968:	9f 4f       	sbci	r25, 0xFF	; 255

	tcnter_lastTcnt = thisTcnt;
 96a:	20 93 76 00 	sts	0x0076, r18

	tcnter_myTcnter += (tcnter_t)deltaTcnt;
 96e:	40 91 77 00 	lds	r20, 0x0077
 972:	50 91 78 00 	lds	r21, 0x0078
 976:	60 91 79 00 	lds	r22, 0x0079
 97a:	70 91 7a 00 	lds	r23, 0x007A
 97e:	aa 27       	eor	r26, r26
 980:	97 fd       	sbrc	r25, 7
 982:	a0 95       	com	r26
 984:	ba 2f       	mov	r27, r26
 986:	84 0f       	add	r24, r20
 988:	95 1f       	adc	r25, r21
 98a:	a6 1f       	adc	r26, r22
 98c:	b7 1f       	adc	r27, r23
 98e:	80 93 77 00 	sts	0x0077, r24
 992:	90 93 78 00 	sts	0x0078, r25
 996:	a0 93 79 00 	sts	0x0079, r26
 99a:	b0 93 7a 00 	sts	0x007A, r27
 99e:	08 95       	ret

000009a0 <tcnter_wait>:
	DPRINT("tcnter_init()\n");
}


void tcnter_wait(myTcnter_t tcnts)
{
 9a0:	8f 92       	push	r8
 9a2:	9f 92       	push	r9
 9a4:	af 92       	push	r10
 9a6:	bf 92       	push	r11
 9a8:	cf 92       	push	r12
 9aa:	df 92       	push	r13
 9ac:	ef 92       	push	r14
 9ae:	ff 92       	push	r15
 9b0:	cf 93       	push	r28
 9b2:	df 93       	push	r29
 9b4:	00 d0       	rcall	.+0      	; 0x9b6 <tcnter_wait+0x16>
 9b6:	00 d0       	rcall	.+0      	; 0x9b8 <tcnter_wait+0x18>
 9b8:	cd b7       	in	r28, 0x3d	; 61
 9ba:	de b7       	in	r29, 0x3e	; 62

//Inlined: Saved 40B
TCNTER_INLINEABLE
tcnter_t tcnter_get(void)
{
	return tcnter_myTcnter;
 9bc:	c0 90 77 00 	lds	r12, 0x0077
 9c0:	d0 90 78 00 	lds	r13, 0x0078
 9c4:	e0 90 79 00 	lds	r14, 0x0079
 9c8:	f0 90 7a 00 	lds	r15, 0x007A

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
 9cc:	80 90 77 00 	lds	r8, 0x0077
 9d0:	90 90 78 00 	lds	r9, 0x0078
 9d4:	a0 90 79 00 	lds	r10, 0x0079
 9d8:	b0 90 7a 00 	lds	r11, 0x007A
 9dc:	8c 18       	sub	r8, r12
 9de:	9d 08       	sbc	r9, r13
 9e0:	ae 08       	sbc	r10, r14
 9e2:	bf 08       	sbc	r11, r15

   if(thisDelta >= deltaTime)
 9e4:	86 16       	cp	r8, r22
 9e6:	97 06       	cpc	r9, r23
 9e8:	a8 06       	cpc	r10, r24
 9ea:	b9 06       	cpc	r11, r25
 9ec:	b8 f0       	brcs	.+46     	; 0xa1c <tcnter_wait+0x7c>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
 9ee:	80 91 77 00 	lds	r24, 0x0077
 9f2:	90 91 78 00 	lds	r25, 0x0078
 9f6:	a0 91 79 00 	lds	r26, 0x0079
 9fa:	b0 91 7a 00 	lds	r27, 0x007A
	while(!tcnter_isItTime(&startTime, tcnts))
	{
		tcnter_update();
		//asm("nop;");
	}
}
 9fe:	0f 90       	pop	r0
 a00:	0f 90       	pop	r0
 a02:	0f 90       	pop	r0
 a04:	0f 90       	pop	r0
 a06:	df 91       	pop	r29
 a08:	cf 91       	pop	r28
 a0a:	ff 90       	pop	r15
 a0c:	ef 90       	pop	r14
 a0e:	df 90       	pop	r13
 a10:	cf 90       	pop	r12
 a12:	bf 90       	pop	r11
 a14:	af 90       	pop	r10
 a16:	9f 90       	pop	r9
 a18:	8f 90       	pop	r8
 a1a:	08 95       	ret
{
	myTcnter_t startTime = tcnter_get();

	while(!tcnter_isItTime(&startTime, tcnts))
	{
		tcnter_update();
 a1c:	69 83       	std	Y+1, r22	; 0x01
 a1e:	7a 83       	std	Y+2, r23	; 0x02
 a20:	8b 83       	std	Y+3, r24	; 0x03
 a22:	9c 83       	std	Y+4, r25	; 0x04
 a24:	7f df       	rcall	.-258    	; 0x924 <tcnter_update>
 a26:	69 81       	ldd	r22, Y+1	; 0x01
 a28:	7a 81       	ldd	r23, Y+2	; 0x02
 a2a:	8b 81       	ldd	r24, Y+3	; 0x03
 a2c:	9c 81       	ldd	r25, Y+4	; 0x04
 a2e:	ce cf       	rjmp	.-100    	; 0x9cc <tcnter_wait+0x2c>

00000a30 <tcnter_get>:

//Inlined: Saved 40B
TCNTER_INLINEABLE
tcnter_t tcnter_get(void)
{
	return tcnter_myTcnter;
 a30:	60 91 77 00 	lds	r22, 0x0077
 a34:	70 91 78 00 	lds	r23, 0x0078
 a38:	80 91 79 00 	lds	r24, 0x0079
 a3c:	90 91 7a 00 	lds	r25, 0x007A
}
 a40:	08 95       	ret

00000a42 <quadrantizeTheta>:
// negative values returned here are to be absoluted, first
// but they indicate that the resulting sine value is to be negated
theta_t quadrantizeTheta(theta_t theta)
{

	theta %= SINE_2PI;
 a42:	60 e0       	ldi	r22, 0x00	; 0
 a44:	72 e0       	ldi	r23, 0x02	; 2
 a46:	36 d1       	rcall	.+620    	; 0xcb4 <__divmodhi4>

	if(theta < 0)
 a48:	97 fd       	sbrc	r25, 7
		theta = SINE_2PI + theta;
 a4a:	9e 5f       	subi	r25, 0xFE	; 254

//For more accurate realtimeishness, it might be worthwhile to reverse this order...
	
	//in the first quadrant, just take the sine value from the table
	if(theta < SINE_SIZE-1) //128)
 a4c:	80 38       	cpi	r24, 0x80	; 128
 a4e:	91 05       	cpc	r25, r1
 a50:	84 f0       	brlt	.+32     	; 0xa72 <quadrantizeTheta+0x30>
	{
		//theta=theta;
	}	
	//in the second quadrant, mirror theta and subtract the offset
	else if(theta < SINE_SIZE2) //256)
 a52:	8f 3f       	cpi	r24, 0xFF	; 255
 a54:	91 05       	cpc	r25, r1
 a56:	29 f0       	breq	.+10     	; 0xa62 <quadrantizeTheta+0x20>
 a58:	24 f0       	brlt	.+8      	; 0xa62 <quadrantizeTheta+0x20>
	{
		theta=SINE_SIZE2-theta;
		//return pgm_read_sine(sineTable[SINE_SIZE2-theta]); //256-theta]);
	}
	//in the third quadrant, mirror the value and subtract the offset
	else if(theta < SINE_SIZE3) //384)
 a5a:	80 38       	cpi	r24, 0x80	; 128
 a5c:	51 e0       	ldi	r21, 0x01	; 1
 a5e:	95 07       	cpc	r25, r21
 a60:	3c f4       	brge	.+14     	; 0xa70 <quadrantizeTheta+0x2e>
	{
		theta=-(theta-SINE_SIZE2);
 a62:	20 e0       	ldi	r18, 0x00	; 0
 a64:	31 e0       	ldi	r19, 0x01	; 1
 a66:	a9 01       	movw	r20, r18
 a68:	48 1b       	sub	r20, r24
 a6a:	59 0b       	sbc	r21, r25
 a6c:	ca 01       	movw	r24, r20
 a6e:	08 95       	ret
		//return -(sine_t)pgm_read_sine(sineTable[theta-SINE_SIZE2]); //256]);
	}
	//in the fourth quadrant, mirror both theta and the value and subtract the offset...
	else
	{
		theta=-(SINE_SIZE4-theta);
 a70:	92 50       	subi	r25, 0x02	; 2
		//negative=TRUE;
		//return -(sine_t)pgm_read_sine(sineTable[SINE_SIZE4-theta]); //512-theta]);
	}

	return theta;
}
 a72:	08 95       	ret

00000a74 <sineRaw>:
//output is a value between -INT32_MAX and INT32_MAX (representing sin values -1 to 1)
sine_t sineRaw(theta_t theta)
{
	uint8_t negative=FALSE;

	theta = quadrantizeTheta(theta);
 a74:	e6 df       	rcall	.-52     	; 0xa42 <quadrantizeTheta>

	//This reduced code-size from 3860 to 3838
*/
	//adding quadrantizeTheta increased it to 3844
	// but should be dramatic in combination with sineRaw8
	if(theta < 0)
 a76:	97 ff       	sbrs	r25, 7
 a78:	05 c0       	rjmp	.+10     	; 0xa84 <sineRaw+0x10>
	{
		theta = -theta;
 a7a:	91 95       	neg	r25
 a7c:	81 95       	neg	r24
 a7e:	91 09       	sbc	r25, r1
		negative=TRUE;
 a80:	21 e0       	ldi	r18, 0x01	; 1
 a82:	01 c0       	rjmp	.+2      	; 0xa86 <sineRaw+0x12>
//theta is a value between 0 and 511 (representing an angle of 0-359.som'n deg)
//   rollover/wraparound should work fine... (e.g. Sine(coord_t))
//output is a value between -INT32_MAX and INT32_MAX (representing sin values -1 to 1)
sine_t sineRaw(theta_t theta)
{
	uint8_t negative=FALSE;
 a84:	20 e0       	ldi	r18, 0x00	; 0
	{
		theta = -theta;
		negative=TRUE;
	}

	sine_t sine=pgm_read_sine(sineTable[theta]);
 a86:	fc 01       	movw	r30, r24
 a88:	ee 0f       	add	r30, r30
 a8a:	ff 1f       	adc	r31, r31
 a8c:	ea 5d       	subi	r30, 0xDA	; 218
 a8e:	ff 4f       	sbci	r31, 0xFF	; 255
 a90:	85 91       	lpm	r24, Z+
 a92:	94 91       	lpm	r25, Z
	
	if(negative)
 a94:	22 23       	and	r18, r18
 a96:	19 f0       	breq	.+6      	; 0xa9e <sineRaw+0x2a>
		sine = -sine;
 a98:	91 95       	neg	r25
 a9a:	81 95       	neg	r24
 a9c:	91 09       	sbc	r25, r1
	return sine;
}
 a9e:	08 95       	ret

00000aa0 <sineRaw8>:
	   return -(int8_t)pgm_read_sine8(sineTable[SINE_SIZE4-theta]); 
	*/

	//And doing this here, reduced from 3844 to 3770
	uint8_t negative = FALSE;
	theta=quadrantizeTheta(theta);
 aa0:	d0 df       	rcall	.-96     	; 0xa42 <quadrantizeTheta>

	if(theta < 0)
 aa2:	97 ff       	sbrs	r25, 7
 aa4:	05 c0       	rjmp	.+10     	; 0xab0 <sineRaw8+0x10>
	{
		theta = -theta;
 aa6:	91 95       	neg	r25
 aa8:	81 95       	neg	r24
 aaa:	91 09       	sbc	r25, r1
		negative = TRUE;
 aac:	21 e0       	ldi	r18, 0x01	; 1
 aae:	01 c0       	rjmp	.+2      	; 0xab2 <sineRaw8+0x12>
	else
	   return -(int8_t)pgm_read_sine8(sineTable[SINE_SIZE4-theta]); 
	*/

	//And doing this here, reduced from 3844 to 3770
	uint8_t negative = FALSE;
 ab0:	20 e0       	ldi	r18, 0x00	; 0
	{
		theta = -theta;
		negative = TRUE;
	}

	int8_t sine=pgm_read_sine8(sineTable[theta]);
 ab2:	fc 01       	movw	r30, r24
 ab4:	ee 0f       	add	r30, r30
 ab6:	ff 1f       	adc	r31, r31
 ab8:	e9 5d       	subi	r30, 0xD9	; 217
 aba:	ff 4f       	sbci	r31, 0xFF	; 255
 abc:	84 91       	lpm	r24, Z

	if(negative)
 abe:	21 11       	cpse	r18, r1
		sine = -sine;
 ac0:	81 95       	neg	r24
	return sine;
}
 ac2:	08 95       	ret

00000ac4 <pll_enable>:
   // The benefit of such high PWM frequency is the low RC values necessary
   //  for filtering to DC.
	// From the ATtiny861 manual:
	// "To change Timer/Counter1 to the async mode follow this procedure"
   // 1: Enable the PLL
   setbit(PLLE, PLLCSR);
 ac4:	89 b5       	in	r24, 0x29	; 41
 ac6:	82 60       	ori	r24, 0x02	; 2
 ac8:	89 bd       	out	0x29, r24	; 41
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 aca:	8f e8       	ldi	r24, 0x8F	; 143
 acc:	91 e0       	ldi	r25, 0x01	; 1
 ace:	01 97       	sbiw	r24, 0x01	; 1
 ad0:	f1 f7       	brne	.-4      	; 0xace <pll_enable+0xa>
 ad2:	00 c0       	rjmp	.+0      	; 0xad4 <pll_enable+0x10>
 ad4:	00 00       	nop
   // 2: Wait 100us for the PLL to stabilize
   // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
   _delay_us(100);
//   dmsWait(1);
   // 3: Poll PLOCK until it is set...
   while(!getbit(PLOCK, PLLCSR))
 ad6:	09 b4       	in	r0, 0x29	; 41
 ad8:	00 fc       	sbrc	r0, 0
 ada:	02 c0       	rjmp	.+4      	; 0xae0 <pll_enable+0x1c>
   {
      asm("nop");
 adc:	00 00       	nop
 ade:	fb cf       	rjmp	.-10     	; 0xad6 <pll_enable+0x12>
   }

//The PWM161 doesn't have a PCKE bit.
#if(!defined(__AVR_AT90PWM161__))
   // 4: Set the PCKE bit to enable async mode
   setbit(PCKE, PLLCSR);
 ae0:	89 b5       	in	r24, 0x29	; 41
 ae2:	84 60       	ori	r24, 0x04	; 4
 ae4:	89 bd       	out	0x29, r24	; 41
 ae6:	08 95       	ret

00000ae8 <lvds_timerInit>:
   //Timer1 is used for LVDS (in PLL clocking mode)
  
     //pll_enable();   
   
   //We want it to count 7 bits, 0-6 and reset at 7
   OCR1C = 6;
 ae8:	86 e0       	ldi	r24, 0x06	; 6
 aea:	8b bd       	out	0x2b, r24	; 43

   //We want the clock to go low at TCNT=0 and high at TCNT=4
   CLOCK_OCR = 3; //2; //3;
 aec:	83 e0       	ldi	r24, 0x03	; 3
 aee:	8c bd       	out	0x2c, r24	; 44
   //PLL is 4MHz*8 = 32MHz
   // then TimerClockDivisor=8 gives 4MHz
   pll_enable();
   #define SLOW_LVDS_TEST TRUE
#elif (defined(OSCCAL_VAL))
   OSCCAL = OSCCAL_VAL;
 af0:	8f ef       	ldi	r24, 0xFF	; 255
 af2:	81 bf       	out	0x31, r24	; 49
   //  (horizontally... pre LVDS_PRESCALER affecting DOTS_TO_CYC)
   //  so accessing *all* pixels in a row would make it even slower...
   // Further, it didn't seem to be paying attention to the fact that
   // the same pixels are drawn on multiple rows...
   // WTF? (the image was scaled, proportionately! 1pix x 1pix)
   pll_enable();
 af4:	e7 df       	rcall	.-50     	; 0xac4 <pll_enable>
   pll_enable();
   //#warning "The PLL configuration code is not in here yet!"
#endif

   //Set the Timer1 clock prescaler...
   writeMasked(CSBITS, 
 af6:	8f b5       	in	r24, 0x2f	; 47
 af8:	80 7f       	andi	r24, 0xF0	; 240
 afa:	81 60       	ori	r24, 0x01	; 1
 afc:	8f bd       	out	0x2f, r24	; 47
               TCCR1B);

   //Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
   // Allegedly this is prescaled from the PCK (or CK)
   //    NOT from the Timer1 prescaler...
   writeMasked(DTPSBITS,
 afe:	8f b5       	in	r24, 0x2f	; 47
 b00:	8f 7c       	andi	r24, 0xCF	; 207
 b02:	8f bd       	out	0x2f, r24	; 47
 
   //FastPWM
//Now Handled in lvds_xxxOnCompare():

   //These are also written below (excluding PWM1D)
   setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
 b04:	80 b7       	in	r24, 0x30	; 48
 b06:	82 60       	ori	r24, 0x02	; 2
 b08:	80 bf       	out	0x30, r24	; 48
                           //Need to do the same for other channels
  
   setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
 b0a:	80 b7       	in	r24, 0x30	; 48
 b0c:	81 60       	ori	r24, 0x01	; 1
 b0e:	80 bf       	out	0x30, r24	; 48

   setbit(PWM1D, TCCR1C);
 b10:	87 b5       	in	r24, 0x27	; 39
 b12:	81 60       	ori	r24, 0x01	; 1
 b14:	87 bd       	out	0x27, r24	; 39

   //PWM1D is not in TCCR1A...

   setoutPORT(PB1, PORTB);   //+OC1A, DVH/BLUE, MISO (usually heart)
 b16:	b9 9a       	sbi	0x17, 1	; 23
//   setoutPORT(PB0, PORTB);   //-OC1A    MOSI unused
   setoutPORT(PB2, PORTB); //-OC1B, -GREEN    (INVERTED) SCK
 b18:	ba 9a       	sbi	0x17, 2	; 23
   setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
 b1a:	bb 9a       	sbi	0x17, 3	; 23
   setoutPORT(PB5, PORTB); //+OC1D, RED
 b1c:	bd 9a       	sbi	0x17, 5	; 23


   writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
 b1e:	86 b5       	in	r24, 0x26	; 38
 b20:	8c 7f       	andi	r24, 0xFC	; 252
 b22:	86 bd       	out	0x26, r24	; 38
//            | (0<<COM1B1) | (1<<COM1B0) 
//            | (1<<PWM1A) | (1<<PWM1B) )
//#define lvds_ComplementaryClrOnCompare() \ //
   //Do TCCR1C first, because it contains shadow-bits of TCCR1A that I
   // don't want to have to rewrite...
   TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
 b24:	89 e0       	ldi	r24, 0x09	; 9
 b26:	87 bd       	out	0x27, r24	; 39
 clock is affected by Dead-Times... Still a bit vague.
*/
//	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
//            | (1<<COM1B1) | (0<<COM1B0) //Don't use complementary for CLK
//            | (1<<PWM1A) | (1<<PWM1B) );
	lvds_disableGreen_MakeClockInsensitiveToDT();
 b28:	83 e6       	ldi	r24, 0x63	; 99
 b2a:	80 bf       	out	0x30, r24	; 48
	// //Make sure Green is off...
	// DT1 = 3;



    Nada_init();
 b2c:	80 e3       	ldi	r24, 0x30	; 48
 b2e:	84 bd       	out	0x24, r24	; 36
 b30:	84 e0       	ldi	r24, 0x04	; 4
 b32:	8d bd       	out	0x2d, r24	; 45
 b34:	08 95       	ret

00000b36 <lcd_init>:
#endif

void lcd_init(void)
{
	//Not sure modifying vSync randomly is safe...
	vSync = 0;
 b36:	10 92 7e 00 	sts	0x007E, r1
	//the rest should be...? assuming it occurs after lcd_update() completes
	// (thus leaving it in NADA-state)
	hsyncCount = 0;
 b3a:	10 92 7d 00 	sts	0x007D, r1
 b3e:	10 92 7c 00 	sts	0x007C, r1
	dataEnable = FALSE;
 b42:	10 92 7f 00 	sts	0x007F, r1
 	Nada_init();
 b46:	80 e3       	ldi	r24, 0x30	; 48
 b48:	84 bd       	out	0x24, r24	; 36
 b4a:	84 e0       	ldi	r24, 0x04	; 4
 b4c:	8d bd       	out	0x2d, r24	; 45
 b4e:	08 95       	ret

00000b50 <drawPix>:


#if(defined(DE_BLUE) && DE_BLUE)
DP_INLINEABLE void drawPix(uint16_t rowNum)
{
		DEblue_fromNada();
 b50:	8f ef       	ldi	r24, 0xFF	; 255
 b52:	8d bd       	out	0x2d, r24	; 45
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 b54:	83 e9       	ldi	r24, 0x93	; 147
 b56:	91 e0       	ldi	r25, 0x01	; 1
 b58:	01 97       	sbiw	r24, 0x01	; 1
 b5a:	f1 f7       	brne	.-4      	; 0xb58 <drawPix+0x8>
		//delay_cyc(DOTS_TO_CYC(DE_ACTIVE_DOTS));
		//delay_Dots(DE_ACTIVE_DOTS);
		DE_DotDelay(DE_ACTIVE_DOTS);
		Nada_fromDEblue();
 b5c:	80 e3       	ldi	r24, 0x30	; 48
 b5e:	84 bd       	out	0x24, r24	; 36
 b60:	84 e0       	ldi	r24, 0x04	; 4
 b62:	8d bd       	out	0x2d, r24	; 45
 b64:	08 95       	ret

00000b66 <lcd_update>:
//           Not *entirely* accurate, as it may be negative during VBLANK
//           OR returns LCD_FRAMECOMPLETE when that's the case.
// DOES THIS RETURN THE ROW THAT WAS DRAWN OR THE NEXT...?
#define LCD_FRAMECOMPLETE	INT16_MAX
int16_t lcd_update(void)
{
 b66:	cf 93       	push	r28
 b68:	df 93       	push	r29
//	uint8_t frameComplete = FALSE;

#warning "this might be off by one, which would explain the weird first row"
	int16_t rowNum = hsyncCount - T_DV-T_VD-T_Vlow;
 b6a:	80 91 7c 00 	lds	r24, 0x007C
 b6e:	90 91 7d 00 	lds	r25, 0x007D
 b72:	07 97       	sbiw	r24, 0x07	; 7
 b74:	d8 2f       	mov	r29, r24
 b76:	c9 2f       	mov	r28, r25
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
//	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);


	loadData(rowNum, dataEnable);
 b78:	20 91 7f 00 	lds	r18, 0x007F
#ifdef drawPixSetup
	drawPixSetup(rowNum);
#endif

	//H Active pulse...
   if(vSync)
 b7c:	30 91 7e 00 	lds	r19, 0x007E
 b80:	33 23       	and	r19, r19
 b82:	19 f0       	breq	.+6      	; 0xb8a <lcd_update+0x24>
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
 b84:	1d bc       	out	0x2d, r1	; 45
      Hlow_Delay();
      Vsync_fromVplusH();
 b86:	35 e0       	ldi	r19, 0x05	; 5
 b88:	03 c0       	rjmp	.+6      	; 0xb90 <lcd_update+0x2a>
      HD_Delay();
   }
   else
   {
      Hsync_fromNada();
 b8a:	33 e0       	ldi	r19, 0x03	; 3
 b8c:	3d bd       	out	0x2d, r19	; 45
      Hlow_Delay();
      Nada_fromHsync();
 b8e:	34 e0       	ldi	r19, 0x04	; 4
 b90:	3d bd       	out	0x2d, r19	; 45
      HD_Delay();
   }

   if(dataEnable)
 b92:	21 11       	cpse	r18, r1
   {

		//No DE_fromNada() in here, either...
		drawPix(rowNum);
 b94:	dd df       	rcall	.-70     	; 0xb50 <drawPix>


	loadData(rowNum, dataEnable);


	hsyncCount++;
 b96:	20 91 7c 00 	lds	r18, 0x007C
 b9a:	30 91 7d 00 	lds	r19, 0x007D
 b9e:	2f 5f       	subi	r18, 0xFF	; 255
 ba0:	3f 4f       	sbci	r19, 0xFF	; 255
 ba2:	30 93 7d 00 	sts	0x007D, r19
 ba6:	20 93 7c 00 	sts	0x007C, r18

	switch(hsyncCount)
 baa:	20 91 7c 00 	lds	r18, 0x007C
 bae:	30 91 7d 00 	lds	r19, 0x007D
 bb2:	24 30       	cpi	r18, 0x04	; 4
 bb4:	31 05       	cpc	r19, r1
 bb6:	e1 f0       	breq	.+56     	; 0xbf0 <lcd_update+0x8a>
 bb8:	60 f4       	brcc	.+24     	; 0xbd2 <lcd_update+0x6c>
 bba:	23 30       	cpi	r18, 0x03	; 3
 bbc:	31 05       	cpc	r19, r1
 bbe:	11 f5       	brne	.+68     	; 0xc04 <lcd_update+0x9e>
	{
		//V Front Porch, begins with initLCD

		//Vsync H->L (Begin V-Sync)
		case T_DV:
			dataEnable = FALSE;
 bc0:	10 92 7f 00 	sts	0x007F, r1
			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = TRUE;
 bc4:	81 e0       	ldi	r24, 0x01	; 1
 bc6:	80 93 7e 00 	sts	0x007E, r24
			Vsync_fromNada();
 bca:	80 e4       	ldi	r24, 0x40	; 64
 bcc:	84 bd       	out	0x24, r24	; 36
 bce:	85 e0       	ldi	r24, 0x05	; 5
 bd0:	14 c0       	rjmp	.+40     	; 0xbfa <lcd_update+0x94>
	loadData(rowNum, dataEnable);


	hsyncCount++;

	switch(hsyncCount)
 bd2:	27 30       	cpi	r18, 0x07	; 7
 bd4:	31 05       	cpc	r19, r1
 bd6:	99 f0       	breq	.+38     	; 0xbfe <lcd_update+0x98>
 bd8:	27 30       	cpi	r18, 0x07	; 7
 bda:	33 40       	sbci	r19, 0x03	; 3
 bdc:	99 f4       	brne	.+38     	; 0xc04 <lcd_update+0x9e>
			dataEnable = TRUE;
			break;
		// All rows have been displayed
		// Return to V Front Porch
		case V_COUNT +(T_VD + T_Vlow + T_DV):
			dataEnable = FALSE;
 bde:	10 92 7f 00 	sts	0x007F, r1
		//	break;
		//Frame complete
		//case HSYNC_COUNT_FRAME_COMPLETE:
			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
			hsyncCount = 0;
 be2:	10 92 7d 00 	sts	0x007D, r1
 be6:	10 92 7c 00 	sts	0x007C, r1
#endif
			
//#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
// Yeah, guess that makes sense... Must be Nada...
			//frameComplete = TRUE;
			rowNum = LCD_FRAMECOMPLETE;
 bea:	df ef       	ldi	r29, 0xFF	; 255
 bec:	cf e7       	ldi	r28, 0x7F	; 127
			break;
 bee:	0a c0       	rjmp	.+20     	; 0xc04 <lcd_update+0x9e>
		//	if(hfm_nextOutput(&modulator))
		//		colorOverride = 0xff;
		//	else
		//		colorOverride = 7;
			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = FALSE;
 bf0:	10 92 7e 00 	sts	0x007E, r1
			Nada_fromVsync();
 bf4:	80 e3       	ldi	r24, 0x30	; 48
 bf6:	84 bd       	out	0x24, r24	; 36
 bf8:	84 e0       	ldi	r24, 0x04	; 4
 bfa:	8d bd       	out	0x2d, r24	; 45
			break;
 bfc:	03 c0       	rjmp	.+6      	; 0xc04 <lcd_update+0x9e>
		//Start of frame (DE active)
		case T_VD +(T_Vlow + T_DV):
			dataEnable = TRUE;
 bfe:	81 e0       	ldi	r24, 0x01	; 1
 c00:	80 93 7f 00 	sts	0x007F, r24
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...

	return rowNum; //frameComplete;
}
 c04:	8d 2f       	mov	r24, r29
 c06:	9c 2f       	mov	r25, r28
 c08:	df 91       	pop	r29
 c0a:	cf 91       	pop	r28
 c0c:	08 95       	ret

00000c0e <restartFrameUpdate>:
 volatile uint8_t frameCount = 0;


 void restartFrameUpdate(void)
 {
	updateFrame = FB_REFRESH_ON_CHANGE_COUNT;
 c0e:	81 e0       	ldi	r24, 0x01	; 1
 c10:	80 93 65 00 	sts	0x0065, r24
 c14:	08 95       	ret

00000c16 <__vector_14>:
 //Nearly everything display-related happens in this interrupt
 // It even calls the functions that load (and calculate!) the data for the
 // next row.
 // So basically, the entire project is running via timer-interrupt.
 SIGNAL(HSYNC_TIMER_INTERRUPT_VECT) //TIMER0_COMPA_vect)
 {
 c16:	1f 92       	push	r1
 c18:	0f 92       	push	r0
 c1a:	0f b6       	in	r0, 0x3f	; 63
 c1c:	0f 92       	push	r0
 c1e:	11 24       	eor	r1, r1
 c20:	2f 93       	push	r18
 c22:	3f 93       	push	r19
 c24:	4f 93       	push	r20
 c26:	5f 93       	push	r21
 c28:	6f 93       	push	r22
 c2a:	7f 93       	push	r23
 c2c:	8f 93       	push	r24
 c2e:	9f 93       	push	r25
 c30:	af 93       	push	r26
 c32:	bf 93       	push	r27
 c34:	ef 93       	push	r30
 c36:	ff 93       	push	r31
		// we need to do it manually...
		// (because the tcnter uses the hsyncTimer)
#if(!defined(HEART_TCNTER_UPDATES_AND_INIT) || \
		!HEART_TCNTER_UPDATES_AND_INIT)
 #if(defined(_HEART_TCNTER_) && _HEART_TCNTER_)
	 tcnter_overflowUpdate();
 c38:	2d de       	rcall	.-934    	; 0x894 <tcnter_overflowUpdate>
 #endif
#endif

	 if(!updateFrame)
 c3a:	80 91 65 00 	lds	r24, 0x0065
 c3e:	88 23       	and	r24, r24
 c40:	49 f0       	breq	.+18     	; 0xc54 <__vector_14+0x3e>

#endif // testing 91 vs 66.51-1
	 //a/o v66.51-64: lcdUpdate() was surrounded by heart set/cleared
	 // for 'scoping syncing... definitely revealed the problem. But easy
	 // enough to do that the code's not reimplemented here (set/clrpinPORT)
	int16_t rowNum = lcd_update();
 c42:	91 df       	rcall	.-222    	; 0xb66 <lcd_update>

	if(rowNum == LCD_FRAMECOMPLETE)
 c44:	8f 3f       	cpi	r24, 0xFF	; 255
 c46:	9f 47       	sbci	r25, 0x7F	; 127
 c48:	29 f4       	brne	.+10     	; 0xc54 <__vector_14+0x3e>
	{
		frameCount++;
 c4a:	80 91 7b 00 	lds	r24, 0x007B
 c4e:	8f 5f       	subi	r24, 0xFF	; 255
 c50:	80 93 7b 00 	sts	0x007B, r24


	//THIS IS A HACK
	//tcnter_update();

 }
 c54:	ff 91       	pop	r31
 c56:	ef 91       	pop	r30
 c58:	bf 91       	pop	r27
 c5a:	af 91       	pop	r26
 c5c:	9f 91       	pop	r25
 c5e:	8f 91       	pop	r24
 c60:	7f 91       	pop	r23
 c62:	6f 91       	pop	r22
 c64:	5f 91       	pop	r21
 c66:	4f 91       	pop	r20
 c68:	3f 91       	pop	r19
 c6a:	2f 91       	pop	r18
 c6c:	0f 90       	pop	r0
 c6e:	0f be       	out	0x3f, r0	; 63
 c70:	0f 90       	pop	r0
 c72:	1f 90       	pop	r1
 c74:	18 95       	reti

00000c76 <init_hsyncTimer>:
//Testing with values returned by hsyncTimerCalculator
//#define HSYNC_TIMER_OCRVAL	65

void init_hsyncTimer(void)
{
   HSYNC_TIMER_OCR = HSYNC_TIMER_OCRVAL; 
 c76:	8f ed       	ldi	r24, 0xDF	; 223
 c78:	83 bb       	out	0x13, r24	; 19
							//T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
   timer_setWGM(HSYNC_TIMER_NUM, WGM_CLR_ON_COMPARE);
 c7a:	62 e0       	ldi	r22, 0x02	; 2
 c7c:	80 e0       	ldi	r24, 0x00	; 0
 c7e:	4d dc       	rcall	.-1894   	; 0x51a <timer_setWGM>
   timer_selectDivisor(HSYNC_TIMER_NUM, HSYNC_TIMER_CLKDIV); //CLKDIV1);
 c80:	63 e0       	ldi	r22, 0x03	; 3
 c82:	80 e0       	ldi	r24, 0x00	; 0
 c84:	25 dc       	rcall	.-1974   	; 0x4d0 <timer_selectDivisor>
   timer_compareMatchIntEnable(HSYNC_TIMER_NUM, OUT_CHANNELA);
 c86:	41 e0       	ldi	r20, 0x01	; 1
 c88:	60 e0       	ldi	r22, 0x00	; 0
 c8a:	80 e0       	ldi	r24, 0x00	; 0
 c8c:	79 cc       	rjmp	.-1806   	; 0x580 <timer_compareMatchIntSetup>

00000c8e <isNewFrame>:
{
	uint8_t newFrame = FALSE;

	static uint8_t lastFrameCount = 0;
#define FRAME_COUNT_LIMIT 0x03
	uint8_t thisFrameCount = frameCount&FRAME_COUNT_LIMIT;
 c8e:	90 91 7b 00 	lds	r25, 0x007B
 c92:	93 70       	andi	r25, 0x03	; 3

//		if(( (thisFrameCount==0) && (lastFrameCount==FRAME_COUNT_LIMIT) ))
	if(thisFrameCount != lastFrameCount)
 c94:	81 e0       	ldi	r24, 0x01	; 1
 c96:	20 91 80 00 	lds	r18, 0x0080
 c9a:	92 13       	cpse	r25, r18
 c9c:	01 c0       	rjmp	.+2      	; 0xca0 <isNewFrame+0x12>
 c9e:	80 e0       	ldi	r24, 0x00	; 0
		newFrame = TRUE;

	lastFrameCount = thisFrameCount;
 ca0:	90 93 80 00 	sts	0x0080, r25

	return newFrame;
}
 ca4:	08 95       	ret

00000ca6 <main>:
#endif



#if(!defined(PWM_TESTING) || !PWM_TESTING)
	init_hsyncTimer();
 ca6:	e7 df       	rcall	.-50     	; 0xc76 <init_hsyncTimer>
#endif

	//This starts pretty late... watch out for WDT
#if(!defined(V6651COMPARE) || !V6651COMPARE)
	init_heartBeat();
 ca8:	df dc       	rcall	.-1602   	; 0x668 <init_heartBeat>

	setHeartRate(0);
 caa:	80 e0       	ldi	r24, 0x00	; 0
 cac:	b5 dc       	rcall	.-1686   	; 0x618 <setHeartRate>





	lvds_timerInit();
 cae:	1c df       	rcall	.-456    	; 0xae8 <lvds_timerInit>
#if( defined(FRAMEBUFFER_TESTING) && (FRAMEBUFFER_TESTING))
		frameBufferUpdate();
#endif

#if(!defined(V6651COMPARE) || !V6651COMPARE)
		heartUpdate();
 cb0:	f2 dc       	rcall	.-1564   	; 0x696 <heartUpdate>
 cb2:	fe cf       	rjmp	.-4      	; 0xcb0 <main+0xa>

00000cb4 <__divmodhi4>:
 cb4:	97 fb       	bst	r25, 7
 cb6:	07 2e       	mov	r0, r23
 cb8:	16 f4       	brtc	.+4      	; 0xcbe <__divmodhi4+0xa>
 cba:	00 94       	com	r0
 cbc:	06 d0       	rcall	.+12     	; 0xcca <__divmodhi4_neg1>
 cbe:	77 fd       	sbrc	r23, 7
 cc0:	08 d0       	rcall	.+16     	; 0xcd2 <__divmodhi4_neg2>
 cc2:	2d d0       	rcall	.+90     	; 0xd1e <__udivmodhi4>
 cc4:	07 fc       	sbrc	r0, 7
 cc6:	05 d0       	rcall	.+10     	; 0xcd2 <__divmodhi4_neg2>
 cc8:	3e f4       	brtc	.+14     	; 0xcd8 <__divmodhi4_exit>

00000cca <__divmodhi4_neg1>:
 cca:	90 95       	com	r25
 ccc:	81 95       	neg	r24
 cce:	9f 4f       	sbci	r25, 0xFF	; 255
 cd0:	08 95       	ret

00000cd2 <__divmodhi4_neg2>:
 cd2:	70 95       	com	r23
 cd4:	61 95       	neg	r22
 cd6:	7f 4f       	sbci	r23, 0xFF	; 255

00000cd8 <__divmodhi4_exit>:
 cd8:	08 95       	ret

00000cda <__udivmodsi4>:
 cda:	a1 e2       	ldi	r26, 0x21	; 33
 cdc:	1a 2e       	mov	r1, r26
 cde:	aa 1b       	sub	r26, r26
 ce0:	bb 1b       	sub	r27, r27
 ce2:	fd 01       	movw	r30, r26
 ce4:	0d c0       	rjmp	.+26     	; 0xd00 <__udivmodsi4_ep>

00000ce6 <__udivmodsi4_loop>:
 ce6:	aa 1f       	adc	r26, r26
 ce8:	bb 1f       	adc	r27, r27
 cea:	ee 1f       	adc	r30, r30
 cec:	ff 1f       	adc	r31, r31
 cee:	a2 17       	cp	r26, r18
 cf0:	b3 07       	cpc	r27, r19
 cf2:	e4 07       	cpc	r30, r20
 cf4:	f5 07       	cpc	r31, r21
 cf6:	20 f0       	brcs	.+8      	; 0xd00 <__udivmodsi4_ep>
 cf8:	a2 1b       	sub	r26, r18
 cfa:	b3 0b       	sbc	r27, r19
 cfc:	e4 0b       	sbc	r30, r20
 cfe:	f5 0b       	sbc	r31, r21

00000d00 <__udivmodsi4_ep>:
 d00:	66 1f       	adc	r22, r22
 d02:	77 1f       	adc	r23, r23
 d04:	88 1f       	adc	r24, r24
 d06:	99 1f       	adc	r25, r25
 d08:	1a 94       	dec	r1
 d0a:	69 f7       	brne	.-38     	; 0xce6 <__udivmodsi4_loop>
 d0c:	60 95       	com	r22
 d0e:	70 95       	com	r23
 d10:	80 95       	com	r24
 d12:	90 95       	com	r25
 d14:	9b 01       	movw	r18, r22
 d16:	ac 01       	movw	r20, r24
 d18:	bd 01       	movw	r22, r26
 d1a:	cf 01       	movw	r24, r30
 d1c:	08 95       	ret

00000d1e <__udivmodhi4>:
 d1e:	aa 1b       	sub	r26, r26
 d20:	bb 1b       	sub	r27, r27
 d22:	51 e1       	ldi	r21, 0x11	; 17
 d24:	07 c0       	rjmp	.+14     	; 0xd34 <__udivmodhi4_ep>

00000d26 <__udivmodhi4_loop>:
 d26:	aa 1f       	adc	r26, r26
 d28:	bb 1f       	adc	r27, r27
 d2a:	a6 17       	cp	r26, r22
 d2c:	b7 07       	cpc	r27, r23
 d2e:	10 f0       	brcs	.+4      	; 0xd34 <__udivmodhi4_ep>
 d30:	a6 1b       	sub	r26, r22
 d32:	b7 0b       	sbc	r27, r23

00000d34 <__udivmodhi4_ep>:
 d34:	88 1f       	adc	r24, r24
 d36:	99 1f       	adc	r25, r25
 d38:	5a 95       	dec	r21
 d3a:	a9 f7       	brne	.-22     	; 0xd26 <__udivmodhi4_loop>
 d3c:	80 95       	com	r24
 d3e:	90 95       	com	r25
 d40:	bc 01       	movw	r22, r24
 d42:	cd 01       	movw	r24, r26
 d44:	08 95       	ret

00000d46 <_exit>:
 d46:	f8 94       	cli

00000d48 <__stop_program>:
 d48:	ff cf       	rjmp	.-2      	; 0xd48 <__stop_program>
