
_BUILD/LCDdirectLVDS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ade  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00001ade  00001b72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000156  0080006a  0080006a  00001b7c  2**0
                  ALLOC
  3 .stab         00004ca4  00000000  00000000  00001b7c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000027ac  00000000  00000000  00006820  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00008fcc  2**0
                  CONTENTS, READONLY
  6 .debug_info   000004b0  00000000  00000000  00008fdd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000470  00000000  00000000  0000948d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001d  00000000  00000000  000098fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001a3  00000000  00000000  0000991a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	ae c3       	rjmp	.+1884   	; 0x75e <__ctors_end>
       2:	c8 c3       	rjmp	.+1936   	; 0x794 <__bad_interrupt>
       4:	21 c9       	rjmp	.-3518   	; 0xfffff248 <__eeprom_end+0xff7ef248>
       6:	c6 c3       	rjmp	.+1932   	; 0x794 <__bad_interrupt>
       8:	c5 c3       	rjmp	.+1930   	; 0x794 <__bad_interrupt>
       a:	c4 c3       	rjmp	.+1928   	; 0x794 <__bad_interrupt>
       c:	c3 c3       	rjmp	.+1926   	; 0x794 <__bad_interrupt>
       e:	c2 c3       	rjmp	.+1924   	; 0x794 <__bad_interrupt>
      10:	c1 c3       	rjmp	.+1922   	; 0x794 <__bad_interrupt>
      12:	c0 c3       	rjmp	.+1920   	; 0x794 <__bad_interrupt>
      14:	bf c3       	rjmp	.+1918   	; 0x794 <__bad_interrupt>
      16:	be c3       	rjmp	.+1916   	; 0x794 <__bad_interrupt>
      18:	bd c3       	rjmp	.+1914   	; 0x794 <__bad_interrupt>
      1a:	bc c3       	rjmp	.+1912   	; 0x794 <__bad_interrupt>
      1c:	54 cc       	rjmp	.-1880   	; 0xfffff8c6 <__eeprom_end+0xff7ef8c6>
      1e:	ba c3       	rjmp	.+1908   	; 0x794 <__bad_interrupt>
      20:	b9 c3       	rjmp	.+1906   	; 0x794 <__bad_interrupt>
      22:	b8 c3       	rjmp	.+1904   	; 0x794 <__bad_interrupt>
      24:	b7 c3       	rjmp	.+1902   	; 0x794 <__bad_interrupt>
      26:	ce c8       	rjmp	.-3684   	; 0xfffff1c4 <__eeprom_end+0xff7ef1c4>
      28:	d0 c8       	rjmp	.-3680   	; 0xfffff1ca <__eeprom_end+0xff7ef1ca>
      2a:	d2 c8       	rjmp	.-3676   	; 0xfffff1d0 <__eeprom_end+0xff7ef1d0>
      2c:	d4 c8       	rjmp	.-3672   	; 0xfffff1d6 <__eeprom_end+0xff7ef1d6>
      2e:	d6 c8       	rjmp	.-3668   	; 0xfffff1dc <__eeprom_end+0xff7ef1dc>
      30:	d8 c8       	rjmp	.-3664   	; 0xfffff1e2 <__eeprom_end+0xff7ef1e2>
      32:	da c8       	rjmp	.-3660   	; 0xfffff1e8 <__eeprom_end+0xff7ef1e8>
      34:	dc c8       	rjmp	.-3656   	; 0xfffff1ee <__eeprom_end+0xff7ef1ee>
      36:	de c8       	rjmp	.-3652   	; 0xfffff1f4 <__eeprom_end+0xff7ef1f4>
      38:	0b ca       	rjmp	.-3050   	; 0xfffff450 <__eeprom_end+0xff7ef450>
      3a:	0a ca       	rjmp	.-3052   	; 0xfffff450 <__eeprom_end+0xff7ef450>
      3c:	09 ca       	rjmp	.-3054   	; 0xfffff450 <__eeprom_end+0xff7ef450>
      3e:	08 ca       	rjmp	.-3056   	; 0xfffff450 <__eeprom_end+0xff7ef450>
      40:	09 ca       	rjmp	.-3054   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      42:	08 ca       	rjmp	.-3056   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      44:	07 ca       	rjmp	.-3058   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      46:	f7 c9       	rjmp	.-3090   	; 0xfffff436 <__eeprom_end+0xff7ef436>
      48:	f6 c9       	rjmp	.-3092   	; 0xfffff436 <__eeprom_end+0xff7ef436>
      4a:	f5 c9       	rjmp	.-3094   	; 0xfffff436 <__eeprom_end+0xff7ef436>
      4c:	f6 c9       	rjmp	.-3092   	; 0xfffff43a <__eeprom_end+0xff7ef43a>
      4e:	f5 c9       	rjmp	.-3094   	; 0xfffff43a <__eeprom_end+0xff7ef43a>
      50:	f4 c9       	rjmp	.-3096   	; 0xfffff43a <__eeprom_end+0xff7ef43a>
      52:	f5 c9       	rjmp	.-3094   	; 0xfffff43e <__eeprom_end+0xff7ef43e>
      54:	f4 c9       	rjmp	.-3096   	; 0xfffff43e <__eeprom_end+0xff7ef43e>
      56:	f3 c9       	rjmp	.-3098   	; 0xfffff43e <__eeprom_end+0xff7ef43e>
      58:	11 ca       	rjmp	.-3038   	; 0xfffff47c <__eeprom_end+0xff7ef47c>
      5a:	10 ca       	rjmp	.-3040   	; 0xfffff47c <__eeprom_end+0xff7ef47c>
      5c:	0f ca       	rjmp	.-3042   	; 0xfffff47c <__eeprom_end+0xff7ef47c>
      5e:	1e ca       	rjmp	.-3012   	; 0xfffff49c <__eeprom_end+0xff7ef49c>
      60:	1d ca       	rjmp	.-3014   	; 0xfffff49c <__eeprom_end+0xff7ef49c>
      62:	0e ca       	rjmp	.-3044   	; 0xfffff480 <__eeprom_end+0xff7ef480>
      64:	0d ca       	rjmp	.-3046   	; 0xfffff480 <__eeprom_end+0xff7ef480>
      66:	1a ca       	rjmp	.-3020   	; 0xfffff49c <__eeprom_end+0xff7ef49c>
      68:	19 ca       	rjmp	.-3022   	; 0xfffff49c <__eeprom_end+0xff7ef49c>
      6a:	08 ca       	rjmp	.-3056   	; 0xfffff47c <__eeprom_end+0xff7ef47c>
      6c:	07 ca       	rjmp	.-3058   	; 0xfffff47c <__eeprom_end+0xff7ef47c>
      6e:	06 ca       	rjmp	.-3060   	; 0xfffff47c <__eeprom_end+0xff7ef47c>

00000070 <__trampolines_end>:
      70:	b7 00       	.word	0x00b7	; ????
      72:	00 00       	nop
      74:	8a 01       	movw	r16, r20
      76:	01 18       	sub	r0, r1
      78:	83 00       	.word	0x0083	; ????
      7a:	86 00       	.word	0x0086	; ????
      7c:	20 07       	cpc	r18, r16
      7e:	a5 00       	.word	0x00a5	; ????
      80:	00 00       	nop
      82:	03 ff       	sbrs	r16, 3

00000083 <LuigiRunsFlip>:
      83:	ff ff ff                                            ...

00000086 <LuigiRunsMotion>:
      86:	00 8c 00 10 2d 07                                   ....-.

0000008c <LuigiRunsX>:
      8c:	ab aa 02 00 00 00                                   ......

00000092 <spriteMARIORUNS>:
      92:	b7 00 00 00 a1 01 01 18 00 00 ab 00 20 07 a5 00     ............ ...
      a2:	00 00 03                                            ...

000000a5 <MarioRunsCamMotion>:
      a5:	00 00 00 10 18 07                                   ......

000000ab <MarioRunsMotion>:
      ab:	00 b1 00 10 2d 07                                   ....-.

000000b1 <MarioRunsX>:
      b1:	aa aa 00 00 00 00                                   ......

000000b7 <pgm_imageMARIORUNS>:
      b7:	00 00 00 00 00 a8 0a 00 00 aa aa 02 00 d5 37 00     ..............7.
      c7:	40 f7 f7 03 40 d7 df 0f 40 fd 57 01 00 fc ff 00     @...@...@.W.....
      d7:	00 55 c6 00 c0 55 f5 03 f0 56 f5 00 50 aa 2a 00     .U...U...V..P.*.
      e7:	90 aa 2a 00 94 8a 0a 00 04 50 01 00 00 50 05 00     ..*......P...P..
      f7:	00 a8 0a 00 00 aa aa 02 00 d5 37 00 40 f7 f7 03     ..........7.@...
     107:	40 d7 df 0f 40 fd 57 01 00 fc ff 00 50 a5 05 00     @...@.W.....P...
     117:	5f a5 56 3f 3f e5 6a 3d 0f aa 2a 04 80 aa aa 05     _.V??.j=..*.....
     127:	a0 aa aa 05 94 0a a8 05 54 00 00 00 50 01 00 00     ........T...P...
     137:	00 a8 0a 00 00 aa aa 02 00 d5 37 00 40 f7 f7 03     ..........7.@...
     147:	40 d7 df 0f 40 fd 57 01 00 fc ff 00 00 65 05 00     @...@.W......e..
     157:	40 95 16 00 40 a5 eb 00 40 95 aa 00 80 f5 ab 00     @...@...@.......
     167:	00 f6 2a 00 00 a8 15 00 00 54 55 00 00 54 01 00     ..*......TU..T..

00000177 <spriteLUIGI>:
     177:	a5 01 00 00 8a 01 01 10 00 00 23 07 1e 07 0e 07     ..........#.....
     187:	00 00 01                                            ...

0000018a <pgm_paletteLUIGI>:
     18a:	25 04 3f 07                                         %.?.

0000018e <spriteMARIO>:
     18e:	a5 01 00 00 a1 01 01 10 00 00 23 07 1e 07 0e 07     ..........#.....
     19e:	00 00 01                                            ...

000001a1 <pgm_paletteMARIO>:
     1a1:	25 05 02 07                                         %...

000001a5 <pgm_imageMARIO>:
     1a5:	00 a8 0a 00 00 aa aa 02 00 d5 37 00 40 f7 f7 03     ..........7.@...
     1b5:	40 d7 df 0f 40 fd 57 01 00 fc ff 00 00 65 05 00     @...@.W......e..
     1c5:	40 65 59 01 50 a5 5a 05 f0 b9 6e 0f f0 ab ea 0f     @eY.P.Z...n.....
     1d5:	f0 aa aa 0f 00 2a a8 00 40 05 50 01 50 05 50 05     .....*..@.P.P.P.

000001e5 <spriteCLOUD>:
     1e5:	fc 01 00 00 f8 01 01 28 00 00 23 07 1e 07 0e 07     .......(..#.....
     1f5:	00 00 01                                            ...

000001f8 <pgm_paletteCLOUD>:
     1f8:	25 2f 00 00                                         %/..

000001fc <pgm_imageCLOUD>:
     1fc:	80 aa aa 02 60 55 55 09 58 55 55 25 58 55 55 25     ....`UU.XUU%XUU%
     20c:	58 55 55 25 56 55 55 95 56 65 59 95 56 65 59 95     XUU%VUU.VeY.VeY.
     21c:	56 65 59 95 56 55 55 95 66 55 55 99 58 59 65 25     VeY.VUU.fUU.XYe%
     22c:	58 a5 5a 25 58 55 55 25 60 95 56 09 80 2a a8 02     X.Z%XUU%`.V..*..

0000023c <spriteLEAF>:
     23c:	8f 02 00 00 8b 02 01 30 85 02 61 02 7f 02 4f 02     .......0..a...O.
     24c:	00 00 01                                            ...

0000024f <LeafCamMotion>:
     24f:	00 00 00 00 55 02                                   ....U.

00000255 <LeafCamY>:
     255:	55 55 55 55 57 55 55 44 44 04 00 00                 UUUUWUUDD...

00000261 <LeafMotion>:
     261:	00 73 02 f0 67 02                                   .s..g.

00000267 <LeafY>:
     267:	aa aa aa aa 57 55 55 55 55 55 55 55                 ....WUUUUUUU

00000273 <LeafX>:
     273:	00 00 00 00 ea aa ea aa ea aa ea aa                 ............

0000027f <LeafLayer>:
     27f:	ff ff 00 00 00 00                                   ......

00000285 <LeafFlip>:
     285:	00 00 f8 07 f8 07                                   ......

0000028b <pgm_paletteLEAF>:
     28b:	25 02 00 00                                         %...

0000028f <pgm_imageLEAF>:
     28f:	00 00 00 00 00 00 00 a0 00 00 00 98 00 00 00 98     ................
     29f:	00 00 a8 a6 00 80 56 2a 00 68 a5 95 00 56 6a 95     ......V*.h...Vj.
     2af:	80 a9 65 95 a0 66 65 25 6a 65 59 25 56 59 55 09     ..e..fe%jeY%VYU.
     2bf:	68 55 55 02 a0 56 a5 02 00 aa 2a 00 00 00 00 00     hUU..V....*.....

000002cf <spriteCOIN>:
     2cf:	f6 02 00 00 f2 02 01 28 00 00 e2 02 1e 07 0e 07     .......(........
     2df:	00 00 04                                            ...

000002e2 <CoinMotion>:
     2e2:	00 00 00 f0 e8 02                                   ......

000002e8 <CoinY>:
     2e8:	aa aa aa aa 55 aa aa aa aa aa                       ....U.....

000002f2 <pgm_paletteCOIN>:
     2f2:	25 02 07 2f                                         %../

000002f6 <pgm_imageCOIN>:
     2f6:	00 00 00 00 00 80 02 00 00 a0 0a 00 00 a8 2a 00     ..............*.
     306:	00 e8 29 00 00 ba a6 00 00 ba a6 00 00 ba a6 00     ..).............
     316:	00 ba a6 00 00 ba a6 00 00 ba a6 00 00 e8 29 00     ..............).
     326:	00 a8 2a 00 00 a0 0a 00 00 80 02 00 00 00 00 00     ..*.............
     336:	00 00 00 00 00 80 01 00 00 80 01 00 00 60 05 00     .............`..
     346:	00 60 05 00 00 60 05 00 00 60 05 00 00 70 05 00     .`...`...`...p..
     356:	00 70 05 00 00 60 05 00 00 60 05 00 00 60 05 00     .p...`...`...`..
     366:	00 60 05 00 00 80 01 00 00 80 01 00 00 00 00 00     .`..............
     376:	00 00 00 00 00 80 00 00 00 80 00 00 00 80 00 00     ................
     386:	00 80 00 00 00 80 00 00 00 80 00 00 00 c0 00 00     ................
     396:	00 c0 00 00 00 80 00 00 00 80 00 00 00 80 00 00     ................
     3a6:	00 80 00 00 00 80 00 00 00 80 00 00 00 00 00 00     ................
     3b6:	00 00 00 00 00 c0 01 00 00 c0 01 00 00 f0 07 00     ................
     3c6:	00 f0 07 00 00 f0 07 00 00 f0 07 00 00 f0 07 00     ................
     3d6:	00 f0 07 00 00 f0 07 00 00 f0 07 00 00 f0 07 00     ................
     3e6:	00 f0 07 00 00 c0 01 00 00 c0 01 00 00 00 00 00     ................

000003f6 <spriteGOOMBA>:
     3f6:	73 04 00 00 5b 04 06 50 51 04 37 04 13 04 1d 04     s...[..PQ.7.....
     406:	09 04 01                                            ...

00000409 <GoombaPA>:
     409:	00 00 01 00 04 10 80 00 01 00                       ..........

00000413 <GoombaLayer>:
     413:	ff ff 00 00 00 00 00 00 00 00                       ..........

0000041d <GoombaCamMotion>:
     41d:	00 00 00 00 23 04                                   ....#.

00000423 <GoombaCamY>:
     423:	55 55 55 55 00 00 03 00 00 00 00 00 00 00 00 00     UUUU............
     433:	55 55 55 55                                         UUUU

00000437 <GoombaMotion>:
     437:	00 00 00 f0 3d 04                                   ....=.

0000043d <GoombaY>:
     43d:	aa aa aa aa 00 00 00 00 00 00 00 00 00 00 00 00     ................
     44d:	00 00 00 00                                         ....

00000451 <GoombaFlip>:
     451:	aa aa aa aa aa aa aa aa ff ff                       ..........

0000045b <pgm_paletteGOOMBA>:
     45b:	25 02 27 00 08 02 27 00 0e 02 27 00 0a 02 27 00     %.'...'...'...'.
     46b:	03 01 26 00 00 20 01 20                             ..&.. . 

00000473 <pgm_imageGOOMBA>:
     473:	00 50 05 00 00 54 15 00 00 55 55 00 40 55 55 01     .P...T...UU.@UU.
     483:	d0 57 d5 07 54 5e b5 15 54 fe bf 15 55 6e b9 55     .W..T^..T...Un.U
     493:	55 6a a9 55 55 55 55 55 54 a9 6a 15 00 aa aa 00     Uj.UUUUUT.j.....
     4a3:	00 aa aa 0f c0 ab fa 3f c0 af fe 3f 00 bf ff 0f     .......?...?....

000004b3 <spriteSTAR>:
     4b3:	ce 04 00 00 c6 04 02 28 00 00 23 07 1e 07 0e 07     .......(..#.....
     4c3:	b9 06 01                                            ...

000004c6 <pgm_paletteSTAR>:
     4c6:	25 07 02 00 25 02 00 00                             %...%...

000004ce <pgm_imageSTAR>:
     4ce:	00 40 01 00 00 40 01 00 00 50 05 00 00 50 05 00     .@...@...P...P..
     4de:	00 54 15 00 54 55 55 15 54 65 59 15 50 65 59 05     .T..TUU.TeY.PeY.
     4ee:	40 65 59 01 00 55 55 00 00 55 55 00 40 55 55 01     @eY..UU..UU.@UU.
     4fe:	40 55 55 01 40 15 54 01 50 01 40 05 50 00 00 05     @UU.@.T.P.@.P...

0000050e <spriteBIG>:
     50e:	3c 05 00 00 21 05 01 28 00 00 23 07 1e 07 0e 07     <...!..(..#.....
     51e:	00 00 01                                            ...

00000521 <pgm_paletteBIG>:
     521:	25 07 02 2f                                         %../

00000525 <sprite1UP>:
     525:	3c 05 00 00 38 05 01 28 00 00 23 07 1e 07 0e 07     <...8..(..#.....
     535:	00 00 01                                            ...

00000538 <pgm_palette1UP>:
     538:	25 07 04 2f                                         %../

0000053c <pgm_imageSHROOM>:
     53c:	00 50 05 00 00 54 29 00 00 55 aa 00 40 55 aa 02     .P...T)..U..@U..
     54c:	50 55 a9 05 94 5a 55 15 a4 6a 55 15 a5 6a 55 5a     PU...ZU..jU..jUZ
     55c:	a5 6a 55 6a 95 5a 55 69 55 55 55 55 a4 fe bf 1a     .jUj.ZUiUUUU....
     56c:	00 ff ff 00 00 ff df 00 00 ff df 00 00 fc 37 00     ..............7.

0000057c <spriteDEADGOOMBA>:
     57c:	a4 05 00 00 a0 05 01 14 00 00 9a 05 00 00 8f 05     ................
     58c:	00 00 01                                            ...

0000058f <DeadGoombaCamMotion>:
     58f:	00 00 00 10 95 05                                   ......

00000595 <DeadGoombaCamY>:
     595:	03 55 55 55 55                                      .UUUU

0000059a <DeadGoombaMotion>:
     59a:	00 00 00 10 00 00                                   ......

000005a0 <pgm_paletteDEADGOOMBA>:
     5a0:	25 02 27 00                                         %.'.

000005a4 <pgm_imageDEADGOOMBA>:
     5a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     5b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 50 05 00     .............P..
     5c4:	40 55 55 01 d4 5f f5 17 a5 fa af 5a 55 55 55 55     @UU.._.....ZUUUU
     5d4:	80 aa aa 02 80 aa aa 02 f0 0f f0 3f 00 00 00 00     ...........?....

000005e4 <spriteSOLID>:
     5e4:	fb 05 00 00 f7 05 01 08 00 00 33 07 00 00 33 07     ..........3...3.
     5f4:	00 00 01                                            ...

000005f7 <pgm_paletteSOLID>:
     5f7:	25 02 00 00                                         %...

000005fb <pgm_imageSOLID>:
     5fb:	fc ff ff 3f 57 55 55 d5 77 55 55 dd 57 55 55 d5     ...?WUU.wUU.WUU.
     60b:	57 55 55 d5 57 55 55 d5 57 55 55 d5 57 55 55 d5     WUU.WUU.WUU.WUU.
     61b:	57 55 55 d5 57 55 55 d5 57 55 55 d5 57 55 55 d5     WUU.WUU.WUU.WUU.
     62b:	57 55 55 d5 77 55 55 dd 57 55 55 d5 fc ff ff 3f     WUU.wUU.WUU....?

0000063b <spriteQ>:
     63b:	66 06 00 00 56 06 04 3c 00 00 33 07 00 00 33 07     f...V..<..3...3.
     64b:	4e 06 01                                            N..

0000064e <QPaletteAdvance>:
     64e:	a8 82 2a a8 82 2a a8 02                             ..*..*..

00000656 <pgm_paletteQ>:
     656:	25 02 07 00 25 02 02 00 25 02 01 00 25 02 02 00     %...%...%...%...

00000666 <pgm_imageQ>:
     666:	54 55 55 15 a9 aa aa ea b9 aa aa ee a9 56 a5 ea     TUU..........V..
     676:	a9 f5 97 ea a9 b5 d6 ea a9 b5 d6 ea a9 be d5 ea     ................
     686:	a9 6a fd ea a9 6a ad ea a9 aa af ea a9 6a a9 ea     .j...j.......j..
     696:	a9 6a ad ea b9 aa af ee a9 aa aa ea ff ff ff ff     .j..............

000006a6 <spriteFLOWER>:
     6a6:	ce 06 00 00 be 06 03 28 00 00 23 07 1e 07 0e 07     .......(..#.....
     6b6:	b9 06 01                                            ...

000006b9 <FlowerPA>:
     6b9:	ff ff ff ff ff                                      .....

000006be <pgm_paletteFLOWER>:
     6be:	25 2f 07 04 25 17 02 00 25 07 05 02 25 04 00 00     %/..%...%...%...

000006ce <pgm_imageFLOWER>:
     6ce:	00 55 55 00 50 55 55 05 54 aa aa 15 a5 fe bf 5a     .UU.PUU.T......Z
     6de:	a5 fe bf 5a 54 aa aa 15 50 55 55 05 00 55 55 00     ...ZT...PUU..UU.
     6ee:	00 40 01 00 15 40 01 54 54 40 01 15 54 41 41 15     .@...@.TT@..TAA.
     6fe:	50 45 51 05 50 45 51 05 40 55 55 01 00 50 05 00     PEQ.PEQ.@UU..P..

0000070e <DefaultCamMotion>:
     70e:	00 00 00 00 14 07                                   ......

00000714 <DefaultCamY>:
     714:	55 55 55 55 00 03 55 55 55 55                       UUUU..UUUU

0000071e <DefaultLayer>:
     71e:	ff ff 00 00 00                                      .....

00000723 <DefaultMotion>:
     723:	00 00 00 f0 29 07                                   ....).

00000729 <DefaultY>:
     729:	aa aa aa aa 00 00 00 00 00 00                       ..........

00000733 <NadaMotion>:
     733:	00 00 00 00 00 00                                   ......

00000739 <header>:
     739:	4c 43 44 64 69 72 65 63 74 4c 56 44 53 39 30 20     LCDdirectLVDS90 
     749:	32 30 31 34 2d 30 37 2d 30 39 20 30 35 3a 35 38     2014-07-09 05:58
     759:	3a 35 32 00 00                                      :52..

0000075e <__ctors_end>:
     75e:	11 24       	eor	r1, r1
     760:	1f be       	out	0x3f, r1	; 63
     762:	cf e5       	ldi	r28, 0x5F	; 95
     764:	d2 e0       	ldi	r29, 0x02	; 2
     766:	de bf       	out	0x3e, r29	; 62
     768:	cd bf       	out	0x3d, r28	; 61

0000076a <__do_copy_data>:
     76a:	10 e0       	ldi	r17, 0x00	; 0
     76c:	a0 e6       	ldi	r26, 0x60	; 96
     76e:	b0 e0       	ldi	r27, 0x00	; 0
     770:	ee ed       	ldi	r30, 0xDE	; 222
     772:	fa e1       	ldi	r31, 0x1A	; 26
     774:	02 c0       	rjmp	.+4      	; 0x77a <__do_copy_data+0x10>
     776:	05 90       	lpm	r0, Z+
     778:	0d 92       	st	X+, r0
     77a:	aa 36       	cpi	r26, 0x6A	; 106
     77c:	b1 07       	cpc	r27, r17
     77e:	d9 f7       	brne	.-10     	; 0x776 <__do_copy_data+0xc>

00000780 <__do_clear_bss>:
     780:	11 e0       	ldi	r17, 0x01	; 1
     782:	aa e6       	ldi	r26, 0x6A	; 106
     784:	b0 e0       	ldi	r27, 0x00	; 0
     786:	01 c0       	rjmp	.+2      	; 0x78a <.do_clear_bss_start>

00000788 <.do_clear_bss_loop>:
     788:	1d 92       	st	X+, r1

0000078a <.do_clear_bss_start>:
     78a:	a0 3c       	cpi	r26, 0xC0	; 192
     78c:	b1 07       	cpc	r27, r17
     78e:	e1 f7       	brne	.-8      	; 0x788 <.do_clear_bss_loop>
     790:	04 d9       	rcall	.-3576   	; 0xfffff99a <__eeprom_end+0xff7ef99a>
     792:	a3 c9       	rjmp	.-3258   	; 0xfffffada <__eeprom_end+0xff7efada>

00000794 <__bad_interrupt>:
     794:	35 cc       	rjmp	.-1942   	; 0x0 <__vectors>

00000796 <hfm_setPower>:
// This needs to be set, initially! 
//   either init it in the hfm variable declaration
//   or use hfm_setup (ideal)
// however, sometimes it needs to be variable, thus hfm_setup (above)
void hfm_setPower(hfm_t	*modulator, uint8_t power)
{
     796:	fc 01       	movw	r30, r24
	//Don't allow power values > 1, otherwise who knows what'll happen...
	//(This is probably unnecessary, but whatev)
	//It's not, actually, if power's greater than maxPower, the values never reset
	// This is trouble, e.g. in heartbeat, where modulator.power is read
	if(power <= (modulator->maxPower))
     798:	82 81       	ldd	r24, Z+2	; 0x02
     79a:	86 17       	cp	r24, r22
     79c:	10 f0       	brcs	.+4      	; 0x7a2 <hfm_setPower+0xc>
		modulator->power = power;
     79e:	63 83       	std	Z+3, r22	; 0x03
     7a0:	08 95       	ret
	else
		modulator->power = modulator->maxPower;
     7a2:	82 81       	ldd	r24, Z+2	; 0x02
     7a4:	83 83       	std	Z+3, r24	; 0x03
     7a6:	08 95       	ret

000007a8 <hfm_setup>:
//Mainly just for setting up the maxPower (divisor)
// [can] use hfm_setPower otherwise...
// can't tell how to get away without using hfm_setup once
void hfm_setup(hfm_t *modulator, uint8_t power, uint8_t maxPower)
{
	modulator->desiredSum = 0;
     7a8:	fc 01       	movw	r30, r24
     7aa:	11 82       	std	Z+1, r1	; 0x01
     7ac:	10 82       	st	Z, r1
	modulator->maxPower = maxPower;
     7ae:	42 83       	std	Z+2, r20	; 0x02
	hfm_setPower(modulator, power);
     7b0:	f2 cf       	rjmp	.-28     	; 0x796 <hfm_setPower>

000007b2 <hfm_nextOutput>:
}

//Returns 0 if the "output" should be "off" in this cycle
//		  1 if the "output" should be "on"  in this cycle
uint8_t hfm_nextOutput(hfm_t *modulator)
{
     7b2:	fc 01       	movw	r30, r24
	// IF desired == 255, we want it never to clr...
	//		but running will be 0 the first time
	//		and we'll therefore if... set == good
	//		and later we'll runningSum == desiredSum (above) 
	//    and reset and if again
	if(modulator->desiredSum > 0)
     7b4:	80 81       	ld	r24, Z
     7b6:	91 81       	ldd	r25, Z+1	; 0x01
     7b8:	18 16       	cp	r1, r24
     7ba:	19 06       	cpc	r1, r25
     7bc:	4c f4       	brge	.+18     	; 0x7d0 <hfm_nextOutput+0x1e>
	{
		(modulator->desiredSum) -= (modulator->maxPower); //0xff;
     7be:	80 81       	ld	r24, Z
     7c0:	91 81       	ldd	r25, Z+1	; 0x01
     7c2:	22 81       	ldd	r18, Z+2	; 0x02
     7c4:	82 1b       	sub	r24, r18
     7c6:	91 09       	sbc	r25, r1
     7c8:	91 83       	std	Z+1, r25	; 0x01
     7ca:	80 83       	st	Z, r24
		toReturn = TRUE;
     7cc:	81 e0       	ldi	r24, 0x01	; 1
     7ce:	01 c0       	rjmp	.+2      	; 0x7d2 <hfm_nextOutput+0x20>
	}
	else	//avg == desired is handled at the start... (except 0-case which works here too)
	{
		//Don't modify runningSum, wait until desiredSum catches up...
		toReturn = FALSE;
     7d0:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	(modulator->desiredSum) += (modulator->power);
     7d2:	20 81       	ld	r18, Z
     7d4:	31 81       	ldd	r19, Z+1	; 0x01
     7d6:	93 81       	ldd	r25, Z+3	; 0x03
     7d8:	29 0f       	add	r18, r25
     7da:	31 1d       	adc	r19, r1
     7dc:	31 83       	std	Z+1, r19	; 0x01
     7de:	20 83       	st	Z, r18
		modulator->runningSum = 0;
		modulator->desiredSum = 0;
	}
*/	
	return toReturn;
}
     7e0:	08 95       	ret

000007e2 <timer_selectDivisor>:
 #else
	uint8_t csbits;
  #if defined(CSOBS)
	if(timerNum == 0 || timerNum == 1 || timerNum == 3)//IS_CSTYP(timerNum) || IS_CSOBS(timerNum))
  #else
	if(IS_CSTYP(timerNum))
     7e2:	82 30       	cpi	r24, 0x02	; 2
     7e4:	08 f5       	brcc	.+66     	; 0x828 <timer_selectDivisor+0x46>
  #endif
	{
		switch(clockDiv)
     7e6:	66 30       	cpi	r22, 0x06	; 6
     7e8:	79 f0       	breq	.+30     	; 0x808 <timer_selectDivisor+0x26>
     7ea:	30 f4       	brcc	.+12     	; 0x7f8 <timer_selectDivisor+0x16>
     7ec:	66 23       	and	r22, r22
     7ee:	51 f0       	breq	.+20     	; 0x804 <timer_selectDivisor+0x22>
     7f0:	63 30       	cpi	r22, 0x03	; 3
     7f2:	d1 f4       	brne	.+52     	; 0x828 <timer_selectDivisor+0x46>
		{
			case CLKDIV1:
				csbits = CSTYP_DIV1;	
				break;
			case CLKDIV8:
				csbits = CSTYP_DIV8;
     7f4:	92 e0       	ldi	r25, 0x02	; 2
     7f6:	0b c0       	rjmp	.+22     	; 0x80e <timer_selectDivisor+0x2c>
	if(timerNum == 0 || timerNum == 1 || timerNum == 3)//IS_CSTYP(timerNum) || IS_CSOBS(timerNum))
  #else
	if(IS_CSTYP(timerNum))
  #endif
	{
		switch(clockDiv)
     7f8:	68 30       	cpi	r22, 0x08	; 8
     7fa:	41 f0       	breq	.+16     	; 0x80c <timer_selectDivisor+0x2a>
     7fc:	6a 30       	cpi	r22, 0x0A	; 10
     7fe:	a1 f4       	brne	.+40     	; 0x828 <timer_selectDivisor+0x46>
				break;
			case CLKDIV256:
				csbits = CSTYP_DIV256;	
				break;
			case CLKDIV1024:
				csbits = CSTYP_DIV1024; 
     800:	95 e0       	ldi	r25, 0x05	; 5
				break;
     802:	05 c0       	rjmp	.+10     	; 0x80e <timer_selectDivisor+0x2c>
  #endif
	{
		switch(clockDiv)
		{
			case CLKDIV1:
				csbits = CSTYP_DIV1;	
     804:	91 e0       	ldi	r25, 0x01	; 1
     806:	03 c0       	rjmp	.+6      	; 0x80e <timer_selectDivisor+0x2c>
				break;
			case CLKDIV8:
				csbits = CSTYP_DIV8;
				break;
			case CLKDIV64:
				csbits = CSTYP_DIV64;	
     808:	93 e0       	ldi	r25, 0x03	; 3
				break;
     80a:	01 c0       	rjmp	.+2      	; 0x80e <timer_selectDivisor+0x2c>
			case CLKDIV256:
				csbits = CSTYP_DIV256;	
     80c:	94 e0       	ldi	r25, 0x04	; 4
	}
  #endif
	else 
		return 1;	

	switch(timerNum)
     80e:	81 30       	cpi	r24, 0x01	; 1
     810:	29 f0       	breq	.+10     	; 0x81c <timer_selectDivisor+0x3a>
	{
		//Assume Timer0 and Timer1 exist (see setWGM)
		case 0:
			writeMasked(csbits, CSMASK, T0_CSReg);
     812:	83 b7       	in	r24, 0x33	; 51
     814:	88 7f       	andi	r24, 0xF8	; 248
     816:	89 2b       	or	r24, r25
     818:	83 bf       	out	0x33, r24	; 51
     81a:	04 c0       	rjmp	.+8      	; 0x824 <timer_selectDivisor+0x42>
			break;
		case 1:
			writeMasked(csbits, CSMASK, T1_CSReg);
     81c:	8f b5       	in	r24, 0x2f	; 47
     81e:	88 7f       	andi	r24, 0xF8	; 248
     820:	89 2b       	or	r24, r25
     822:	8f bd       	out	0x2f, r24	; 47
		default:
			return 1;
			break;
	}
	
	return 0;
     824:	80 e0       	ldi	r24, 0x00	; 0
		case 0:
			writeMasked(csbits, CSMASK, T0_CSReg);
			break;
		case 1:
			writeMasked(csbits, CSMASK, T1_CSReg);
			break;
     826:	08 95       	ret
						return 1;	
				}
				else
					return 1;
			  #else
				return 1;
     828:	81 e0       	ldi	r24, 0x01	; 1
			break;
	}
	
	return 0;
 #endif
}
     82a:	08 95       	ret

0000082c <timer_setWGM>:
//	wgmLb *= 0xff;
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
     82c:	64 30       	cpi	r22, 0x04	; 4
     82e:	d0 f4       	brcc	.+52     	; 0x864 <timer_setWGM+0x38>
		return 1;
	
	switch(timerNum)
     830:	88 23       	and	r24, r24
     832:	19 f0       	breq	.+6      	; 0x83a <timer_setWGM+0xe>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	49 f0       	breq	.+18     	; 0x84a <timer_setWGM+0x1e>
     838:	15 c0       	rjmp	.+42     	; 0x864 <timer_setWGM+0x38>
 #ifdef _AVR_IOTNx61_H_
			//TinyX61s' Timer0 is an exception...
			// It only has WGM00, which serves the same functionality as
			// most others' WGM01 (when their WGM00 == 0)
			// (No PWM)
			if(wgmLb)
     83a:	60 fd       	sbrc	r22, 0
     83c:	13 c0       	rjmp	.+38     	; 0x864 <timer_setWGM+0x38>
#if(!defined(TIMER_SETWGM_UNUSED) || !TIMER_SETWGM_UNUSED)
uint8_t timer_setWGM(uint8_t timerNum, uint8_t wgm)
{
#if(!defined(__AVR_AT90PWM161__))
	uint8_t wgmLb = getbit(0, wgm);
	uint8_t wgmHb = getbit(1, wgm);
     83e:	66 95       	lsr	r22
			// (No PWM)
			if(wgmLb)
				return 1;

			//Whatever .stab is, this single change reduces it by 36Bytes
			writebit(WGM00, T0_WGMReg, wgmHb);
     840:	11 f0       	breq	.+4      	; 0x846 <timer_setWGM+0x1a>
     842:	a8 9a       	sbi	0x15, 0	; 21
     844:	0d c0       	rjmp	.+26     	; 0x860 <timer_setWGM+0x34>
     846:	a8 98       	cbi	0x15, 0	; 21
     848:	0b c0       	rjmp	.+22     	; 0x860 <timer_setWGM+0x34>
//			wgmLb=0;
//			wgmHb=0;
//			if(wgm == WGM_PHASE_PWM)
//				wgmLb = 0xff;

			switch(wgm)
     84a:	61 30       	cpi	r22, 0x01	; 1
     84c:	19 f4       	brne	.+6      	; 0x854 <timer_setWGM+0x28>
					wgmHb = 0;
					break;
			}

			//NOTE: TinyX61s' WGM bits are both in TCCR1D (very unusual)
			writebit(WGM10, TCCR1D, wgmLb);
     84e:	86 b5       	in	r24, 0x26	; 38
     850:	81 60       	ori	r24, 0x01	; 1
     852:	02 c0       	rjmp	.+4      	; 0x858 <timer_setWGM+0x2c>
     854:	86 b5       	in	r24, 0x26	; 38
     856:	8e 7f       	andi	r24, 0xFE	; 254
     858:	86 bd       	out	0x26, r24	; 38
			writebit(WGM11, TCCR1D, wgmHb);
     85a:	86 b5       	in	r24, 0x26	; 38
     85c:	8d 7f       	andi	r24, 0xFD	; 253
     85e:	86 bd       	out	0x26, r24	; 38
		default:
			return 1;
			break;
	}
	
	return 0;
     860:	80 e0       	ldi	r24, 0x00	; 0
     862:	08 95       	ret
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
		return 1;
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	08 95       	ret

00000868 <timer_init>:

//Roughly equivalent to the ol' Init_timerX(clkDiv, wgm)
//Return 0 if no error...
#if (!defined(TIMER_INIT_UNUSED) || !TIMER_INIT_UNUSED)
uint8_t timer_init(uint8_t timerNum, uint8_t clockDiv, uint8_t wgm)
{
     868:	cf 93       	push	r28
     86a:	df 93       	push	r29
     86c:	c8 2f       	mov	r28, r24
     86e:	d6 2f       	mov	r29, r22
	//set the waveform mode
	ERR_HANDLE_NUM(1,				\
     870:	64 2f       	mov	r22, r20
     872:	dc df       	rcall	.-72     	; 0x82c <timer_setWGM>
     874:	88 23       	and	r24, r24
     876:	11 f0       	breq	.+4      	; 0x87c <timer_init+0x14>
     878:	80 61       	ori	r24, 0x10	; 16
     87a:	08 c0       	rjmp	.+16     	; 0x88c <timer_init+0x24>
		timer_setWGM(timerNum, wgm)	);

	//select the clock
	ERR_HANDLE_NUM(2,							\
     87c:	6d 2f       	mov	r22, r29
     87e:	8c 2f       	mov	r24, r28
     880:	b0 df       	rcall	.-160    	; 0x7e2 <timer_selectDivisor>
     882:	88 23       	and	r24, r24
     884:	11 f0       	breq	.+4      	; 0x88a <timer_init+0x22>
     886:	80 62       	ori	r24, 0x20	; 32
     888:	01 c0       	rjmp	.+2      	; 0x88c <timer_init+0x24>
		timer_selectDivisor(timerNum, clockDiv)	);
		
	return 0;
     88a:	80 e0       	ldi	r24, 0x00	; 0
}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	08 95       	ret

00000892 <timer_compareMatchIntSetup>:
uint8_t timer_compareMatchIntSetup(uint8_t timerNum, uint8_t outputChannel,
	  												uint8_t enable)
{
	uint8_t channelNum;

	if(timerNum >= MAXTIMERS)
     892:	84 30       	cpi	r24, 0x04	; 4
     894:	08 f0       	brcs	.+2      	; 0x898 <timer_compareMatchIntSetup+0x6>
     896:	42 c0       	rjmp	.+132    	; 0x91c <timer_compareMatchIntSetup+0x8a>
		return 1;

	if(outputChannel >= 2) //MAXCHANNELSPERTIMER)
     898:	62 30       	cpi	r22, 0x02	; 2
     89a:	08 f0       	brcs	.+2      	; 0x89e <timer_compareMatchIntSetup+0xc>
     89c:	41 c0       	rjmp	.+130    	; 0x920 <timer_compareMatchIntSetup+0x8e>
		return 2;

	//writebit (used later) does not currently handle TRUE and FALSE properly, just 0 and 1...
	// this should be fixed now...
	if(enable)
     89e:	91 e0       	ldi	r25, 0x01	; 1
     8a0:	41 11       	cpse	r20, r1
     8a2:	01 c0       	rjmp	.+2      	; 0x8a6 <timer_compareMatchIntSetup+0x14>
     8a4:	90 e0       	ldi	r25, 0x00	; 0
		enable = 1;
	
	//For the sake of our brute-force switch statement...
	//Combine the timer number and channel into a single variable...
	//The high nibble contains the timer number, and the low contains the channel number (A=0,B=1)
	channelNum = (timerNum<<4) + outputChannel;
     8a6:	82 95       	swap	r24
     8a8:	80 7f       	andi	r24, 0xF0	; 240
     8aa:	86 0f       	add	r24, r22

	//Don't clear interrupts before disabling this one, or that defeats the purpose!
	// But do clear so we don't get unexpected overflows on init
	if(enable)
     8ac:	99 23       	and	r25, r25
     8ae:	09 f0       	breq	.+2      	; 0x8b2 <timer_compareMatchIntSetup+0x20>
		cli();
     8b0:	f8 94       	cli
	
	switch(channelNum)
     8b2:	81 30       	cpi	r24, 0x01	; 1
     8b4:	81 f0       	breq	.+32     	; 0x8d6 <timer_compareMatchIntSetup+0x44>
     8b6:	28 f0       	brcs	.+10     	; 0x8c2 <timer_compareMatchIntSetup+0x30>
     8b8:	80 31       	cpi	r24, 0x10	; 16
     8ba:	b9 f0       	breq	.+46     	; 0x8ea <timer_compareMatchIntSetup+0x58>
     8bc:	81 31       	cpi	r24, 0x11	; 17
     8be:	f9 f0       	breq	.+62     	; 0x8fe <timer_compareMatchIntSetup+0x6c>
     8c0:	31 c0       	rjmp	.+98     	; 0x924 <timer_compareMatchIntSetup+0x92>
			break;
	   #endif
	   #if defined(OCIE0A)
		case 0x00:
//			setbit(OCIE0A, T0_TIMSK);
			writebit(OCIE0A, T0_TIMSK, enable);
     8c2:	89 b7       	in	r24, 0x39	; 57
     8c4:	99 23       	and	r25, r25
     8c6:	11 f0       	breq	.+4      	; 0x8cc <timer_compareMatchIntSetup+0x3a>
     8c8:	80 61       	ori	r24, 0x10	; 16
     8ca:	01 c0       	rjmp	.+2      	; 0x8ce <timer_compareMatchIntSetup+0x3c>
     8cc:	8f 7e       	andi	r24, 0xEF	; 239
     8ce:	89 bf       	out	0x39, r24	; 57
			// My OCD bit me in the ass, this was set to TIMSK by mistake(?)
			setbit(OCF0A, T0_TIFR);
     8d0:	88 b7       	in	r24, 0x38	; 56
     8d2:	80 61       	ori	r24, 0x10	; 16
     8d4:	1d c0       	rjmp	.+58     	; 0x910 <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE0B)
		case 0x01:
//			setbit(OCIE0B, T0_TIMSK);
			writebit(OCIE0B, T0_TIMSK, enable);
     8d6:	89 b7       	in	r24, 0x39	; 57
     8d8:	99 23       	and	r25, r25
     8da:	11 f0       	breq	.+4      	; 0x8e0 <timer_compareMatchIntSetup+0x4e>
     8dc:	88 60       	ori	r24, 0x08	; 8
     8de:	01 c0       	rjmp	.+2      	; 0x8e2 <timer_compareMatchIntSetup+0x50>
     8e0:	87 7f       	andi	r24, 0xF7	; 247
     8e2:	89 bf       	out	0x39, r24	; 57
			// As was this...
			setbit(OCF0B, T0_TIFR);
     8e4:	88 b7       	in	r24, 0x38	; 56
     8e6:	88 60       	ori	r24, 0x08	; 8
     8e8:	13 c0       	rjmp	.+38     	; 0x910 <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE1A)
		case 0x10:
//			setbit(OCIE1A, T1_TIMSK);
			writebit(OCIE1A, T1_TIMSK, enable);
     8ea:	89 b7       	in	r24, 0x39	; 57
     8ec:	99 23       	and	r25, r25
     8ee:	11 f0       	breq	.+4      	; 0x8f4 <timer_compareMatchIntSetup+0x62>
     8f0:	80 64       	ori	r24, 0x40	; 64
     8f2:	01 c0       	rjmp	.+2      	; 0x8f6 <timer_compareMatchIntSetup+0x64>
     8f4:	8f 7b       	andi	r24, 0xBF	; 191
     8f6:	89 bf       	out	0x39, r24	; 57
			setbit(OCF1A, T1_TIFR);
     8f8:	88 b7       	in	r24, 0x38	; 56
     8fa:	80 64       	ori	r24, 0x40	; 64
     8fc:	09 c0       	rjmp	.+18     	; 0x910 <timer_compareMatchIntSetup+0x7e>
			break;
	   #endif
	   #if defined(OCIE1B)
		case 0x11:
//			setbit(OCIE1B, T1_TIMSK);
			writebit(OCIE1B, T1_TIMSK, enable);
     8fe:	89 b7       	in	r24, 0x39	; 57
     900:	99 23       	and	r25, r25
     902:	11 f0       	breq	.+4      	; 0x908 <timer_compareMatchIntSetup+0x76>
     904:	80 62       	ori	r24, 0x20	; 32
     906:	01 c0       	rjmp	.+2      	; 0x90a <timer_compareMatchIntSetup+0x78>
     908:	8f 7d       	andi	r24, 0xDF	; 223
     90a:	89 bf       	out	0x39, r24	; 57
			setbit(OCF1B, T1_TIFR);
     90c:	88 b7       	in	r24, 0x38	; 56
     90e:	80 62       	ori	r24, 0x20	; 32
     910:	88 bf       	out	0x38, r24	; 56
			break;
	}
	
	//Don't reenable interrupts here if disabling... just leave them as they were....
	// but do enable for init...
	if(enable)
     912:	99 23       	and	r25, r25
     914:	41 f0       	breq	.+16     	; 0x926 <timer_compareMatchIntSetup+0x94>
		sei();
     916:	78 94       	sei
	
	return 0;
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	05 c0       	rjmp	.+10     	; 0x926 <timer_compareMatchIntSetup+0x94>
	  												uint8_t enable)
{
	uint8_t channelNum;

	if(timerNum >= MAXTIMERS)
		return 1;
     91c:	91 e0       	ldi	r25, 0x01	; 1
     91e:	03 c0       	rjmp	.+6      	; 0x926 <timer_compareMatchIntSetup+0x94>

	if(outputChannel >= 2) //MAXCHANNELSPERTIMER)
		return 2;
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	01 c0       	rjmp	.+2      	; 0x926 <timer_compareMatchIntSetup+0x94>
			setbit(OCF3B, T3_TIFR);
			break;
	   #endif
	  #endif
		default:
			return 3;
     924:	93 e0       	ldi	r25, 0x03	; 3
	// but do enable for init...
	if(enable)
		sei();
	
	return 0;
}
     926:	89 2f       	mov	r24, r25
     928:	08 95       	ret

0000092a <setHeartRate>:

void setHeartRate(uint8_t rate)
{
//	heartRate = rate;
	
	if(rate == 0)
     92a:	81 11       	cpse	r24, r1
     92c:	01 c0       	rjmp	.+2      	; 0x930 <setHeartRate+0x6>
		rate = 1;
     92e:	81 e0       	ldi	r24, 0x01	; 1
		
    heartStepTime = (HEARTSTEPTIME/rate);
     930:	28 2f       	mov	r18, r24
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	40 e0       	ldi	r20, 0x00	; 0
     936:	50 e0       	ldi	r21, 0x00	; 0
     938:	60 ee       	ldi	r22, 0xE0	; 224
     93a:	79 e7       	ldi	r23, 0x79	; 121
     93c:	80 e0       	ldi	r24, 0x00	; 0
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	aa d8       	rcall	.-3756   	; 0xfffffa96 <__eeprom_end+0xff7efa96>
     942:	20 93 61 00 	sts	0x0061, r18
     946:	30 93 62 00 	sts	0x0062, r19
     94a:	40 93 63 00 	sts	0x0063, r20
     94e:	50 93 64 00 	sts	0x0064, r21
     952:	08 95       	ret

00000954 <getHeartRate>:

#if (!defined(HEART_GETRATE_UNUSED) || !HEART_GETRATE_UNUSED)
//This function takes about 20 bytes
uint8_t getHeartRate(void)
{
	 return (uint8_t)(HEARTSTEPTIME/heartStepTime);
     954:	20 91 61 00 	lds	r18, 0x0061
     958:	30 91 62 00 	lds	r19, 0x0062
     95c:	40 91 63 00 	lds	r20, 0x0063
     960:	50 91 64 00 	lds	r21, 0x0064
     964:	60 ee       	ldi	r22, 0xE0	; 224
     966:	79 e7       	ldi	r23, 0x79	; 121
     968:	80 e0       	ldi	r24, 0x00	; 0
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	94 d8       	rcall	.-3800   	; 0xfffffa96 <__eeprom_end+0xff7efa96>
     96e:	82 2f       	mov	r24, r18
}
     970:	08 95       	ret

00000972 <heartClear>:
 #endif
#endif

void heartClear(void)
{
	hfm_setPower(&heartModulator, 0);
     972:	60 e0       	ldi	r22, 0x00	; 0
     974:	8e e8       	ldi	r24, 0x8E	; 142
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	0e cf       	rjmp	.-484    	; 0x796 <hfm_setPower>

0000097a <init_heartBeat>:
	//DDR = H,out
	setoutVar(heartBeatPin, heartPIN);
#else
void init_heartBeat(void)
{
	clrpinPORT(HEART_PINNUM, HEART_PINPORT);
     97a:	c1 98       	cbi	0x18, 1	; 24
	setoutPORT(HEART_PINNUM, HEART_PINPORT);
     97c:	b9 9a       	sbi	0x17, 1	; 23
#endif



//	hfm_setPower(&heartModulator, 0);
	hfm_setup(&heartModulator, 0, HEART_MAXBRIGHT);
     97e:	4f ef       	ldi	r20, 0xFF	; 255
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	8e e8       	ldi	r24, 0x8E	; 142
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	10 df       	rcall	.-480    	; 0x7a8 <hfm_setup>
//	heartRate = rate;
	
	if(rate == 0)
		rate = 1;
		
    heartStepTime = (HEARTSTEPTIME/rate);
     988:	80 ee       	ldi	r24, 0xE0	; 224
     98a:	99 e7       	ldi	r25, 0x79	; 121
     98c:	a0 e0       	ldi	r26, 0x00	; 0
     98e:	b0 e0       	ldi	r27, 0x00	; 0
     990:	80 93 61 00 	sts	0x0061, r24
     994:	90 93 62 00 	sts	0x0062, r25
     998:	a0 93 63 00 	sts	0x0063, r26
     99c:	b0 93 64 00 	sts	0x0064, r27
	init_dmsTimer();
 #endif

#elif(defined(HEART_TCNTER_UPDATES_AND_INIT) && \
		HEART_TCNTER_UPDATES_AND_INIT)
	tcnter_init();
     9a0:	f5 c0       	rjmp	.+490    	; 0xb8c <tcnter_init>

000009a2 <set_heartBlink>:
uint8_t heartBlink = 0;
//#define TOGGLETIME	(250*DMS_MS)

void set_heartBlink(uint8_t count)
{
	heartBlink = count;
     9a2:	80 93 6a 00 	sts	0x006A, r24
     9a6:	08 95       	ret

000009a8 <heartUpdate>:
#endif

//This function takes about 186 bytes
// Really?! Or is hfm not compiled if it's not used?
uint8_t heartUpdate(void)
{	
     9a8:	0f 93       	push	r16
     9aa:	1f 93       	push	r17
	static dms6sec_t lastTime = 0;
 #elif ( _HEART_TCNTER_ )
	static myTcnter_t lastTime = 0;

  #if (HEART_TCNTER_UPDATES_AND_INIT)
	tcnter_update();
     9ac:	43 d1       	rcall	.+646    	; 0xc34 <tcnter_update>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
     9ae:	80 91 7b 00 	lds	r24, 0x007B
     9b2:	90 91 7c 00 	lds	r25, 0x007C
     9b6:	a0 91 7d 00 	lds	r26, 0x007D
     9ba:	b0 91 7e 00 	lds	r27, 0x007E
     9be:	40 91 71 00 	lds	r20, 0x0071
     9c2:	50 91 72 00 	lds	r21, 0x0072
     9c6:	60 91 73 00 	lds	r22, 0x0073
     9ca:	70 91 74 00 	lds	r23, 0x0074
     9ce:	84 1b       	sub	r24, r20
     9d0:	95 0b       	sbc	r25, r21
     9d2:	a6 0b       	sbc	r26, r22
     9d4:	b7 0b       	sbc	r27, r23

   if(thisDelta >= deltaTime)
     9d6:	40 91 61 00 	lds	r20, 0x0061
     9da:	50 91 62 00 	lds	r21, 0x0062
     9de:	60 91 63 00 	lds	r22, 0x0063
     9e2:	70 91 64 00 	lds	r23, 0x0064
     9e6:	84 17       	cp	r24, r20
     9e8:	95 07       	cpc	r25, r21
     9ea:	a6 07       	cpc	r26, r22
     9ec:	b7 07       	cpc	r27, r23
     9ee:	68 f1       	brcs	.+90     	; 0xa4a <heartUpdate+0xa2>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
     9f0:	80 91 7b 00 	lds	r24, 0x007B
     9f4:	90 91 7c 00 	lds	r25, 0x007C
     9f8:	a0 91 7d 00 	lds	r26, 0x007D
     9fc:	b0 91 7e 00 	lds	r27, 0x007E
     a00:	80 93 71 00 	sts	0x0071, r24
     a04:	90 93 72 00 	sts	0x0072, r25
     a08:	a0 93 73 00 	sts	0x0073, r26
     a0c:	b0 93 74 00 	sts	0x0074, r27
#if (!defined(_WDT_DISABLE_) || !_WDT_DISABLE_)
	//Woot! Saved two bytes!
	wdt_reset();
#endif

	desired = (uint8_t)(heartModulator.power);
     a10:	80 91 91 00 	lds	r24, 0x0091

	desired += direction;
     a14:	60 91 60 00 	lds	r22, 0x0060
     a18:	77 27       	eor	r23, r23
     a1a:	67 fd       	sbrc	r22, 7
     a1c:	70 95       	com	r23
     a1e:	68 0f       	add	r22, r24
     a20:	71 1d       	adc	r23, r1
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
     a22:	6f 3f       	cpi	r22, 0xFF	; 255
     a24:	71 05       	cpc	r23, r1
     a26:	34 f0       	brlt	.+12     	; 0xa34 <heartUpdate+0x8c>
	{
		desired = HEART_MAXBRIGHT;
		direction = -1;
     a28:	8f ef       	ldi	r24, 0xFF	; 255
     a2a:	80 93 60 00 	sts	0x0060, r24
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
	{
		desired = HEART_MAXBRIGHT;
     a2e:	6f ef       	ldi	r22, 0xFF	; 255
     a30:	70 e0       	ldi	r23, 0x00	; 0
     a32:	08 c0       	rjmp	.+16     	; 0xa44 <heartUpdate+0x9c>
		direction = -1;
	}	

	if(desired <= 0)
     a34:	16 16       	cp	r1, r22
     a36:	17 06       	cpc	r1, r23
     a38:	2c f0       	brlt	.+10     	; 0xa44 <heartUpdate+0x9c>
	{
		desired = 0;
		direction = +1;
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	80 93 60 00 	sts	0x0060, r24
		direction = -1;
	}	

	if(desired <= 0)
	{
		desired = 0;
     a40:	60 e0       	ldi	r22, 0x00	; 0
     a42:	70 e0       	ldi	r23, 0x00	; 0
//	dms6sec_t currentTime;
	
//	currentTime = dmsGetTime();

	if(heart_isItTime(&lastTime, heartStepTime, HEART_PRECISE))
		hfm_setPower(&heartModulator, getNextDesired());
     a44:	8e e8       	ldi	r24, 0x8E	; 142
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	a6 de       	rcall	.-692    	; 0x796 <hfm_setPower>
	//determine whether the LED should be on or off based on the HFM
	// return TRUE if the pin is available as an input
	uint8_t ledVal;

#if (!defined(HEART_BLINK_UNUSED) || !HEART_BLINK_UNUSED)
	if(heartBlink)
     a4a:	80 91 6a 00 	lds	r24, 0x006A
     a4e:	88 23       	and	r24, r24
     a50:	09 f4       	brne	.+2      	; 0xa54 <heartUpdate+0xac>
     a52:	83 c0       	rjmp	.+262    	; 0xb5a <heartUpdate+0x1b2>
     a54:	98 2f       	mov	r25, r24
     a56:	9f 70       	andi	r25, 0x0F	; 15
	

	uint8_t thisNibble = heartBlink;

	//If both nibbles are filled, process them as specified
	if((heartBlink & 0xf0) && (heartBlink & 0x0f))
     a58:	28 2f       	mov	r18, r24
     a5a:	20 7f       	andi	r18, 0xF0	; 240
     a5c:	31 f0       	breq	.+12     	; 0xa6a <heartUpdate+0xc2>
     a5e:	91 11       	cpse	r25, r1
     a60:	07 c0       	rjmp	.+14     	; 0xa70 <heartUpdate+0xc8>
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
		highNibble = 0;
	else if(heartBlink & 0xf0)
		highNibble = 1;
     a62:	21 e0       	ldi	r18, 0x01	; 1
     a64:	20 93 70 00 	sts	0x0070, r18
     a68:	03 c0       	rjmp	.+6      	; 0xa70 <heartUpdate+0xc8>
	{	//Fall through and toggle...
	}
	//Otherwise just process the one that's filled
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
     a6a:	91 11       	cpse	r25, r1
		highNibble = 0;
     a6c:	10 92 70 00 	sts	0x0070, r1
	else if(heartBlink & 0xf0)
		highNibble = 1;

	//Fill the appropriate nibble for blinking...
	if(highNibble)
     a70:	e0 91 70 00 	lds	r30, 0x0070
     a74:	ee 23       	and	r30, r30
     a76:	19 f0       	breq	.+6      	; 0xa7e <heartUpdate+0xd6>
		thisNibble = (thisNibble & 0xf0) >> 4;
     a78:	82 95       	swap	r24
     a7a:	8f 70       	andi	r24, 0x0F	; 15
     a7c:	01 c0       	rjmp	.+2      	; 0xa80 <heartUpdate+0xd8>
	else
		thisNibble = (thisNibble & 0x0f);
     a7e:	89 2f       	mov	r24, r25

#if(HEART_USES_TIMER)
	//Blink the proper number of times
	if((toggleCount>>1) < thisNibble)
     a80:	40 91 6f 00 	lds	r20, 0x006F
     a84:	94 2f       	mov	r25, r20
     a86:	96 95       	lsr	r25
     a88:	00 91 6b 00 	lds	r16, 0x006B
     a8c:	10 91 6c 00 	lds	r17, 0x006C
     a90:	20 91 6d 00 	lds	r18, 0x006D
     a94:	30 91 6e 00 	lds	r19, 0x006E
     a98:	98 17       	cp	r25, r24
     a9a:	30 f5       	brcc	.+76     	; 0xae8 <heartUpdate+0x140>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
     a9c:	80 91 7b 00 	lds	r24, 0x007B
     aa0:	90 91 7c 00 	lds	r25, 0x007C
     aa4:	a0 91 7d 00 	lds	r26, 0x007D
     aa8:	b0 91 7e 00 	lds	r27, 0x007E
     aac:	80 1b       	sub	r24, r16
     aae:	91 0b       	sbc	r25, r17
     ab0:	a2 0b       	sbc	r26, r18
     ab2:	b3 0b       	sbc	r27, r19

   if(thisDelta >= deltaTime)
     ab4:	80 32       	cpi	r24, 0x20	; 32
     ab6:	91 4a       	sbci	r25, 0xA1	; 161
     ab8:	a7 40       	sbci	r26, 0x07	; 7
     aba:	b1 05       	cpc	r27, r1
     abc:	08 f4       	brcc	.+2      	; 0xac0 <heartUpdate+0x118>
     abe:	48 c0       	rjmp	.+144    	; 0xb50 <heartUpdate+0x1a8>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
     ac0:	80 91 7b 00 	lds	r24, 0x007B
     ac4:	90 91 7c 00 	lds	r25, 0x007C
     ac8:	a0 91 7d 00 	lds	r26, 0x007D
     acc:	b0 91 7e 00 	lds	r27, 0x007E
     ad0:	80 93 6b 00 	sts	0x006B, r24
     ad4:	90 93 6c 00 	sts	0x006C, r25
     ad8:	a0 93 6d 00 	sts	0x006D, r26
     adc:	b0 93 6e 00 	sts	0x006E, r27
	{
		if(heart_isItTime(&lastToggleTime, TOGGLETIME, HEART_PRECISE))
			toggleCount++;
     ae0:	4f 5f       	subi	r20, 0xFF	; 255
     ae2:	40 93 6f 00 	sts	0x006F, r20
     ae6:	34 c0       	rjmp	.+104    	; 0xb50 <heartUpdate+0x1a8>

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
     ae8:	40 91 7b 00 	lds	r20, 0x007B
     aec:	50 91 7c 00 	lds	r21, 0x007C
     af0:	60 91 7d 00 	lds	r22, 0x007D
     af4:	70 91 7e 00 	lds	r23, 0x007E
     af8:	40 1b       	sub	r20, r16
     afa:	51 0b       	sbc	r21, r17
     afc:	62 0b       	sbc	r22, r18
     afe:	73 0b       	sbc	r23, r19
	}
	else if(heart_isItTime(&lastToggleTime, 
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	99 e0       	ldi	r25, 0x09	; 9
     b04:	ad e3       	ldi	r26, 0x3D	; 61
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	0e 2e       	mov	r0, r30
     b0a:	04 c0       	rjmp	.+8      	; 0xb14 <heartUpdate+0x16c>
     b0c:	88 0f       	add	r24, r24
     b0e:	99 1f       	adc	r25, r25
     b10:	aa 1f       	adc	r26, r26
     b12:	bb 1f       	adc	r27, r27
     b14:	0a 94       	dec	r0
     b16:	d2 f7       	brpl	.-12     	; 0xb0c <heartUpdate+0x164>

   if(thisDelta >= deltaTime)
     b18:	48 17       	cp	r20, r24
     b1a:	59 07       	cpc	r21, r25
     b1c:	6a 07       	cpc	r22, r26
     b1e:	7b 07       	cpc	r23, r27
     b20:	b8 f0       	brcs	.+46     	; 0xb50 <heartUpdate+0x1a8>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
     b22:	80 91 7b 00 	lds	r24, 0x007B
     b26:	90 91 7c 00 	lds	r25, 0x007C
     b2a:	a0 91 7d 00 	lds	r26, 0x007D
     b2e:	b0 91 7e 00 	lds	r27, 0x007E
     b32:	80 93 6b 00 	sts	0x006B, r24
     b36:	90 93 6c 00 	sts	0x006C, r25
     b3a:	a0 93 6d 00 	sts	0x006D, r26
     b3e:	b0 93 6e 00 	sts	0x006E, r27
						((((uint32_t)TOGGLETIME) * 8)<<(highNibble)),
						HEART_PRECISE))
	{
		toggleCount = 0;
     b42:	10 92 6f 00 	sts	0x006F, r1
		//Only valid if both nibbles are filled (see above)
		highNibble = !highNibble;
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	e1 11       	cpse	r30, r1
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	80 93 70 00 	sts	0x0070, r24
		//Only valid if both nibbles are filled (see above)
		highNibble = !highNibble;
	}
#endif
	//(actually, the new value, at this point... but will be the last soon)
	return !getbit(0, toggleCount);
     b50:	80 91 6f 00 	lds	r24, 0x006F
     b54:	80 95       	com	r24
     b56:	81 70       	andi	r24, 0x01	; 1
     b58:	03 c0       	rjmp	.+6      	; 0xb60 <heartUpdate+0x1b8>
 #endif
		//ledVal = blinkHeart((dms6sec_t)currentTime);
	}
	else
#endif
		ledVal = hfm_nextOutput(&heartModulator);
     b5a:	8e e8       	ldi	r24, 0x8E	; 142
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	29 de       	rcall	.-942    	; 0x7b2 <hfm_nextOutput>

	if(ledVal)
     b60:	88 23       	and	r24, r24
     b62:	21 f0       	breq	.+8      	; 0xb6c <heartUpdate+0x1c4>
			setoutVar(heartBeatPin, heartPIN);
			setpinVar(heartBeatPin, heartPIN);
		}
#else
 #if (HEART_LEDCONNECTION == LED_DIRECT_HIGH)
		setinPORT(HEART_PINNUM, HEART_PINPORT);
     b64:	b9 98       	cbi	0x17, 1	; 23
		setpuPORT(HEART_PINNUM, HEART_PINPORT);
     b66:	c1 9a       	sbi	0x18, 1	; 24
		setpinPORT(HEART_PINNUM, HEART_PINPORT);
 #else
	#error "Not Handled..."
 #endif
#endif
		return TRUE;
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	03 c0       	rjmp	.+6      	; 0xb72 <heartUpdate+0x1ca>
		//PORT = L
		clrpinVar(heartBeatPin, heartPIN);
		//DDR = H,out
		setoutVar(heartBeatPin, heartPIN);
#else
		clrpinPORT(HEART_PINNUM, HEART_PINPORT);
     b6c:	c1 98       	cbi	0x18, 1	; 24
		setoutPORT(HEART_PINNUM, HEART_PINPORT);
     b6e:	b9 9a       	sbi	0x17, 1	; 23
#endif
		return FALSE;
     b70:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
     b76:	08 95       	ret

00000b78 <heartPinInputPoll>:
	   asm("nop;");
	}

	pinState = getpinVar(heartBeatPin, heartPIN);
#else
	setinPORT(HEART_PINNUM, HEART_PINPORT);
     b78:	b9 98       	cbi	0x17, 1	; 23
	setpuPORT(HEART_PINNUM, HEART_PINPORT);
     b7a:	c1 9a       	sbi	0x18, 1	; 24
     b7c:	8f ef       	ldi	r24, 0xFF	; 255
	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
     b7e:	00 00       	nop
     b80:	81 50       	subi	r24, 0x01	; 1
	setinPORT(HEART_PINNUM, HEART_PINPORT);
	setpuPORT(HEART_PINNUM, HEART_PINPORT);

	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
     b82:	e9 f7       	brne	.-6      	; 0xb7e <heartPinInputPoll+0x6>
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
	}

	pinState = getpinPORT(HEART_PINNUM, HEART_PINPORT);
     b84:	86 b3       	in	r24, 0x16	; 22
	// to assure valid/safe values of PORT and DDR...
	//Return the pin to the heartbeat
//	setoutVar(heartBeatPin, heartPIN);

	return pinState;
}
     b86:	86 95       	lsr	r24
     b88:	81 70       	andi	r24, 0x01	; 1
     b8a:	08 95       	ret

00000b8c <tcnter_init>:
	//What if the timer is 16bit (do they default as such?)
	timer_setWGM(TCNTER_AVRTIMER_NUM, WGM_NORMAL); //Necessary?
	timer_selectDivisor(TCNTER_AVRTIMER_NUM, TCNTER_AVRTIMER_CLKDIV);
#endif

	tcnter_lastTcnt = TCNTER_SOURCE_VAR;
     b8c:	82 b7       	in	r24, 0x32	; 50
     b8e:	80 93 7a 00 	sts	0x007A, r24
	tcnter_myTcnter = 0;
     b92:	10 92 7b 00 	sts	0x007B, r1
     b96:	10 92 7c 00 	sts	0x007C, r1
     b9a:	10 92 7d 00 	sts	0x007D, r1
     b9e:	10 92 7e 00 	sts	0x007E, r1
     ba2:	08 95       	ret

00000ba4 <tcnter_overflowUpdate>:
// (and after the actual overflow)... and therefore could be called at
// slightly different (+/-) times WRT the actual overflow...
TCNTER_INLINEABLE
void tcnter_overflowUpdate(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;
     ba4:	e2 b7       	in	r30, 0x32	; 50
	tcnter_compare_t deltaTcnt;


	//If tcnter_update() has been called inbetween, just treat this like a
	//normal tcnter_update()	
	if(tcnter_updatesSinceOverflowUpdate)
     ba6:	40 91 76 00 	lds	r20, 0x0076
     baa:	50 91 77 00 	lds	r21, 0x0077
     bae:	60 91 78 00 	lds	r22, 0x0078
     bb2:	70 91 79 00 	lds	r23, 0x0079
     bb6:	8e 2f       	mov	r24, r30
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	45 2b       	or	r20, r21
     bbc:	46 2b       	or	r20, r22
     bbe:	47 2b       	or	r20, r23
     bc0:	71 f0       	breq	.+28     	; 0xbde <tcnter_overflowUpdate+0x3a>
	{
		//wrap-around can be handled here...
		// (This shouldn't happen, right? Since overflowUpdate is called?)
		if(thisTcnt < tcnter_lastTcnt)
     bc2:	40 91 7a 00 	lds	r20, 0x007A
     bc6:	e4 17       	cp	r30, r20
     bc8:	18 f4       	brcc	.+6      	; 0xbd0 <tcnter_overflowUpdate+0x2c>
			deltaTcnt = (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
     bca:	27 e8       	ldi	r18, 0x87	; 135
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	02 c0       	rjmp	.+4      	; 0xbd4 <tcnter_overflowUpdate+0x30>
		else
			deltaTcnt = 0;
     bd0:	20 e0       	ldi	r18, 0x00	; 0
     bd2:	30 e0       	ldi	r19, 0x00	; 0

		deltaTcnt += (tcnter_compare_t)thisTcnt
						- (tcnter_compare_t)tcnter_lastTcnt;
     bd4:	84 1b       	sub	r24, r20
     bd6:	91 09       	sbc	r25, r1
		if(thisTcnt < tcnter_lastTcnt)
			deltaTcnt = (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
		else
			deltaTcnt = 0;

		deltaTcnt += (tcnter_compare_t)thisTcnt
     bd8:	82 0f       	add	r24, r18
     bda:	93 1f       	adc	r25, r19
     bdc:	06 c0       	rjmp	.+12     	; 0xbea <tcnter_overflowUpdate+0x46>
		deltaTcnt = TCNTER_SOURCE_OVERFLOW_VAL;

		//This should probably be small, e.g. +-1 WRT the last overflowUpdate
		// since it likely occurs in the overflow interrupt.
		deltaTcnt += (tcnter_compare_t)thisTcnt
						- (tcnter_compare_t)tcnter_lastOverflowTcnt;
     bde:	20 91 75 00 	lds	r18, 0x0075
     be2:	82 1b       	sub	r24, r18
     be4:	91 09       	sbc	r25, r1
		//Any error will be subtracted later...
		deltaTcnt = TCNTER_SOURCE_OVERFLOW_VAL;

		//This should probably be small, e.g. +-1 WRT the last overflowUpdate
		// since it likely occurs in the overflow interrupt.
		deltaTcnt += (tcnter_compare_t)thisTcnt
     be6:	89 57       	subi	r24, 0x79	; 121
     be8:	9f 4f       	sbci	r25, 0xFF	; 255

	}


	//Add the delta to myTcnter
	tcnter_myTcnter += deltaTcnt;
     bea:	40 91 7b 00 	lds	r20, 0x007B
     bee:	50 91 7c 00 	lds	r21, 0x007C
     bf2:	60 91 7d 00 	lds	r22, 0x007D
     bf6:	70 91 7e 00 	lds	r23, 0x007E
     bfa:	aa 27       	eor	r26, r26
     bfc:	97 fd       	sbrc	r25, 7
     bfe:	a0 95       	com	r26
     c00:	ba 2f       	mov	r27, r26
     c02:	84 0f       	add	r24, r20
     c04:	95 1f       	adc	r25, r21
     c06:	a6 1f       	adc	r26, r22
     c08:	b7 1f       	adc	r27, r23
     c0a:	80 93 7b 00 	sts	0x007B, r24
     c0e:	90 93 7c 00 	sts	0x007C, r25
     c12:	a0 93 7d 00 	sts	0x007D, r26
     c16:	b0 93 7e 00 	sts	0x007E, r27
	
	//And prep for the next call...
	tcnter_updatesSinceOverflowUpdate = 0;
     c1a:	10 92 76 00 	sts	0x0076, r1
     c1e:	10 92 77 00 	sts	0x0077, r1
     c22:	10 92 78 00 	sts	0x0078, r1
     c26:	10 92 79 00 	sts	0x0079, r1
	tcnter_lastTcnt = thisTcnt;
     c2a:	e0 93 7a 00 	sts	0x007A, r30
	tcnter_lastOverflowTcnt = thisTcnt;
     c2e:	e0 93 75 00 	sts	0x0075, r30
     c32:	08 95       	ret

00000c34 <tcnter_update>:
//  (how could it take *more* instructions?!)
//   trying to shuffle registers?
//TCNTER_INLINEABLE
void tcnter_update(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;	//e.g. TCNT0
     c34:	22 b7       	in	r18, 0x32	; 50
	
	tcnter_compare_t deltaTcnt = (tcnter_compare_t)thisTcnt 
										- (tcnter_compare_t)tcnter_lastTcnt;
     c36:	30 91 7a 00 	lds	r19, 0x007A
//TCNTER_INLINEABLE
void tcnter_update(void)
{
	tcnter_source_t thisTcnt = TCNTER_SOURCE_VAR;	//e.g. TCNT0
	
	tcnter_compare_t deltaTcnt = (tcnter_compare_t)thisTcnt 
     c3a:	82 2f       	mov	r24, r18
     c3c:	90 e0       	ldi	r25, 0x00	; 0
     c3e:	83 1b       	sub	r24, r19
     c40:	91 09       	sbc	r25, r1
	// and update() is called after, at TCNT=1
	// update won't increment, and the updatesSinceOverflow, if allowed to
	// be incremented, would indicate to overflowUpdate that it should treat
	// the next overflow as a normal update, which may well occur at, again,
	// TCNT=1, which would result in a non-advancement at all.
	if(thisTcnt == tcnter_lastOverflowTcnt)
     c42:	40 91 75 00 	lds	r20, 0x0075
     c46:	24 17       	cp	r18, r20
     c48:	91 f1       	breq	.+100    	; 0xcae <tcnter_update+0x7a>
		return;

	tcnter_updatesSinceOverflowUpdate++;
     c4a:	40 91 76 00 	lds	r20, 0x0076
     c4e:	50 91 77 00 	lds	r21, 0x0077
     c52:	60 91 78 00 	lds	r22, 0x0078
     c56:	70 91 79 00 	lds	r23, 0x0079
     c5a:	4f 5f       	subi	r20, 0xFF	; 255
     c5c:	5f 4f       	sbci	r21, 0xFF	; 255
     c5e:	6f 4f       	sbci	r22, 0xFF	; 255
     c60:	7f 4f       	sbci	r23, 0xFF	; 255
     c62:	40 93 76 00 	sts	0x0076, r20
     c66:	50 93 77 00 	sts	0x0077, r21
     c6a:	60 93 78 00 	sts	0x0078, r22
     c6e:	70 93 79 00 	sts	0x0079, r23
#endif
	
	// Handle wrap-around...
	if (thisTcnt < tcnter_lastTcnt)
     c72:	23 17       	cp	r18, r19
     c74:	10 f4       	brcc	.+4      	; 0xc7a <tcnter_update+0x46>
		deltaTcnt += (tcnter_compare_t)(TCNTER_SOURCE_OVERFLOW_VAL);
     c76:	89 57       	subi	r24, 0x79	; 121
     c78:	9f 4f       	sbci	r25, 0xFF	; 255

	tcnter_lastTcnt = thisTcnt;
     c7a:	20 93 7a 00 	sts	0x007A, r18

	tcnter_myTcnter += (tcnter_t)deltaTcnt;
     c7e:	40 91 7b 00 	lds	r20, 0x007B
     c82:	50 91 7c 00 	lds	r21, 0x007C
     c86:	60 91 7d 00 	lds	r22, 0x007D
     c8a:	70 91 7e 00 	lds	r23, 0x007E
     c8e:	aa 27       	eor	r26, r26
     c90:	97 fd       	sbrc	r25, 7
     c92:	a0 95       	com	r26
     c94:	ba 2f       	mov	r27, r26
     c96:	84 0f       	add	r24, r20
     c98:	95 1f       	adc	r25, r21
     c9a:	a6 1f       	adc	r26, r22
     c9c:	b7 1f       	adc	r27, r23
     c9e:	80 93 7b 00 	sts	0x007B, r24
     ca2:	90 93 7c 00 	sts	0x007C, r25
     ca6:	a0 93 7d 00 	sts	0x007D, r26
     caa:	b0 93 7e 00 	sts	0x007E, r27
     cae:	08 95       	ret

00000cb0 <tcnter_wait>:
	DPRINT("tcnter_init()\n");
}


void tcnter_wait(myTcnter_t tcnts)
{
     cb0:	8f 92       	push	r8
     cb2:	9f 92       	push	r9
     cb4:	af 92       	push	r10
     cb6:	bf 92       	push	r11
     cb8:	cf 92       	push	r12
     cba:	df 92       	push	r13
     cbc:	ef 92       	push	r14
     cbe:	ff 92       	push	r15
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <tcnter_wait+0x16>
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <tcnter_wait+0x18>
     cc8:	cd b7       	in	r28, 0x3d	; 61
     cca:	de b7       	in	r29, 0x3e	; 62

//Inlined: Saved 40B
TCNTER_INLINEABLE
tcnter_t tcnter_get(void)
{
	return tcnter_myTcnter;
     ccc:	c0 90 7b 00 	lds	r12, 0x007B
     cd0:	d0 90 7c 00 	lds	r13, 0x007C
     cd4:	e0 90 7d 00 	lds	r14, 0x007D
     cd8:	f0 90 7e 00 	lds	r15, 0x007E

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
     cdc:	80 90 7b 00 	lds	r8, 0x007B
     ce0:	90 90 7c 00 	lds	r9, 0x007C
     ce4:	a0 90 7d 00 	lds	r10, 0x007D
     ce8:	b0 90 7e 00 	lds	r11, 0x007E
     cec:	8c 18       	sub	r8, r12
     cee:	9d 08       	sbc	r9, r13
     cf0:	ae 08       	sbc	r10, r14
     cf2:	bf 08       	sbc	r11, r15

   if(thisDelta >= deltaTime)
     cf4:	86 16       	cp	r8, r22
     cf6:	97 06       	cpc	r9, r23
     cf8:	a8 06       	cpc	r10, r24
     cfa:	b9 06       	cpc	r11, r25
     cfc:	b8 f0       	brcs	.+46     	; 0xd2c <tcnter_wait+0x7c>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
     cfe:	80 91 7b 00 	lds	r24, 0x007B
     d02:	90 91 7c 00 	lds	r25, 0x007C
     d06:	a0 91 7d 00 	lds	r26, 0x007D
     d0a:	b0 91 7e 00 	lds	r27, 0x007E
	while(!tcnter_isItTime(&startTime, tcnts))
	{
		tcnter_update();
		//asm("nop;");
	}
}
     d0e:	0f 90       	pop	r0
     d10:	0f 90       	pop	r0
     d12:	0f 90       	pop	r0
     d14:	0f 90       	pop	r0
     d16:	df 91       	pop	r29
     d18:	cf 91       	pop	r28
     d1a:	ff 90       	pop	r15
     d1c:	ef 90       	pop	r14
     d1e:	df 90       	pop	r13
     d20:	cf 90       	pop	r12
     d22:	bf 90       	pop	r11
     d24:	af 90       	pop	r10
     d26:	9f 90       	pop	r9
     d28:	8f 90       	pop	r8
     d2a:	08 95       	ret
{
	myTcnter_t startTime = tcnter_get();

	while(!tcnter_isItTime(&startTime, tcnts))
	{
		tcnter_update();
     d2c:	69 83       	std	Y+1, r22	; 0x01
     d2e:	7a 83       	std	Y+2, r23	; 0x02
     d30:	8b 83       	std	Y+3, r24	; 0x03
     d32:	9c 83       	std	Y+4, r25	; 0x04
     d34:	7f df       	rcall	.-258    	; 0xc34 <tcnter_update>
     d36:	69 81       	ldd	r22, Y+1	; 0x01
     d38:	7a 81       	ldd	r23, Y+2	; 0x02
     d3a:	8b 81       	ldd	r24, Y+3	; 0x03
     d3c:	9c 81       	ldd	r25, Y+4	; 0x04
     d3e:	ce cf       	rjmp	.-100    	; 0xcdc <tcnter_wait+0x2c>

00000d40 <tcnter_get>:

//Inlined: Saved 40B
TCNTER_INLINEABLE
tcnter_t tcnter_get(void)
{
	return tcnter_myTcnter;
     d40:	60 91 7b 00 	lds	r22, 0x007B
     d44:	70 91 7c 00 	lds	r23, 0x007C
     d48:	80 91 7d 00 	lds	r24, 0x007D
     d4c:	90 91 7e 00 	lds	r25, 0x007E
}
     d50:	08 95       	ret

00000d52 <pll_enable>:
   // The benefit of such high PWM frequency is the low RC values necessary
   //  for filtering to DC.
	// From the ATtiny861 manual:
	// "To change Timer/Counter1 to the async mode follow this procedure"
   // 1: Enable the PLL
   setbit(PLLE, PLLCSR);
     d52:	89 b5       	in	r24, 0x29	; 41
     d54:	82 60       	ori	r24, 0x02	; 2
     d56:	89 bd       	out	0x29, r24	; 41
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d58:	8f e8       	ldi	r24, 0x8F	; 143
     d5a:	91 e0       	ldi	r25, 0x01	; 1
     d5c:	01 97       	sbiw	r24, 0x01	; 1
     d5e:	f1 f7       	brne	.-4      	; 0xd5c <pll_enable+0xa>
     d60:	00 c0       	rjmp	.+0      	; 0xd62 <pll_enable+0x10>
     d62:	00 00       	nop
   // 2: Wait 100us for the PLL to stabilize
   // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
   _delay_us(100);
//   dmsWait(1);
   // 3: Poll PLOCK until it is set...
   while(!getbit(PLOCK, PLLCSR))
     d64:	09 b4       	in	r0, 0x29	; 41
     d66:	00 fc       	sbrc	r0, 0
     d68:	02 c0       	rjmp	.+4      	; 0xd6e <pll_enable+0x1c>
   {
      asm("nop");
     d6a:	00 00       	nop
     d6c:	fb cf       	rjmp	.-10     	; 0xd64 <pll_enable+0x12>
   }

//The PWM161 doesn't have a PCKE bit.
#if(!defined(__AVR_AT90PWM161__))
   // 4: Set the PCKE bit to enable async mode
   setbit(PCKE, PLLCSR);
     d6e:	89 b5       	in	r24, 0x29	; 41
     d70:	84 60       	ori	r24, 0x04	; 4
     d72:	89 bd       	out	0x29, r24	; 41
     d74:	08 95       	ret

00000d76 <hitSensor_init>:

void hitSensor_init(void)
{
	
	//Enable the pin as an input, pulled-up
	setinpuPORT(BUMP_SENSOR_PIN, BUMP_SENSOR_PORT);
     d76:	d7 98       	cbi	0x1a, 7	; 26
     d78:	df 9a       	sbi	0x1b, 7	; 27
	//The default PCMSK value is NON-ZERO!
	//Since the PCINT_vect is (so far) exclusively used for the bump-sensor
	// disable all the other PCINTs
	//Enable the corresponding Pin-Change pin...
	//setbit(BUMP_SENSOR_PCINT, BUMP_SENSOR_PCMSK);
	BUMP_SENSOR_PCMSK = (1<<BUMP_SENSOR_PCINT);
     d7a:	80 e8       	ldi	r24, 0x80	; 128
     d7c:	83 bd       	out	0x23, r24	; 35

	//The other PCMSK register also has defaults with certain pins enabled
	// and stupidly (?) the PCMSK# doesn't correspond to the PCIE#
	BUMP_SENSOR_NOTMY_PCMSK = 0;
     d7e:	12 bc       	out	0x22, r1	; 34

	//Clear the Pin-Change interrupt (probably not necessary)
	setbit(PCIF, GIFR);
     d80:	8a b7       	in	r24, 0x3a	; 58
     d82:	80 62       	ori	r24, 0x20	; 32
     d84:	8a bf       	out	0x3a, r24	; 58

	//Enable the Pin-Change interrupt
	// (They are *all* disabled by default)
	setbit(BUMP_SENSOR_PCIE, GIMSK);
     d86:	8b b7       	in	r24, 0x3b	; 59
     d88:	80 62       	ori	r24, 0x20	; 32
     d8a:	8b bf       	out	0x3b, r24	; 59
     d8c:	08 95       	ret

00000d8e <setColor>:
//This was #if'd into existence with IMAGE_BUFFER, but since it's only been
// used with frameBuffer, and since IMAGE_BUFFER is somewhat entangled with
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
     d8e:	0f 93       	push	r16
     d90:	a8 2f       	mov	r26, r24
     d92:	36 2f       	mov	r19, r22
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     d94:	82 2f       	mov	r24, r18
     d96:	90 e0       	ldi	r25, 0x00	; 0
     d98:	61 e1       	ldi	r22, 0x11	; 17
     d9a:	70 e0       	ldi	r23, 0x00	; 0
     d9c:	38 d6       	rcall	.+3184   	; 0x1a0e <__mulhi3>
     d9e:	fc 01       	movw	r30, r24
     da0:	e0 0f       	add	r30, r16
     da2:	f1 1d       	adc	r31, r1
     da4:	e0 55       	subi	r30, 0x50	; 80
     da6:	ff 4f       	sbci	r31, 0xFF	; 255
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;
     da8:	44 30       	cpi	r20, 0x04	; 4
     daa:	08 f0       	brcs	.+2      	; 0xdae <setColor+0x20>
     dac:	43 e0       	ldi	r20, 0x03	; 3

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     dae:	50 e0       	ldi	r21, 0x00	; 0
     db0:	84 e0       	ldi	r24, 0x04	; 4
     db2:	44 0f       	add	r20, r20
     db4:	55 1f       	adc	r21, r21
     db6:	8a 95       	dec	r24
     db8:	e1 f7       	brne	.-8      	; 0xdb2 <setColor+0x24>
// used with frameBuffer, and since IMAGE_BUFFER is somewhat entangled with
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
     dba:	8a 2f       	mov	r24, r26
     dbc:	a4 30       	cpi	r26, 0x04	; 4
     dbe:	08 f0       	brcs	.+2      	; 0xdc2 <setColor+0x34>
     dc0:	83 e0       	ldi	r24, 0x03	; 3
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     dc2:	48 2b       	or	r20, r24
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
     dc4:	63 2f       	mov	r22, r19
     dc6:	34 30       	cpi	r19, 0x04	; 4
     dc8:	08 f0       	brcs	.+2      	; 0xdcc <setColor+0x3e>
     dca:	63 e0       	ldi	r22, 0x03	; 3
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     dcc:	66 0f       	add	r22, r22
     dce:	66 0f       	add	r22, r22
     dd0:	64 2b       	or	r22, r20
     dd2:	60 83       	st	Z, r22
}
     dd4:	0f 91       	pop	r16
     dd6:	08 95       	ret

00000dd8 <frameBufferInit>:
// This stuff was located in main() before the while loop...
// #if !COLOR_BAR_SCROLL... (which is *nearly every case* including 
//  RowSegBuffer, etc)
// it's long-since been commented-out...
void frameBufferInit(void)
{
     dd8:	e0 ec       	ldi	r30, 0xC0	; 192
     dda:	f0 e0       	ldi	r31, 0x00	; 0
	//_W in FB_WIDTH is a hack for equal-length pixels, see frameBuffer's
	//definition, above.
	uint8_t i;
	for(i=0; i<FB_HEIGHT; i++)
		frameBuffer[i][FB_WIDTH] = FB_END_OF_ROW_COLOR;
     ddc:	10 82       	st	Z, r1
     dde:	71 96       	adiw	r30, 0x11	; 17
void frameBufferInit(void)
{
	//_W in FB_WIDTH is a hack for equal-length pixels, see frameBuffer's
	//definition, above.
	uint8_t i;
	for(i=0; i<FB_HEIGHT; i++)
     de0:	81 e0       	ldi	r24, 0x01	; 1
     de2:	e0 3d       	cpi	r30, 0xD0	; 208
     de4:	f8 07       	cpc	r31, r24
     de6:	d1 f7       	brne	.-12     	; 0xddc <frameBufferInit+0x4>
//               ), r, c);
      }
   }
*/

}
     de8:	08 95       	ret

00000dea <setSpriteSkyColorOverride>:
const __flash sprite_t *skyOverrideSprite = NULL;
//uint8_t skyOverridePalette;

void setSpriteSkyColorOverride(const __flash sprite_t *sprite) //, uint8_t palette)
{
	skyOverrideSprite = sprite;
     dea:	90 93 87 00 	sts	0x0087, r25
     dee:	80 93 86 00 	sts	0x0086, r24
     df2:	08 95       	ret

00000df4 <getRawPixelVal>:
uint8_t getRawPixelVal(const __flash sprite_t *sprite, uint8_t row, 
														uint8_t col, uint8_t imageNum)
{

	return
		(((pgm_read_byte((uint8_t *)(&(sprite->p_image[imageNum][ \
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	56 e0       	ldi	r21, 0x06	; 6
     df8:	22 0f       	add	r18, r18
     dfa:	33 1f       	adc	r19, r19
     dfc:	5a 95       	dec	r21
     dfe:	e1 f7       	brne	.-8      	; 0xdf8 <getRawPixelVal+0x4>
     e00:	fc 01       	movw	r30, r24
     e02:	a5 91       	lpm	r26, Z+
     e04:	b5 91       	lpm	r27, Z+
     e06:	a2 0f       	add	r26, r18
     e08:	b3 1f       	adc	r27, r19
     e0a:	70 e0       	ldi	r23, 0x00	; 0
     e0c:	66 0f       	add	r22, r22
     e0e:	77 1f       	adc	r23, r23
     e10:	66 0f       	add	r22, r22
     e12:	77 1f       	adc	r23, r23
     e14:	84 2f       	mov	r24, r20
     e16:	86 95       	lsr	r24
     e18:	86 95       	lsr	r24
     e1a:	68 0f       	add	r22, r24
     e1c:	71 1d       	adc	r23, r1
     e1e:	a6 0f       	add	r26, r22
     e20:	b7 1f       	adc	r27, r23
     e22:	fd 01       	movw	r30, r26
     e24:	84 91       	lpm	r24, Z
					(row)*PACKED_BYTES_PER_ROW + (col)/PIXELS_PER_PACKAGE])))\
		  )>>((col)%PIXELS_PER_PACKAGE)*(PACKED_BITS_PER_PIXEL))&0x03);
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	43 70       	andi	r20, 0x03	; 3
     e2a:	44 0f       	add	r20, r20
     e2c:	02 c0       	rjmp	.+4      	; 0xe32 <getRawPixelVal+0x3e>
     e2e:	95 95       	asr	r25
     e30:	87 95       	ror	r24
     e32:	4a 95       	dec	r20
     e34:	e2 f7       	brpl	.-8      	; 0xe2e <getRawPixelVal+0x3a>
}
     e36:	83 70       	andi	r24, 0x03	; 3
     e38:	08 95       	ret

00000e3a <rawPixValToGimpColorVal>:

uint8_t rawPixValToGimpColorVal(uint8_t rawPixelVal, const __flash sprite_t *sprite, 
																			uint8_t palette)
{
	return 
	pgm_read_byte(
     e3a:	6c 5f       	subi	r22, 0xFC	; 252
     e3c:	7f 4f       	sbci	r23, 0xFF	; 255
     e3e:	50 e0       	ldi	r21, 0x00	; 0
     e40:	44 0f       	add	r20, r20
     e42:	55 1f       	adc	r21, r21
     e44:	44 0f       	add	r20, r20
     e46:	55 1f       	adc	r21, r21
     e48:	48 0f       	add	r20, r24
     e4a:	51 1d       	adc	r21, r1
     e4c:	fb 01       	movw	r30, r22
     e4e:	85 91       	lpm	r24, Z+
     e50:	95 91       	lpm	r25, Z+
     e52:	84 0f       	add	r24, r20
     e54:	95 1f       	adc	r25, r21
     e56:	fc 01       	movw	r30, r24
     e58:	84 91       	lpm	r24, Z
			(uint8_t *)(&(sprite->p_palette[ (palette)*4 + rawPixelVal ])));
}
     e5a:	08 95       	ret

00000e5c <fbQ_repositionSprite>:


//This can also be used for repositioning the camera...
//THIS ASSUMES it's only called ONCE per count...
void fbQ_repositionSprite(spriteState_t *state)
{
     e5c:	ef 92       	push	r14
     e5e:	ff 92       	push	r15
     e60:	0f 93       	push	r16
     e62:	1f 93       	push	r17
     e64:	cf 93       	push	r28
     e66:	df 93       	push	r29
     e68:	dc 01       	movw	r26, r24
      state->position[axis] = startPos;
      state->dir[axis] = 1;
   }
	*/

   int8_t motion = GET_MOTION(state->motion[axis].motion, state->count);
     e6a:	19 96       	adiw	r26, 0x09	; 9
     e6c:	0d 91       	ld	r16, X+
     e6e:	1c 91       	ld	r17, X
     e70:	1a 97       	sbiw	r26, 0x0a	; 10
     e72:	ec 01       	movw	r28, r24
     e74:	20 e0       	ldi	r18, 0x00	; 0
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	c9 01       	movw	r24, r18
     e7a:	63 e0       	ldi	r22, 0x03	; 3
     e7c:	70 e0       	ldi	r23, 0x00	; 0
     e7e:	c7 d5       	rcall	.+2958   	; 0x1a0e <__mulhi3>
     e80:	80 0f       	add	r24, r16
     e82:	91 1f       	adc	r25, r17
     e84:	01 96       	adiw	r24, 0x01	; 1
     e86:	fc 01       	movw	r30, r24
     e88:	e5 90       	lpm	r14, Z+
     e8a:	f5 90       	lpm	r15, Z+
     e8c:	ad 01       	movw	r20, r26
     e8e:	42 0f       	add	r20, r18
     e90:	53 1f       	adc	r21, r19
     e92:	e1 14       	cp	r14, r1
     e94:	f1 04       	cpc	r15, r1
     e96:	d1 f0       	breq	.+52     	; 0xecc <fbQ_repositionSprite+0x70>
     e98:	14 96       	adiw	r26, 0x04	; 4
     e9a:	6c 91       	ld	r22, X
     e9c:	14 97       	sbiw	r26, 0x04	; 4
     e9e:	86 2f       	mov	r24, r22
     ea0:	86 95       	lsr	r24
     ea2:	86 95       	lsr	r24
     ea4:	f7 01       	movw	r30, r14
     ea6:	e8 0f       	add	r30, r24
     ea8:	f1 1d       	adc	r31, r1
     eaa:	e4 91       	lpm	r30, Z
     eac:	8e 2f       	mov	r24, r30
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	63 70       	andi	r22, 0x03	; 3
     eb2:	66 0f       	add	r22, r22
     eb4:	02 c0       	rjmp	.+4      	; 0xeba <fbQ_repositionSprite+0x5e>
     eb6:	95 95       	asr	r25
     eb8:	87 95       	ror	r24
     eba:	6a 95       	dec	r22
     ebc:	e2 f7       	brpl	.-8      	; 0xeb6 <fbQ_repositionSprite+0x5a>
     ebe:	83 70       	andi	r24, 0x03	; 3
   if(motion == DIR_TOGGLE)
     ec0:	83 30       	cpi	r24, 0x03	; 3
     ec2:	29 f4       	brne	.+10     	; 0xece <fbQ_repositionSprite+0x72>
   {
      state->dir[axis] = -state->dir[axis];
     ec4:	fa 01       	movw	r30, r20
     ec6:	82 81       	ldd	r24, Z+2	; 0x02
     ec8:	81 95       	neg	r24
     eca:	82 83       	std	Z+2, r24	; 0x02
      state->position[axis] = startPos;
      state->dir[axis] = 1;
   }
	*/

   int8_t motion = GET_MOTION(state->motion[axis].motion, state->count);
     ecc:	80 e0       	ldi	r24, 0x00	; 0
   {
      state->dir[axis] = -state->dir[axis];
      motion = 0;
   }

   motion *= state->dir[axis];
     ece:	fa 01       	movw	r30, r20
     ed0:	62 81       	ldd	r22, Z+2	; 0x02
     ed2:	94 d5       	rcall	.+2856   	; 0x19fc <__mulqi3>

   //Considering having LeafX be more like acceleration...?
   // e.g. motion: 1, 0, 0, DIR_TOGGLE -> motionX = 1 1 1 0(-)
   //(-= because we want +1 to shift right)
   if(axis == 0)
     ed4:	21 11       	cpse	r18, r1
     ed6:	01 c0       	rjmp	.+2      	; 0xeda <fbQ_repositionSprite+0x7e>
      motion *= (-1);
     ed8:	81 95       	neg	r24

   state->position[axis] += motion;
     eda:	98 81       	ld	r25, Y
     edc:	98 0f       	add	r25, r24
     ede:	99 93       	st	Y+, r25
     ee0:	2f 5f       	subi	r18, 0xFF	; 255
     ee2:	3f 4f       	sbci	r19, 0xFF	; 255
//THIS ASSUMES it's only called ONCE per count...
void fbQ_repositionSprite(spriteState_t *state)
{
   uint8_t axis;

   for(axis=0; axis<=1; axis++)
     ee4:	22 30       	cpi	r18, 0x02	; 2
     ee6:	31 05       	cpc	r19, r1
     ee8:	39 f6       	brne	.-114    	; 0xe78 <fbQ_repositionSprite+0x1c>
      motion *= (-1);

   state->position[axis] += motion;
   }

	state->paletteNum += GET_PALETTE_ADVANCE(state->sprite->p_paletteAdvance,
     eea:	1d 96       	adiw	r26, 0x0d	; 13
     eec:	8c 91       	ld	r24, X
     eee:	1d 97       	sbiw	r26, 0x0d	; 13
     ef0:	1b 96       	adiw	r26, 0x0b	; 11
     ef2:	2d 91       	ld	r18, X+
     ef4:	3c 91       	ld	r19, X
     ef6:	1c 97       	sbiw	r26, 0x0c	; 12
     ef8:	f9 01       	movw	r30, r18
     efa:	70 96       	adiw	r30, 0x10	; 16
     efc:	05 90       	lpm	r0, Z+
     efe:	f4 91       	lpm	r31, Z
     f00:	e0 2d       	mov	r30, r0
     f02:	30 97       	sbiw	r30, 0x00	; 0
     f04:	99 f0       	breq	.+38     	; 0xf2c <fbQ_repositionSprite+0xd0>
     f06:	14 96       	adiw	r26, 0x04	; 4
     f08:	9c 91       	ld	r25, X
     f0a:	14 97       	sbiw	r26, 0x04	; 4
     f0c:	49 2f       	mov	r20, r25
     f0e:	46 95       	lsr	r20
     f10:	46 95       	lsr	r20
     f12:	46 95       	lsr	r20
     f14:	e4 0f       	add	r30, r20
     f16:	f1 1d       	adc	r31, r1
     f18:	e4 91       	lpm	r30, Z
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	97 70       	andi	r25, 0x07	; 7
     f1e:	02 c0       	rjmp	.+4      	; 0xf24 <fbQ_repositionSprite+0xc8>
     f20:	f5 95       	asr	r31
     f22:	e7 95       	ror	r30
     f24:	9a 95       	dec	r25
     f26:	e2 f7       	brpl	.-8      	; 0xf20 <fbQ_repositionSprite+0xc4>
     f28:	e1 70       	andi	r30, 0x01	; 1
     f2a:	01 c0       	rjmp	.+2      	; 0xf2e <fbQ_repositionSprite+0xd2>
     f2c:	e0 e0       	ldi	r30, 0x00	; 0
     f2e:	8e 0f       	add	r24, r30
     f30:	1d 96       	adiw	r26, 0x0d	; 13
     f32:	8c 93       	st	X, r24
     f34:	1d 97       	sbiw	r26, 0x0d	; 13
																			state->count);
	state->paletteNum %= state->sprite->numPalettes;
     f36:	f9 01       	movw	r30, r18
     f38:	36 96       	adiw	r30, 0x06	; 6
     f3a:	64 91       	lpm	r22, Z
     f3c:	79 d5       	rcall	.+2802   	; 0x1a30 <__udivmodqi4>
     f3e:	1d 96       	adiw	r26, 0x0d	; 13
     f40:	9c 93       	st	X, r25
}
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	1f 91       	pop	r17
     f48:	0f 91       	pop	r16
     f4a:	ff 90       	pop	r15
     f4c:	ef 90       	pop	r14
     f4e:	08 95       	ret

00000f50 <fbQ_overlaySprite>:
//determined by its motionStuff... (repositionSprite() needs to be called
//prior)
//Eventually will return the rowNum for REFRESH_ON_CHANGE, etc...
uint8_t fbQ_overlaySprite(const __flash sprite_t *p_theSprite, spriteState_t *state)     
																//int8_t *spritePosition)
{
     f50:	2f 92       	push	r2
     f52:	3f 92       	push	r3
     f54:	4f 92       	push	r4
     f56:	5f 92       	push	r5
     f58:	6f 92       	push	r6
     f5a:	7f 92       	push	r7
     f5c:	8f 92       	push	r8
     f5e:	9f 92       	push	r9
     f60:	af 92       	push	r10
     f62:	bf 92       	push	r11
     f64:	cf 92       	push	r12
     f66:	df 92       	push	r13
     f68:	ef 92       	push	r14
     f6a:	ff 92       	push	r15
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	00 d0       	rcall	.+0      	; 0xf76 <fbQ_overlaySprite+0x26>
     f76:	00 d0       	rcall	.+0      	; 0xf78 <fbQ_overlaySprite+0x28>
     f78:	1f 92       	push	r1
     f7a:	cd b7       	in	r28, 0x3d	; 61
     f7c:	de b7       	in	r29, 0x3e	; 62
     f7e:	7c 01       	movw	r14, r24
     f80:	7d 83       	std	Y+5, r23	; 0x05
     f82:	6c 83       	std	Y+4, r22	; 0x04
	uint8_t * hFlip = NULL;
	uint8_t count = 0;

	//An unchanging sprite, e.g. SOLID in the background of a Reward...
	// (when NULL)
	if (state != NULL)
     f84:	61 15       	cp	r22, r1
     f86:	71 05       	cpc	r23, r1
     f88:	51 f0       	breq	.+20     	; 0xf9e <fbQ_overlaySprite+0x4e>
	{
		position[0] = state->position[0];
     f8a:	fb 01       	movw	r30, r22
     f8c:	20 80       	ld	r2, Z
		position[1] = state->position[1];
     f8e:	f1 81       	ldd	r31, Z+1	; 0x01
     f90:	f9 83       	std	Y+1, r31	; 0x01
		//hFlip = state->sprite->p_hFlip;	//6404
		hFlip = state->hFlip;					//6382
     f92:	fb 01       	movw	r30, r22
     f94:	a7 80       	ldd	r10, Z+7	; 0x07
     f96:	b0 84       	ldd	r11, Z+8	; 0x08
		count = state->count;
     f98:	84 81       	ldd	r24, Z+4	; 0x04
		paletteForColor = state->paletteNum;
     f9a:	55 85       	ldd	r21, Z+13	; 0x0d
     f9c:	06 c0       	rjmp	.+12     	; 0xfaa <fbQ_overlaySprite+0x5a>

   //I can't recall how this used to work...
//   uint8_t paletteForColor = getSpritePalette(p_theSprite, 0, 0);
	uint8_t paletteForColor = 0;

	int8_t position[2] = {0,0};
     f9e:	19 82       	std	Y+1, r1	; 0x01
     fa0:	21 2c       	mov	r2, r1
	uint8_t * hFlip = NULL;
	uint8_t count = 0;
     fa2:	80 e0       	ldi	r24, 0x00	; 0
   //I can't recall how this used to work...
//   uint8_t paletteForColor = getSpritePalette(p_theSprite, 0, 0);
	uint8_t paletteForColor = 0;

	int8_t position[2] = {0,0};
	uint8_t * hFlip = NULL;
     fa4:	a1 2c       	mov	r10, r1
     fa6:	b1 2c       	mov	r11, r1
   //int8_t camRow, camCol;
   int8_t frameRow, frameCol;

   //I can't recall how this used to work...
//   uint8_t paletteForColor = getSpritePalette(p_theSprite, 0, 0);
	uint8_t paletteForColor = 0;
     fa8:	50 e0       	ldi	r21, 0x00	; 0
      {
      
         int8_t spriteCol =
            (position[0] - cameraState.position[0]) + frameCol;
            
         if(GET_FLIP(hFlip, count))
     faa:	98 2f       	mov	r25, r24
     fac:	96 95       	lsr	r25
     fae:	96 95       	lsr	r25
     fb0:	96 95       	lsr	r25
     fb2:	25 01       	movw	r4, r10
     fb4:	49 0e       	add	r4, r25
     fb6:	51 1c       	adc	r5, r1
     fb8:	87 70       	andi	r24, 0x07	; 7
     fba:	88 24       	eor	r8, r8
     fbc:	83 94       	inc	r8
     fbe:	91 2c       	mov	r9, r1
     fc0:	02 c0       	rjmp	.+4      	; 0xfc6 <fbQ_overlaySprite+0x76>
     fc2:	88 0c       	add	r8, r8
     fc4:	99 1c       	adc	r9, r9
     fc6:	8a 95       	dec	r24
     fc8:	e2 f7       	brpl	.-8      	; 0xfc2 <fbQ_overlaySprite+0x72>
     fca:	b0 eb       	ldi	r27, 0xB0	; 176
     fcc:	cb 2e       	mov	r12, r27
     fce:	b0 e0       	ldi	r27, 0x00	; 0
     fd0:	db 2e       	mov	r13, r27
		paletteForColor = state->paletteNum;
	}



   for(frameRow = 0; frameRow<FB_HEIGHT; frameRow++)
     fd2:	31 2c       	mov	r3, r1
//prior)
//Eventually will return the rowNum for REFRESH_ON_CHANGE, etc...
uint8_t fbQ_overlaySprite(const __flash sprite_t *p_theSprite, spriteState_t *state)     
																//int8_t *spritePosition)
{
   uint8_t imageChangedTillRow=0;
     fd4:	80 e0       	ldi	r24, 0x00	; 0
           
		  //As it stands, a multi-image sprite is assumed to always
		  //cycle-through the images; one with each redraw...
         uint8_t colorData = getRawPixelVal(p_theSprite, spriteRow,
                                            spriteCol, 
											(state->count)%(p_theSprite->numImages));
     fd6:	37 01       	movw	r6, r14
     fd8:	f2 e1       	ldi	r31, 0x12	; 18
     fda:	6f 0e       	add	r6, r31
     fdc:	71 1c       	adc	r7, r1



   for(frameRow = 0; frameRow<FB_HEIGHT; frameRow++)
   {
      int8_t spriteRow =
     fde:	90 91 a1 00 	lds	r25, 0x00A1
     fe2:	39 81       	ldd	r19, Y+1	; 0x01
     fe4:	39 1b       	sub	r19, r25
     fe6:	33 0d       	add	r19, r3
         (position[1] - cameraState.position[1]) + frameRow;
         
      //The sky's already been drawn...
      if((spriteRow >= FB_HEIGHT) || (spriteRow < 0))
     fe8:	30 31       	cpi	r19, 0x10	; 16
     fea:	08 f0       	brcs	.+2      	; 0xfee <fbQ_overlaySprite+0x9e>
     fec:	44 c0       	rjmp	.+136    	; 0x1076 <fbQ_overlaySprite+0x126>
         continue;
        
	  	if(p_theSprite == &spriteFLOWER)
     fee:	86 ea       	ldi	r24, 0xA6	; 166
     ff0:	e8 16       	cp	r14, r24
     ff2:	86 e0       	ldi	r24, 0x06	; 6
     ff4:	f8 06       	cpc	r15, r24
     ff6:	19 f4       	brne	.+6      	; 0xffe <fbQ_overlaySprite+0xae>
		{	
			if(spriteRow >= 8)
     ff8:	38 30       	cpi	r19, 0x08	; 8
     ffa:	0c f0       	brlt	.+2      	; 0xffe <fbQ_overlaySprite+0xae>
				paletteForColor = NUMPALETTES_FLOWER-1;
     ffc:	53 e0       	ldi	r21, 0x03	; 3
     ffe:	00 e0       	ldi	r16, 0x00	; 0
    1000:	10 e0       	ldi	r17, 0x00	; 0

      //Don't need to do this if the row is not in the sprite...
      for(frameCol = 0; frameCol<FB_WIDTH; frameCol++)
      {
      
         int8_t spriteCol =
    1002:	80 91 a0 00 	lds	r24, 0x00A0
    1006:	42 2d       	mov	r20, r2
    1008:	48 1b       	sub	r20, r24
    100a:	40 0f       	add	r20, r16
            (position[0] - cameraState.position[0]) + frameCol;
            
         if(GET_FLIP(hFlip, count))
    100c:	a1 14       	cp	r10, r1
    100e:	b1 04       	cpc	r11, r1
    1010:	51 f0       	breq	.+20     	; 0x1026 <fbQ_overlaySprite+0xd6>
    1012:	f2 01       	movw	r30, r4
    1014:	84 91       	lpm	r24, Z
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	88 21       	and	r24, r8
    101a:	99 21       	and	r25, r9
    101c:	89 2b       	or	r24, r25
    101e:	19 f0       	breq	.+6      	; 0x1026 <fbQ_overlaySprite+0xd6>
            spriteCol=(FB_WIDTH-1)-spriteCol;
    1020:	ff e0       	ldi	r31, 0x0F	; 15
    1022:	f4 1b       	sub	r31, r20
    1024:	4f 2f       	mov	r20, r31
            
         //The sky's already been drawn...
         if((spriteCol >= FB_WIDTH) || (spriteCol < 0))
    1026:	40 31       	cpi	r20, 0x10	; 16
    1028:	00 f5       	brcc	.+64     	; 0x106a <fbQ_overlaySprite+0x11a>
            continue;
           
		  //As it stands, a multi-image sprite is assumed to always
		  //cycle-through the images; one with each redraw...
         uint8_t colorData = getRawPixelVal(p_theSprite, spriteRow,
    102a:	ec 81       	ldd	r30, Y+4	; 0x04
    102c:	fd 81       	ldd	r31, Y+5	; 0x05
    102e:	84 81       	ldd	r24, Z+4	; 0x04
    1030:	f3 01       	movw	r30, r6
    1032:	64 91       	lpm	r22, Z
    1034:	fd d4       	rcall	.+2554   	; 0x1a30 <__udivmodqi4>
    1036:	29 2f       	mov	r18, r25
    1038:	63 2f       	mov	r22, r19
    103a:	c7 01       	movw	r24, r14
    103c:	3b 83       	std	Y+3, r19	; 0x03
    103e:	5a 83       	std	Y+2, r21	; 0x02
    1040:	d9 de       	rcall	.-590    	; 0xdf4 <getRawPixelVal>
                                            spriteCol, 
											(state->count)%(p_theSprite->numImages));
                                                         
         //The sky is always, now, as I recall, 0...     
         // so use it as a mask.
         if(colorData == 0)
    1042:	3b 81       	ldd	r19, Y+3	; 0x03
    1044:	5a 81       	ldd	r21, Y+2	; 0x02
    1046:	88 23       	and	r24, r24
    1048:	81 f0       	breq	.+32     	; 0x106a <fbQ_overlaySprite+0x11a>
            continue; 



			colorData = rawPixValToGimpColorVal(colorData,
    104a:	45 2f       	mov	r20, r21
    104c:	b7 01       	movw	r22, r14
    104e:	f5 de       	rcall	.-534    	; 0xe3a <rawPixValToGimpColorVal>
                                                p_theSprite,
                                                paletteForColor);
         colorData = gimpPixelValToLColor(colorData);
    1050:	68 2f       	mov	r22, r24
    1052:	60 73       	andi	r22, 0x30	; 48
    1054:	70 e0       	ldi	r23, 0x00	; 0
    1056:	3b 81       	ldd	r19, Y+3	; 0x03
    1058:	5a 81       	ldd	r21, Y+2	; 0x02
    105a:	60 32       	cpi	r22, 0x20	; 32
    105c:	71 05       	cpc	r23, r1
    105e:	0c f0       	brlt	.+2      	; 0x1062 <fbQ_overlaySprite+0x112>
    1060:	80 5f       	subi	r24, 0xF0	; 240
    1062:	f6 01       	movw	r30, r12
    1064:	e0 0f       	add	r30, r16
    1066:	f1 1f       	adc	r31, r17
         
         frameBuffer[frameRow][frameCol] = colorData;
    1068:	80 83       	st	Z, r24
    106a:	0f 5f       	subi	r16, 0xFF	; 255
    106c:	1f 4f       	sbci	r17, 0xFF	; 255
			if(spriteRow >= 8)
				paletteForColor = NUMPALETTES_FLOWER-1;
		}

      //Don't need to do this if the row is not in the sprite...
      for(frameCol = 0; frameCol<FB_WIDTH; frameCol++)
    106e:	00 31       	cpi	r16, 0x10	; 16
    1070:	11 05       	cpc	r17, r1
    1072:	39 f6       	brne	.-114    	; 0x1002 <fbQ_overlaySprite+0xb2>
         //NEED TO STOP AT THE END OF THE MOTIONARRAY
      }  
      
      //For now we're just going to presume that the framebuffer 
      // has changed each time...
      imageChangedTillRow = frameRow;
    1074:	83 2d       	mov	r24, r3
    1076:	33 94       	inc	r3
    1078:	f1 e1       	ldi	r31, 0x11	; 17
    107a:	cf 0e       	add	r12, r31
    107c:	d1 1c       	adc	r13, r1
		paletteForColor = state->paletteNum;
	}



   for(frameRow = 0; frameRow<FB_HEIGHT; frameRow++)
    107e:	90 e1       	ldi	r25, 0x10	; 16
    1080:	39 12       	cpse	r3, r25
    1082:	ad cf       	rjmp	.-166    	; 0xfde <fbQ_overlaySprite+0x8e>
      imageChangedTillRow = frameRow;
   }  
   
   return imageChangedTillRow;
   
}  
    1084:	0f 90       	pop	r0
    1086:	0f 90       	pop	r0
    1088:	0f 90       	pop	r0
    108a:	0f 90       	pop	r0
    108c:	0f 90       	pop	r0
    108e:	df 91       	pop	r29
    1090:	cf 91       	pop	r28
    1092:	1f 91       	pop	r17
    1094:	0f 91       	pop	r16
    1096:	ff 90       	pop	r15
    1098:	ef 90       	pop	r14
    109a:	df 90       	pop	r13
    109c:	cf 90       	pop	r12
    109e:	bf 90       	pop	r11
    10a0:	af 90       	pop	r10
    10a2:	9f 90       	pop	r9
    10a4:	8f 90       	pop	r8
    10a6:	7f 90       	pop	r7
    10a8:	6f 90       	pop	r6
    10aa:	5f 90       	pop	r5
    10ac:	4f 90       	pop	r4
    10ae:	3f 90       	pop	r3
    10b0:	2f 90       	pop	r2
    10b2:	08 95       	ret

000010b4 <initSpriteStates>:
	initSpriteStates(p_nowSprite);
}

void initSpriteStates(const __flash sprite_t *newSprite)
{
	qCount = 0;
    10b4:	10 92 84 00 	sts	0x0084, r1
	//.count is handled by qCount... but let's init it anyhow.
	
	p_nowSprite = newSprite;
    10b8:	90 93 68 00 	sts	0x0068, r25
    10bc:	80 93 67 00 	sts	0x0067, r24
	
	
	
	
	nowSpriteState.sprite = p_nowSprite;
    10c0:	90 93 9e 00 	sts	0x009E, r25
    10c4:	80 93 9d 00 	sts	0x009D, r24
	nowSpriteState.count = 0;
    10c8:	10 92 96 00 	sts	0x0096, r1
	nowSpriteState.hFlip = p_nowSprite->p_hFlip;
    10cc:	fc 01       	movw	r30, r24
    10ce:	38 96       	adiw	r30, 0x08	; 8
    10d0:	25 91       	lpm	r18, Z+
    10d2:	35 91       	lpm	r19, Z+
    10d4:	30 93 9a 00 	sts	0x009A, r19
    10d8:	20 93 99 00 	sts	0x0099, r18
	nowSpriteState.motion = p_nowSprite->p_motion;
    10dc:	fc 01       	movw	r30, r24
    10de:	3a 96       	adiw	r30, 0x0a	; 10
    10e0:	05 90       	lpm	r0, Z+
    10e2:	f4 91       	lpm	r31, Z
    10e4:	e0 2d       	mov	r30, r0
    10e6:	f0 93 9c 00 	sts	0x009C, r31
    10ea:	e0 93 9b 00 	sts	0x009B, r30
	//Origin is lower-left, but nextSpritePosition is upper-left...
	nowSpriteState.position[0] = -(nowSpriteState.motion[0].startPosition);
    10ee:	24 91       	lpm	r18, Z
    10f0:	21 95       	neg	r18
    10f2:	20 93 92 00 	sts	0x0092, r18
	nowSpriteState.position[1] = nowSpriteState.motion[1].startPosition;
    10f6:	33 96       	adiw	r30, 0x03	; 3
    10f8:	24 91       	lpm	r18, Z
    10fa:	20 93 93 00 	sts	0x0093, r18
	nowSpriteState.dir[0] = 1;
    10fe:	41 e0       	ldi	r20, 0x01	; 1
    1100:	40 93 94 00 	sts	0x0094, r20
	nowSpriteState.dir[1] = 1;
    1104:	40 93 95 00 	sts	0x0095, r20

	nowSpriteState.layer = p_nowSprite->p_layer;
    1108:	fc 01       	movw	r30, r24
    110a:	3c 96       	adiw	r30, 0x0c	; 12
    110c:	25 91       	lpm	r18, Z+
    110e:	35 91       	lpm	r19, Z+
    1110:	30 93 98 00 	sts	0x0098, r19
    1114:	20 93 97 00 	sts	0x0097, r18
	nowSpriteState.paletteNum = 0;
    1118:	10 92 9f 00 	sts	0x009F, r1


	//No sprite associated with the camera...
	cameraState.sprite = NULL;
    111c:	10 92 ac 00 	sts	0x00AC, r1
    1120:	10 92 ab 00 	sts	0x00AB, r1
	cameraState.count = 0;
    1124:	10 92 a4 00 	sts	0x00A4, r1
	cameraState.hFlip = NadaFlip;
    1128:	10 92 a8 00 	sts	0x00A8, r1
    112c:	10 92 a7 00 	sts	0x00A7, r1
	cameraState.motion = p_nowSprite->p_camMotion;
    1130:	fc 01       	movw	r30, r24
    1132:	3e 96       	adiw	r30, 0x0e	; 14
    1134:	05 90       	lpm	r0, Z+
    1136:	f4 91       	lpm	r31, Z
    1138:	e0 2d       	mov	r30, r0
    113a:	f0 93 aa 00 	sts	0x00AA, r31
    113e:	e0 93 a9 00 	sts	0x00A9, r30
	cameraState.position[0] = -(cameraState.motion[0].startPosition);
    1142:	84 91       	lpm	r24, Z
    1144:	81 95       	neg	r24
    1146:	80 93 a0 00 	sts	0x00A0, r24
	cameraState.position[1] = cameraState.motion[1].startPosition;
    114a:	33 96       	adiw	r30, 0x03	; 3
    114c:	84 91       	lpm	r24, Z
    114e:	80 93 a1 00 	sts	0x00A1, r24
	cameraState.dir[0] = 1;
    1152:	40 93 a2 00 	sts	0x00A2, r20
	cameraState.dir[1] = 1;
    1156:	40 93 a3 00 	sts	0x00A3, r20

	cameraState.layer = NadaLayer;
    115a:	10 92 a6 00 	sts	0x00A6, r1
    115e:	10 92 a5 00 	sts	0x00A5, r1
	cameraState.paletteNum = 0;
    1162:	10 92 ad 00 	sts	0x00AD, r1
    1166:	08 95       	ret

00001168 <fbQuestion_hitDetected>:

void initSpriteStates(const __flash sprite_t *newSprite);


void fbQuestion_hitDetected(void)
{
    1168:	1f 93       	push	r17
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29

	if( (p_nowSprite == &spriteQ)
    116e:	80 91 67 00 	lds	r24, 0x0067
    1172:	90 91 68 00 	lds	r25, 0x0068
    1176:	26 e0       	ldi	r18, 0x06	; 6
    1178:	8b 33       	cpi	r24, 0x3B	; 59
    117a:	92 07       	cpc	r25, r18
    117c:	09 f0       	breq	.+2      	; 0x1180 <fbQuestion_hitDetected+0x18>
    117e:	4b c0       	rjmp	.+150    	; 0x1216 <fbQuestion_hitDetected+0xae>
#elif (defined(HSYNC_TIMER_TCNT))
		static uint8_t lastReward;
		
		do
		{
			hitReward = (HSYNC_TIMER_TCNT + callCount + qCount)%12;
    1180:	20 91 85 00 	lds	r18, 0x0085
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	e0 91 84 00 	lds	r30, 0x0084
    118a:	f0 e0       	ldi	r31, 0x00	; 0
			//Don't allow double-goombas
		} while ((lastReward == 4) && (hitReward == 4));
    118c:	10 91 89 00 	lds	r17, 0x0089
#elif (defined(HSYNC_TIMER_TCNT))
		static uint8_t lastReward;
		
		do
		{
			hitReward = (HSYNC_TIMER_TCNT + callCount + qCount)%12;
    1190:	cc e0       	ldi	r28, 0x0C	; 12
    1192:	d0 e0       	ldi	r29, 0x00	; 0
    1194:	82 b7       	in	r24, 0x32	; 50
    1196:	a9 01       	movw	r20, r18
    1198:	48 0f       	add	r20, r24
    119a:	51 1d       	adc	r21, r1
    119c:	ca 01       	movw	r24, r20
    119e:	8e 0f       	add	r24, r30
    11a0:	9f 1f       	adc	r25, r31
    11a2:	be 01       	movw	r22, r28
    11a4:	65 d4       	rcall	.+2250   	; 0x1a70 <__divmodhi4>
    11a6:	48 2f       	mov	r20, r24
			//Don't allow double-goombas
		} while ((lastReward == 4) && (hitReward == 4));
    11a8:	14 30       	cpi	r17, 0x04	; 4
    11aa:	49 f0       	breq	.+18     	; 0x11be <fbQuestion_hitDetected+0x56>

		lastReward = hitReward;
    11ac:	40 93 89 00 	sts	0x0089, r20
		hitReward = (callCount+qCount)%8;
 #endif
#endif
#endif

		switch(hitReward)
    11b0:	89 30       	cpi	r24, 0x09	; 9
    11b2:	91 05       	cpc	r25, r1
    11b4:	10 f5       	brcc	.+68     	; 0x11fa <fbQuestion_hitDetected+0x92>
    11b6:	fc 01       	movw	r30, r24
    11b8:	ed 5e       	subi	r30, 0xED	; 237
    11ba:	ff 4f       	sbci	r31, 0xFF	; 255
    11bc:	09 94       	ijmp
		
		do
		{
			hitReward = (HSYNC_TIMER_TCNT + callCount + qCount)%12;
			//Don't allow double-goombas
		} while ((lastReward == 4) && (hitReward == 4));
    11be:	84 30       	cpi	r24, 0x04	; 4
    11c0:	49 f3       	breq	.-46     	; 0x1194 <fbQuestion_hitDetected+0x2c>
    11c2:	f4 cf       	rjmp	.-24     	; 0x11ac <fbQuestion_hitDetected+0x44>
#endif

		switch(hitReward)
		{
			case 0:
				p_nowSprite = &spriteFLOWER;
    11c4:	86 ea       	ldi	r24, 0xA6	; 166
    11c6:	96 e0       	ldi	r25, 0x06	; 6
    11c8:	1a c0       	rjmp	.+52     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 1:
				p_nowSprite = &sprite1UP;
    11ca:	85 e2       	ldi	r24, 0x25	; 37
    11cc:	95 e0       	ldi	r25, 0x05	; 5
    11ce:	17 c0       	rjmp	.+46     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 2:
				p_nowSprite = &spriteBIG;
    11d0:	8e e0       	ldi	r24, 0x0E	; 14
    11d2:	95 e0       	ldi	r25, 0x05	; 5
    11d4:	14 c0       	rjmp	.+40     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 3:
				p_nowSprite = &spriteSTAR;
    11d6:	83 eb       	ldi	r24, 0xB3	; 179
    11d8:	94 e0       	ldi	r25, 0x04	; 4
    11da:	11 c0       	rjmp	.+34     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 4:
				p_nowSprite = &spriteGOOMBA;
    11dc:	86 ef       	ldi	r24, 0xF6	; 246
    11de:	93 e0       	ldi	r25, 0x03	; 3
    11e0:	0e c0       	rjmp	.+28     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 5:
				p_nowSprite = &spriteLEAF;
    11e2:	8c e3       	ldi	r24, 0x3C	; 60
    11e4:	92 e0       	ldi	r25, 0x02	; 2
    11e6:	0b c0       	rjmp	.+22     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 6:
				p_nowSprite = &spriteCLOUD;
    11e8:	85 ee       	ldi	r24, 0xE5	; 229
    11ea:	91 e0       	ldi	r25, 0x01	; 1
    11ec:	08 c0       	rjmp	.+16     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 7:
				p_nowSprite = &spriteMARIO;
    11ee:	8e e8       	ldi	r24, 0x8E	; 142
    11f0:	91 e0       	ldi	r25, 0x01	; 1
    11f2:	05 c0       	rjmp	.+10     	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
			case 8:
				p_nowSprite = &spriteLUIGI;
    11f4:	87 e7       	ldi	r24, 0x77	; 119
    11f6:	91 e0       	ldi	r25, 0x01	; 1
    11f8:	02 c0       	rjmp	.+4      	; 0x11fe <fbQuestion_hitDetected+0x96>
				break;
//			case 9:
//				p_nowSprite = &spriteMARIORUNS;
				break;
			default:
				p_nowSprite = &spriteCOIN;
    11fa:	8f ec       	ldi	r24, 0xCF	; 207
    11fc:	92 e0       	ldi	r25, 0x02	; 2
    11fe:	90 93 68 00 	sts	0x0068, r25
    1202:	80 93 67 00 	sts	0x0067, r24
				break;
		}
		//qCount = 0;
		nowIsReward = TRUE;
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	80 93 66 00 	sts	0x0066, r24
		initSpriteStates(p_nowSprite);
    120c:	80 91 67 00 	lds	r24, 0x0067
    1210:	90 91 68 00 	lds	r25, 0x0068
    1214:	11 c0       	rjmp	.+34     	; 0x1238 <fbQuestion_hitDetected+0xd0>
	//briefly before scroll-back-to-question starts...
	// so there's no reason to test for KILLABLE
	// since it can't be killed when it's scrolling.
	// There's probably a tiny fraction of a second window where it is
	// possible to hit it when it's blue, and kill it... but it's TINY.
	else if((p_nowSprite == &spriteGOOMBA)
    1216:	86 5f       	subi	r24, 0xF6	; 246
    1218:	93 40       	sbci	r25, 0x03	; 3
    121a:	91 f4       	brne	.+36     	; 0x1240 <fbQuestion_hitDetected+0xd8>
				&& ((qCount > 16) && (qCount < 62)))
    121c:	80 91 84 00 	lds	r24, 0x0084
    1220:	81 51       	subi	r24, 0x11	; 17
    1222:	8d 32       	cpi	r24, 0x2D	; 45
    1224:	68 f4       	brcc	.+26     	; 0x1240 <fbQuestion_hitDetected+0xd8>
//				&& (p_nextSprite == NULL) )
//			   && ((qCount > 0) && (qCount < 16)) )
//			   && (qCount < GOOMBA_KILLABLE_QCOUNT) )
	{
		//qCount = 0;
		nowIsReward = TRUE;
    1226:	81 e0       	ldi	r24, 0x01	; 1
    1228:	80 93 66 00 	sts	0x0066, r24
		p_nowSprite = &spriteDEADGOOMBA;
    122c:	8c e7       	ldi	r24, 0x7C	; 124
    122e:	95 e0       	ldi	r25, 0x05	; 5
    1230:	90 93 68 00 	sts	0x0068, r25
    1234:	80 93 67 00 	sts	0x0067, r24
		initSpriteStates(p_nowSprite);
	}

}
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	1f 91       	pop	r17
//			   && (qCount < GOOMBA_KILLABLE_QCOUNT) )
	{
		//qCount = 0;
		nowIsReward = TRUE;
		p_nowSprite = &spriteDEADGOOMBA;
		initSpriteStates(p_nowSprite);
    123e:	3a cf       	rjmp	.-396    	; 0x10b4 <initSpriteStates>
	}

}
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	1f 91       	pop	r17
    1246:	08 95       	ret

00001248 <__vector_2>:

}


SIGNAL(PCINT_vect)
{
    1248:	1f 92       	push	r1
    124a:	0f 92       	push	r0
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	0f 92       	push	r0
    1250:	11 24       	eor	r1, r1
    1252:	2f 93       	push	r18
    1254:	3f 93       	push	r19
    1256:	4f 93       	push	r20
    1258:	5f 93       	push	r21
    125a:	6f 93       	push	r22
    125c:	7f 93       	push	r23
    125e:	8f 93       	push	r24
    1260:	9f 93       	push	r25
    1262:	af 93       	push	r26
    1264:	bf 93       	push	r27
    1266:	ef 93       	push	r30
    1268:	ff 93       	push	r31
	fbQuestion_hitDetected();	
    126a:	7e df       	rcall	.-260    	; 0x1168 <fbQuestion_hitDetected>
	//BOUNCE is INHERENT
	//So clear the interrupt again, even though it was cleared upon entry of
	//the interrupt-vector
	// (Will this prevent reentry to this interrupt if the bounce occurred
	// before it exitted and sei()ed at the end?
	setbit(PCIF, GIFR);
    126c:	8a b7       	in	r24, 0x3a	; 58
    126e:	80 62       	ori	r24, 0x20	; 32
    1270:	8a bf       	out	0x3a, r24	; 58
}
    1272:	ff 91       	pop	r31
    1274:	ef 91       	pop	r30
    1276:	bf 91       	pop	r27
    1278:	af 91       	pop	r26
    127a:	9f 91       	pop	r25
    127c:	8f 91       	pop	r24
    127e:	7f 91       	pop	r23
    1280:	6f 91       	pop	r22
    1282:	5f 91       	pop	r21
    1284:	4f 91       	pop	r20
    1286:	3f 91       	pop	r19
    1288:	2f 91       	pop	r18
    128a:	0f 90       	pop	r0
    128c:	0f be       	out	0x3f, r0	; 63
    128e:	0f 90       	pop	r0
    1290:	1f 90       	pop	r1
    1292:	18 95       	reti

00001294 <prepNextSprite>:
	// time. It should probably be renamed to selectedSprite, and the old
	// p_selectedSprite should probably be removed entirely.
	// IOW: There's no need for "nextSprite" in the new method.

	// Q Loops...
	if(p_nowSprite == &spriteQ)
    1294:	80 91 67 00 	lds	r24, 0x0067
    1298:	90 91 68 00 	lds	r25, 0x0068
    129c:	26 e0       	ldi	r18, 0x06	; 6
    129e:	8b 33       	cpi	r24, 0x3B	; 59
    12a0:	92 07       	cpc	r25, r18
    12a2:	39 f1       	breq	.+78     	; 0x12f2 <prepNextSprite+0x5e>
	  #else
		return;
     #endif
	}
	// Mario -> MarioRuns
	else if(p_nowSprite == &spriteMARIO)
    12a4:	21 e0       	ldi	r18, 0x01	; 1
    12a6:	8e 38       	cpi	r24, 0x8E	; 142
    12a8:	92 07       	cpc	r25, r18
    12aa:	31 f4       	brne	.+12     	; 0x12b8 <prepNextSprite+0x24>
	{
		nowIsReward = TRUE;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	80 93 66 00 	sts	0x0066, r24
		p_nowSprite = &spriteMARIORUNS;
    12b2:	82 e9       	ldi	r24, 0x92	; 146
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	14 c0       	rjmp	.+40     	; 0x12e0 <prepNextSprite+0x4c>
	}
	// Luigi -> LuigiRuns
	else if(p_nowSprite == &spriteLUIGI)
    12b8:	21 e0       	ldi	r18, 0x01	; 1
    12ba:	87 37       	cpi	r24, 0x77	; 119
    12bc:	92 07       	cpc	r25, r18
    12be:	31 f4       	brne	.+12     	; 0x12cc <prepNextSprite+0x38>
	{
		nowIsReward = TRUE;
    12c0:	81 e0       	ldi	r24, 0x01	; 1
    12c2:	80 93 66 00 	sts	0x0066, r24
		p_nowSprite = &spriteLUIGIRUNS;
    12c6:	80 e7       	ldi	r24, 0x70	; 112
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	0a c0       	rjmp	.+20     	; 0x12e0 <prepNextSprite+0x4c>
	}
	// Solid -> Q
	else if(p_nowSprite == &spriteSOLID)
	{
		nowIsReward = FALSE;
    12cc:	10 92 66 00 	sts	0x0066, r1
	{
		nowIsReward = TRUE;
		p_nowSprite = &spriteLUIGIRUNS;
	}
	// Solid -> Q
	else if(p_nowSprite == &spriteSOLID)
    12d0:	84 5e       	subi	r24, 0xE4	; 228
    12d2:	95 40       	sbci	r25, 0x05	; 5
    12d4:	19 f4       	brne	.+6      	; 0x12dc <prepNextSprite+0x48>
	{
		nowIsReward = FALSE;
		p_nowSprite = &spriteQ;
    12d6:	8b e3       	ldi	r24, 0x3B	; 59
    12d8:	96 e0       	ldi	r25, 0x06	; 6
    12da:	02 c0       	rjmp	.+4      	; 0x12e0 <prepNextSprite+0x4c>
	}
	// "Reward" -> Solid
	else
	{
		nowIsReward = FALSE;
		p_nowSprite = &spriteSOLID;
    12dc:	84 ee       	ldi	r24, 0xE4	; 228
    12de:	95 e0       	ldi	r25, 0x05	; 5
    12e0:	90 93 68 00 	sts	0x0068, r25
    12e4:	80 93 67 00 	sts	0x0067, r24
	}	

	initSpriteStates(p_nowSprite);
    12e8:	80 91 67 00 	lds	r24, 0x0067
    12ec:	90 91 68 00 	lds	r25, 0x0068
    12f0:	e1 ce       	rjmp	.-574    	; 0x10b4 <initSpriteStates>
    12f2:	08 95       	ret

000012f4 <fbQ_drawBackground>:
#if(defined(FBQ_SKYCOLOR_OVERRIDE))
	uint8_t skyColorData = FBQ_SKYCOLOR_OVERRIDE;
#else
	//uint8_t skyColorData = getRawPixelVal(, 0, 0);

	uint8_t skyColorData = rawPixValToGimpColorVal(0, 
    12f4:	fc 01       	movw	r30, r24
    12f6:	63 85       	ldd	r22, Z+11	; 0x0b
    12f8:	74 85       	ldd	r23, Z+12	; 0x0c
    12fa:	45 85       	ldd	r20, Z+13	; 0x0d
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	9d dd       	rcall	.-1222   	; 0xe3a <rawPixValToGimpColorVal>
														state->sprite,
														paletteForColor);
	skyColorData = gimpPixelValToLColor(skyColorData);
    1300:	28 2f       	mov	r18, r24
    1302:	20 73       	andi	r18, 0x30	; 48
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	20 32       	cpi	r18, 0x20	; 32
    1308:	31 05       	cpc	r19, r1
    130a:	0c f0       	brlt	.+2      	; 0x130e <fbQ_drawBackground+0x1a>
    130c:	80 5f       	subi	r24, 0xF0	; 240
    130e:	40 eb       	ldi	r20, 0xB0	; 176
    1310:	50 e0       	ldi	r21, 0x00	; 0


//This is sort-of Motion-Handling, as well...
//Usually the sky...
void fbQ_drawBackground(spriteState_t *state)
{
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	fa 01       	movw	r30, r20
    1318:	e2 0f       	add	r30, r18
    131a:	f3 1f       	adc	r31, r19
		for(camCol = 0; camCol<FB_WIDTH; camCol++)
		{
#if(defined(FBQ_RAINBOW_SKY) && FBQ_RAINBOW_SKY)
			frameBuffer[camRow][camCol] = (camRow+camCol)&0x3f;//skyColorData;
#else
			frameBuffer[camRow][camCol] = skyColorData;
    131c:	80 83       	st	Z, r24
    131e:	2f 5f       	subi	r18, 0xFF	; 255
    1320:	3f 4f       	sbci	r19, 0xFF	; 255

	int8_t camRow, camCol;

	for(camRow = 0; camRow<FB_HEIGHT; camRow++)
	{
		for(camCol = 0; camCol<FB_WIDTH; camCol++)
    1322:	20 31       	cpi	r18, 0x10	; 16
    1324:	31 05       	cpc	r19, r1
    1326:	b9 f7       	brne	.-18     	; 0x1316 <fbQ_drawBackground+0x22>
    1328:	4f 5e       	subi	r20, 0xEF	; 239
    132a:	5f 4f       	sbci	r21, 0xFF	; 255
#endif


	int8_t camRow, camCol;

	for(camRow = 0; camRow<FB_HEIGHT; camRow++)
    132c:	f1 e0       	ldi	r31, 0x01	; 1
    132e:	40 3c       	cpi	r20, 0xC0	; 192
    1330:	5f 07       	cpc	r21, r31
    1332:	79 f7       	brne	.-34     	; 0x1312 <fbQ_drawBackground+0x1e>
    1334:	08 95       	ret

00001336 <fbQuestion_update>:

//Returns the last image-row that has changed...
// (for refresh-on-change and/or partial-refresh)
// otherwise -1 if no change.
int8_t fbQuestion_update(void) //uint8_t triggerDetected)
{
    1336:	cf 93       	push	r28
	//last row that was changed...
	int8_t imageChangedTillRow = -1;

	//This is just used for helping to throw in some randomness for the next
	//sprite after a hit...
	callCount++;
    1338:	80 91 85 00 	lds	r24, 0x0085
    133c:	8f 5f       	subi	r24, 0xFF	; 255
    133e:	80 93 85 00 	sts	0x0085, r24
const __flash sprite_t *skyOverrideSprite = NULL;
//uint8_t skyOverridePalette;

void setSpriteSkyColorOverride(const __flash sprite_t *sprite) //, uint8_t palette)
{
	skyOverrideSprite = sprite;
    1342:	80 91 67 00 	lds	r24, 0x0067
    1346:	90 91 68 00 	lds	r25, 0x0068
    134a:	90 93 87 00 	sts	0x0087, r25
    134e:	80 93 86 00 	sts	0x0086, r24
				fbQuestion_hitDetected();
#endif



			nowSpriteState.count = qCount;
    1352:	80 91 84 00 	lds	r24, 0x0084
    1356:	80 93 96 00 	sts	0x0096, r24
			cameraState.count = qCount;
    135a:	80 93 a4 00 	sts	0x00A4, r24
			//Override for now...
			//otherSpriteState.count=0;

			fbQ_drawBackground(&nowSpriteState);
    135e:	82 e9       	ldi	r24, 0x92	; 146
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	c8 df       	rcall	.-112    	; 0x12f4 <fbQ_drawBackground>

			fbQ_repositionSprite(&nowSpriteState);
    1364:	82 e9       	ldi	r24, 0x92	; 146
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	79 dd       	rcall	.-1294   	; 0xe5c <fbQ_repositionSprite>
			fbQ_repositionSprite(&cameraState);
    136a:	80 ea       	ldi	r24, 0xA0	; 160
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	76 dd       	rcall	.-1300   	; 0xe5c <fbQ_repositionSprite>
			// "otherSpriteState" needn't be repositioned, it's always
			// SOLID (if used, only during a Reward)

			if(nowIsReward)
    1370:	80 91 66 00 	lds	r24, 0x0066
    1374:	88 23       	and	r24, r24
    1376:	61 f1       	breq	.+88     	; 0x13d0 <fbQuestion_update+0x9a>
			{
				//0 is foreground, so it should be drawn last
				if(!GET_LAYER(nowSpriteState.layer, nowSpriteState.count))
    1378:	e0 91 97 00 	lds	r30, 0x0097
    137c:	f0 91 98 00 	lds	r31, 0x0098
    1380:	30 97       	sbiw	r30, 0x00	; 0
    1382:	91 f0       	breq	.+36     	; 0x13a8 <fbQuestion_update+0x72>
    1384:	80 91 96 00 	lds	r24, 0x0096
    1388:	98 2f       	mov	r25, r24
    138a:	96 95       	lsr	r25
    138c:	96 95       	lsr	r25
    138e:	96 95       	lsr	r25
    1390:	e9 0f       	add	r30, r25
    1392:	f1 1d       	adc	r31, r1
    1394:	e4 91       	lpm	r30, Z
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	87 70       	andi	r24, 0x07	; 7
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <fbQuestion_update+0x6a>
    139c:	f5 95       	asr	r31
    139e:	e7 95       	ror	r30
    13a0:	8a 95       	dec	r24
    13a2:	e2 f7       	brpl	.-8      	; 0x139c <fbQuestion_update+0x66>
    13a4:	e0 fd       	sbrc	r30, 0
    13a6:	06 c0       	rjmp	.+12     	; 0x13b4 <fbQuestion_update+0x7e>
				{
					//imageChangedTillRow =
					//fbQ_overlaySprite(p_selectedSprite, selectedSpritePosition);
					fbQ_overlaySprite(&spriteSOLID, NULL); //&otherSpriteState);
    13a8:	60 e0       	ldi	r22, 0x00	; 0
    13aa:	70 e0       	ldi	r23, 0x00	; 0
    13ac:	84 ee       	ldi	r24, 0xE4	; 228
    13ae:	95 e0       	ldi	r25, 0x05	; 5
    13b0:	cf dd       	rcall	.-1122   	; 0xf50 <fbQ_overlaySprite>
    13b2:	0e c0       	rjmp	.+28     	; 0x13d0 <fbQuestion_update+0x9a>
						fbQ_overlaySprite(p_nowSprite, &nowSpriteState);
				}
				else
				{
					imageChangedTillRow =
						fbQ_overlaySprite(p_nowSprite, &nowSpriteState);
    13b4:	62 e9       	ldi	r22, 0x92	; 146
    13b6:	70 e0       	ldi	r23, 0x00	; 0
    13b8:	80 91 67 00 	lds	r24, 0x0067
    13bc:	90 91 68 00 	lds	r25, 0x0068
    13c0:	c7 dd       	rcall	.-1138   	; 0xf50 <fbQ_overlaySprite>
    13c2:	c8 2f       	mov	r28, r24
				
					//imageChangedTillRow =
					//fbQ_overlaySprite(p_selectedSprite, selectedSpritePosition);
					fbQ_overlaySprite(&spriteSOLID, NULL); //&otherSpriteState);
    13c4:	60 e0       	ldi	r22, 0x00	; 0
    13c6:	70 e0       	ldi	r23, 0x00	; 0
    13c8:	84 ee       	ldi	r24, 0xE4	; 228
    13ca:	95 e0       	ldi	r25, 0x05	; 5
    13cc:	c1 dd       	rcall	.-1150   	; 0xf50 <fbQ_overlaySprite>
    13ce:	08 c0       	rjmp	.+16     	; 0x13e0 <fbQuestion_update+0xaa>
				}
			}
			else //Not a reward, so only one sprite is drawn...
			{
				imageChangedTillRow =
					fbQ_overlaySprite(p_nowSprite, &nowSpriteState);
    13d0:	62 e9       	ldi	r22, 0x92	; 146
    13d2:	70 e0       	ldi	r23, 0x00	; 0
    13d4:	80 91 67 00 	lds	r24, 0x0067
    13d8:	90 91 68 00 	lds	r25, 0x0068
    13dc:	b9 dd       	rcall	.-1166   	; 0xf50 <fbQ_overlaySprite>
    13de:	c8 2f       	mov	r28, r24
			}

			qCount++;
    13e0:	90 91 84 00 	lds	r25, 0x0084
    13e4:	9f 5f       	subi	r25, 0xFF	; 255
    13e6:	90 93 84 00 	sts	0x0084, r25
			if(qCount >= (sizeof(DefaultY)*4))
#else
			if(qCount >= (sizeof(LeafX)*4))
#endif
*/
			if(qCount >= p_nowSprite->totalCount)
    13ea:	e0 91 67 00 	lds	r30, 0x0067
    13ee:	f0 91 68 00 	lds	r31, 0x0068
    13f2:	37 96       	adiw	r30, 0x07	; 7
    13f4:	84 91       	lpm	r24, Z
    13f6:	98 17       	cp	r25, r24
    13f8:	18 f0       	brcs	.+6      	; 0x1400 <fbQuestion_update+0xca>
			{
				qCount = 0;
    13fa:	10 92 84 00 	sts	0x0084, r1
				prepNextSprite();
    13fe:	4a df       	rcall	.-364    	; 0x1294 <prepNextSprite>
		if(qCount >= ((255 / 12) * 12))
			qCount = 0;
	}
*/
	return imageChangedTillRow;
}
    1400:	8c 2f       	mov	r24, r28
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <getSpritePalette>:

uint8_t getSpritePalette(const __flash sprite_t *p_thisSprite, uint8_t spritePhase,
																	uint8_t spriteRow)
{
    1406:	9c 01       	movw	r18, r24
    1408:	86 2f       	mov	r24, r22

	uint8_t thePalette;
	
	
	if(p_thisSprite == &spriteFLOWER)
    140a:	96 e0       	ldi	r25, 0x06	; 6
    140c:	26 3a       	cpi	r18, 0xA6	; 166
    140e:	39 07       	cpc	r19, r25
    1410:	31 f4       	brne	.+12     	; 0x141e <getSpritePalette+0x18>
	{
		if(spriteRow<FLOWER_PALETTE1_ROW)
    1412:	48 30       	cpi	r20, 0x08	; 8
    1414:	e8 f4       	brcc	.+58     	; 0x1450 <getSpritePalette+0x4a>
			//data = getGimpColorVal(&spriteFLOWER,
			  thePalette = spritePhase%(spriteFLOWER.numPalettes-1) + 1; 
    1416:	96 2f       	mov	r25, r22
    1418:	91 70       	andi	r25, 0x01	; 1
    141a:	9f 5f       	subi	r25, 0xFF	; 255
    141c:	1c c0       	rjmp	.+56     	; 0x1456 <getSpritePalette+0x50>
					 //spriteRow, qCol);
		else
			thePalette = 0;
			//data = getGimpColorVal(&spriteFLOWER, 0, spriteRow, qCol);
	}
	else if(p_thisSprite == &spriteGOOMBA)
    141e:	93 e0       	ldi	r25, 0x03	; 3
    1420:	26 3f       	cpi	r18, 0xF6	; 246
    1422:	39 07       	cpc	r19, r25
    1424:	81 f4       	brne	.+32     	; 0x1446 <getSpritePalette+0x40>
		//uint8_t palette; // = qCount * p_thisSprite->numPalettes / 16;
		//if(palette >= p_thisSprite->numPalettes)
		//	palette = p_thisSprite->numPalettes-1;

			
		switch(spritePhase)
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	80 31       	cpi	r24, 0x10	; 16
    142a:	91 05       	cpc	r25, r1
    142c:	50 f4       	brcc	.+20     	; 0x1442 <getSpritePalette+0x3c>
    142e:	fc 01       	movw	r30, r24
    1430:	e4 5e       	subi	r30, 0xE4	; 228
    1432:	ff 4f       	sbci	r31, 0xFF	; 255
    1434:	09 94       	ijmp
					thePalette = 1;
					break;
				case 7:
				case 8:
				case 9:
					thePalette = 2;
    1436:	92 e0       	ldi	r25, 0x02	; 2
					break;
    1438:	0e c0       	rjmp	.+28     	; 0x1456 <getSpritePalette+0x50>
				case 10:
				case 11:
				case 12:
					thePalette = 3;
    143a:	93 e0       	ldi	r25, 0x03	; 3
					break;
    143c:	0c c0       	rjmp	.+24     	; 0x1456 <getSpritePalette+0x50>
				case 13:
				case 14:
				case 15:
					thePalette = 4;
    143e:	94 e0       	ldi	r25, 0x04	; 4
					break;
    1440:	0a c0       	rjmp	.+20     	; 0x1456 <getSpritePalette+0x50>
				default:
					thePalette = p_thisSprite->numPalettes-1;
    1442:	95 e0       	ldi	r25, 0x05	; 5
    1444:	08 c0       	rjmp	.+16     	; 0x1456 <getSpritePalette+0x50>
		//data = getGimpColorVal(&spriteGOOMBA, palette, spriteRow, gCol);
	}
	else
	{
		//data = getGimpColorVal(p_thisSprite, 
		  thePalette = spritePhase%p_thisSprite->numPalettes;
    1446:	f9 01       	movw	r30, r18
    1448:	36 96       	adiw	r30, 0x06	; 6
    144a:	64 91       	lpm	r22, Z
    144c:	f1 d2       	rcall	.+1506   	; 0x1a30 <__udivmodqi4>
    144e:	03 c0       	rjmp	.+6      	; 0x1456 <getSpritePalette+0x50>
		if(spriteRow<FLOWER_PALETTE1_ROW)
			//data = getGimpColorVal(&spriteFLOWER,
			  thePalette = spritePhase%(spriteFLOWER.numPalettes-1) + 1; 
					 //spriteRow, qCol);
		else
			thePalette = 0;
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	01 c0       	rjmp	.+2      	; 0x1456 <getSpritePalette+0x50>
					thePalette = 0;
					break;
				case 4:
				case 5:
				case 6:
					thePalette = 1;
    1454:	91 e0       	ldi	r25, 0x01	; 1
		  thePalette = spritePhase%p_thisSprite->numPalettes;
						//spriteRow, qCol);
	}

	return thePalette;
}
    1456:	89 2f       	mov	r24, r25
    1458:	08 95       	ret

0000145a <getSpritePhase>:
// vOffset is whether the sprite is above the frame-buffer or below...
// centered = 0
// so, e.g. vOffset = spriteRow - rowToDrawAt
uint8_t getSpritePhase(const __flash sprite_t *p_thisSprite, uint8_t qCount, int8_t
		vOffset)
{
    145a:	9c 01       	movw	r18, r24
    145c:	86 2f       	mov	r24, r22
	uint8_t spritePhase = qCount;

	if(p_thisSprite == &spriteQ)
    145e:	96 e0       	ldi	r25, 0x06	; 6
    1460:	2b 33       	cpi	r18, 0x3B	; 59
    1462:	39 07       	cpc	r19, r25
    1464:	79 f4       	brne	.+30     	; 0x1484 <getSpritePhase+0x2a>
	{
		switch(spritePhase%12)
    1466:	6c e0       	ldi	r22, 0x0C	; 12
    1468:	e3 d2       	rcall	.+1478   	; 0x1a30 <__udivmodqi4>
    146a:	89 2f       	mov	r24, r25
    146c:	90 e0       	ldi	r25, 0x00	; 0
    146e:	8c 30       	cpi	r24, 0x0C	; 12
    1470:	91 05       	cpc	r25, r1
    1472:	30 f4       	brcc	.+12     	; 0x1480 <getSpritePhase+0x26>
    1474:	fc 01       	movw	r30, r24
    1476:	e4 5d       	subi	r30, 0xD4	; 212
    1478:	ff 4f       	sbci	r31, 0xFF	; 255
    147a:	09 94       	ijmp
			case 2:

			case 9:
			case 10:
			case 11:
				spritePhase = 0; //yellow background
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	08 95       	ret
				break;
			case 5:
			case 6:

			default:
				spritePhase = 2; //brown background
    1480:	82 e0       	ldi	r24, 0x02	; 2
				break;
    1482:	08 95       	ret
		}

	}
	//else if(p_thisSprite == &spriteCOIN) //handled in getRowPixelValCOIN()
	else if(p_thisSprite == &spriteGOOMBA)
    1484:	26 5f       	subi	r18, 0xF6	; 246
    1486:	33 40       	sbci	r19, 0x03	; 3
    1488:	61 f4       	brne	.+24     	; 0x14a2 <getSpritePhase+0x48>
	{
		if (vOffset < 0) //(spriteRow < rowToDrawAt)
    148a:	47 fd       	sbrc	r20, 7
    148c:	03 c0       	rjmp	.+6      	; 0x1494 <getSpritePhase+0x3a>
			spritePhase = 0;
		if (vOffset > 0) //(spriteRow > rowToDrawAt)
    148e:	41 11       	cpse	r20, r1
    1490:	07 c0       	rjmp	.+14     	; 0x14a0 <getSpritePhase+0x46>
    1492:	01 c0       	rjmp	.+2      	; 0x1496 <getSpritePhase+0x3c>
	}
	//else if(p_thisSprite == &spriteCOIN) //handled in getRowPixelValCOIN()
	else if(p_thisSprite == &spriteGOOMBA)
	{
		if (vOffset < 0) //(spriteRow < rowToDrawAt)
			spritePhase = 0;
    1494:	80 e0       	ldi	r24, 0x00	; 0
		if (vOffset > 0) //(spriteRow > rowToDrawAt)
			spritePhase = GOOMBA_QCOUNT;
		else
			spritePhase /=3;
    1496:	63 e0       	ldi	r22, 0x03	; 3
    1498:	cb d2       	rcall	.+1430   	; 0x1a30 <__udivmodqi4>
    149a:	08 95       	ret
			case 3:
			case 4:

			case 7:
			case 8:
				spritePhase = 1; //red background
    149c:	81 e0       	ldi	r24, 0x01	; 1
    149e:	08 95       	ret
	else if(p_thisSprite == &spriteGOOMBA)
	{
		if (vOffset < 0) //(spriteRow < rowToDrawAt)
			spritePhase = 0;
		if (vOffset > 0) //(spriteRow > rowToDrawAt)
			spritePhase = GOOMBA_QCOUNT;
    14a0:	80 e5       	ldi	r24, 0x50	; 80

	}

	return spritePhase;

}
    14a2:	08 95       	ret

000014a4 <lcd_init>:
#endif

void lcd_init(void)
{
	//Not sure modifying vSync randomly is safe...
	vSync = 0;
    14a4:	10 92 82 00 	sts	0x0082, r1
	//the rest should be...? assuming it occurs after lcd_update() completes
	// (thus leaving it in NADA-state)
	hsyncCount = 0;
    14a8:	10 92 81 00 	sts	0x0081, r1
    14ac:	10 92 80 00 	sts	0x0080, r1
	dataEnable = FALSE;
    14b0:	10 92 83 00 	sts	0x0083, r1
 	Nada_init();
    14b4:	88 b3       	in	r24, 0x18	; 24
    14b6:	80 63       	ori	r24, 0x30	; 48
    14b8:	88 bb       	out	0x18, r24	; 24
    14ba:	8b b3       	in	r24, 0x1b	; 27
    14bc:	8f 7c       	andi	r24, 0xCF	; 207
    14be:	8b bb       	out	0x1b, r24	; 27
    14c0:	08 95       	ret

000014c2 <lcd_update>:
//           Not *entirely* accurate, as it may be negative during VBLANK
//           OR returns LCD_FRAMECOMPLETE when that's the case.
// DOES THIS RETURN THE ROW THAT WAS DRAWN OR THE NEXT...?
#define LCD_FRAMECOMPLETE	INT16_MAX
int16_t lcd_update(void)
{
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
//	uint8_t frameComplete = FALSE;

#warning "this might be off by one, which would explain the weird first row"
	int16_t rowNum = hsyncCount - T_DV-T_VD-T_Vlow;
    14c6:	c0 91 80 00 	lds	r28, 0x0080
    14ca:	d0 91 81 00 	lds	r29, 0x0081
    14ce:	a8 97       	sbiw	r28, 0x28	; 40
	//Hsync and Actually draw the pixels... (when DE is active)
	// This takes a LONG time and will occupy most of the CPU...
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
//	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
	loadData(rowNum, dataEnable);
    14d0:	20 91 83 00 	lds	r18, 0x0083
#endif

#if(defined(ROW_BUFFER) && ROW_BUFFER)
   wc_color = &(rowBuffer[0]);
#else
	rowNum = rowNum*FB_HEIGHT / V_COUNT;
    14d4:	ce 01       	movw	r24, r28
    14d6:	34 e0       	ldi	r19, 0x04	; 4
    14d8:	88 0f       	add	r24, r24
    14da:	99 1f       	adc	r25, r25
    14dc:	3a 95       	dec	r19
    14de:	e1 f7       	brne	.-8      	; 0x14d8 <lcd_update+0x16>
    14e0:	60 ea       	ldi	r22, 0xA0	; 160
    14e2:	70 e0       	ldi	r23, 0x00	; 0
    14e4:	b1 d2       	rcall	.+1378   	; 0x1a48 <__udivmodhi4>
    14e6:	cb 01       	movw	r24, r22
//	rowNum &= 0x0f;
	wc_color = &(frameBuffer[rowNum][0]);
    14e8:	61 e1       	ldi	r22, 0x11	; 17
    14ea:	70 e0       	ldi	r23, 0x00	; 0
    14ec:	90 d2       	rcall	.+1312   	; 0x1a0e <__mulhi3>
    14ee:	80 55       	subi	r24, 0x50	; 80
    14f0:	9f 4f       	sbci	r25, 0xFF	; 255
    14f2:	90 93 af 00 	sts	0x00AF, r25
    14f6:	80 93 ae 00 	sts	0x00AE, r24
#ifdef drawPixSetup
	drawPixSetup(rowNum);
#endif

	//H Active pulse...
   if(vSync)
    14fa:	80 91 82 00 	lds	r24, 0x0082
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
    14fe:	c4 98       	cbi	0x18, 4	; 24
#ifdef drawPixSetup
	drawPixSetup(rowNum);
#endif

	//H Active pulse...
   if(vSync)
    1500:	88 23       	and	r24, r24
    1502:	21 f1       	breq	.+72     	; 0x154c <lcd_update+0x8a>
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
    1504:	89 e0       	ldi	r24, 0x09	; 9
    1506:	90 e0       	ldi	r25, 0x00	; 0
      Hlow_Delay();
    1508:	00 00       	nop
    150a:	c3 98       	cbi	0x18, 3	; 24
    150c:	00 00       	nop
    150e:	c3 9a       	sbi	0x18, 3	; 24
    1510:	01 97       	sbiw	r24, 0x01	; 1
    1512:	00 97       	sbiw	r24, 0x00	; 0
    1514:	c9 f7       	brne	.-14     	; 0x1508 <lcd_update+0x46>
      Vsync_fromVplusH();
    1516:	c4 9a       	sbi	0x18, 4	; 24
    1518:	87 e0       	ldi	r24, 0x07	; 7
    151a:	90 e0       	ldi	r25, 0x00	; 0
      HD_Delay();
    151c:	00 00       	nop
    151e:	c3 98       	cbi	0x18, 3	; 24
    1520:	00 00       	nop
    1522:	c3 9a       	sbi	0x18, 3	; 24
    1524:	01 97       	sbiw	r24, 0x01	; 1
    1526:	00 97       	sbiw	r24, 0x00	; 0
    1528:	c9 f7       	brne	.-14     	; 0x151c <lcd_update+0x5a>
      Hlow_Delay();
      Nada_fromHsync();
      HD_Delay();
   }

   if(dataEnable)
    152a:	22 23       	and	r18, r18
    152c:	09 f4       	brne	.+2      	; 0x1530 <lcd_update+0x6e>
    152e:	35 c1       	rjmp	.+618    	; 0x179a <lcd_update+0x2d8>
	//a/o v80
	//Stupid optimizer... just having these assigned at the beginning of the
	//function doesn't make them occur in that order.
	//In fact, the first writeColor... maybe I'm mistaken.
#if(defined(WC_SETUP) && WC_SETUP)
	uint8_t * color = wc_color;
    1530:	e0 91 ae 00 	lds	r30, 0x00AE
    1534:	f0 91 af 00 	lds	r31, 0x00AF
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1538:	80 81       	ld	r24, Z
    153a:	80 6c       	ori	r24, 0xC0	; 192
    153c:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    153e:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    1540:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    1542:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    1544:	c3 9a       	sbi	0x18, 3	; 24
    1546:	8d e0       	ldi	r24, 0x0D	; 13
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	14 c0       	rjmp	.+40     	; 0x1574 <lcd_update+0xb2>
      Vsync_fromVplusH();
      HD_Delay();
   }
   else
   {
      Hsync_fromNada();
    154c:	89 e0       	ldi	r24, 0x09	; 9
    154e:	90 e0       	ldi	r25, 0x00	; 0
      Hlow_Delay();
    1550:	00 00       	nop
    1552:	c3 98       	cbi	0x18, 3	; 24
    1554:	00 00       	nop
    1556:	c3 9a       	sbi	0x18, 3	; 24
    1558:	01 97       	sbiw	r24, 0x01	; 1
    155a:	00 97       	sbiw	r24, 0x00	; 0
    155c:	c9 f7       	brne	.-14     	; 0x1550 <lcd_update+0x8e>
      Nada_fromHsync();
    155e:	c4 9a       	sbi	0x18, 4	; 24
    1560:	87 e0       	ldi	r24, 0x07	; 7
    1562:	90 e0       	ldi	r25, 0x00	; 0
      HD_Delay();
    1564:	00 00       	nop
    1566:	c3 98       	cbi	0x18, 3	; 24
    1568:	00 00       	nop
    156a:	c3 9a       	sbi	0x18, 3	; 24
    156c:	01 97       	sbiw	r24, 0x01	; 1
    156e:	00 97       	sbiw	r24, 0x00	; 0
    1570:	c9 f7       	brne	.-14     	; 0x1564 <lcd_update+0xa2>
    1572:	db cf       	rjmp	.-74     	; 0x152a <lcd_update+0x68>
		// The intention being to get enableGreen as soon after the
		// register-settings as possible.
#if (!defined(LCDSTUFF_INCLUDE_NON_DE) || !LCDSTUFF_INCLUDE_NON_DE)
		delay_cyc(WRITE_COLOR_DELAY);
#else
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1574:	00 00       	nop
    1576:	c3 98       	cbi	0x18, 3	; 24
    1578:	00 00       	nop
    157a:	c3 9a       	sbi	0x18, 3	; 24
    157c:	01 97       	sbiw	r24, 0x01	; 1
    157e:	00 97       	sbiw	r24, 0x00	; 0
    1580:	c9 f7       	brne	.-14     	; 0x1574 <lcd_update+0xb2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1582:	81 81       	ldd	r24, Z+1	; 0x01
    1584:	80 6c       	ori	r24, 0xC0	; 192
    1586:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1588:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    158a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    158c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    158e:	c3 9a       	sbi	0x18, 3	; 24
    1590:	8d e0       	ldi	r24, 0x0D	; 13
    1592:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1594:	00 00       	nop
    1596:	c3 98       	cbi	0x18, 3	; 24
    1598:	00 00       	nop
    159a:	c3 9a       	sbi	0x18, 3	; 24
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	00 97       	sbiw	r24, 0x00	; 0
    15a0:	c9 f7       	brne	.-14     	; 0x1594 <lcd_update+0xd2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    15a2:	82 81       	ldd	r24, Z+2	; 0x02
    15a4:	80 6c       	ori	r24, 0xC0	; 192
    15a6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    15a8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    15aa:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    15ac:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    15ae:	c3 9a       	sbi	0x18, 3	; 24
    15b0:	8d e0       	ldi	r24, 0x0D	; 13
    15b2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    15b4:	00 00       	nop
    15b6:	c3 98       	cbi	0x18, 3	; 24
    15b8:	00 00       	nop
    15ba:	c3 9a       	sbi	0x18, 3	; 24
    15bc:	01 97       	sbiw	r24, 0x01	; 1
    15be:	00 97       	sbiw	r24, 0x00	; 0
    15c0:	c9 f7       	brne	.-14     	; 0x15b4 <lcd_update+0xf2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    15c2:	83 81       	ldd	r24, Z+3	; 0x03
    15c4:	80 6c       	ori	r24, 0xC0	; 192
    15c6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    15c8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    15ca:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    15cc:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    15ce:	c3 9a       	sbi	0x18, 3	; 24
    15d0:	8d e0       	ldi	r24, 0x0D	; 13
    15d2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    15d4:	00 00       	nop
    15d6:	c3 98       	cbi	0x18, 3	; 24
    15d8:	00 00       	nop
    15da:	c3 9a       	sbi	0x18, 3	; 24
    15dc:	01 97       	sbiw	r24, 0x01	; 1
    15de:	00 97       	sbiw	r24, 0x00	; 0
    15e0:	c9 f7       	brne	.-14     	; 0x15d4 <lcd_update+0x112>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    15e2:	84 81       	ldd	r24, Z+4	; 0x04
    15e4:	80 6c       	ori	r24, 0xC0	; 192
    15e6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    15e8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    15ea:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    15ec:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    15ee:	c3 9a       	sbi	0x18, 3	; 24
    15f0:	8d e0       	ldi	r24, 0x0D	; 13
    15f2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    15f4:	00 00       	nop
    15f6:	c3 98       	cbi	0x18, 3	; 24
    15f8:	00 00       	nop
    15fa:	c3 9a       	sbi	0x18, 3	; 24
    15fc:	01 97       	sbiw	r24, 0x01	; 1
    15fe:	00 97       	sbiw	r24, 0x00	; 0
    1600:	c9 f7       	brne	.-14     	; 0x15f4 <lcd_update+0x132>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1602:	85 81       	ldd	r24, Z+5	; 0x05
    1604:	80 6c       	ori	r24, 0xC0	; 192
    1606:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1608:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    160a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    160c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    160e:	c3 9a       	sbi	0x18, 3	; 24
    1610:	8d e0       	ldi	r24, 0x0D	; 13
    1612:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1614:	00 00       	nop
    1616:	c3 98       	cbi	0x18, 3	; 24
    1618:	00 00       	nop
    161a:	c3 9a       	sbi	0x18, 3	; 24
    161c:	01 97       	sbiw	r24, 0x01	; 1
    161e:	00 97       	sbiw	r24, 0x00	; 0
    1620:	c9 f7       	brne	.-14     	; 0x1614 <lcd_update+0x152>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1622:	86 81       	ldd	r24, Z+6	; 0x06
    1624:	80 6c       	ori	r24, 0xC0	; 192
    1626:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1628:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    162a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    162c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    162e:	c3 9a       	sbi	0x18, 3	; 24
    1630:	8d e0       	ldi	r24, 0x0D	; 13
    1632:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1634:	00 00       	nop
    1636:	c3 98       	cbi	0x18, 3	; 24
    1638:	00 00       	nop
    163a:	c3 9a       	sbi	0x18, 3	; 24
    163c:	01 97       	sbiw	r24, 0x01	; 1
    163e:	00 97       	sbiw	r24, 0x00	; 0
    1640:	c9 f7       	brne	.-14     	; 0x1634 <lcd_update+0x172>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1642:	87 81       	ldd	r24, Z+7	; 0x07
    1644:	80 6c       	ori	r24, 0xC0	; 192
    1646:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1648:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    164a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    164c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    164e:	c3 9a       	sbi	0x18, 3	; 24
    1650:	8d e0       	ldi	r24, 0x0D	; 13
    1652:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1654:	00 00       	nop
    1656:	c3 98       	cbi	0x18, 3	; 24
    1658:	00 00       	nop
    165a:	c3 9a       	sbi	0x18, 3	; 24
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	00 97       	sbiw	r24, 0x00	; 0
    1660:	c9 f7       	brne	.-14     	; 0x1654 <lcd_update+0x192>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1662:	80 85       	ldd	r24, Z+8	; 0x08
    1664:	80 6c       	ori	r24, 0xC0	; 192
    1666:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1668:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    166a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    166c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    166e:	c3 9a       	sbi	0x18, 3	; 24
    1670:	8d e0       	ldi	r24, 0x0D	; 13
    1672:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1674:	00 00       	nop
    1676:	c3 98       	cbi	0x18, 3	; 24
    1678:	00 00       	nop
    167a:	c3 9a       	sbi	0x18, 3	; 24
    167c:	01 97       	sbiw	r24, 0x01	; 1
    167e:	00 97       	sbiw	r24, 0x00	; 0
    1680:	c9 f7       	brne	.-14     	; 0x1674 <lcd_update+0x1b2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1682:	81 85       	ldd	r24, Z+9	; 0x09
    1684:	80 6c       	ori	r24, 0xC0	; 192
    1686:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1688:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    168a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    168c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    168e:	c3 9a       	sbi	0x18, 3	; 24
    1690:	8d e0       	ldi	r24, 0x0D	; 13
    1692:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1694:	00 00       	nop
    1696:	c3 98       	cbi	0x18, 3	; 24
    1698:	00 00       	nop
    169a:	c3 9a       	sbi	0x18, 3	; 24
    169c:	01 97       	sbiw	r24, 0x01	; 1
    169e:	00 97       	sbiw	r24, 0x00	; 0
    16a0:	c9 f7       	brne	.-14     	; 0x1694 <lcd_update+0x1d2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    16a2:	82 85       	ldd	r24, Z+10	; 0x0a
    16a4:	80 6c       	ori	r24, 0xC0	; 192
    16a6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    16a8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    16aa:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    16ac:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    16ae:	c3 9a       	sbi	0x18, 3	; 24
    16b0:	8d e0       	ldi	r24, 0x0D	; 13
    16b2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    16b4:	00 00       	nop
    16b6:	c3 98       	cbi	0x18, 3	; 24
    16b8:	00 00       	nop
    16ba:	c3 9a       	sbi	0x18, 3	; 24
    16bc:	01 97       	sbiw	r24, 0x01	; 1
    16be:	00 97       	sbiw	r24, 0x00	; 0
    16c0:	c9 f7       	brne	.-14     	; 0x16b4 <lcd_update+0x1f2>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    16c2:	83 85       	ldd	r24, Z+11	; 0x0b
    16c4:	80 6c       	ori	r24, 0xC0	; 192
    16c6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    16c8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    16ca:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    16cc:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    16ce:	c3 9a       	sbi	0x18, 3	; 24
    16d0:	8d e0       	ldi	r24, 0x0D	; 13
    16d2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    16d4:	00 00       	nop
    16d6:	c3 98       	cbi	0x18, 3	; 24
    16d8:	00 00       	nop
    16da:	c3 9a       	sbi	0x18, 3	; 24
    16dc:	01 97       	sbiw	r24, 0x01	; 1
    16de:	00 97       	sbiw	r24, 0x00	; 0
    16e0:	c9 f7       	brne	.-14     	; 0x16d4 <lcd_update+0x212>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    16e2:	84 85       	ldd	r24, Z+12	; 0x0c
    16e4:	80 6c       	ori	r24, 0xC0	; 192
    16e6:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    16e8:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    16ea:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    16ec:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    16ee:	c3 9a       	sbi	0x18, 3	; 24
    16f0:	8d e0       	ldi	r24, 0x0D	; 13
    16f2:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    16f4:	00 00       	nop
    16f6:	c3 98       	cbi	0x18, 3	; 24
    16f8:	00 00       	nop
    16fa:	c3 9a       	sbi	0x18, 3	; 24
    16fc:	01 97       	sbiw	r24, 0x01	; 1
    16fe:	00 97       	sbiw	r24, 0x00	; 0
    1700:	c9 f7       	brne	.-14     	; 0x16f4 <lcd_update+0x232>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1702:	85 85       	ldd	r24, Z+13	; 0x0d
    1704:	80 6c       	ori	r24, 0xC0	; 192
    1706:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1708:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    170a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    170c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    170e:	c3 9a       	sbi	0x18, 3	; 24
    1710:	8d e0       	ldi	r24, 0x0D	; 13
    1712:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1714:	00 00       	nop
    1716:	c3 98       	cbi	0x18, 3	; 24
    1718:	00 00       	nop
    171a:	c3 9a       	sbi	0x18, 3	; 24
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	00 97       	sbiw	r24, 0x00	; 0
    1720:	c9 f7       	brne	.-14     	; 0x1714 <lcd_update+0x252>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1722:	86 85       	ldd	r24, Z+14	; 0x0e
    1724:	80 6c       	ori	r24, 0xC0	; 192
    1726:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1728:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    172a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    172c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    172e:	c3 9a       	sbi	0x18, 3	; 24
    1730:	8d e0       	ldi	r24, 0x0D	; 13
    1732:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1734:	00 00       	nop
    1736:	c3 98       	cbi	0x18, 3	; 24
    1738:	00 00       	nop
    173a:	c3 9a       	sbi	0x18, 3	; 24
    173c:	01 97       	sbiw	r24, 0x01	; 1
    173e:	00 97       	sbiw	r24, 0x00	; 0
    1740:	c9 f7       	brne	.-14     	; 0x1734 <lcd_update+0x272>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1742:	87 85       	ldd	r24, Z+15	; 0x0f
    1744:	80 6c       	ori	r24, 0xC0	; 192
    1746:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1748:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    174a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    174c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    174e:	c3 9a       	sbi	0x18, 3	; 24
    1750:	8d e0       	ldi	r24, 0x0D	; 13
    1752:	90 e0       	ldi	r25, 0x00	; 0
	if(includeDelay)
	{
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
 //#error "Wait, we need delay_dots!"
		//One dot has been written, with clrpinPORT, above...
		delay_Dots(WRITE_COLOR_DOT_DELAY);
    1754:	00 00       	nop
    1756:	c3 98       	cbi	0x18, 3	; 24
    1758:	00 00       	nop
    175a:	c3 9a       	sbi	0x18, 3	; 24
    175c:	01 97       	sbiw	r24, 0x01	; 1
    175e:	00 97       	sbiw	r24, 0x00	; 0
    1760:	c9 f7       	brne	.-14     	; 0x1754 <lcd_update+0x292>
	//worry about masking:
//WTF... this looks right, order of inclusions in main.c... WTF.
//#if (defined(BUMP_SENSOR_PORT_ON_RGB_PORT) && BUMP_SENSOR_PORT_ON_RGB_PORT)
//#error "OK"
#if(defined(OTHER_BITS_HIGH) && OTHER_BITS_HIGH)
	RGB_PORT = colorVal | ((1<<7) | (1<<6));
    1762:	80 89       	ldd	r24, Z+16	; 0x10
    1764:	80 6c       	ori	r24, 0xC0	; 192
    1766:	8b bb       	out	0x1b, r24	; 27
#if (defined(LCDSTUFF_INCLUDE_NON_DE) && LCDSTUFF_INCLUDE_NON_DE)
	//THIS ASSUMES: F_CPU <= 16Mhz -> F_MCK <= 4MHz
	// This probably isn't particularly accurate...
	// e.g. it's 5 cycles, actually, since MCK and Data can't be written at
	// the same instruction (unless MCK was on the same port)
	asm("nop;");
    1768:	00 00       	nop
	clrpinPORT(MCK_PIN, MCK_PORT);
    176a:	c3 98       	cbi	0x18, 3	; 24
	asm("nop;");
    176c:	00 00       	nop
	setpinPORT(MCK_PIN, MCK_PORT);
    176e:	c3 9a       	sbi	0x18, 3	; 24
    1770:	80 e1       	ldi	r24, 0x10	; 16
    1772:	90 e0       	ldi	r25, 0x00	; 0
#else //LCDSTUFF_INCLUDE_NON_DE (Bitbanged MCK, usually)
 #define ROW_COMPLETION_DOTS \
		(DE_ACTIVE_DOTS - ((WRITE_COLOR_DOT_DELAY+1) * COLORS_WRITTEN))

 #if (ROW_COMPLETION_DOTS > 0)
		delay_Dots(ROW_COMPLETION_DOTS);
    1774:	00 00       	nop
    1776:	c3 98       	cbi	0x18, 3	; 24
    1778:	00 00       	nop
    177a:	c3 9a       	sbi	0x18, 3	; 24
    177c:	01 97       	sbiw	r24, 0x01	; 1
    177e:	00 97       	sbiw	r24, 0x00	; 0
    1780:	c9 f7       	brne	.-14     	; 0x1774 <lcd_update+0x2b2>
		// Setting this here indicates where the drawing has completed
		// This is handy for determining timing, stretching, etc...
		//OCR1D = 6; //0;
		//fullRed();
		// Now that we're using WHITE, use noRed instead
		noRed();
    1782:	8b b3       	in	r24, 0x1b	; 27
    1784:	8c 7f       	andi	r24, 0xFC	; 252
    1786:	8b bb       	out	0x1b, r24	; 27

		lvds_disableGreen_MakeClockInsensitiveToDT();

      //fullBlue();
      //Nada_fromDEonly();
		Nada_init();
    1788:	88 b3       	in	r24, 0x18	; 24
    178a:	80 63       	ori	r24, 0x30	; 48
    178c:	88 bb       	out	0x18, r24	; 24
    178e:	8b b3       	in	r24, 0x1b	; 27
    1790:	8f 7c       	andi	r24, 0xCF	; 207
    1792:	8b bb       	out	0x1b, r24	; 27
   }

   if(dataEnable)
    1794:	80 e1       	ldi	r24, 0x10	; 16
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	0a c0       	rjmp	.+20     	; 0x17ae <lcd_update+0x2ec>
    179a:	80 ef       	ldi	r24, 0xF0	; 240
    179c:	90 e0       	ldi	r25, 0x00	; 0
		// So, delay_Dots() (if it even exists in sdramThing?) wouldn't work,
		// because it wouldn't take into account page-boundaries, etc.
		
		// DE_DotDelay() Does NOT change the current *mode* (e.g. hsync/vsync
		// /DE/Nada...)
		DE_DotDelay(DE_ACTIVE_DOTS);
    179e:	00 00       	nop
    17a0:	c3 98       	cbi	0x18, 3	; 24
    17a2:	00 00       	nop
    17a4:	c3 9a       	sbi	0x18, 3	; 24
    17a6:	01 97       	sbiw	r24, 0x01	; 1
    17a8:	00 97       	sbiw	r24, 0x00	; 0
    17aa:	c9 f7       	brne	.-14     	; 0x179e <lcd_update+0x2dc>
    17ac:	f3 cf       	rjmp	.-26     	; 0x1794 <lcd_update+0x2d2>
	
	//delay_Dots(DH_DOTS);
  #ifdef DH_Delay
	DH_Delay();
  #else
	delay_Dots(DH_DOTS);
    17ae:	00 00       	nop
    17b0:	c3 98       	cbi	0x18, 3	; 24
    17b2:	00 00       	nop
    17b4:	c3 9a       	sbi	0x18, 3	; 24
    17b6:	01 97       	sbiw	r24, 0x01	; 1
    17b8:	00 97       	sbiw	r24, 0x00	; 0
    17ba:	c9 f7       	brne	.-14     	; 0x17ae <lcd_update+0x2ec>
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
//	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
	loadData(rowNum, dataEnable);

	hsyncCount++;
    17bc:	20 91 80 00 	lds	r18, 0x0080
    17c0:	30 91 81 00 	lds	r19, 0x0081
    17c4:	2f 5f       	subi	r18, 0xFF	; 255
    17c6:	3f 4f       	sbci	r19, 0xFF	; 255
    17c8:	30 93 81 00 	sts	0x0081, r19
    17cc:	20 93 80 00 	sts	0x0080, r18

	switch(hsyncCount)
    17d0:	24 32       	cpi	r18, 0x24	; 36
    17d2:	31 05       	cpc	r19, r1
    17d4:	d1 f0       	breq	.+52     	; 0x180a <lcd_update+0x348>
    17d6:	50 f4       	brcc	.+20     	; 0x17ec <lcd_update+0x32a>
    17d8:	24 31       	cpi	r18, 0x14	; 20
    17da:	31 05       	cpc	r19, r1
    17dc:	e9 f4       	brne	.+58     	; 0x1818 <lcd_update+0x356>
	{
		//V Front Porch, begins with initLCD

		//Vsync H->L (Begin V-Sync)
		case T_DV:
			dataEnable = FALSE;
    17de:	10 92 83 00 	sts	0x0083, r1
			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = TRUE;
    17e2:	81 e0       	ldi	r24, 0x01	; 1
    17e4:	80 93 82 00 	sts	0x0082, r24
			Vsync_fromNada();
    17e8:	c5 98       	cbi	0x18, 5	; 24
			break;
    17ea:	16 c0       	rjmp	.+44     	; 0x1818 <lcd_update+0x356>
//	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
	loadData(rowNum, dataEnable);

	hsyncCount++;

	switch(hsyncCount)
    17ec:	28 32       	cpi	r18, 0x28	; 40
    17ee:	31 05       	cpc	r19, r1
    17f0:	81 f0       	breq	.+32     	; 0x1812 <lcd_update+0x350>
    17f2:	28 3c       	cpi	r18, 0xC8	; 200
    17f4:	31 05       	cpc	r19, r1
    17f6:	81 f4       	brne	.+32     	; 0x1818 <lcd_update+0x356>
			dataEnable = TRUE;
			break;
		// All rows have been displayed
		// Return to V Front Porch
		case V_COUNT +(T_VD + T_Vlow + T_DV):
			dataEnable = FALSE;
    17f8:	10 92 83 00 	sts	0x0083, r1
		//	break;
		//Frame complete
		//case HSYNC_COUNT_FRAME_COMPLETE:
			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
			hsyncCount = 0;
    17fc:	10 92 81 00 	sts	0x0081, r1
    1800:	10 92 80 00 	sts	0x0080, r1
#endif
			
//#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
// Yeah, guess that makes sense... Must be Nada...
			//frameComplete = TRUE;
			rowNum = LCD_FRAMECOMPLETE;
    1804:	cf ef       	ldi	r28, 0xFF	; 255
    1806:	df e7       	ldi	r29, 0x7F	; 127
			break;
    1808:	07 c0       	rjmp	.+14     	; 0x1818 <lcd_update+0x356>
		//	if(hfm_nextOutput(&modulator))
		//		colorOverride = 0xff;
		//	else
		//		colorOverride = 7;
			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = FALSE;
    180a:	10 92 82 00 	sts	0x0082, r1
			Nada_fromVsync();
    180e:	c5 9a       	sbi	0x18, 5	; 24
			break;
    1810:	03 c0       	rjmp	.+6      	; 0x1818 <lcd_update+0x356>
		//Start of frame (DE active)
		case T_VD +(T_Vlow + T_DV):
			dataEnable = TRUE;
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	80 93 83 00 	sts	0x0083, r24
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...

	return rowNum; //frameComplete;
}
    1818:	ce 01       	movw	r24, r28
    181a:	df 91       	pop	r29
    181c:	cf 91       	pop	r28
    181e:	08 95       	ret

00001820 <restartFrameUpdate>:
 volatile uint8_t frameCount = 0;


 void restartFrameUpdate(void)
 {
	updateFrame = FB_REFRESH_ON_CHANGE_COUNT;
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	80 93 65 00 	sts	0x0065, r24
	//FOR NOW: Assuming we're using a 16MHz system-clock
	// The dot-clock is supposed to be <= 4.2MHz, so let's go for 4MHz
	//
	// 16MHz/4MHz = 4
	// So set the timer to count from 0 to 3 and reset
	OCR1C = 3;
    1826:	93 e0       	ldi	r25, 0x03	; 3
    1828:	9b bd       	out	0x2b, r25	; 43
	// (except for OCRVal == 0)
	// so an OCR-value of 1 causes:
	// TCNT    0   1   2   3   0 ....
	//      ___         _______
	//         |_______|       |___
	MCK_OCR = 1;
    182a:	8c bd       	out	0x2c, r24	; 44

	//Set the Timer1 clock prescaler... (No prescaler == /1)
	writeMasked((1<<CS10),
    182c:	8f b5       	in	r24, 0x2f	; 47
    182e:	80 7f       	andi	r24, 0xF0	; 240
    1830:	81 60       	ori	r24, 0x01	; 1
    1832:	8f bd       	out	0x2f, r24	; 47
			            ((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)),
							            TCCR1B);
	//Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
	// Allegedly this is prescaled from the PCK (or CK)
	//    NOT from the Timer1 prescaler...
	writeMasked(0,
    1834:	8f b5       	in	r24, 0x2f	; 47
    1836:	8f 7c       	andi	r24, 0xCF	; 207
    1838:	8f bd       	out	0x2f, r24	; 47
			            ((1<<DTPS11) | (1<<DTPS10)),
							            TCCR1B);


	writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
    183a:	86 b5       	in	r24, 0x26	; 38
    183c:	8c 7f       	andi	r24, 0xFC	; 252
    183e:	86 bd       	out	0x26, r24	; 38
	            ((1<<WGM11) | (1<<WGM10)), // (affects all PWM channels)
	            TCCR1D);

	//Forgot this... it was enableGreenMakeClockInsensitive-ish
	// from lvds.c
	writeMasked((onOff<<COM1B1) | (0<<COM1B0),
    1840:	80 b7       	in	r24, 0x30	; 48
    1842:	8f 7c       	andi	r24, 0xCF	; 207
    1844:	80 bf       	out	0x30, r24	; 48
					(1<<COM1B1) | (1<<COM1B0),
					TCCR1A);
	
		
	writebit(PWM1B, TCCR1A, onOff);  //Enable PWM on OC1B for CLOCK
    1846:	80 b7       	in	r24, 0x30	; 48
    1848:	8e 7f       	andi	r24, 0xFE	; 254
    184a:	80 bf       	out	0x30, r24	; 48
    184c:	08 95       	ret

0000184e <frameBufferUpdate>:
//      static uint8_t lastUpdated = FALSE;
      static fb_timer_t fbLastUpdateTime = 0;

      //Because the dmsTimer is running somewhat arbitarily, this "200ms"
      // isn't particularly accurate...
      if(updateFrame)
    184e:	80 91 65 00 	lds	r24, 0x0065
    1852:	88 23       	and	r24, r24
    1854:	51 f0       	breq	.+20     	; 0x186a <frameBufferUpdate+0x1c>
		{
         fbLastUpdateTime = fb_getTime();
    1856:	74 da       	rcall	.-2840   	; 0xd40 <tcnter_get>
    1858:	60 93 8a 00 	sts	0x008A, r22
    185c:	70 93 8b 00 	sts	0x008B, r23
    1860:	80 93 8c 00 	sts	0x008C, r24
    1864:	90 93 8d 00 	sts	0x008D, r25
			return;
    1868:	08 95       	ret

static __inline__
uint8_t tcnter_isItTimeV2(tcnter_t *startTime, tcnter_t deltaTime,
										uint8_t dontAllowCumulation)
{
   tcnter_t thisDelta = tcnter_myTcnter - *startTime;
    186a:	80 91 7b 00 	lds	r24, 0x007B
    186e:	90 91 7c 00 	lds	r25, 0x007C
    1872:	a0 91 7d 00 	lds	r26, 0x007D
    1876:	b0 91 7e 00 	lds	r27, 0x007E
    187a:	40 91 8a 00 	lds	r20, 0x008A
    187e:	50 91 8b 00 	lds	r21, 0x008B
    1882:	60 91 8c 00 	lds	r22, 0x008C
    1886:	70 91 8d 00 	lds	r23, 0x008D
    188a:	84 1b       	sub	r24, r20
    188c:	95 0b       	sbc	r25, r21
    188e:	a6 0b       	sbc	r26, r22
    1890:	b7 0b       	sbc	r27, r23

   if(thisDelta >= deltaTime)
    1892:	80 34       	cpi	r24, 0x40	; 64
    1894:	9d 40       	sbci	r25, 0x0D	; 13
    1896:	a3 40       	sbci	r26, 0x03	; 3
    1898:	b1 05       	cpc	r27, r1
    189a:	a0 f0       	brcs	.+40     	; 0x18c4 <frameBufferUpdate+0x76>
   {
		if(dontAllowCumulation)
      	*startTime = tcnter_myTcnter - (thisDelta - deltaTime);
      else
			*startTime = tcnter_myTcnter;
    189c:	80 91 7b 00 	lds	r24, 0x007B
    18a0:	90 91 7c 00 	lds	r25, 0x007C
    18a4:	a0 91 7d 00 	lds	r26, 0x007D
    18a8:	b0 91 7e 00 	lds	r27, 0x007E
    18ac:	80 93 8a 00 	sts	0x008A, r24
    18b0:	90 93 8b 00 	sts	0x008B, r25
    18b4:	a0 93 8c 00 	sts	0x008C, r26
    18b8:	b0 93 8d 00 	sts	0x008D, r27
		// (a/o v71 this has changed, it was in an else, and this else-case
		// handled multiple-refresh. That should now be handled in
		// endOfFrameHandler())
      if(fb_isItTime(&fbLastUpdateTime, FB_REFRESH_ON_CHANGE_DELAY))
      {
			int16_t fb_changedTillRow = fb_updater();
    18bc:	3c dd       	rcall	.-1416   	; 0x1336 <fbQuestion_update>
			//call fb_updater()
			// and ONLY REFRESH if there's been a change to the frameBuffer
      	if(fb_changedTillRow != -1)
    18be:	8f 3f       	cpi	r24, 0xFF	; 255
    18c0:	09 f0       	breq	.+2      	; 0x18c4 <frameBufferUpdate+0x76>
				extern uint16_t stopRefreshAtRow;
				//This must be +1 to account for the length of the last pixel
				// possibly 2 to help clear out ghosting
				stopRefreshAtRow = (fb_changedTillRow+2) * V_COUNT / FB_HEIGHT;	
#endif
				restartFrameUpdate();
    18c2:	ae cf       	rjmp	.-164    	; 0x1820 <restartFrameUpdate>
    18c4:	08 95       	ret

000018c6 <__vector_14>:
 //Nearly everything display-related happens in this interrupt
 // It even calls the functions that load (and calculate!) the data for the
 // next row.
 // So basically, the entire project is running via timer-interrupt.
 SIGNAL(HSYNC_TIMER_INTERRUPT_VECT) //TIMER0_COMPA_vect)
 {
    18c6:	1f 92       	push	r1
    18c8:	0f 92       	push	r0
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	0f 92       	push	r0
    18ce:	11 24       	eor	r1, r1
    18d0:	2f 93       	push	r18
    18d2:	3f 93       	push	r19
    18d4:	4f 93       	push	r20
    18d6:	5f 93       	push	r21
    18d8:	6f 93       	push	r22
    18da:	7f 93       	push	r23
    18dc:	8f 93       	push	r24
    18de:	9f 93       	push	r25
    18e0:	af 93       	push	r26
    18e2:	bf 93       	push	r27
    18e4:	ef 93       	push	r30
    18e6:	ff 93       	push	r31
		// we need to do it manually...
		// (because the tcnter uses the hsyncTimer)
#if(!defined(HEART_TCNTER_UPDATES_AND_INIT) || \
		!HEART_TCNTER_UPDATES_AND_INIT)
#if(defined(_HEART_TCNTER_) && _HEART_TCNTER_)
	 tcnter_overflowUpdate();
    18e8:	5d d9       	rcall	.-3398   	; 0xba4 <tcnter_overflowUpdate>
#endif
#endif

	 if(!updateFrame)
    18ea:	80 91 65 00 	lds	r24, 0x0065
    18ee:	88 23       	and	r24, r24
    18f0:	59 f1       	breq	.+86     	; 0x1948 <__vector_14+0x82>
	// Vblank rows)
	// H-Front-Porch is handled in the time between completion of this
	// interrupt and the next interrupt...


	int16_t rowNum = lcd_update();
    18f2:	e7 dd       	rcall	.-1074   	; 0x14c2 <lcd_update>

	if(rowNum == LCD_FRAMECOMPLETE)
    18f4:	8f 3f       	cpi	r24, 0xFF	; 255
    18f6:	9f 47       	sbci	r25, 0x7F	; 127
    18f8:	39 f5       	brne	.+78     	; 0x1948 <__vector_14+0x82>
	{
		frameCount++;
    18fa:	80 91 7f 00 	lds	r24, 0x007F
    18fe:	8f 5f       	subi	r24, 0xFF	; 255
    1900:	80 93 7f 00 	sts	0x007F, r24
// This is revisited from _unusedIdeas/frameCountToDelay.c
void endOfFrameHandler(void)
{
	//The original plan was to stop the timer, but now that is used by
	//dmsTimer... so instead:
	if(updateFrame)
    1904:	80 91 65 00 	lds	r24, 0x0065
    1908:	88 23       	and	r24, r24
    190a:	29 f0       	breq	.+10     	; 0x1916 <__vector_14+0x50>
		updateFrame--; //= FALSE;
    190c:	80 91 65 00 	lds	r24, 0x0065
    1910:	81 50       	subi	r24, 0x01	; 1
    1912:	80 93 65 00 	sts	0x0065, r24

	//The sony display seems to dislike not having a dot-clock...
	// This is an experiment...
  #if (defined(LCDINTERFACE_BITBANGED_DOTCLOCK_PWM) && \
		  LCDINTERFACE_BITBANGED_DOTCLOCK_PWM)
	if(!updateFrame)
    1916:	80 91 65 00 	lds	r24, 0x0065
    191a:	81 11       	cpse	r24, r1
    191c:	15 c0       	rjmp	.+42     	; 0x1948 <__vector_14+0x82>
	//FOR NOW: Assuming we're using a 16MHz system-clock
	// The dot-clock is supposed to be <= 4.2MHz, so let's go for 4MHz
	//
	// 16MHz/4MHz = 4
	// So set the timer to count from 0 to 3 and reset
	OCR1C = 3;
    191e:	83 e0       	ldi	r24, 0x03	; 3
    1920:	8b bd       	out	0x2b, r24	; 43
	// (except for OCRVal == 0)
	// so an OCR-value of 1 causes:
	// TCNT    0   1   2   3   0 ....
	//      ___         _______
	//         |_______|       |___
	MCK_OCR = 1;
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	8c bd       	out	0x2c, r24	; 44

	//Set the Timer1 clock prescaler... (No prescaler == /1)
	writeMasked((1<<CS10),
    1926:	8f b5       	in	r24, 0x2f	; 47
    1928:	80 7f       	andi	r24, 0xF0	; 240
    192a:	81 60       	ori	r24, 0x01	; 1
    192c:	8f bd       	out	0x2f, r24	; 47
			            ((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)),
							            TCCR1B);
	//Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
	// Allegedly this is prescaled from the PCK (or CK)
	//    NOT from the Timer1 prescaler...
	writeMasked(0,
    192e:	8f b5       	in	r24, 0x2f	; 47
    1930:	8f 7c       	andi	r24, 0xCF	; 207
    1932:	8f bd       	out	0x2f, r24	; 47
			            ((1<<DTPS11) | (1<<DTPS10)),
							            TCCR1B);


	writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
    1934:	86 b5       	in	r24, 0x26	; 38
    1936:	8c 7f       	andi	r24, 0xFC	; 252
    1938:	86 bd       	out	0x26, r24	; 38
	            ((1<<WGM11) | (1<<WGM10)), // (affects all PWM channels)
	            TCCR1D);

	//Forgot this... it was enableGreenMakeClockInsensitive-ish
	// from lvds.c
	writeMasked((onOff<<COM1B1) | (0<<COM1B0),
    193a:	80 b7       	in	r24, 0x30	; 48
    193c:	8f 7c       	andi	r24, 0xCF	; 207
    193e:	80 62       	ori	r24, 0x20	; 32
    1940:	80 bf       	out	0x30, r24	; 48
					(1<<COM1B1) | (1<<COM1B0),
					TCCR1A);
	
		
	writebit(PWM1B, TCCR1A, onOff);  //Enable PWM on OC1B for CLOCK
    1942:	80 b7       	in	r24, 0x30	; 48
    1944:	81 60       	ori	r24, 0x01	; 1
    1946:	80 bf       	out	0x30, r24	; 48


	//THIS IS A HACK
	//tcnter_update();

 }
    1948:	ff 91       	pop	r31
    194a:	ef 91       	pop	r30
    194c:	bf 91       	pop	r27
    194e:	af 91       	pop	r26
    1950:	9f 91       	pop	r25
    1952:	8f 91       	pop	r24
    1954:	7f 91       	pop	r23
    1956:	6f 91       	pop	r22
    1958:	5f 91       	pop	r21
    195a:	4f 91       	pop	r20
    195c:	3f 91       	pop	r19
    195e:	2f 91       	pop	r18
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63
    1964:	0f 90       	pop	r0
    1966:	1f 90       	pop	r1
    1968:	18 95       	reti

0000196a <init_hsyncTimer>:
//Testing with values returned by hsyncTimerCalculator
//#define HSYNC_TIMER_OCRVAL	65

void init_hsyncTimer(void)
{
   HSYNC_TIMER_OCR = HSYNC_TIMER_OCRVAL; 
    196a:	87 e8       	ldi	r24, 0x87	; 135
    196c:	83 bb       	out	0x13, r24	; 19
							//T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
   timer_setWGM(HSYNC_TIMER_NUM, WGM_CLR_ON_COMPARE);
    196e:	62 e0       	ldi	r22, 0x02	; 2
    1970:	80 e0       	ldi	r24, 0x00	; 0
    1972:	5c d7       	rcall	.+3768   	; 0x282c <__data_load_end+0xd44>
   timer_selectDivisor(HSYNC_TIMER_NUM, HSYNC_TIMER_CLKDIV); //CLKDIV1);
    1974:	63 e0       	ldi	r22, 0x03	; 3
    1976:	80 e0       	ldi	r24, 0x00	; 0
    1978:	34 d7       	rcall	.+3688   	; 0x27e2 <__data_load_end+0xcfa>
   timer_compareMatchIntEnable(HSYNC_TIMER_NUM, OUT_CHANNELA);
    197a:	41 e0       	ldi	r20, 0x01	; 1
    197c:	60 e0       	ldi	r22, 0x00	; 0
    197e:	80 e0       	ldi	r24, 0x00	; 0
    1980:	88 c7       	rjmp	.+3856   	; 0x2892 <__data_load_end+0xdaa>

00001982 <isNewFrame>:
{
	uint8_t newFrame = FALSE;

	static uint8_t lastFrameCount = 0;
#define FRAME_COUNT_LIMIT 0x03
	uint8_t thisFrameCount = frameCount&FRAME_COUNT_LIMIT;
    1982:	90 91 7f 00 	lds	r25, 0x007F
    1986:	93 70       	andi	r25, 0x03	; 3

//		if(( (thisFrameCount==0) && (lastFrameCount==FRAME_COUNT_LIMIT) ))
	if(thisFrameCount != lastFrameCount)
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	20 91 88 00 	lds	r18, 0x0088
    198e:	92 13       	cpse	r25, r18
    1990:	01 c0       	rjmp	.+2      	; 0x1994 <isNewFrame+0x12>
    1992:	80 e0       	ldi	r24, 0x00	; 0
		newFrame = TRUE;

	lastFrameCount = thisFrameCount;
    1994:	90 93 88 00 	sts	0x0088, r25

	return newFrame;
}
    1998:	08 95       	ret

0000199a <main>:
{
// a/o FB_TETRIS, testing...
	//WTF... this ain't showin' up when FB_WIDTH=24...?!

#if(defined(FRAMEBUFFER_TESTING) && FRAMEBUFFER_TESTING)
	frameBufferInit();
    199a:	1e da       	rcall	.-3012   	; 0xdd8 <frameBufferInit>
    199c:	20 eb       	ldi	r18, 0xB0	; 176
    199e:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t i, j;
	for(i=0; i<FB_HEIGHT; i++)
    19a0:	40 e0       	ldi	r20, 0x00	; 0
#if(defined(TEST__FLASH) && TEST__FLASH)
 #include "test__flash.c"
#endif

int main(void)
{
    19a2:	80 e0       	ldi	r24, 0x00	; 0
    19a4:	90 e0       	ldi	r25, 0x00	; 0
    19a6:	f9 01       	movw	r30, r18
    19a8:	e8 0f       	add	r30, r24
    19aa:	f9 1f       	adc	r31, r25
    19ac:	54 2f       	mov	r21, r20
    19ae:	58 0f       	add	r21, r24
#if(defined(FRAMEBUFFER_TESTING) && FRAMEBUFFER_TESTING)
	frameBufferInit();
	uint8_t i, j;
	for(i=0; i<FB_HEIGHT; i++)
		for(j=0; j<FB_WIDTH; j++)
			frameBuffer[i][j] = i+j;
    19b0:	50 83       	st	Z, r21
    19b2:	01 96       	adiw	r24, 0x01	; 1

#if(defined(FRAMEBUFFER_TESTING) && FRAMEBUFFER_TESTING)
	frameBufferInit();
	uint8_t i, j;
	for(i=0; i<FB_HEIGHT; i++)
		for(j=0; j<FB_WIDTH; j++)
    19b4:	80 31       	cpi	r24, 0x10	; 16
    19b6:	91 05       	cpc	r25, r1
    19b8:	b1 f7       	brne	.-20     	; 0x19a6 <main+0xc>
	//WTF... this ain't showin' up when FB_WIDTH=24...?!

#if(defined(FRAMEBUFFER_TESTING) && FRAMEBUFFER_TESTING)
	frameBufferInit();
	uint8_t i, j;
	for(i=0; i<FB_HEIGHT; i++)
    19ba:	4f 5f       	subi	r20, 0xFF	; 255
    19bc:	2f 5e       	subi	r18, 0xEF	; 239
    19be:	3f 4f       	sbci	r19, 0xFF	; 255
    19c0:	40 31       	cpi	r20, 0x10	; 16
    19c2:	79 f7       	brne	.-34     	; 0x19a2 <main+0x8>
#endif



#if(!defined(PWM_TESTING) || !PWM_TESTING)
	init_hsyncTimer();
    19c4:	d2 df       	rcall	.-92     	; 0x196a <init_hsyncTimer>
#endif

	//This starts pretty late... watch out for WDT
	init_heartBeat();
    19c6:	d9 d7       	rcall	.+4018   	; 0x297a <__data_load_end+0xe92>

	setHeartRate(0);
    19c8:	80 e0       	ldi	r24, 0x00	; 0
    19ca:	af d7       	rcall	.+3934   	; 0x292a <__data_load_end+0xe42>
  #else
	#warning "LCDSTUFF_INCLUDE_NON_DE has been used to indicate that we're	bit-banging MCK... MOST refrences to this should be changed to something like BITBANGED_MCK"
  #endif //NOT: LCDSTUFF_INCLUDE_NON_DE (e.g. use PWM for MCK)
 //Otherwise we're bit-banging MCK

	setoutPORT(MCK_PIN, MCK_PORT); //+OC1B Clock (OC1B, not inverted)
    19cc:	bb 9a       	sbi	0x17, 3	; 23

	//Set the other pins as outputs, as well...
	setoutPORT(HSYNC_PIN, HSYNC_PORT);
    19ce:	bc 9a       	sbi	0x17, 4	; 23
	setoutPORT(VSYNC_PIN, VSYNC_PORT);
    19d0:	bd 9a       	sbi	0x17, 5	; 23
	setoutPORT(SD_PIN, SD_PORT);
    19d2:	be 9a       	sbi	0x17, 6	; 23

	setPORToutMasked(RGB_PORT, (RED_MASK | GREEN_MASK | BLUE_MASK));
    19d4:	8a b3       	in	r24, 0x1a	; 26
    19d6:	8f 63       	ori	r24, 0x3F	; 63
    19d8:	8a bb       	out	0x1a, r24	; 26

#warning "The ShutDown pin is completely unimplemented, but for now it seems to work..."
	setpinPORT(SD_PIN, SD_PORT);
    19da:	c6 9a       	sbi	0x18, 6	; 24



	Nada_init();
    19dc:	88 b3       	in	r24, 0x18	; 24
    19de:	80 63       	ori	r24, 0x30	; 48
    19e0:	88 bb       	out	0x18, r24	; 24
    19e2:	8b b3       	in	r24, 0x1b	; 27
    19e4:	8f 7c       	andi	r24, 0xCF	; 207
    19e6:	8b bb       	out	0x1b, r24	; 27
	noGreen();
    19e8:	8b b3       	in	r24, 0x1b	; 27
    19ea:	83 7f       	andi	r24, 0xF3	; 243
    19ec:	8b bb       	out	0x1b, r24	; 27
	noRed();
    19ee:	8b b3       	in	r24, 0x1b	; 27
    19f0:	8c 7f       	andi	r24, 0xFC	; 252
    19f2:	8b bb       	out	0x1b, r24	; 27
	lvds_timerInit();


#if (defined(FB_QUESTION) && FB_QUESTION)
 #if (defined(BUMP_SWITCH) && BUMP_SWITCH)
	hitSensor_init();
    19f4:	c0 d9       	rcall	.-3200   	; 0xd76 <hitSensor_init>
#endif

//#if( (defined(FB_QUESTION) && FB_QUESTION) 
//	  ||	(defined(FB_SMILEY) && FB_SMILEY) )
#if( defined(FRAMEBUFFER_TESTING) && (FRAMEBUFFER_TESTING))
		frameBufferUpdate();
    19f6:	2b df       	rcall	.-426    	; 0x184e <frameBufferUpdate>
#endif

		heartUpdate();
    19f8:	d7 d7       	rcall	.+4014   	; 0x29a8 <__data_load_end+0xec0>
    19fa:	fd cf       	rjmp	.-6      	; 0x19f6 <main+0x5c>

000019fc <__mulqi3>:
    19fc:	00 24       	eor	r0, r0

000019fe <__mulqi3_loop>:
    19fe:	80 fd       	sbrc	r24, 0
    1a00:	06 0e       	add	r0, r22
    1a02:	66 0f       	add	r22, r22
    1a04:	11 f0       	breq	.+4      	; 0x1a0a <__mulqi3_exit>
    1a06:	86 95       	lsr	r24
    1a08:	d1 f7       	brne	.-12     	; 0x19fe <__mulqi3_loop>

00001a0a <__mulqi3_exit>:
    1a0a:	80 2d       	mov	r24, r0
    1a0c:	08 95       	ret

00001a0e <__mulhi3>:
    1a0e:	00 24       	eor	r0, r0
    1a10:	55 27       	eor	r21, r21
    1a12:	04 c0       	rjmp	.+8      	; 0x1a1c <__mulhi3+0xe>
    1a14:	08 0e       	add	r0, r24
    1a16:	59 1f       	adc	r21, r25
    1a18:	88 0f       	add	r24, r24
    1a1a:	99 1f       	adc	r25, r25
    1a1c:	00 97       	sbiw	r24, 0x00	; 0
    1a1e:	29 f0       	breq	.+10     	; 0x1a2a <__mulhi3+0x1c>
    1a20:	76 95       	lsr	r23
    1a22:	67 95       	ror	r22
    1a24:	b8 f3       	brcs	.-18     	; 0x1a14 <__mulhi3+0x6>
    1a26:	71 05       	cpc	r23, r1
    1a28:	b9 f7       	brne	.-18     	; 0x1a18 <__mulhi3+0xa>
    1a2a:	80 2d       	mov	r24, r0
    1a2c:	95 2f       	mov	r25, r21
    1a2e:	08 95       	ret

00001a30 <__udivmodqi4>:
    1a30:	99 1b       	sub	r25, r25
    1a32:	79 e0       	ldi	r23, 0x09	; 9
    1a34:	04 c0       	rjmp	.+8      	; 0x1a3e <__udivmodqi4_ep>

00001a36 <__udivmodqi4_loop>:
    1a36:	99 1f       	adc	r25, r25
    1a38:	96 17       	cp	r25, r22
    1a3a:	08 f0       	brcs	.+2      	; 0x1a3e <__udivmodqi4_ep>
    1a3c:	96 1b       	sub	r25, r22

00001a3e <__udivmodqi4_ep>:
    1a3e:	88 1f       	adc	r24, r24
    1a40:	7a 95       	dec	r23
    1a42:	c9 f7       	brne	.-14     	; 0x1a36 <__udivmodqi4_loop>
    1a44:	80 95       	com	r24
    1a46:	08 95       	ret

00001a48 <__udivmodhi4>:
    1a48:	aa 1b       	sub	r26, r26
    1a4a:	bb 1b       	sub	r27, r27
    1a4c:	51 e1       	ldi	r21, 0x11	; 17
    1a4e:	07 c0       	rjmp	.+14     	; 0x1a5e <__udivmodhi4_ep>

00001a50 <__udivmodhi4_loop>:
    1a50:	aa 1f       	adc	r26, r26
    1a52:	bb 1f       	adc	r27, r27
    1a54:	a6 17       	cp	r26, r22
    1a56:	b7 07       	cpc	r27, r23
    1a58:	10 f0       	brcs	.+4      	; 0x1a5e <__udivmodhi4_ep>
    1a5a:	a6 1b       	sub	r26, r22
    1a5c:	b7 0b       	sbc	r27, r23

00001a5e <__udivmodhi4_ep>:
    1a5e:	88 1f       	adc	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	5a 95       	dec	r21
    1a64:	a9 f7       	brne	.-22     	; 0x1a50 <__udivmodhi4_loop>
    1a66:	80 95       	com	r24
    1a68:	90 95       	com	r25
    1a6a:	bc 01       	movw	r22, r24
    1a6c:	cd 01       	movw	r24, r26
    1a6e:	08 95       	ret

00001a70 <__divmodhi4>:
    1a70:	97 fb       	bst	r25, 7
    1a72:	07 2e       	mov	r0, r23
    1a74:	16 f4       	brtc	.+4      	; 0x1a7a <__divmodhi4+0xa>
    1a76:	00 94       	com	r0
    1a78:	06 d0       	rcall	.+12     	; 0x1a86 <__divmodhi4_neg1>
    1a7a:	77 fd       	sbrc	r23, 7
    1a7c:	08 d0       	rcall	.+16     	; 0x1a8e <__divmodhi4_neg2>
    1a7e:	e4 df       	rcall	.-56     	; 0x1a48 <__udivmodhi4>
    1a80:	07 fc       	sbrc	r0, 7
    1a82:	05 d0       	rcall	.+10     	; 0x1a8e <__divmodhi4_neg2>
    1a84:	3e f4       	brtc	.+14     	; 0x1a94 <__divmodhi4_exit>

00001a86 <__divmodhi4_neg1>:
    1a86:	90 95       	com	r25
    1a88:	81 95       	neg	r24
    1a8a:	9f 4f       	sbci	r25, 0xFF	; 255
    1a8c:	08 95       	ret

00001a8e <__divmodhi4_neg2>:
    1a8e:	70 95       	com	r23
    1a90:	61 95       	neg	r22
    1a92:	7f 4f       	sbci	r23, 0xFF	; 255

00001a94 <__divmodhi4_exit>:
    1a94:	08 95       	ret

00001a96 <__udivmodsi4>:
    1a96:	a1 e2       	ldi	r26, 0x21	; 33
    1a98:	1a 2e       	mov	r1, r26
    1a9a:	aa 1b       	sub	r26, r26
    1a9c:	bb 1b       	sub	r27, r27
    1a9e:	fd 01       	movw	r30, r26
    1aa0:	0d c0       	rjmp	.+26     	; 0x1abc <__udivmodsi4_ep>

00001aa2 <__udivmodsi4_loop>:
    1aa2:	aa 1f       	adc	r26, r26
    1aa4:	bb 1f       	adc	r27, r27
    1aa6:	ee 1f       	adc	r30, r30
    1aa8:	ff 1f       	adc	r31, r31
    1aaa:	a2 17       	cp	r26, r18
    1aac:	b3 07       	cpc	r27, r19
    1aae:	e4 07       	cpc	r30, r20
    1ab0:	f5 07       	cpc	r31, r21
    1ab2:	20 f0       	brcs	.+8      	; 0x1abc <__udivmodsi4_ep>
    1ab4:	a2 1b       	sub	r26, r18
    1ab6:	b3 0b       	sbc	r27, r19
    1ab8:	e4 0b       	sbc	r30, r20
    1aba:	f5 0b       	sbc	r31, r21

00001abc <__udivmodsi4_ep>:
    1abc:	66 1f       	adc	r22, r22
    1abe:	77 1f       	adc	r23, r23
    1ac0:	88 1f       	adc	r24, r24
    1ac2:	99 1f       	adc	r25, r25
    1ac4:	1a 94       	dec	r1
    1ac6:	69 f7       	brne	.-38     	; 0x1aa2 <__udivmodsi4_loop>
    1ac8:	60 95       	com	r22
    1aca:	70 95       	com	r23
    1acc:	80 95       	com	r24
    1ace:	90 95       	com	r25
    1ad0:	9b 01       	movw	r18, r22
    1ad2:	ac 01       	movw	r20, r24
    1ad4:	bd 01       	movw	r22, r26
    1ad6:	cf 01       	movw	r24, r30
    1ad8:	08 95       	ret

00001ada <_exit>:
    1ada:	f8 94       	cli

00001adc <__stop_program>:
    1adc:	ff cf       	rjmp	.-2      	; 0x1adc <__stop_program>
