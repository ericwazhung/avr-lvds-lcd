
_BUILD/LCDdirectLVDS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  0000187a  0000190e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000187a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000012e  00800106  00800106  00001914  2**0
                  ALLOC
  3 .stab         00005e14  00000000  00000000  00001914  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000021e0  00000000  00000000  00007728  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00009908  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000064e  00000000  00000000  00009919  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005f7  00000000  00000000  00009f67  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001d  00000000  00000000  0000a55e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000023d  00000000  00000000  0000a57b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 03 	jmp	0x676	; 0x676 <__ctors_end>
       4:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
       8:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
       c:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      10:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      14:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      18:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      1c:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      20:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      24:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      28:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      2c:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__vector_11>
      30:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      34:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      38:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      3c:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      40:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      44:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      48:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>
      4c:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__bad_interrupt>

00000050 <__trampolines_end>:
      50:	00 00       	nop
      52:	92 01       	movw	r18, r4
      54:	24 03       	mulsu	r18, r20
      56:	b6 04       	cpc	r11, r6
      58:	48 06       	cpc	r4, r24
      5a:	d9 07       	cpc	r29, r25
      5c:	6a 09       	sbc	r22, r10
      5e:	fb 0a       	sbc	r15, r27
      60:	8c 0c       	add	r8, r12
      62:	1c 0e       	add	r1, r28
      64:	ab 0f       	add	r26, r27
      66:	3a 11       	cpse	r19, r10
      68:	c8 12       	cpse	r12, r24
      6a:	55 14       	cp	r5, r5
      6c:	e2 15       	cp	r30, r2
      6e:	6e 17       	cp	r22, r30
      70:	f9 18       	sub	r15, r9
      72:	82 1a       	sub	r8, r18
      74:	0b 1c       	adc	r0, r11
      76:	93 1d       	adc	r25, r3
      78:	1a 1f       	adc	r17, r26
      7a:	9f 20       	and	r9, r15
      7c:	23 22       	and	r2, r19
      7e:	a6 23       	and	r26, r22
      80:	28 25       	eor	r18, r8
      82:	a8 26       	eor	r10, r24
      84:	26 28       	or	r2, r6
      86:	a3 29       	or	r26, r3
      88:	1f 2b       	or	r17, r31
      8a:	99 2c       	mov	r9, r9
      8c:	11 2e       	mov	r1, r17
      8e:	87 2f       	mov	r24, r23
      90:	fb 30       	cpi	r31, 0x0B	; 11
      92:	6e 32       	cpi	r22, 0x2E	; 46
      94:	df 33       	cpi	r29, 0x3F	; 63
      96:	4d 35       	cpi	r20, 0x5D	; 93
      98:	ba 36       	cpi	r27, 0x6A	; 106
      9a:	24 38       	cpi	r18, 0x84	; 132
      9c:	8c 39       	cpi	r24, 0x9C	; 156
      9e:	f2 3a       	cpi	r31, 0xA2	; 162
      a0:	56 3c       	cpi	r21, 0xC6	; 198
      a2:	b8 3d       	cpi	r27, 0xD8	; 216
      a4:	17 3f       	cpi	r17, 0xF7	; 247
      a6:	73 40       	sbci	r23, 0x03	; 3
      a8:	ce 41       	sbci	r28, 0x1E	; 30
      aa:	25 43       	sbci	r18, 0x35	; 53
      ac:	7a 44       	sbci	r23, 0x4A	; 74
      ae:	cd 45       	sbci	r28, 0x5D	; 93
      b0:	1c 47       	sbci	r17, 0x7C	; 124
      b2:	69 48       	sbci	r22, 0x89	; 137
      b4:	b4 49       	sbci	r27, 0x94	; 148
      b6:	fb 4a       	sbci	r31, 0xAB	; 171
      b8:	3f 4c       	sbci	r19, 0xCF	; 207
      ba:	81 4d       	sbci	r24, 0xD1	; 209
      bc:	bf 4e       	sbci	r27, 0xEF	; 239
      be:	fb 4f       	sbci	r31, 0xFB	; 251
      c0:	33 51       	subi	r19, 0x13	; 19
      c2:	68 52       	subi	r22, 0x28	; 40
      c4:	9b 53       	subi	r25, 0x3B	; 59
      c6:	c9 54       	subi	r28, 0x49	; 73
      c8:	f5 55       	subi	r31, 0x55	; 85
      ca:	1d 57       	subi	r17, 0x7D	; 125
      cc:	42 58       	subi	r20, 0x82	; 130
      ce:	64 59       	subi	r22, 0x94	; 148
      d0:	82 5a       	subi	r24, 0xA2	; 162
      d2:	9c 5b       	subi	r25, 0xBC	; 188
      d4:	b3 5c       	subi	r27, 0xC3	; 195
      d6:	c7 5d       	subi	r28, 0xD7	; 215
      d8:	d7 5e       	subi	r29, 0xE7	; 231
      da:	e3 5f       	subi	r30, 0xF3	; 243
      dc:	eb 60       	ori	r30, 0x0B	; 11
      de:	f0 61       	ori	r31, 0x10	; 16
      e0:	f1 62       	ori	r31, 0x21	; 33
      e2:	ee 63       	ori	r30, 0x3E	; 62
      e4:	e8 64       	ori	r30, 0x48	; 72
      e6:	dd 65       	ori	r29, 0x5D	; 93
      e8:	cf 66       	ori	r28, 0x6F	; 111
      ea:	bc 67       	ori	r27, 0x7C	; 124
      ec:	a6 68       	ori	r26, 0x86	; 134
      ee:	8b 69       	ori	r24, 0x9B	; 155
      f0:	6d 6a       	ori	r22, 0xAD	; 173
      f2:	4a 6b       	ori	r20, 0xBA	; 186
      f4:	23 6c       	ori	r18, 0xC3	; 195
      f6:	f8 6c       	ori	r31, 0xC8	; 200
      f8:	c9 6d       	ori	r28, 0xD9	; 217
      fa:	96 6e       	ori	r25, 0xE6	; 230
      fc:	5e 6f       	ori	r21, 0xFE	; 254
      fe:	22 70       	andi	r18, 0x02	; 2
     100:	e2 70       	andi	r30, 0x02	; 2
     102:	9d 71       	andi	r25, 0x1D	; 29
     104:	54 72       	andi	r21, 0x24	; 36
     106:	07 73       	andi	r16, 0x37	; 55
     108:	b5 73       	andi	r27, 0x35	; 53
     10a:	5f 74       	andi	r21, 0x4F	; 79
     10c:	04 75       	andi	r16, 0x54	; 84
     10e:	a5 75       	andi	r26, 0x55	; 85
     110:	41 76       	andi	r20, 0x61	; 97
     112:	d8 76       	andi	r29, 0x68	; 104
     114:	6b 77       	andi	r22, 0x7B	; 123
     116:	fa 77       	andi	r31, 0x7A	; 122
     118:	84 78       	andi	r24, 0x84	; 132
     11a:	09 79       	andi	r16, 0x99	; 153
     11c:	89 79       	andi	r24, 0x99	; 153
     11e:	05 7a       	andi	r16, 0xA5	; 165
     120:	7c 7a       	andi	r23, 0xAC	; 172
     122:	ee 7a       	andi	r30, 0xAE	; 174
     124:	5c 7b       	andi	r21, 0xBC	; 188
     126:	c5 7b       	andi	r28, 0xB5	; 181
     128:	29 7c       	andi	r18, 0xC9	; 201
     12a:	88 7c       	andi	r24, 0xC8	; 200
     12c:	e3 7c       	andi	r30, 0xC3	; 195
     12e:	39 7d       	andi	r19, 0xD9	; 217
     130:	89 7d       	andi	r24, 0xD9	; 217
     132:	d5 7d       	andi	r29, 0xD5	; 213
     134:	1d 7e       	andi	r17, 0xED	; 237
     136:	5f 7e       	andi	r21, 0xEF	; 239
     138:	9c 7e       	andi	r25, 0xEC	; 236
     13a:	d5 7e       	andi	r29, 0xE5	; 229
     13c:	09 7f       	andi	r16, 0xF9	; 249
     13e:	37 7f       	andi	r19, 0xF7	; 247
     140:	61 7f       	andi	r22, 0xF1	; 241
     142:	86 7f       	andi	r24, 0xF6	; 246
     144:	a6 7f       	andi	r26, 0xF6	; 246
     146:	c1 7f       	andi	r28, 0xF1	; 241
     148:	d8 7f       	andi	r29, 0xF8	; 248
     14a:	e9 7f       	andi	r30, 0xF9	; 249
     14c:	f5 7f       	andi	r31, 0xF5	; 245
     14e:	fd 7f       	andi	r31, 0xFD	; 253
     150:	ff 7f       	andi	r31, 0xFF	; 255

00000152 <pgm_image2>:
     152:	c0 c0 c0 c0 c0 00 00 00 00 00 00 c0 c0 c0 c0 c0     ................
     162:	c0 c0 c0 00 00 0f 0f 0f 0f 0f 0f 00 00 c0 c0 c0     ................
     172:	c0 c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0 c0     ................
     182:	c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0     ................
     192:	c0 00 0f 0f 0f 00 0f 0f 0f 0f 0f 0f 0f 0f 00 c0     ................
     1a2:	00 0f 0f 0f 00 00 00 0f 0f 00 0f 0f 0f 0f 0f 00     ................
     1b2:	00 0f 0f 0f 0f 00 0f 0f 0f 0f 00 00 0f 0f 0f 00     ................
     1c2:	00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00     ................
     1d2:	00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00     ................
     1e2:	00 0f 0f 00 00 0f 0f 0f 0f 0f 0f 00 00 0f 0f 00     ................
     1f2:	00 0f 0f 0f 00 00 0f 0f 0f 0f 00 00 0f 0f 0f 00     ................
     202:	c0 00 0f 0f 0f 00 00 00 00 00 00 0f 0f 0f 00 c0     ................
     212:	c0 00 00 0f 0f 0f 00 03 00 03 00 0f 0f 00 00 c0     ................
     222:	c0 c0 00 00 0f 0f 00 03 03 03 00 0f 00 00 c0 c0     ................
     232:	c0 c0 c0 00 00 0f 0f 00 00 00 0f 00 00 c0 c0 c0     ................
     242:	c0 c0 c0 c0 c0 00 00 00 00 00 00 c0 c0 c0 c0 c0     ................

00000252 <pgm_image1>:
     252:	c0 c0 c0 c0 c0 00 00 00 00 00 00 c0 c0 c0 c0 c0     ................
     262:	c0 c0 c0 00 00 0f 0f 0f 0f 0f 0f 00 00 c0 c0 c0     ................
     272:	c0 c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0 c0     ................
     282:	c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0     ................
     292:	c0 00 0f 0f 0f 00 0f 0f 0f 0f 00 0f 0f 0f 00 c0     ................
     2a2:	00 0f 0f 0f 00 00 00 0f 0f 00 00 00 0f 0f 0f 00     ................
     2b2:	00 0f 0f 0f 0f 00 0f 0f 0f 0f 00 0f 0f 0f 0f 00     ................
     2c2:	00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00     ................
     2d2:	00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00     ................
     2e2:	00 0f 0f 00 00 0f 0f 0f 0f 0f 0f 00 00 0f 0f 00     ................
     2f2:	00 0f 0f 0f 00 00 0f 0f 0f 0f 00 00 0f 0f 0f 00     ................
     302:	c0 00 0f 0f 0f 00 00 00 00 00 00 0f 0f 0f 00 c0     ................
     312:	c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0     ................
     322:	c0 c0 00 00 0f 0f 0f 0f 0f 0f 0f 0f 00 00 c0 c0     ................
     332:	c0 c0 c0 00 00 0f 0f 0f 0f 0f 0f 00 00 c0 c0 c0     ................
     342:	c0 c0 c0 c0 c0 00 00 00 00 00 00 c0 c0 c0 c0 c0     ................

00000352 <characters>:
     352:	00 0c 36 36 0c 00 1c 06 18 06 00 00 00 00 00 60     ..66...........`
     362:	1e 0c 1e 1e 38 3f 1c 3f 1e 1e 00 00 18 00 06 1e     ....8?.?........
     372:	3e 0c 3f 3c 3f 7f 7f 3c 33 1e 78 67 0f 63 63 1c     >.?<?..<3.xg.cc.
     382:	3f 1e 3f 1e 3f 33 33 63 63 33 7f 1e 03 1e 08 00     ?.?.?33cc3......
     392:	0c 00 07 00 38 00 1c 00 07 0c 18 07 0e 00 00 00     ....8...........
     3a2:	00 00 00 00 08 00 00 00 00 00 00 38 18 07 6e 0e     ...........8..n.
     3b2:	00 1e 36 36 3e 63 36 06 0c 0c 66 0c 00 00 00 30     ..66>c6...f....0
     3c2:	33 0f 33 33 3c 03 06 33 33 33 00 00 0c 00 0c 33     3.33<..333.....3
     3d2:	63 1e 66 66 36 46 46 66 33 0c 30 66 06 77 67 36     c.ff6FFf3.0f.wg6
     3e2:	66 33 66 33 2d 33 33 63 63 33 33 06 06 18 1c 00     f3f3-33cc33.....
     3f2:	0c 00 06 00 30 00 36 00 06 00 00 06 0c 00 00 00     ....0.6.........
     402:	00 00 00 00 0c 00 00 00 00 00 00 0c 18 0c 3b 13     ..............;.
     412:	00 1e 36 7f 03 33 1c 03 06 18 3c 0c 00 00 00 18     ..6..3....<.....
     422:	3b 0c 30 30 36 1f 03 30 33 33 0c 0c 06 3f 18 30     ;.006..033...?.0
     432:	7b 33 66 03 66 16 16 03 33 0c 30 36 06 7f 6f 63     {3f.f...3.06..oc
     442:	66 33 66 07 0c 33 33 63 36 33 19 06 0c 18 36 00     f3f..33c63....6.
     452:	18 1e 3e 1e 30 1e 06 6e 36 0e 1e 66 0c 37 1f 1e     ..>.0..n6..f.7..
     462:	3b 6e 1b 3e 3e 33 33 63 63 33 3f 0c 18 0c 00 39     ;n.>>33cc3?....9
     472:	00 0c 00 36 1e 18 6e 00 06 18 ff 3f 00 3f 00 0c     ...6..n....?.?..
     482:	3f 0c 1c 1c 33 30 1f 18 1e 3e 0c 0c 03 00 30 18     ?...30...>....0.
     492:	7b 33 3e 03 66 1e 1e 03 3f 0c 30 1e 06 6b 7b 63     {3>.f...?.0..k{c
     4a2:	3e 33 3e 1c 0c 33 33 6b 1c 1e 0c 06 18 18 63 00     >3>..33k......c.
     4b2:	00 30 66 33 3e 33 0f 33 6e 0c 18 36 0c 7f 33 33     .0f3>3.3n..6..33
     4c2:	66 33 36 03 0c 33 33 63 36 33 19 07 00 38 00 69     f36..33c63...8.i
     4d2:	00 0c 00 7f 30 0c 3b 00 06 18 3c 0c 00 00 00 06     ....0.;...<.....
     4e2:	37 0c 06 30 7f 30 33 0c 33 30 00 00 06 3f 18 0c     7..0.03.30...?..
     4f2:	7b 3f 66 03 66 16 16 73 33 0c 33 36 46 63 73 63     {?f.f..s3.36Fcsc
     502:	06 3b 1e 38 0c 33 33 7f 36 0c 46 06 30 18 00 00     .;.8.33.6.F.0...
     512:	00 3e 66 03 33 3f 06 33 66 0c 18 1e 0c 6b 33 33     .>f.3?.3f....k33
     522:	66 33 36 1e 0c 33 33 6b 1c 33 0c 0c 18 0c 00 0e     f36..33k.3......
     532:	00 00 00 36 1f 66 33 00 0c 0c 66 0c 0e 00 0c 03     ...6.f3...f.....
     542:	33 0c 33 33 30 33 33 06 33 18 0c 0e 0c 00 0c 00     3.33033.3.......
     552:	03 33 66 66 36 46 06 66 33 0c 33 66 66 63 63 36     .3ff6F.f3.3ffcc6
     562:	06 1e 36 33 0c 33 1e 77 63 0c 63 06 60 18 00 00     ..63.3.wc.c.`...
     572:	00 33 66 33 33 03 06 3e 66 0c 18 36 0c 63 33 33     .3f33..>f..6.c33
     582:	3e 3e 06 30 2c 33 1e 7f 36 3e 26 0c 18 0c 00 f3     >>.0,3..6>&.....
     592:	00 0c 00 36 0c 63 6e 00 18 06 00 00 0c 00 0c 01     ...6.cn.........
     5a2:	1e 3f 3f 1e 30 1e 1e 06 1e 0e 0c 0c 18 00 06 0c     .??.0...........
     5b2:	1e 33 3f 3c 3f 7f 0f 7c 33 1e 1e 67 7f 63 63 1c     .3?<?..|3..g.cc.
     5c2:	0f 38 67 1e 1e 3f 0c 63 63 1e 7f 1e 40 1e 00 00     .8g..?.cc...@...
     5d2:	00 6e 3d 1e 6e 1e 0f 30 67 1e 1b 67 1e 63 33 1e     .n=.n..0g..g.c3.
     5e2:	06 30 0f 1f 18 6e 0c 36 63 30 3f 38 18 07 00 46     .0...n.6c0?8...F
     5f2:	00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00     ................
     602:	00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 00     ................
     612:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     622:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff     ................
     632:	00 00 00 00 00 00 00 1f 00 00 0e 00 00 00 00 00     ................
     642:	0f 78 00 00 00 00 00 00 00 1f 00 00 00 00 00 f4     .x..............

00000652 <header>:
     652:	4c 43 44 64 69 72 65 63 74 4c 56 44 53 36 38 20     LCDdirectLVDS68 
     662:	32 30 31 34 2d 30 34 2d 32 38 20 32 31 3a 33 37     2014-04-28 21:37
     672:	3a 34 33 00                                         :43.

00000676 <__ctors_end>:
     676:	11 24       	eor	r1, r1
     678:	1f be       	out	0x3f, r1	; 63
     67a:	cf ef       	ldi	r28, 0xFF	; 255
     67c:	d4 e0       	ldi	r29, 0x04	; 4
     67e:	de bf       	out	0x3e, r29	; 62
     680:	cd bf       	out	0x3d, r28	; 61

00000682 <__do_copy_data>:
     682:	11 e0       	ldi	r17, 0x01	; 1
     684:	a0 e0       	ldi	r26, 0x00	; 0
     686:	b1 e0       	ldi	r27, 0x01	; 1
     688:	ea e7       	ldi	r30, 0x7A	; 122
     68a:	f8 e1       	ldi	r31, 0x18	; 24
     68c:	02 c0       	rjmp	.+4      	; 0x692 <__do_copy_data+0x10>
     68e:	05 90       	lpm	r0, Z+
     690:	0d 92       	st	X+, r0
     692:	a6 30       	cpi	r26, 0x06	; 6
     694:	b1 07       	cpc	r27, r17
     696:	d9 f7       	brne	.-10     	; 0x68e <__do_copy_data+0xc>

00000698 <__do_clear_bss>:
     698:	12 e0       	ldi	r17, 0x02	; 2
     69a:	a6 e0       	ldi	r26, 0x06	; 6
     69c:	b1 e0       	ldi	r27, 0x01	; 1
     69e:	01 c0       	rjmp	.+2      	; 0x6a2 <.do_clear_bss_start>

000006a0 <.do_clear_bss_loop>:
     6a0:	1d 92       	st	X+, r1

000006a2 <.do_clear_bss_start>:
     6a2:	a4 33       	cpi	r26, 0x34	; 52
     6a4:	b1 07       	cpc	r27, r17
     6a6:	e1 f7       	brne	.-8      	; 0x6a0 <.do_clear_bss_loop>
     6a8:	0e 94 ad 0b 	call	0x175a	; 0x175a <main>
     6ac:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <_exit>

000006b0 <__bad_interrupt>:
     6b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006b4 <hfm_setPower>:
// This needs to be set, initially! 
//   either init it in the hfm variable declaration
//   or use hfm_setup (ideal)
// however, sometimes it needs to be variable, thus hfm_setup (above)
void hfm_setPower(hfm_t	*modulator, uint8_t power)
{
     6b4:	fc 01       	movw	r30, r24
	//Don't allow power values > 1, otherwise who knows what'll happen...
	//(This is probably unnecessary, but whatev)
	//It's not, actually, if power's greater than maxPower, the values never reset
	// This is trouble, e.g. in heartbeat, where modulator.power is read
	if(power <= (modulator->maxPower))
     6b6:	82 81       	ldd	r24, Z+2	; 0x02
     6b8:	86 17       	cp	r24, r22
     6ba:	10 f0       	brcs	.+4      	; 0x6c0 <hfm_setPower+0xc>
		modulator->power = power;
     6bc:	63 83       	std	Z+3, r22	; 0x03
     6be:	08 95       	ret
	else
		modulator->power = modulator->maxPower;
     6c0:	82 81       	ldd	r24, Z+2	; 0x02
     6c2:	83 83       	std	Z+3, r24	; 0x03
     6c4:	08 95       	ret

000006c6 <hfm_setup>:
//Mainly just for setting up the maxPower (divisor)
// [can] use hfm_setPower otherwise...
// can't tell how to get away without using hfm_setup once
void hfm_setup(hfm_t *modulator, uint8_t power, uint8_t maxPower)
{
	modulator->desiredSum = 0;
     6c6:	fc 01       	movw	r30, r24
     6c8:	11 82       	std	Z+1, r1	; 0x01
     6ca:	10 82       	st	Z, r1
	modulator->maxPower = maxPower;
     6cc:	42 83       	std	Z+2, r20	; 0x02
	hfm_setPower(modulator, power);
     6ce:	0c 94 5a 03 	jmp	0x6b4	; 0x6b4 <hfm_setPower>

000006d2 <hfm_nextOutput>:
}

//Returns 0 if the "output" should be "off" in this cycle
//		  1 if the "output" should be "on"  in this cycle
uint8_t hfm_nextOutput(hfm_t *modulator)
{
     6d2:	fc 01       	movw	r30, r24
	// IF desired == 255, we want it never to clr...
	//		but running will be 0 the first time
	//		and we'll therefore if... set == good
	//		and later we'll runningSum == desiredSum (above) 
	//    and reset and if again
	if(modulator->desiredSum > 0)
     6d4:	80 81       	ld	r24, Z
     6d6:	91 81       	ldd	r25, Z+1	; 0x01
     6d8:	18 16       	cp	r1, r24
     6da:	19 06       	cpc	r1, r25
     6dc:	4c f4       	brge	.+18     	; 0x6f0 <hfm_nextOutput+0x1e>
	{
		(modulator->desiredSum) -= (modulator->maxPower); //0xff;
     6de:	80 81       	ld	r24, Z
     6e0:	91 81       	ldd	r25, Z+1	; 0x01
     6e2:	22 81       	ldd	r18, Z+2	; 0x02
     6e4:	82 1b       	sub	r24, r18
     6e6:	91 09       	sbc	r25, r1
     6e8:	91 83       	std	Z+1, r25	; 0x01
     6ea:	80 83       	st	Z, r24
		toReturn = TRUE;
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <hfm_nextOutput+0x20>
	}
	else	//avg == desired is handled at the start... (except 0-case which works here too)
	{
		//Don't modify runningSum, wait until desiredSum catches up...
		toReturn = FALSE;
     6f0:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	(modulator->desiredSum) += (modulator->power);
     6f2:	20 81       	ld	r18, Z
     6f4:	31 81       	ldd	r19, Z+1	; 0x01
     6f6:	93 81       	ldd	r25, Z+3	; 0x03
     6f8:	29 0f       	add	r18, r25
     6fa:	31 1d       	adc	r19, r1
     6fc:	31 83       	std	Z+1, r19	; 0x01
     6fe:	20 83       	st	Z, r18
		modulator->runningSum = 0;
		modulator->desiredSum = 0;
	}
*/	
	return toReturn;
}
     700:	08 95       	ret

00000702 <adc_select>:
	// see Figure 21.5
	//"Note that the conversion starts on the following rising ADC clock edge after 
	// ADSC is written. The user is thus advised not to write new channel or reference
	// selection values to ADMUX until one ADC clock cycle after ADSC is written. 

	writeMasked(adcNum, ADC_SELECT_MASK, ADMUX);
     702:	98 b1       	in	r25, 0x08	; 8
     704:	8f 71       	andi	r24, 0x1F	; 31
     706:	90 7e       	andi	r25, 0xE0	; 224
     708:	89 2b       	or	r24, r25
     70a:	88 b9       	out	0x08, r24	; 8
     70c:	08 95       	ret

0000070e <adc_getValue>:
//Return the last value read by the ADC
// check if adc_isBusy is true before reading, in lockstep...
// Since ADLAR is cleared, it will be the low ten bits 
uint16_t adc_getValue(void)
{
	return ADC;
     70e:	8c b5       	in	r24, 0x2c	; 44
     710:	9d b5       	in	r25, 0x2d	; 45
	//reading both values takes longer and some other things mentioned in the manual
	// (i.e. it might be more efficient to only read one byte if acceptable)
	// unless only reading ADCH: "ADCL must be read first, then ADCH"
	//!!! Might want to verify this occurs properly in the assembly code
	
}
     712:	08 95       	ret

00000714 <adc_isBusy>:
	//  The ADSC bit will be read as one during a conversion, 
	//  independently of how the conversion was started."
	//  actually, it would return true /always/ during free-running mode

	//Check state-machine... might be better to use ADIF...?
	return getbit(ADSC, ADCSRA);
     714:	86 b1       	in	r24, 0x06	; 6
}
     716:	86 fb       	bst	r24, 6
     718:	88 27       	eor	r24, r24
     71a:	80 f9       	bld	r24, 0
     71c:	08 95       	ret

0000071e <adc_startConversion>:

//Return TRUE on error (if there was a previous conversion in progress...)
uint8_t adc_startConversion(void)
{
	//Check if a conversion is already in progress...
	if(adc_isBusy())
     71e:	0e 94 8a 03 	call	0x714	; 0x714 <adc_isBusy>
     722:	81 11       	cpse	r24, r1
     724:	02 c0       	rjmp	.+4      	; 0x72a <adc_startConversion+0xc>
	// until a conversion is started. Once the conversion starts, the channel and 
	// reference selection is locked to ensure a sufficient sampling time for the ADC."
	
	//"In Single Conversion mode, write this bit to one to start each conversion."
	// BEWARE: calling this will CLEAR the conversion-complete indicator
	setbit(ADSC, ADCSRA);
     726:	36 9a       	sbi	0x06, 6	; 6
	return FALSE;
     728:	08 95       	ret
//Return TRUE on error (if there was a previous conversion in progress...)
uint8_t adc_startConversion(void)
{
	//Check if a conversion is already in progress...
	if(adc_isBusy())
		return TRUE;
     72a:	81 e0       	ldi	r24, 0x01	; 1
	
	//"In Single Conversion mode, write this bit to one to start each conversion."
	// BEWARE: calling this will CLEAR the conversion-complete indicator
	setbit(ADSC, ADCSRA);
	return FALSE;
}
     72c:	08 95       	ret

0000072e <adc_setPrescaler>:
}

void adc_setPrescaler(uint8_t adps)
{
	//This will clear the conversion-complete flag!
	writeMasked(adps, ADPS_MASK, ADCSRA);
     72e:	96 b1       	in	r25, 0x06	; 6
     730:	87 70       	andi	r24, 0x07	; 7
     732:	98 7f       	andi	r25, 0xF8	; 248
     734:	89 2b       	or	r24, r25
     736:	86 b9       	out	0x06, r24	; 6
     738:	08 95       	ret

0000073a <adc_init>:
	// (i.e. a 3.3V voltage regulator output)
	//Technically, these values are reset-defaults, but just make sure
	//!!!According to attiny861, these values set VCC as the voltage ref
	//   NOT an external reference. So the above note seems odd...
	// This IS what I want on the Tiny861 threePinIDer...
	clrbit(REFS0, ADMUX);
     73a:	46 98       	cbi	0x08, 6	; 8
	clrbit(REFS1, ADMUX);
     73c:	47 98       	cbi	0x08, 7	; 8
	
	//Use right-adjusted output
	// so values read from the 2-byte register are:
	//	8-bits in the Low reg, and 2 in the High reg
	clrbit(ADLAR, ADMUX);
     73e:	45 98       	cbi	0x08, 5	; 8

	//Enable the ADC
	// (see description for noise cancelling techniques)
	setbit(ADEN, ADCSRA);
     740:	37 9a       	sbi	0x06, 7	; 6
	
	//Don't use Auto Triggering
	// (@@@ could use a timer, etc.)
	clrbit(ADATE, ADCSRA);
     742:	35 98       	cbi	0x06, 5	; 6
	// "ADIF is cleared by writing a logical one to the flag."
	// " BEWARE that if doing a Read-Modify-Write on ADCSRA, a pending interrupt can be disabled. "
	//   because the flag may be 1 when read, and re-writing 1 clears it.
	//   ???could get around this by using a special set/clrbit instruction which would always write 0
	//   to this bit...
	setbit(ADIF, ADCSRA);
     744:	34 9a       	sbi	0x06, 4	; 6
	
	//make sure the interrupt is not enabled...
	clrbit(ADIE, ADCSRA);
     746:	33 98       	cbi	0x06, 3	; 6
	//  If a lower resolution than 10 bits is needed, the input clock frequency 
	//  to the ADC can be higher than 200 kHz to get a higher sample rate."
	// For now, let's go for higher-precision... 
	// 16MHz / 200kHz = 80
	// our best-bet for precision is 128
	adc_setPrescaler(ADPS_128);
     748:	87 e0       	ldi	r24, 0x07	; 7
     74a:	0e 94 97 03 	call	0x72e	; 0x72e <adc_setPrescaler>
		
	//Select GND as the first ADC source...
	adc_select(ADC_SELECT_GND);
     74e:	8f e1       	ldi	r24, 0x1F	; 31
     750:	0e 94 81 03 	call	0x702	; 0x702 <adc_select>
	//Start a conversion so it will be initialized for the next...
	//"The first conversion after ADSC has been written 
	// after the ADC has been enabled ... 
	// will take 25 ADC clock cycles instead of the normal 13. 
	// This first conversion performs initialization of the ADC. "
	adc_startConversion();
     754:	0e 94 8f 03 	call	0x71e	; 0x71e <adc_startConversion>

	//Wait for the initialization to complete for lockstepping...
	while(adc_isBusy())
     758:	0e 94 8a 03 	call	0x714	; 0x714 <adc_isBusy>
     75c:	81 11       	cpse	r24, r1
     75e:	fc cf       	rjmp	.-8      	; 0x758 <adc_init+0x1e>
	{}
}
     760:	08 95       	ret

00000762 <adc_takeInput>:
		setbit(bitNum, DIDR1);
		return;
	}
#endif

	if(bitNum <= 7)
     762:	88 30       	cpi	r24, 0x08	; 8
     764:	60 f4       	brcc	.+24     	; 0x77e <adc_takeInput+0x1c>
		setbit(bitNum, DIDR0);
     766:	90 91 77 00 	lds	r25, 0x0077
     76a:	21 e0       	ldi	r18, 0x01	; 1
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	08 2e       	mov	r0, r24
     770:	01 c0       	rjmp	.+2      	; 0x774 <adc_takeInput+0x12>
     772:	22 0f       	add	r18, r18
     774:	0a 94       	dec	r0
     776:	ea f7       	brpl	.-6      	; 0x772 <adc_takeInput+0x10>
     778:	92 2b       	or	r25, r18
     77a:	90 93 77 00 	sts	0x0077, r25
     77e:	08 95       	ret

00000780 <timer_selectDivisor>:
#if (!defined(TIMER_SELECTDIVISOR_UNUSED) || !TIMER_SELECTDIVISOR_UNUSED)
uint8_t timer_selectDivisor(uint8_t timerNum, uint8_t clockDiv)
{

 #if(defined(__AVR_AT90PWM161__))
	if((timerNum != 1) || (clockDiv != CLKDIV1))
     780:	81 30       	cpi	r24, 0x01	; 1
     782:	51 f4       	brne	.+20     	; 0x798 <timer_selectDivisor+0x18>
     784:	61 11       	cpse	r22, r1
     786:	08 c0       	rjmp	.+16     	; 0x798 <timer_selectDivisor+0x18>
		return 1;

	writeMasked(CSTYP_DIV1, CSMASK, T1_CSReg);
     788:	80 91 8a 00 	lds	r24, 0x008A
     78c:	88 7f       	andi	r24, 0xF8	; 248
     78e:	81 60       	ori	r24, 0x01	; 1
     790:	80 93 8a 00 	sts	0x008A, r24
	return 0;
     794:	80 e0       	ldi	r24, 0x00	; 0
     796:	08 95       	ret
uint8_t timer_selectDivisor(uint8_t timerNum, uint8_t clockDiv)
{

 #if(defined(__AVR_AT90PWM161__))
	if((timerNum != 1) || (clockDiv != CLKDIV1))
		return 1;
     798:	81 e0       	ldi	r24, 0x01	; 1
			break;
	}
	
	return 0;
 #endif
}
     79a:	08 95       	ret

0000079c <timer_setWGM>:
//	wgmLb *= 0xff;
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
     79c:	64 30       	cpi	r22, 0x04	; 4
     79e:	88 f4       	brcc	.+34     	; 0x7c2 <timer_setWGM+0x26>
		return 1;
	
	switch(timerNum)
     7a0:	81 30       	cpi	r24, 0x01	; 1
     7a2:	79 f4       	brne	.+30     	; 0x7c2 <timer_setWGM+0x26>
			break;
#endif //!__AVR_AT90PWM161__
		//Also Timer1, since all devices I've explored have both T0 and T1...
		case 1:
#if(defined(__AVR_AT90PWM161__))
			if(wgm == WGM_NORMAL)
     7a4:	61 11       	cpse	r22, r1
     7a6:	04 c0       	rjmp	.+8      	; 0x7b0 <timer_setWGM+0x14>
			{
				clrbit(WGM13, TCCR1B);
     7a8:	80 91 8a 00 	lds	r24, 0x008A
     7ac:	8f 7e       	andi	r24, 0xEF	; 239
     7ae:	05 c0       	rjmp	.+10     	; 0x7ba <timer_setWGM+0x1e>
				return 0;
			}
			else if(wgm == WGM_CLR_ON_COMPARE)
     7b0:	62 30       	cpi	r22, 0x02	; 2
     7b2:	39 f4       	brne	.+14     	; 0x7c2 <timer_setWGM+0x26>
			{
				setbit(WGM13, TCCR1B);
     7b4:	80 91 8a 00 	lds	r24, 0x008A
     7b8:	80 61       	ori	r24, 0x10	; 16
     7ba:	80 93 8a 00 	sts	0x008A, r24
				return 0;
     7be:	80 e0       	ldi	r24, 0x00	; 0
     7c0:	08 95       	ret
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
		return 1;
     7c2:	81 e0       	ldi	r24, 0x01	; 1
			return 1;
			break;
	}
	
	return 0;
}
     7c4:	08 95       	ret

000007c6 <timer_init>:

//Roughly equivalent to the ol' Init_timerX(clkDiv, wgm)
//Return 0 if no error...
#if (!defined(TIMER_INIT_UNUSED) || !TIMER_INIT_UNUSED)
uint8_t timer_init(uint8_t timerNum, uint8_t clockDiv, uint8_t wgm)
{
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	c8 2f       	mov	r28, r24
     7cc:	d6 2f       	mov	r29, r22
	//set the waveform mode
	ERR_HANDLE_NUM(1,				\
     7ce:	64 2f       	mov	r22, r20
     7d0:	0e 94 ce 03 	call	0x79c	; 0x79c <timer_setWGM>
     7d4:	88 23       	and	r24, r24
     7d6:	11 f0       	breq	.+4      	; 0x7dc <timer_init+0x16>
     7d8:	80 61       	ori	r24, 0x10	; 16
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <timer_init+0x28>
		timer_setWGM(timerNum, wgm)	);

	//select the clock
	ERR_HANDLE_NUM(2,							\
     7dc:	6d 2f       	mov	r22, r29
     7de:	8c 2f       	mov	r24, r28
     7e0:	0e 94 c0 03 	call	0x780	; 0x780 <timer_selectDivisor>
     7e4:	88 23       	and	r24, r24
     7e6:	11 f0       	breq	.+4      	; 0x7ec <timer_init+0x26>
     7e8:	80 62       	ori	r24, 0x20	; 32
     7ea:	01 c0       	rjmp	.+2      	; 0x7ee <timer_init+0x28>
		timer_selectDivisor(timerNum, clockDiv)	);
		
	return 0;
     7ec:	80 e0       	ldi	r24, 0x00	; 0
}
     7ee:	df 91       	pop	r29
     7f0:	cf 91       	pop	r28
     7f2:	08 95       	ret

000007f4 <timer_compareMatchIntSetup>:

#if(defined(__AVR_AT90PWM161__))
uint8_t timer_compareMatchIntSetup(uint8_t timerNum, uint8_t outputChannel,
	  												uint8_t enable)
{
	if(timerNum != 1)
     7f4:	81 30       	cpi	r24, 0x01	; 1
     7f6:	51 f4       	brne	.+20     	; 0x80c <timer_compareMatchIntSetup+0x18>
		return 1;
	//outputChannel is ignored...
	if(enable)
     7f8:	44 23       	and	r20, r20
     7fa:	61 f0       	breq	.+24     	; 0x814 <timer_compareMatchIntSetup+0x20>
	{
		cli();
     7fc:	f8 94       	cli
		enable = 1;
	}

	writebit(ICIE1, TIMSK1, enable);
     7fe:	0d 9a       	sbi	0x01, 5	; 1
		return 1;
	//outputChannel is ignored...
	if(enable)
	{
		cli();
		enable = 1;
     800:	41 e0       	ldi	r20, 0x01	; 1
	}

	writebit(ICIE1, TIMSK1, enable);
	//Clear the overflow flag...
	setbit(ICF1, TIFR1);
     802:	15 9a       	sbi	0x02, 5	; 2

	if(enable)
     804:	44 23       	and	r20, r20
     806:	21 f0       	breq	.+8      	; 0x810 <timer_compareMatchIntSetup+0x1c>
		sei();
     808:	78 94       	sei
     80a:	02 c0       	rjmp	.+4      	; 0x810 <timer_compareMatchIntSetup+0x1c>
#if(defined(__AVR_AT90PWM161__))
uint8_t timer_compareMatchIntSetup(uint8_t timerNum, uint8_t outputChannel,
	  												uint8_t enable)
{
	if(timerNum != 1)
		return 1;
     80c:	81 e0       	ldi	r24, 0x01	; 1
     80e:	08 95       	ret
	setbit(ICF1, TIFR1);

	if(enable)
		sei();

	return 0;
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	08 95       	ret
	{
		cli();
		enable = 1;
	}

	writebit(ICIE1, TIMSK1, enable);
     814:	0d 98       	cbi	0x01, 5	; 1
     816:	f5 cf       	rjmp	.-22     	; 0x802 <timer_compareMatchIntSetup+0xe>

00000818 <setHeartRate>:

void setHeartRate(uint8_t rate)
{
//	heartRate = rate;
	
	if(rate == 0)
     818:	81 11       	cpse	r24, r1
     81a:	01 c0       	rjmp	.+2      	; 0x81e <setHeartRate+0x6>
		rate = 1;
     81c:	81 e0       	ldi	r24, 0x01	; 1
		
	#if (_HEART_DMS_)

#warning "Relevant Everywhere: dms6sec_t used in heartbeat, yet a full cycle is 8 seconds, and nevermind blinks! This might need changing!"
    heartStepTime = (HEARTSTEPTIME/rate);
     81e:	68 2f       	mov	r22, r24
     820:	70 e0       	ldi	r23, 0x00	; 0
     822:	8c e9       	ldi	r24, 0x9C	; 156
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <__divmodhi4>
     82a:	70 93 02 01 	sts	0x0102, r23
     82e:	60 93 01 01 	sts	0x0101, r22
     832:	08 95       	ret

00000834 <getHeartRate>:
#if (!defined(HEART_GETRATE_UNUSED) || !HEART_GETRATE_UNUSED)
//This function takes about 20 bytes
uint8_t getHeartRate(void)
{
	#if (_HEART_DMS_)
	 return HEARTSTEPTIME/heartStepTime;
     834:	60 91 01 01 	lds	r22, 0x0101
     838:	70 91 02 01 	lds	r23, 0x0102
     83c:	8c e9       	ldi	r24, 0x9C	; 156
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <__udivmodhi4>
     844:	86 2f       	mov	r24, r22
	#else
	 return HEART_ITERATIONCOUNT/heartStepTime;
	#endif
}
     846:	08 95       	ret

00000848 <heartClear>:
}
#endif

void heartClear(void)
{
	hfm_setPower(&heartModulator, 0);
     848:	60 e0       	ldi	r22, 0x00	; 0
     84a:	8b e1       	ldi	r24, 0x1B	; 27
     84c:	91 e0       	ldi	r25, 0x01	; 1
     84e:	0c 94 5a 03 	jmp	0x6b4	; 0x6b4 <hfm_setPower>

00000852 <init_heartBeat>:
	//DDR = H,out
	setoutVar(heartBeatPin, heartPIN);
#else
void init_heartBeat(void)
{
	clrpinPORT(HEART_PINNUM, HEART_PINPORT);
     852:	2e 98       	cbi	0x05, 6	; 5
	setoutPORT(HEART_PINNUM, HEART_PINPORT);
     854:	26 9a       	sbi	0x04, 6	; 4
#endif



//	hfm_setPower(&heartModulator, 0);
	hfm_setup(&heartModulator, 0, HEART_MAXBRIGHT);
     856:	4f ef       	ldi	r20, 0xFF	; 255
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	8b e1       	ldi	r24, 0x1B	; 27
     85c:	91 e0       	ldi	r25, 0x01	; 1
     85e:	0e 94 63 03 	call	0x6c6	; 0x6c6 <hfm_setup>
		rate = 1;
		
	#if (_HEART_DMS_)

#warning "Relevant Everywhere: dms6sec_t used in heartbeat, yet a full cycle is 8 seconds, and nevermind blinks! This might need changing!"
    heartStepTime = (HEARTSTEPTIME/rate);
     862:	8c e9       	ldi	r24, 0x9C	; 156
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	90 93 02 01 	sts	0x0102, r25
     86a:	80 93 01 01 	sts	0x0101, r24
     86e:	08 95       	ret

00000870 <set_heartBlink>:
uint8_t heartBlink = 0;
//#define TOGGLETIME	(250*DMS_MS)

void set_heartBlink(uint8_t count)
{
	heartBlink = count;
     870:	80 93 06 01 	sts	0x0106, r24
     874:	08 95       	ret

00000876 <blinkHeart>:
#if (_HEART_DMS_)
#define TOGGLETIME   (250*DMS_MS)
//This function takes about 288 bytes
#warning "This may get cut, if the blink-rate is longer than 6sec!"
uint8_t blinkHeart(dms6sec_t currentTime)
{
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
	// This is True or False depending on 
	//  whether thisNibble is the high nibble
	static uint8_t highNibble = 0;
	

	uint8_t thisNibble = heartBlink;
     87a:	30 91 06 01 	lds	r19, 0x0106

	//If both nibbles are filled, process them as specified
	if((heartBlink & 0xf0) && (heartBlink & 0x0f))
     87e:	43 2f       	mov	r20, r19
     880:	40 7f       	andi	r20, 0xF0	; 240
     882:	23 2f       	mov	r18, r19
     884:	2f 70       	andi	r18, 0x0F	; 15
     886:	44 23       	and	r20, r20
     888:	31 f0       	breq	.+12     	; 0x896 <blinkHeart+0x20>
     88a:	21 11       	cpse	r18, r1
     88c:	07 c0       	rjmp	.+14     	; 0x89c <blinkHeart+0x26>
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
		highNibble = 0;
	else if(heartBlink & 0xf0)
		highNibble = 1;
     88e:	41 e0       	ldi	r20, 0x01	; 1
     890:	40 93 0c 01 	sts	0x010C, r20
     894:	03 c0       	rjmp	.+6      	; 0x89c <blinkHeart+0x26>
	{	//Fall through and toggle...
	}
	//Otherwise just process the one that's filled
	// to avoid long delays and hopefully make it easier to determine which
	// nibble is filled...
	else if(heartBlink & 0x0f)
     896:	21 11       	cpse	r18, r1
		highNibble = 0;
     898:	10 92 0c 01 	sts	0x010C, r1
	else if(heartBlink & 0xf0)
		highNibble = 1;

	//Fill the appropriate nibble for blinking...
	if(highNibble)
     89c:	e0 91 0c 01 	lds	r30, 0x010C
     8a0:	ee 23       	and	r30, r30
     8a2:	21 f0       	breq	.+8      	; 0x8ac <blinkHeart+0x36>
		thisNibble = (thisNibble & 0xf0) >> 4;
     8a4:	53 2f       	mov	r21, r19
     8a6:	52 95       	swap	r21
     8a8:	5f 70       	andi	r21, 0x0F	; 15
     8aa:	01 c0       	rjmp	.+2      	; 0x8ae <blinkHeart+0x38>
	else
		thisNibble = (thisNibble & 0x0f);
     8ac:	52 2f       	mov	r21, r18

	//Blink the proper number of times
	if((toggleCount>>1) < thisNibble)
     8ae:	40 91 0b 01 	lds	r20, 0x010B
     8b2:	64 2f       	mov	r22, r20
     8b4:	66 95       	lsr	r22
     8b6:	20 91 09 01 	lds	r18, 0x0109
     8ba:	30 91 0a 01 	lds	r19, 0x010A
     8be:	65 17       	cp	r22, r21
     8c0:	78 f4       	brcc	.+30     	; 0x8e0 <blinkHeart+0x6a>
	{
		if(currentTime - lastToggleTime > TOGGLETIME)
     8c2:	bc 01       	movw	r22, r24
     8c4:	62 1b       	sub	r22, r18
     8c6:	73 0b       	sbc	r23, r19
     8c8:	9b 01       	movw	r18, r22
     8ca:	25 3c       	cpi	r18, 0xC5	; 197
     8cc:	39 40       	sbci	r19, 0x09	; 9
     8ce:	48 f1       	brcs	.+82     	; 0x922 <blinkHeart+0xac>
		{
			lastToggleTime = currentTime;
     8d0:	90 93 0a 01 	sts	0x010A, r25
     8d4:	80 93 09 01 	sts	0x0109, r24
			toggleCount++;
     8d8:	4f 5f       	subi	r20, 0xFF	; 255
     8da:	40 93 0b 01 	sts	0x010B, r20
     8de:	21 c0       	rjmp	.+66     	; 0x922 <blinkHeart+0xac>
		}
	}
	//Wait for a while
#warning "There may be some integer promotion issues here..."
	else if(currentTime - lastToggleTime > 
     8e0:	8c 01       	movw	r16, r24
     8e2:	02 1b       	sub	r16, r18
     8e4:	13 0b       	sbc	r17, r19
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	30 e0       	ldi	r19, 0x00	; 0
						(((uint32_t)(TOGGLETIME * 8))<<(highNibble)))
     8ea:	40 e2       	ldi	r20, 0x20	; 32
     8ec:	5e e4       	ldi	r21, 0x4E	; 78
     8ee:	60 e0       	ldi	r22, 0x00	; 0
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	0e 2e       	mov	r0, r30
     8f4:	04 c0       	rjmp	.+8      	; 0x8fe <blinkHeart+0x88>
     8f6:	44 0f       	add	r20, r20
     8f8:	55 1f       	adc	r21, r21
     8fa:	66 1f       	adc	r22, r22
     8fc:	77 1f       	adc	r23, r23
     8fe:	0a 94       	dec	r0
     900:	d2 f7       	brpl	.-12     	; 0x8f6 <blinkHeart+0x80>
			toggleCount++;
		}
	}
	//Wait for a while
#warning "There may be some integer promotion issues here..."
	else if(currentTime - lastToggleTime > 
     902:	40 17       	cp	r20, r16
     904:	51 07       	cpc	r21, r17
     906:	62 07       	cpc	r22, r18
     908:	73 07       	cpc	r23, r19
     90a:	58 f4       	brcc	.+22     	; 0x922 <blinkHeart+0xac>
						(((uint32_t)(TOGGLETIME * 8))<<(highNibble)))
	{
		toggleCount = 0;
     90c:	10 92 0b 01 	sts	0x010B, r1
		lastToggleTime = currentTime;
     910:	90 93 0a 01 	sts	0x010A, r25
     914:	80 93 09 01 	sts	0x0109, r24
		//Only valid if both nibbles are filled (see above)
		highNibble = !highNibble;
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	e1 11       	cpse	r30, r1
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	80 93 0c 01 	sts	0x010C, r24
	}

	//(actually, the new value, at this point... but will be the last soon)
	return !getbit(0, toggleCount);
     922:	80 91 0b 01 	lds	r24, 0x010B
     926:	80 95       	com	r24
}
     928:	81 70       	andi	r24, 0x01	; 1
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	08 95       	ret

00000930 <heartUpdate>:
#endif

//This function takes about 186 bytes
// Really?! Or is hfm not compiled if it's not used?
uint8_t heartUpdate(void)
{	
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
}

__inline__ \
dms4day_t dmsGetTime(void)
{
	return dmsCount;
     938:	c0 90 0d 01 	lds	r12, 0x010D
     93c:	d0 90 0e 01 	lds	r13, 0x010E
     940:	e0 90 0f 01 	lds	r14, 0x010F
     944:	f0 90 10 01 	lds	r15, 0x0110
//	if(currentTime - lastTime > (HEART_ITERATIONCOUNT>>heartRate))
	//heartStepTime is number of updates, no corelation with actual seconds..
//#warning "heartStepTime without dms is untested"
#endif

	if((currentTime - lastTime) > heartStepTime)
     948:	80 91 07 01 	lds	r24, 0x0107
     94c:	90 91 08 01 	lds	r25, 0x0108
     950:	96 01       	movw	r18, r12
     952:	28 1b       	sub	r18, r24
     954:	39 0b       	sbc	r19, r25
     956:	80 91 01 01 	lds	r24, 0x0101
     95a:	90 91 02 01 	lds	r25, 0x0102
     95e:	82 17       	cp	r24, r18
     960:	93 07       	cpc	r25, r19
     962:	10 f5       	brcc	.+68     	; 0x9a8 <heartUpdate+0x78>
	{
		lastTime = currentTime;
     964:	d0 92 08 01 	sts	0x0108, r13
     968:	c0 92 07 01 	sts	0x0107, r12
#if (!defined(_WDT_DISABLE_) || !_WDT_DISABLE_)
	//Woot! Saved two bytes!
	wdt_reset();
#endif

	desired = (uint8_t)(heartModulator.power);
     96c:	80 91 1e 01 	lds	r24, 0x011E

	desired += direction;
     970:	60 91 00 01 	lds	r22, 0x0100
     974:	77 27       	eor	r23, r23
     976:	67 fd       	sbrc	r22, 7
     978:	70 95       	com	r23
     97a:	68 0f       	add	r22, r24
     97c:	71 1d       	adc	r23, r1
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
     97e:	6f 3f       	cpi	r22, 0xFF	; 255
     980:	71 05       	cpc	r23, r1
     982:	34 f0       	brlt	.+12     	; 0x990 <heartUpdate+0x60>
	{
		desired = HEART_MAXBRIGHT;
		direction = -1;
     984:	8f ef       	ldi	r24, 0xFF	; 255
     986:	80 93 00 01 	sts	0x0100, r24
	
	//Slightly slower not to have these internal to above, but also safer...
	
	if(desired >= HEART_MAXBRIGHT)
	{
		desired = HEART_MAXBRIGHT;
     98a:	6f ef       	ldi	r22, 0xFF	; 255
     98c:	70 e0       	ldi	r23, 0x00	; 0
     98e:	08 c0       	rjmp	.+16     	; 0x9a0 <heartUpdate+0x70>
		direction = -1;
	}	

	if(desired <= 0)
     990:	16 16       	cp	r1, r22
     992:	17 06       	cpc	r1, r23
     994:	2c f0       	brlt	.+10     	; 0x9a0 <heartUpdate+0x70>
	{
		desired = 0;
		direction = +1;
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	80 93 00 01 	sts	0x0100, r24
		direction = -1;
	}	

	if(desired <= 0)
	{
		desired = 0;
     99c:	60 e0       	ldi	r22, 0x00	; 0
     99e:	70 e0       	ldi	r23, 0x00	; 0

	if((currentTime - lastTime) > heartStepTime)
	{
		lastTime = currentTime;

		hfm_setPower(&heartModulator, getNextDesired());
     9a0:	8b e1       	ldi	r24, 0x1B	; 27
     9a2:	91 e0       	ldi	r25, 0x01	; 1
     9a4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <hfm_setPower>
	//determine whether the LED should be on or off based on the HFM
	// return TRUE if the pin is available as an input
	uint8_t ledVal;

#if (!defined(HEART_BLINK_UNUSED) || !HEART_BLINK_UNUSED)
	if(heartBlink)
     9a8:	80 91 06 01 	lds	r24, 0x0106
     9ac:	88 23       	and	r24, r24
     9ae:	21 f0       	breq	.+8      	; 0x9b8 <heartUpdate+0x88>
		ledVal = blinkHeart(currentTime);
     9b0:	c6 01       	movw	r24, r12
     9b2:	0e 94 3b 04 	call	0x876	; 0x876 <blinkHeart>
     9b6:	04 c0       	rjmp	.+8      	; 0x9c0 <heartUpdate+0x90>
		//ledVal = blinkHeart((dms6sec_t)currentTime);
	else
#endif
		ledVal = hfm_nextOutput(&heartModulator);
     9b8:	8b e1       	ldi	r24, 0x1B	; 27
     9ba:	91 e0       	ldi	r25, 0x01	; 1
     9bc:	0e 94 69 03 	call	0x6d2	; 0x6d2 <hfm_nextOutput>

	if(ledVal)
     9c0:	88 23       	and	r24, r24
     9c2:	21 f0       	breq	.+8      	; 0x9cc <heartUpdate+0x9c>
			setoutVar(heartBeatPin, heartPIN);
			setpinVar(heartBeatPin, heartPIN);
		}
#else
 #if (HEART_LEDCONNECTION == LED_DIRECT_HIGH)
		setinPORT(HEART_PINNUM, HEART_PINPORT);
     9c4:	26 98       	cbi	0x04, 6	; 4
		setpuPORT(HEART_PINNUM, HEART_PINPORT);
     9c6:	2e 9a       	sbi	0x05, 6	; 5
		setpinPORT(HEART_PINNUM, HEART_PINPORT);
 #else
	#error "Not Handled..."
 #endif
#endif
		return TRUE;
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	03 c0       	rjmp	.+6      	; 0x9d2 <heartUpdate+0xa2>
		//PORT = L
		clrpinVar(heartBeatPin, heartPIN);
		//DDR = H,out
		setoutVar(heartBeatPin, heartPIN);
#else
		clrpinPORT(HEART_PINNUM, HEART_PINPORT);
     9cc:	2e 98       	cbi	0x05, 6	; 5
		setoutPORT(HEART_PINNUM, HEART_PINPORT);
     9ce:	26 9a       	sbi	0x04, 6	; 4
#endif
		return FALSE;
     9d0:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     9d2:	ff 90       	pop	r15
     9d4:	ef 90       	pop	r14
     9d6:	df 90       	pop	r13
     9d8:	cf 90       	pop	r12
     9da:	08 95       	ret

000009dc <heartupdate>:

#if (!defined(DMS_WAITFN_UNUSED) || !DMS_WAITFN_UNUSED)
// This only saves 4 bytes...
void heartupdate(void)
{
	heartUpdate();
     9dc:	0c 94 98 04 	jmp	0x930	; 0x930 <heartUpdate>

000009e0 <heartPinInputPoll>:
	   asm("nop;");
	}

	pinState = getpinVar(heartBeatPin, heartPIN);
#else
	setinPORT(HEART_PINNUM, HEART_PINPORT);
     9e0:	26 98       	cbi	0x04, 6	; 4
	setpuPORT(HEART_PINNUM, HEART_PINPORT);
     9e2:	2e 9a       	sbi	0x05, 6	; 5
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
     9e6:	00 00       	nop
     9e8:	81 50       	subi	r24, 0x01	; 1
	setinPORT(HEART_PINNUM, HEART_PINPORT);
	setpuPORT(HEART_PINNUM, HEART_PINPORT);

	//Insert a delay to allow the pull-up to rise...
	uint8_t delay;
	for(delay = 0; delay < HEART_PULLUP_DELAY; delay++)
     9ea:	e9 f7       	brne	.-6      	; 0x9e6 <heartPinInputPoll+0x6>
	{
		//Necessary or this'll be optimised-out
		asm("nop;");
	}

	pinState = getpinPORT(HEART_PINNUM, HEART_PINPORT);
     9ec:	83 b1       	in	r24, 0x03	; 3
	// to assure valid/safe values of PORT and DDR...
	//Return the pin to the heartbeat
//	setoutVar(heartBeatPin, heartPIN);

	return pinState;
}
     9ee:	86 fb       	bst	r24, 6
     9f0:	88 27       	eor	r24, r24
     9f2:	80 f9       	bld	r24, 0
     9f4:	08 95       	ret

000009f6 <dmsWaitFn>:
//pt2Function = DoIt;      // short form
//pt2Function = &DoMore;   // correct assignment using address operator

#if (!defined(DMS_WAITFN_UNUSED) || !DMS_WAITFN_UNUSED)
void dmsWaitFn(uint32_t time, void (*p_waitFn)(void))		//Wait time deci-milliseconds
{
     9f6:	8f 92       	push	r8
     9f8:	9f 92       	push	r9
     9fa:	af 92       	push	r10
     9fc:	bf 92       	push	r11
     9fe:	cf 92       	push	r12
     a00:	df 92       	push	r13
     a02:	ef 92       	push	r14
     a04:	ff 92       	push	r15
     a06:	0f 93       	push	r16
     a08:	1f 93       	push	r17
     a0a:	cf 93       	push	r28
     a0c:	df 93       	push	r29
     a0e:	00 d0       	rcall	.+0      	; 0xa10 <dmsWaitFn+0x1a>
     a10:	00 d0       	rcall	.+0      	; 0xa12 <dmsWaitFn+0x1c>
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
     a16:	8a 01       	movw	r16, r20
}

__inline__ \
dms4day_t dmsGetTime(void)
{
	return dmsCount;
     a18:	c0 90 0d 01 	lds	r12, 0x010D
     a1c:	d0 90 0e 01 	lds	r13, 0x010E
     a20:	e0 90 0f 01 	lds	r14, 0x010F
     a24:	f0 90 10 01 	lds	r15, 0x0110
     a28:	80 90 0d 01 	lds	r8, 0x010D
     a2c:	90 90 0e 01 	lds	r9, 0x010E
     a30:	a0 90 0f 01 	lds	r10, 0x010F
     a34:	b0 90 10 01 	lds	r11, 0x0110
	uint32_t startTime;
	
	startTime = dmsGetTime();
	
	while(dmsGetTime() - startTime < time)
     a38:	8c 18       	sub	r8, r12
     a3a:	9d 08       	sbc	r9, r13
     a3c:	ae 08       	sbc	r10, r14
     a3e:	bf 08       	sbc	r11, r15
     a40:	86 16       	cp	r8, r22
     a42:	97 06       	cpc	r9, r23
     a44:	a8 06       	cpc	r10, r24
     a46:	b9 06       	cpc	r11, r25
     a48:	70 f4       	brcc	.+28     	; 0xa66 <dmsWaitFn+0x70>
		//else
		//   printf("Pointer not initialized!!\n");

		//WTF was I thinking?
      //if(*waitFn != 0)
		if(p_waitFn != 0)
     a4a:	01 15       	cp	r16, r1
     a4c:	11 05       	cpc	r17, r1
     a4e:	61 f3       	breq	.-40     	; 0xa28 <dmsWaitFn+0x32>
			// 2.5 calling a function using a function pointer
			//int result1 = pt2Function    (12, 'a', 'b');          // C short way
			//int result2 = (*pt2Function) (12, 'a', 'b');          // C
			
			//waitFn();
			(*p_waitFn)();
     a50:	69 83       	std	Y+1, r22	; 0x01
     a52:	7a 83       	std	Y+2, r23	; 0x02
     a54:	8b 83       	std	Y+3, r24	; 0x03
     a56:	9c 83       	std	Y+4, r25	; 0x04
     a58:	f8 01       	movw	r30, r16
     a5a:	09 95       	icall
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	8b 81       	ldd	r24, Y+3	; 0x03
     a60:	7a 81       	ldd	r23, Y+2	; 0x02
     a62:	69 81       	ldd	r22, Y+1	; 0x01
     a64:	e1 cf       	rjmp	.-62     	; 0xa28 <dmsWaitFn+0x32>
		}

	}

}
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	0f 90       	pop	r0
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	1f 91       	pop	r17
     a74:	0f 91       	pop	r16
     a76:	ff 90       	pop	r15
     a78:	ef 90       	pop	r14
     a7a:	df 90       	pop	r13
     a7c:	cf 90       	pop	r12
     a7e:	bf 90       	pop	r11
     a80:	af 90       	pop	r10
     a82:	9f 90       	pop	r9
     a84:	8f 90       	pop	r8
     a86:	08 95       	ret

00000a88 <coord_abs>:

coord_t coord_abs(coord_t value)
{
   //#define coord_abs(value) (((value) >= 0) ? (value) : -(value))
   //Can return 0
   if(value >= 0)
     a88:	97 ff       	sbrs	r25, 7
     a8a:	12 c0       	rjmp	.+36     	; 0xab0 <coord_abs+0x28>
      return value;
   else if(value < -(INT32_MAX)) //because INT32_MIN < -(INT32_MAX)
     a8c:	61 15       	cp	r22, r1
     a8e:	71 05       	cpc	r23, r1
     a90:	81 05       	cpc	r24, r1
     a92:	20 e8       	ldi	r18, 0x80	; 128
     a94:	92 07       	cpc	r25, r18
     a96:	41 f0       	breq	.+16     	; 0xaa8 <coord_abs+0x20>
      return INT32_MAX;
   else  // -INT32_MAX < value < 0
      return -value;
     a98:	90 95       	com	r25
     a9a:	80 95       	com	r24
     a9c:	70 95       	com	r23
     a9e:	61 95       	neg	r22
     aa0:	7f 4f       	sbci	r23, 0xFF	; 255
     aa2:	8f 4f       	sbci	r24, 0xFF	; 255
     aa4:	9f 4f       	sbci	r25, 0xFF	; 255
     aa6:	08 95       	ret
   //#define coord_abs(value) (((value) >= 0) ? (value) : -(value))
   //Can return 0
   if(value >= 0)
      return value;
   else if(value < -(INT32_MAX)) //because INT32_MIN < -(INT32_MAX)
      return INT32_MAX;
     aa8:	6f ef       	ldi	r22, 0xFF	; 255
     aaa:	7f ef       	ldi	r23, 0xFF	; 255
     aac:	8f ef       	ldi	r24, 0xFF	; 255
     aae:	9f e7       	ldi	r25, 0x7F	; 127
   else  // -INT32_MAX < value < 0
      return -value;
}
     ab0:	08 95       	ret

00000ab2 <coord_max>:


#if (!defined(COORD_MAX_UNUSED) || !COORD_MAX_UNUSED)
coord_t coord_max(coord_t value1, coord_t value2)
{
     ab2:	62 17       	cp	r22, r18
     ab4:	73 07       	cpc	r23, r19
     ab6:	84 07       	cpc	r24, r20
     ab8:	95 07       	cpc	r25, r21
     aba:	14 f4       	brge	.+4      	; 0xac0 <coord_max+0xe>
     abc:	ca 01       	movw	r24, r20
     abe:	b9 01       	movw	r22, r18
   if(value1 > value2)
      return value1;
   else
      return value2;
}
     ac0:	08 95       	ret

00000ac2 <coord_sign>:
#if (!defined(COORD_SIGN_UNUSED) || !COORD_SIGN_UNUSED)
int8_t coord_sign(coord_t value)
{
   //#define coord_sign(value) 
   //  (value ? ((value<0) ? -value : value) : 0)
   if(value > 0)
     ac2:	16 16       	cp	r1, r22
     ac4:	17 06       	cpc	r1, r23
     ac6:	18 06       	cpc	r1, r24
     ac8:	19 06       	cpc	r1, r25
     aca:	4c f0       	brlt	.+18     	; 0xade <coord_sign+0x1c>
      return 1;
   else if(value < 0)
     acc:	21 e0       	ldi	r18, 0x01	; 1
     ace:	67 2b       	or	r22, r23
     ad0:	68 2b       	or	r22, r24
     ad2:	69 2b       	or	r22, r25
     ad4:	09 f4       	brne	.+2      	; 0xad8 <coord_sign+0x16>
     ad6:	20 e0       	ldi	r18, 0x00	; 0
     ad8:	82 2f       	mov	r24, r18
     ada:	81 95       	neg	r24
     adc:	08 95       	ret
int8_t coord_sign(coord_t value)
{
   //#define coord_sign(value) 
   //  (value ? ((value<0) ? -value : value) : 0)
   if(value > 0)
      return 1;
     ade:	81 e0       	ldi	r24, 0x01	; 1
   else if(value < 0)
      return -1;
   else
      return 0;
}
     ae0:	08 95       	ret

00000ae2 <coord_limit>:
//    (what about limit-handling in gotoStepping?)

//Returns -1 or +1 if limited to the min or max, respectively
//Returns 0 if not limited
int8_t coord_limit(coord_t min, coord_t *val, coord_t max)
{
     ae2:	cf 92       	push	r12
     ae4:	df 92       	push	r13
     ae6:	ef 92       	push	r14
     ae8:	ff 92       	push	r15
     aea:	0f 93       	push	r16
     aec:	1f 93       	push	r17
     aee:	fa 01       	movw	r30, r20
	if(*val < min)
     af0:	c0 80       	ld	r12, Z
     af2:	d1 80       	ldd	r13, Z+1	; 0x01
     af4:	e2 80       	ldd	r14, Z+2	; 0x02
     af6:	f3 80       	ldd	r15, Z+3	; 0x03
     af8:	c6 16       	cp	r12, r22
     afa:	d7 06       	cpc	r13, r23
     afc:	e8 06       	cpc	r14, r24
     afe:	f9 06       	cpc	r15, r25
     b00:	34 f4       	brge	.+12     	; 0xb0e <coord_limit+0x2c>
	{
		*val = min;
     b02:	60 83       	st	Z, r22
     b04:	71 83       	std	Z+1, r23	; 0x01
     b06:	82 83       	std	Z+2, r24	; 0x02
     b08:	93 83       	std	Z+3, r25	; 0x03
		return -1;
     b0a:	8f ef       	ldi	r24, 0xFF	; 255
     b0c:	0c c0       	rjmp	.+24     	; 0xb26 <coord_limit+0x44>
	}
	else if(*val > max)
     b0e:	0c 15       	cp	r16, r12
     b10:	1d 05       	cpc	r17, r13
     b12:	2e 05       	cpc	r18, r14
     b14:	3f 05       	cpc	r19, r15
     b16:	34 f4       	brge	.+12     	; 0xb24 <coord_limit+0x42>
	{
		*val = max;
     b18:	00 83       	st	Z, r16
     b1a:	11 83       	std	Z+1, r17	; 0x01
     b1c:	22 83       	std	Z+2, r18	; 0x02
     b1e:	33 83       	std	Z+3, r19	; 0x03
		return 1;
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	01 c0       	rjmp	.+2      	; 0xb26 <coord_limit+0x44>
	}
	else
		return 0;
     b24:	80 e0       	ldi	r24, 0x00	; 0
}
     b26:	1f 91       	pop	r17
     b28:	0f 91       	pop	r16
     b2a:	ff 90       	pop	r15
     b2c:	ef 90       	pop	r14
     b2e:	df 90       	pop	r13
     b30:	cf 90       	pop	r12
     b32:	08 95       	ret

00000b34 <ucoord_limit>:

//Returns -1 or +1 if limited to the min or max, respectively
//Returns 0 if not limited
int8_t ucoord_limit(ucoord_t min, ucoord_t *val, ucoord_t max)
{
     b34:	cf 92       	push	r12
     b36:	df 92       	push	r13
     b38:	ef 92       	push	r14
     b3a:	ff 92       	push	r15
     b3c:	0f 93       	push	r16
     b3e:	1f 93       	push	r17
     b40:	fa 01       	movw	r30, r20
   if(*val < min)
     b42:	c0 80       	ld	r12, Z
     b44:	d1 80       	ldd	r13, Z+1	; 0x01
     b46:	e2 80       	ldd	r14, Z+2	; 0x02
     b48:	f3 80       	ldd	r15, Z+3	; 0x03
     b4a:	c6 16       	cp	r12, r22
     b4c:	d7 06       	cpc	r13, r23
     b4e:	e8 06       	cpc	r14, r24
     b50:	f9 06       	cpc	r15, r25
     b52:	30 f4       	brcc	.+12     	; 0xb60 <ucoord_limit+0x2c>
   {
      *val = min;
     b54:	60 83       	st	Z, r22
     b56:	71 83       	std	Z+1, r23	; 0x01
     b58:	82 83       	std	Z+2, r24	; 0x02
     b5a:	93 83       	std	Z+3, r25	; 0x03
      return -1;
     b5c:	8f ef       	ldi	r24, 0xFF	; 255
     b5e:	0c c0       	rjmp	.+24     	; 0xb78 <ucoord_limit+0x44>
   }
   else if(*val > max)
     b60:	0c 15       	cp	r16, r12
     b62:	1d 05       	cpc	r17, r13
     b64:	2e 05       	cpc	r18, r14
     b66:	3f 05       	cpc	r19, r15
     b68:	30 f4       	brcc	.+12     	; 0xb76 <ucoord_limit+0x42>
   {
      *val = max;
     b6a:	00 83       	st	Z, r16
     b6c:	11 83       	std	Z+1, r17	; 0x01
     b6e:	22 83       	std	Z+2, r18	; 0x02
     b70:	33 83       	std	Z+3, r19	; 0x03
      return 1;
     b72:	81 e0       	ldi	r24, 0x01	; 1
     b74:	01 c0       	rjmp	.+2      	; 0xb78 <ucoord_limit+0x44>
   }
   else
      return 0;
     b76:	80 e0       	ldi	r24, 0x00	; 0
}
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	ef 90       	pop	r14
     b80:	df 90       	pop	r13
     b82:	cf 90       	pop	r12
     b84:	08 95       	ret

00000b86 <xyt_init>:
//    0 if rise and run values are valid
//    Or the OR of the following:
//    0x01 if run was limited
//    0x02 if rise was limited
uint8_t xyt_init(xyt_t *line, coord_t rise, ucoord_t run)
{
     b86:	9f 92       	push	r9
     b88:	af 92       	push	r10
     b8a:	bf 92       	push	r11
     b8c:	cf 92       	push	r12
     b8e:	df 92       	push	r13
     b90:	ef 92       	push	r14
     b92:	ff 92       	push	r15
     b94:	0f 93       	push	r16
     b96:	1f 93       	push	r17
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	cd b7       	in	r28, 0x3d	; 61
     b9e:	de b7       	in	r29, 0x3e	; 62
     ba0:	2c 97       	sbiw	r28, 0x0c	; 12
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	de bf       	out	0x3e, r29	; 62
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	cd bf       	out	0x3d, r28	; 61
     bac:	5c 01       	movw	r10, r24
     bae:	49 83       	std	Y+1, r20	; 0x01
     bb0:	5a 83       	std	Y+2, r21	; 0x02
     bb2:	6b 83       	std	Y+3, r22	; 0x03
     bb4:	7c 83       	std	Y+4, r23	; 0x04
     bb6:	0d 83       	std	Y+5, r16	; 0x05
     bb8:	1e 83       	std	Y+6, r17	; 0x06
     bba:	2f 83       	std	Y+7, r18	; 0x07
     bbc:	38 87       	std	Y+8, r19	; 0x08
	uint8_t retVal = 0;

	//Track the sign of the rise (berfore making it unsigned)
	if(rise < 0)
     bbe:	77 ff       	sbrs	r23, 7
     bc0:	02 c0       	rjmp	.+4      	; 0xbc6 <xyt_init+0x40>
		line->outSign = -1;
     bc2:	8f ef       	ldi	r24, 0xFF	; 255
     bc4:	01 c0       	rjmp	.+2      	; 0xbc8 <xyt_init+0x42>
	else
		line->outSign = +1;
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	f5 01       	movw	r30, r10
     bca:	80 8b       	std	Z+16, r24	; 0x10


	//Check if the rise is out of range and fit it...
	// (still signed at this point)
	if(coord_limit(XYT_RISE_MIN, &rise, XYT_RISE_MAX))
     bcc:	0f ef       	ldi	r16, 0xFF	; 255
     bce:	1f ef       	ldi	r17, 0xFF	; 255
     bd0:	2f ef       	ldi	r18, 0xFF	; 255
     bd2:	3f e3       	ldi	r19, 0x3F	; 63
     bd4:	ae 01       	movw	r20, r28
     bd6:	4f 5f       	subi	r20, 0xFF	; 255
     bd8:	5f 4f       	sbci	r21, 0xFF	; 255
     bda:	61 e0       	ldi	r22, 0x01	; 1
     bdc:	70 e0       	ldi	r23, 0x00	; 0
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	90 ec       	ldi	r25, 0xC0	; 192
     be2:	0e 94 71 05 	call	0xae2	; 0xae2 <coord_limit>
     be6:	81 11       	cpse	r24, r1
     be8:	02 c0       	rjmp	.+4      	; 0xbee <xyt_init+0x68>
//    Or the OR of the following:
//    0x01 if run was limited
//    0x02 if rise was limited
uint8_t xyt_init(xyt_t *line, coord_t rise, ucoord_t run)
{
	uint8_t retVal = 0;
     bea:	91 2c       	mov	r9, r1
     bec:	02 c0       	rjmp	.+4      	; 0xbf2 <xyt_init+0x6c>


	//Check if the rise is out of range and fit it...
	// (still signed at this point)
	if(coord_limit(XYT_RISE_MIN, &rise, XYT_RISE_MAX))
		retVal |= 0x02;
     bee:	82 e0       	ldi	r24, 0x02	; 2
     bf0:	98 2e       	mov	r9, r24
	//    but it might make more sense to decrease the encoder resolution 
	//    and/or increase time resolution in the calling function...)
//	if (run == 0)
//		run = 1;

	if(ucoord_limit(XYT_RUN_MIN, &run, XYT_RUN_MAX))
     bf2:	0f ef       	ldi	r16, 0xFF	; 255
     bf4:	1f ef       	ldi	r17, 0xFF	; 255
     bf6:	2f ef       	ldi	r18, 0xFF	; 255
     bf8:	3f e7       	ldi	r19, 0x7F	; 127
     bfa:	ae 01       	movw	r20, r28
     bfc:	4b 5f       	subi	r20, 0xFB	; 251
     bfe:	5f 4f       	sbci	r21, 0xFF	; 255
     c00:	61 e0       	ldi	r22, 0x01	; 1
     c02:	70 e0       	ldi	r23, 0x00	; 0
     c04:	80 e0       	ldi	r24, 0x00	; 0
     c06:	90 e0       	ldi	r25, 0x00	; 0
     c08:	0e 94 9a 05 	call	0xb34	; 0xb34 <ucoord_limit>
     c0c:	88 23       	and	r24, r24
     c0e:	19 f0       	breq	.+6      	; 0xc16 <xyt_init+0x90>
		retVal |= 0x01;
     c10:	f9 2d       	mov	r31, r9
     c12:	f1 60       	ori	r31, 0x01	; 1
     c14:	9f 2e       	mov	r9, r31

//	if(coord_abs(rise) >= coord_abs(run))
//	{
		coord_t incBase = rise/run;
     c16:	c9 80       	ldd	r12, Y+1	; 0x01
     c18:	da 80       	ldd	r13, Y+2	; 0x02
     c1a:	eb 80       	ldd	r14, Y+3	; 0x03
     c1c:	fc 80       	ldd	r15, Y+4	; 0x04
     c1e:	2d 81       	ldd	r18, Y+5	; 0x05
     c20:	3e 81       	ldd	r19, Y+6	; 0x06
     c22:	4f 81       	ldd	r20, Y+7	; 0x07
     c24:	58 85       	ldd	r21, Y+8	; 0x08
     c26:	c7 01       	movw	r24, r14
     c28:	b6 01       	movw	r22, r12
     c2a:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <__udivmodsi4>
		//signed
		line->incrementBase = incBase;
     c2e:	f5 01       	movw	r30, r10
     c30:	24 83       	std	Z+4, r18	; 0x04
     c32:	35 83       	std	Z+5, r19	; 0x05
     c34:	46 83       	std	Z+6, r20	; 0x06
     c36:	57 83       	std	Z+7, r21	; 0x07
		//line->additionalRise = line->incrementBase * run;
		line->rise = coord_abs(rise) - coord_abs(incBase * run);
     c38:	c7 01       	movw	r24, r14
     c3a:	b6 01       	movw	r22, r12
     c3c:	29 87       	std	Y+9, r18	; 0x09
     c3e:	3a 87       	std	Y+10, r19	; 0x0a
     c40:	4b 87       	std	Y+11, r20	; 0x0b
     c42:	5c 87       	std	Y+12, r21	; 0x0c
     c44:	0e 94 44 05 	call	0xa88	; 0xa88 <coord_abs>
     c48:	6b 01       	movw	r12, r22
     c4a:	7c 01       	movw	r14, r24
     c4c:	6d 81       	ldd	r22, Y+5	; 0x05
     c4e:	7e 81       	ldd	r23, Y+6	; 0x06
     c50:	8f 81       	ldd	r24, Y+7	; 0x07
     c52:	98 85       	ldd	r25, Y+8	; 0x08
     c54:	29 85       	ldd	r18, Y+9	; 0x09
     c56:	3a 85       	ldd	r19, Y+10	; 0x0a
     c58:	4b 85       	ldd	r20, Y+11	; 0x0b
     c5a:	5c 85       	ldd	r21, Y+12	; 0x0c
     c5c:	0e 94 c7 0b 	call	0x178e	; 0x178e <__mulsi3>
     c60:	0e 94 44 05 	call	0xa88	; 0xa88 <coord_abs>
     c64:	c6 1a       	sub	r12, r22
     c66:	d7 0a       	sbc	r13, r23
     c68:	e8 0a       	sbc	r14, r24
     c6a:	f9 0a       	sbc	r15, r25
     c6c:	f5 01       	movw	r30, r10
     c6e:	c0 86       	std	Z+8, r12	; 0x08
     c70:	d1 86       	std	Z+9, r13	; 0x09
     c72:	e2 86       	std	Z+10, r14	; 0x0a
     c74:	f3 86       	std	Z+11, r15	; 0x0b
//	else
//	{
//		line->incrementBase = 0;
//		line->rise = 
//	}
	line->run = run;	//unsigned 31bits (32nd used in runningSum!)
     c76:	8d 81       	ldd	r24, Y+5	; 0x05
     c78:	9e 81       	ldd	r25, Y+6	; 0x06
     c7a:	af 81       	ldd	r26, Y+7	; 0x07
     c7c:	b8 85       	ldd	r27, Y+8	; 0x08
     c7e:	84 87       	std	Z+12, r24	; 0x0c
     c80:	95 87       	std	Z+13, r25	; 0x0d
     c82:	a6 87       	std	Z+14, r26	; 0x0e
     c84:	b7 87       	std	Z+15, r27	; 0x0f
//	line->rise = coord_abs(rise); //Also unsigned 30bit
	line->runningSum = 0;
     c86:	10 82       	st	Z, r1
     c88:	11 82       	std	Z+1, r1	; 0x01
     c8a:	12 82       	std	Z+2, r1	; 0x02
     c8c:	13 82       	std	Z+3, r1	; 0x03
	line->output = 0;
     c8e:	11 8a       	std	Z+17, r1	; 0x11
     c90:	12 8a       	std	Z+18, r1	; 0x12
     c92:	13 8a       	std	Z+19, r1	; 0x13
     c94:	14 8a       	std	Z+20, r1	; 0x14
	
	return retVal;
}
     c96:	89 2d       	mov	r24, r9
     c98:	2c 96       	adiw	r28, 0x0c	; 12
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	de bf       	out	0x3e, r29	; 62
     ca0:	0f be       	out	0x3f, r0	; 63
     ca2:	cd bf       	out	0x3d, r28	; 61
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	ff 90       	pop	r15
     cae:	ef 90       	pop	r14
     cb0:	df 90       	pop	r13
     cb2:	cf 90       	pop	r12
     cb4:	bf 90       	pop	r11
     cb6:	af 90       	pop	r10
     cb8:	9f 90       	pop	r9
     cba:	08 95       	ret

00000cbc <xyt_update>:


// Returns the amount of change during this update...
// the old: coord_t xyt_nextOutput(xyt_t *line) only slightly modified
coord_t xyt_update(xyt_t *line)
{
     cbc:	cf 92       	push	r12
     cbe:	df 92       	push	r13
     cc0:	ef 92       	push	r14
     cc2:	ff 92       	push	r15
     cc4:	0f 93       	push	r16
     cc6:	1f 93       	push	r17
     cc8:	fc 01       	movw	r30, r24
	coord_t thisChange = line->incrementBase; //0
     cca:	64 81       	ldd	r22, Z+4	; 0x04
     ccc:	75 81       	ldd	r23, Z+5	; 0x05
     cce:	86 81       	ldd	r24, Z+6	; 0x06
     cd0:	97 81       	ldd	r25, Z+7	; 0x07
	// In 32bit (unsigned): run is 31bits, rise is 30bits
	// then RISEMAX = 2^30-1 = 1,073,741,823
	// Seems like plenty for most coordinate-systems...
	// There *might* be a way to do this with integer-overflow
	//  but I can't determine how off-hand.
	line->runningSum += line->rise;
     cd2:	c0 80       	ld	r12, Z
     cd4:	d1 80       	ldd	r13, Z+1	; 0x01
     cd6:	e2 80       	ldd	r14, Z+2	; 0x02
     cd8:	f3 80       	ldd	r15, Z+3	; 0x03
     cda:	00 85       	ldd	r16, Z+8	; 0x08
     cdc:	11 85       	ldd	r17, Z+9	; 0x09
     cde:	22 85       	ldd	r18, Z+10	; 0x0a
     ce0:	33 85       	ldd	r19, Z+11	; 0x0b
     ce2:	0c 0d       	add	r16, r12
     ce4:	1d 1d       	adc	r17, r13
     ce6:	2e 1d       	adc	r18, r14
     ce8:	3f 1d       	adc	r19, r15
     cea:	00 83       	st	Z, r16
     cec:	11 83       	std	Z+1, r17	; 0x01
     cee:	22 83       	std	Z+2, r18	; 0x02
     cf0:	33 83       	std	Z+3, r19	; 0x03

	//This used to be "if" but rise>run requires "while"	
	// What a SIMPLE change!
	while(line->runningSum >= line->run)
     cf2:	c0 80       	ld	r12, Z
     cf4:	d1 80       	ldd	r13, Z+1	; 0x01
     cf6:	e2 80       	ldd	r14, Z+2	; 0x02
     cf8:	f3 80       	ldd	r15, Z+3	; 0x03
     cfa:	04 85       	ldd	r16, Z+12	; 0x0c
     cfc:	15 85       	ldd	r17, Z+13	; 0x0d
     cfe:	26 85       	ldd	r18, Z+14	; 0x0e
     d00:	37 85       	ldd	r19, Z+15	; 0x0f
     d02:	c0 16       	cp	r12, r16
     d04:	d1 06       	cpc	r13, r17
     d06:	e2 06       	cpc	r14, r18
     d08:	f3 06       	cpc	r15, r19
     d0a:	d8 f0       	brcs	.+54     	; 0xd42 <xyt_update+0x86>
	{
		line->runningSum -= line->run;
     d0c:	00 81       	ld	r16, Z
     d0e:	11 81       	ldd	r17, Z+1	; 0x01
     d10:	22 81       	ldd	r18, Z+2	; 0x02
     d12:	33 81       	ldd	r19, Z+3	; 0x03
     d14:	c4 84       	ldd	r12, Z+12	; 0x0c
     d16:	d5 84       	ldd	r13, Z+13	; 0x0d
     d18:	e6 84       	ldd	r14, Z+14	; 0x0e
     d1a:	f7 84       	ldd	r15, Z+15	; 0x0f
     d1c:	0c 19       	sub	r16, r12
     d1e:	1d 09       	sbc	r17, r13
     d20:	2e 09       	sbc	r18, r14
     d22:	3f 09       	sbc	r19, r15
     d24:	00 83       	st	Z, r16
     d26:	11 83       	std	Z+1, r17	; 0x01
     d28:	22 83       	std	Z+2, r18	; 0x02
     d2a:	33 83       	std	Z+3, r19	; 0x03
		//line->output += line->outSign;
      thisChange += line->outSign;
     d2c:	00 89       	ldd	r16, Z+16	; 0x10
     d2e:	11 27       	eor	r17, r17
     d30:	07 fd       	sbrc	r16, 7
     d32:	10 95       	com	r17
     d34:	21 2f       	mov	r18, r17
     d36:	31 2f       	mov	r19, r17
     d38:	60 0f       	add	r22, r16
     d3a:	71 1f       	adc	r23, r17
     d3c:	82 1f       	adc	r24, r18
     d3e:	93 1f       	adc	r25, r19
     d40:	d8 cf       	rjmp	.-80     	; 0xcf2 <xyt_update+0x36>
	}

	line->output += thisChange;
     d42:	01 89       	ldd	r16, Z+17	; 0x11
     d44:	12 89       	ldd	r17, Z+18	; 0x12
     d46:	23 89       	ldd	r18, Z+19	; 0x13
     d48:	34 89       	ldd	r19, Z+20	; 0x14
     d4a:	06 0f       	add	r16, r22
     d4c:	17 1f       	adc	r17, r23
     d4e:	28 1f       	adc	r18, r24
     d50:	39 1f       	adc	r19, r25
     d52:	01 8b       	std	Z+17, r16	; 0x11
     d54:	12 8b       	std	Z+18, r17	; 0x12
     d56:	23 8b       	std	Z+19, r18	; 0x13
     d58:	34 8b       	std	Z+20, r19	; 0x14
	return thisChange;
//	return line->output;
}
     d5a:	1f 91       	pop	r17
     d5c:	0f 91       	pop	r16
     d5e:	ff 90       	pop	r15
     d60:	ef 90       	pop	r14
     d62:	df 90       	pop	r13
     d64:	cf 90       	pop	r12
     d66:	08 95       	ret

00000d68 <xyt_remainder>:
*/

#if (!defined(XYT_REMAINDER_UNUSED) || !XYT_REMAINDER_UNUSED)
coord_t xyt_remainder(xyt_t *line)
{
	return line->runningSum;
     d68:	fc 01       	movw	r30, r24
     d6a:	60 81       	ld	r22, Z
     d6c:	71 81       	ldd	r23, Z+1	; 0x01
     d6e:	82 81       	ldd	r24, Z+2	; 0x02
     d70:	93 81       	ldd	r25, Z+3	; 0x03
}
     d72:	08 95       	ret

00000d74 <quadrantizeTheta>:
// negative values returned here are to be absoluted, first
// but they indicate that the resulting sine value is to be negated
theta_t quadrantizeTheta(theta_t theta)
{

	theta %= SINE_2PI;
     d74:	60 e0       	ldi	r22, 0x00	; 0
     d76:	72 e0       	ldi	r23, 0x02	; 2
     d78:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <__divmodhi4>

	if(theta < 0)
     d7c:	97 fd       	sbrc	r25, 7
		theta = SINE_2PI + theta;
     d7e:	9e 5f       	subi	r25, 0xFE	; 254

//For more accurate realtimeishness, it might be worthwhile to reverse this order...
	
	//in the first quadrant, just take the sine value from the table
	if(theta < SINE_SIZE-1) //128)
     d80:	80 38       	cpi	r24, 0x80	; 128
     d82:	91 05       	cpc	r25, r1
     d84:	84 f0       	brlt	.+32     	; 0xda6 <quadrantizeTheta+0x32>
	{
		//theta=theta;
	}	
	//in the second quadrant, mirror theta and subtract the offset
	else if(theta < SINE_SIZE2) //256)
     d86:	8f 3f       	cpi	r24, 0xFF	; 255
     d88:	91 05       	cpc	r25, r1
     d8a:	29 f0       	breq	.+10     	; 0xd96 <quadrantizeTheta+0x22>
     d8c:	24 f0       	brlt	.+8      	; 0xd96 <quadrantizeTheta+0x22>
	{
		theta=SINE_SIZE2-theta;
		//return pgm_read_sine(sineTable[SINE_SIZE2-theta]); //256-theta]);
	}
	//in the third quadrant, mirror the value and subtract the offset
	else if(theta < SINE_SIZE3) //384)
     d8e:	80 38       	cpi	r24, 0x80	; 128
     d90:	51 e0       	ldi	r21, 0x01	; 1
     d92:	95 07       	cpc	r25, r21
     d94:	3c f4       	brge	.+14     	; 0xda4 <quadrantizeTheta+0x30>
	{
		theta=-(theta-SINE_SIZE2);
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	31 e0       	ldi	r19, 0x01	; 1
     d9a:	a9 01       	movw	r20, r18
     d9c:	48 1b       	sub	r20, r24
     d9e:	59 0b       	sbc	r21, r25
     da0:	ca 01       	movw	r24, r20
     da2:	08 95       	ret
		//return -(sine_t)pgm_read_sine(sineTable[theta-SINE_SIZE2]); //256]);
	}
	//in the fourth quadrant, mirror both theta and the value and subtract the offset...
	else
	{
		theta=-(SINE_SIZE4-theta);
     da4:	92 50       	subi	r25, 0x02	; 2
		//negative=TRUE;
		//return -(sine_t)pgm_read_sine(sineTable[SINE_SIZE4-theta]); //512-theta]);
	}

	return theta;
}
     da6:	08 95       	ret

00000da8 <sineRaw>:
//output is a value between -INT32_MAX and INT32_MAX (representing sin values -1 to 1)
sine_t sineRaw(theta_t theta)
{
	uint8_t negative=FALSE;

	theta = quadrantizeTheta(theta);
     da8:	0e 94 ba 06 	call	0xd74	; 0xd74 <quadrantizeTheta>

	//This reduced code-size from 3860 to 3838
*/
	//adding quadrantizeTheta increased it to 3844
	// but should be dramatic in combination with sineRaw8
	if(theta < 0)
     dac:	97 ff       	sbrs	r25, 7
     dae:	05 c0       	rjmp	.+10     	; 0xdba <sineRaw+0x12>
	{
		theta = -theta;
     db0:	91 95       	neg	r25
     db2:	81 95       	neg	r24
     db4:	91 09       	sbc	r25, r1
		negative=TRUE;
     db6:	21 e0       	ldi	r18, 0x01	; 1
     db8:	01 c0       	rjmp	.+2      	; 0xdbc <sineRaw+0x14>
//theta is a value between 0 and 511 (representing an angle of 0-359.som'n deg)
//   rollover/wraparound should work fine... (e.g. Sine(coord_t))
//output is a value between -INT32_MAX and INT32_MAX (representing sin values -1 to 1)
sine_t sineRaw(theta_t theta)
{
	uint8_t negative=FALSE;
     dba:	20 e0       	ldi	r18, 0x00	; 0
	{
		theta = -theta;
		negative=TRUE;
	}

	sine_t sine=pgm_read_sine(sineTable[theta]);
     dbc:	fc 01       	movw	r30, r24
     dbe:	ee 0f       	add	r30, r30
     dc0:	ff 1f       	adc	r31, r31
     dc2:	e0 5b       	subi	r30, 0xB0	; 176
     dc4:	ff 4f       	sbci	r31, 0xFF	; 255
     dc6:	85 91       	lpm	r24, Z+
     dc8:	94 91       	lpm	r25, Z
	
	if(negative)
     dca:	22 23       	and	r18, r18
     dcc:	19 f0       	breq	.+6      	; 0xdd4 <sineRaw+0x2c>
		sine = -sine;
     dce:	91 95       	neg	r25
     dd0:	81 95       	neg	r24
     dd2:	91 09       	sbc	r25, r1
	return sine;
}
     dd4:	08 95       	ret

00000dd6 <sineRaw8>:
	   return -(int8_t)pgm_read_sine8(sineTable[SINE_SIZE4-theta]); 
	*/

	//And doing this here, reduced from 3844 to 3770
	uint8_t negative = FALSE;
	theta=quadrantizeTheta(theta);
     dd6:	0e 94 ba 06 	call	0xd74	; 0xd74 <quadrantizeTheta>

	if(theta < 0)
     dda:	97 ff       	sbrs	r25, 7
     ddc:	05 c0       	rjmp	.+10     	; 0xde8 <sineRaw8+0x12>
	{
		theta = -theta;
     dde:	91 95       	neg	r25
     de0:	81 95       	neg	r24
     de2:	91 09       	sbc	r25, r1
		negative = TRUE;
     de4:	21 e0       	ldi	r18, 0x01	; 1
     de6:	01 c0       	rjmp	.+2      	; 0xdea <sineRaw8+0x14>
	else
	   return -(int8_t)pgm_read_sine8(sineTable[SINE_SIZE4-theta]); 
	*/

	//And doing this here, reduced from 3844 to 3770
	uint8_t negative = FALSE;
     de8:	20 e0       	ldi	r18, 0x00	; 0
	{
		theta = -theta;
		negative = TRUE;
	}

	int8_t sine=pgm_read_sine8(sineTable[theta]);
     dea:	fc 01       	movw	r30, r24
     dec:	ee 0f       	add	r30, r30
     dee:	ff 1f       	adc	r31, r31
     df0:	ef 5a       	subi	r30, 0xAF	; 175
     df2:	ff 4f       	sbci	r31, 0xFF	; 255
     df4:	84 91       	lpm	r24, Z

	if(negative)
     df6:	21 11       	cpse	r18, r1
		sine = -sine;
     df8:	81 95       	neg	r24
	return sine;
}
     dfa:	08 95       	ret

00000dfc <pll_enable>:


void pll_enable(void)
{
#if(defined(__AVR_AT90PWM161__))
	pll_setMult(PLL_MULT_FACTOR);
     dfc:	80 91 87 00 	lds	r24, 0x0087
     e00:	83 7e       	andi	r24, 0xE3	; 227
     e02:	88 61       	ori	r24, 0x18	; 24
     e04:	80 93 87 00 	sts	0x0087, r24
   // The benefit of such high PWM frequency is the low RC values necessary
   //  for filtering to DC.
	// From the ATtiny861 manual:
	// "To change Timer/Counter1 to the async mode follow this procedure"
   // 1: Enable the PLL
   setbit(PLLE, PLLCSR);
     e08:	80 91 87 00 	lds	r24, 0x0087
     e0c:	82 60       	ori	r24, 0x02	; 2
     e0e:	80 93 87 00 	sts	0x0087, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e12:	8f e8       	ldi	r24, 0x8F	; 143
     e14:	91 e0       	ldi	r25, 0x01	; 1
     e16:	01 97       	sbiw	r24, 0x01	; 1
     e18:	f1 f7       	brne	.-4      	; 0xe16 <pll_enable+0x1a>
     e1a:	00 c0       	rjmp	.+0      	; 0xe1c <pll_enable+0x20>
     e1c:	00 00       	nop
   // 2: Wait 100us for the PLL to stabilize
   // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
   _delay_us(100);
//   dmsWait(1);
   // 3: Poll PLOCK until it is set...
   while(!getbit(PLOCK, PLLCSR))
     e1e:	80 91 87 00 	lds	r24, 0x0087
     e22:	80 fd       	sbrc	r24, 0
     e24:	02 c0       	rjmp	.+4      	; 0xe2a <pll_enable+0x2e>
   {
      asm("nop");
     e26:	00 00       	nop
     e28:	fa cf       	rjmp	.-12     	; 0xe1e <pll_enable+0x22>
#if(!defined(__AVR_AT90PWM161__))
   // 4: Set the PCKE bit to enable async mode
   setbit(PCKE, PLLCSR);
#endif

}
     e2a:	08 95       	ret

00000e2c <lvds_timerInit>:
#endif



void lvds_timerInit(void)
{
     e2c:	0f 93       	push	r16
  #if(defined(LVDS_MAXIMIZE_OSCCAL) && LVDS_MAXIMIZE_OSCCAL)
	OSCCAL = OSCCAL_VAL;
  #endif

  #if(defined(LVDS_USE_PLL) && LVDS_USE_PLL)
	pll_enable();
     e2e:	0e 94 fe 06 	call	0xdfc	; 0xdfc <pll_enable>
  #endif

	PSOC2 = (0<<POS23)	//PSCOUT23 outputs Waveform A if 1 or B if 0
     e32:	a5 e0       	ldi	r26, 0x05	; 5
     e34:	a0 93 6e 00 	sts	0x006E, r26
	//OCR2SB, OCR2RB	-> LVDS Clock
	// For one-ramp mode, OCR2RB determines the number of cycles (right?)
	// In order to make this work, the LVDS-CLK signal should be on this
	// channel...

	OCR2RB = 6;	//Count to 6, from 0, then reset the count
     e38:	46 e0       	ldi	r20, 0x06	; 6
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	59 bd       	out	0x29, r21	; 41
     e3e:	48 bd       	out	0x28, r20	; 40
	OCR2SB = 3;	// Toggle the lvds-clock high at edge 3 (0->3 = 4 bits off)
     e40:	23 e0       	ldi	r18, 0x03	; 3
     e42:	30 e0       	ldi	r19, 0x00	; 0
     e44:	37 bd       	out	0x27, r19	; 39
     e46:	26 bd       	out	0x26, r18	; 38
	// The outputs of the LVDS driver chips need to be swapped
	// (RXclk-/+)

	//OCR2SA/RA are used for DVH/Blue, and should be handled by this:
#if(!defined(PWM_TESTING) || !PWM_TESTING)
	Nada_init();
     e48:	ad 9a       	sbi	0x15, 5	; 21
     e4a:	82 e0       	ldi	r24, 0x02	; 2
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	90 93 65 00 	sts	0x0065, r25
     e52:	80 93 64 00 	sts	0x0064, r24
     e56:	64 e0       	ldi	r22, 0x04	; 4
     e58:	70 e0       	ldi	r23, 0x00	; 0
     e5a:	7f bd       	out	0x2f, r23	; 47
     e5c:	6e bd       	out	0x2e, r22	; 46
     e5e:	ad 98       	cbi	0x15, 5	; 21
	// 0   5   bits 6 and 0 are low
#endif

	//Also, forgot about FlankWidthModulation (?)

	PCNF2 = (0<<PFIFTY2)	//"Fifty-percent waveforms" unused
     e60:	66 e0       	ldi	r22, 0x06	; 6
     e62:	65 bb       	out	0x15, r22	; 21
			| (1<<PRUN2)  // START THE PSC
			;
#endif
	//A bunch of input configuration registers and capture registers

	POM2 = 0;	//PSC2 Output Matrix (unused)
     e64:	10 92 6f 00 	sts	0x006F, r1

	//NOTE: PSC2/PSCR I/O can be set to defaults on reset, via fuses


//These are for PSCR and closely match PSC2:
	PSOC0 = (0<<PISEL0A1)	//PSC Input A Select (along with PISEL0A0)
     e68:	a0 93 6a 00 	sts	0x006A, r26
	// But for now, I'll leave it with the written assumptions.
	//
	// OCR0RB determines the reset value of the counter, in one-ramp mode...
	// So its value should not change (regardless of whether it's Green or
	// Red)
	OCR0RB = 6; // count from 0->6, then reset
     e6c:	55 bd       	out	0x25, r21	; 37
     e6e:	44 bd       	out	0x24, r20	; 36

	//See notes re: Red OUTPUT INVERTED, green-matched, above.
	// Using R=5, we should be able to get away with simple math
	// see also setRed4()
	OCR0RA = 5;
     e70:	45 e0       	ldi	r20, 0x05	; 5
     e72:	50 e0       	ldi	r21, 0x00	; 0
     e74:	5b bd       	out	0x2b, r21	; 43
     e76:	4a bd       	out	0x2a, r20	; 42

	//These should handle configuring reasonable values for OCR0SA/RA/SB
#if(!defined(PWM_TESTING) || !PWM_TESTING)
	noGreen();
     e78:	8d 9a       	sbi	0x11, 5	; 17
     e7a:	33 bd       	out	0x23, r19	; 35
     e7c:	22 bd       	out	0x22, r18	; 34
     e7e:	8d 98       	cbi	0x11, 5	; 17
	noRed();
     e80:	8d 9a       	sbi	0x11, 5	; 17
     e82:	90 93 61 00 	sts	0x0061, r25
     e86:	80 93 60 00 	sts	0x0060, r24
     e8a:	8d 98       	cbi	0x11, 5	; 17
	OCR0SA = 5;
	OCR0RA = 6;
#endif

	//See PCNF2, above...
	PCNF0 = (0<<PFIFTY0)
     e8c:	82 e0       	ldi	r24, 0x02	; 2
     e8e:	81 bb       	out	0x11, r24	; 17
//Which is OK, since pctln_vals are constants...

//	uint8_t pctl2_val = 0x3f;
//	uint8_t pctl0_val = 0x7f;
	//delayCyc_setup(asdf, (int8_t)PSC_SYNC_CYCLES);
	delayCyc_setup(asdf, (int8_t)(PSC_SYNC_CYCLES));
     e90:	03 e1       	ldi	r16, 0x13	; 19
     e92:	ef e4       	ldi	r30, 0x4F	; 79
     e94:	f7 e0       	ldi	r31, 0x07	; 7

	__asm__ __volatile__
     e96:	81 e0       	ldi	r24, 0x01	; 1

00000e98 <dc_asm_init_asdf>:
     e98:	98 94       	clz

00000e9a <dc_asm_init_exit_asdf>:
     e9a:	86 bb       	out	0x16, r24	; 22

00000e9c <delayCycs_asdf>:
     e9c:	09 94       	ijmp

00000e9e <dc_loop_asdf>:
     e9e:	03 50       	subi	r16, 0x03	; 3
     ea0:	f4 f7       	brge	.-4      	; 0xe9e <dc_loop_asdf>

00000ea2 <dc_loopRemainder_asdf>:
     ea2:	0d 3f       	cpi	r16, 0xFD	; 253
     ea4:	19 f0       	breq	.+6      	; 0xeac <dc_done1_asdf>
     ea6:	0e 3f       	cpi	r16, 0xFE	; 254
     ea8:	11 f0       	breq	.+4      	; 0xeae <dc_done_asdf>
     eaa:	00 00       	nop

00000eac <dc_done1_asdf>:
     eac:	00 00       	nop

00000eae <dc_done_asdf>:
     eae:	82 bb       	out	0x12, r24	; 18

	//PIM0: Interrupt Mask Register, unused
	//PIFR0: Interrupt Flag Register, unused


}
     eb0:	0f 91       	pop	r16
     eb2:	08 95       	ret

00000eb4 <setColor>:
//This was #if'd into existence with IMAGE_BUFFER, but since it's only been
// used with frameBuffer, and since IMAGE_BUFFER is somewhat entangled with
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
     eb4:	0f 93       	push	r16
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     eb6:	90 e1       	ldi	r25, 0x10	; 16
     eb8:	29 9f       	mul	r18, r25
     eba:	f0 01       	movw	r30, r0
     ebc:	11 24       	eor	r1, r1
     ebe:	e0 0f       	add	r30, r16
     ec0:	f1 1d       	adc	r31, r1
     ec2:	ec 5c       	subi	r30, 0xCC	; 204
     ec4:	fe 4f       	sbci	r31, 0xFE	; 254
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;
     ec6:	44 30       	cpi	r20, 0x04	; 4
     ec8:	08 f0       	brcs	.+2      	; 0xecc <setColor+0x18>
     eca:	43 e0       	ldi	r20, 0x03	; 3

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     ecc:	90 e1       	ldi	r25, 0x10	; 16
     ece:	49 9f       	mul	r20, r25
     ed0:	90 01       	movw	r18, r0
     ed2:	11 24       	eor	r1, r1
// used with frameBuffer, and since IMAGE_BUFFER is somewhat entangled with
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
     ed4:	84 30       	cpi	r24, 0x04	; 4
     ed6:	08 f0       	brcs	.+2      	; 0xeda <setColor+0x26>
     ed8:	83 e0       	ldi	r24, 0x03	; 3
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     eda:	28 2b       	or	r18, r24
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
     edc:	64 30       	cpi	r22, 0x04	; 4
     ede:	08 f0       	brcs	.+2      	; 0xee2 <setColor+0x2e>
     ee0:	63 e0       	ldi	r22, 0x03	; 3
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     ee2:	84 e0       	ldi	r24, 0x04	; 4
     ee4:	68 9f       	mul	r22, r24
     ee6:	b0 01       	movw	r22, r0
     ee8:	11 24       	eor	r1, r1
     eea:	62 2b       	or	r22, r18
     eec:	60 83       	st	Z, r22
}
     eee:	0f 91       	pop	r16
     ef0:	08 95       	ret

00000ef2 <frameBufferInit>:
// This stuff was located in main() before the while loop...
// #if !COLOR_BAR_SCROLL... (which is *nearly every case* including 
//  RowSegBuffer, etc)
// it's long-since been commented-out...
void frameBufferInit(void)
{
     ef2:	08 95       	ret

00000ef4 <smileyUpdate>:
//Call this often, and the framebuffer will alternate between two
//smiley-faces. Also, it places a gradient in the background, which scrolls
//over time.
//Returns TRUE if there's a change to the frameBuffer image
uint8_t smileyUpdate(void)
{
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
   static uint16_t updateCount = 0;
   static uint8_t colorShift = 0;

   //colorShift++;

   updateCount++;
     ef8:	80 91 19 01 	lds	r24, 0x0119
     efc:	90 91 1a 01 	lds	r25, 0x011A
     f00:	01 96       	adiw	r24, 0x01	; 1
     f02:	90 93 1a 01 	sts	0x011A, r25
     f06:	80 93 19 01 	sts	0x0119, r24

   if(updateCount % 32 == 0)
     f0a:	9c 01       	movw	r18, r24
     f0c:	2f 71       	andi	r18, 0x1F	; 31
     f0e:	33 27       	eor	r19, r19
     f10:	23 2b       	or	r18, r19
     f12:	29 f4       	brne	.+10     	; 0xf1e <smileyUpdate+0x2a>
      colorShift++;
     f14:	20 91 18 01 	lds	r18, 0x0118
     f18:	2f 5f       	subi	r18, 0xFF	; 255
     f1a:	20 93 18 01 	sts	0x0118, r18

   if(updateCount == 64) //1000)
     f1e:	80 34       	cpi	r24, 0x40	; 64
     f20:	91 05       	cpc	r25, r1
     f22:	89 f4       	brne	.+34     	; 0xf46 <smileyUpdate+0x52>
   {
      updateCount = 0;
     f24:	10 92 1a 01 	sts	0x011A, r1
     f28:	10 92 19 01 	sts	0x0119, r1

      if(imageNum == 0)
     f2c:	80 91 17 01 	lds	r24, 0x0117
     f30:	81 11       	cpse	r24, r1
     f32:	14 c0       	rjmp	.+40     	; 0xf5c <smileyUpdate+0x68>
      {
         imageNum = 1;
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	80 93 17 01 	sts	0x0117, r24
         pimage = pgm_image1;
     f3a:	82 e5       	ldi	r24, 0x52	; 82
     f3c:	92 e0       	ldi	r25, 0x02	; 2
     f3e:	90 93 04 01 	sts	0x0104, r25
     f42:	80 93 03 01 	sts	0x0103, r24
      {
         uint8_t imagePixel=pgm_readImageByte(pimage, row, col);

   
         if(imagePixel == Tr)
            frameBufferChange(&imageChanged, row, col,
     f46:	d0 91 18 01 	lds	r29, 0x0118
     f4a:	64 e3       	ldi	r22, 0x34	; 52
     f4c:	71 e0       	ldi	r23, 0x01	; 1
     f4e:	40 91 03 01 	lds	r20, 0x0103
     f52:	50 91 04 01 	lds	r21, 0x0104
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	05 c0       	rjmp	.+10     	; 0xf66 <smileyUpdate+0x72>
      }
      else
      {
         //   hexColor++;
         //   hexColor&=0x3f;
         imageNum = 0;
     f5c:	10 92 17 01 	sts	0x0117, r1
         pimage = pgm_image2;
     f60:	82 e5       	ldi	r24, 0x52	; 82
     f62:	91 e0       	ldi	r25, 0x01	; 1
     f64:	ec cf       	rjmp	.-40     	; 0xf3e <smileyUpdate+0x4a>
     f66:	c9 2f       	mov	r28, r25
     f68:	cd 0f       	add	r28, r29
//Call this often, and the framebuffer will alternate between two
//smiley-faces. Also, it places a gradient in the background, which scrolls
//over time.
//Returns TRUE if there's a change to the frameBuffer image
uint8_t smileyUpdate(void)
{
     f6a:	20 e0       	ldi	r18, 0x00	; 0
     f6c:	30 e0       	ldi	r19, 0x00	; 0
     f6e:	f9 01       	movw	r30, r18
     f70:	e4 0f       	add	r30, r20
     f72:	f5 1f       	adc	r31, r21
   uint8_t row, col; //, colorShift=0;

   for(row=0; row<FB_HEIGHT; row++)
      for(col=0; col<FB_WIDTH; col++)
      {
         uint8_t imagePixel=pgm_readImageByte(pimage, row, col);
     f74:	e4 91       	lpm	r30, Z
     f76:	db 01       	movw	r26, r22
     f78:	a2 0f       	add	r26, r18
     f7a:	b3 1f       	adc	r27, r19

   
         if(imagePixel == Tr)
     f7c:	e0 3c       	cpi	r30, 0xC0	; 192
     f7e:	11 f4       	brne	.+4      	; 0xf84 <smileyUpdate+0x90>
     f80:	ec 2f       	mov	r30, r28
     f82:	e2 0f       	add	r30, r18
// and the end-value of bufferChanged will either be FALSE if no change, or
// TRUE if there was a change in any of the loops.
void frameBufferChange(uint8_t *bufferChanged, 
							uint8_t row, uint8_t col, uint8_t color)
{
	if(frameBuffer[(row)][(col)] != (color))
     f84:	fc 91       	ld	r31, X
     f86:	fe 17       	cp	r31, r30
     f88:	11 f0       	breq	.+4      	; 0xf8e <smileyUpdate+0x9a>
	{
		frameBuffer[(row)][(col)] = (color);
     f8a:	ec 93       	st	X, r30
		
		if(bufferChanged != NULL)
			*bufferChanged = TRUE;
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	2f 5f       	subi	r18, 0xFF	; 255
     f90:	3f 4f       	sbci	r19, 0xFF	; 255
   }

   uint8_t row, col; //, colorShift=0;

   for(row=0; row<FB_HEIGHT; row++)
      for(col=0; col<FB_WIDTH; col++)
     f92:	20 31       	cpi	r18, 0x10	; 16
     f94:	31 05       	cpc	r19, r1
     f96:	59 f7       	brne	.-42     	; 0xf6e <smileyUpdate+0x7a>
      }
   }

   uint8_t row, col; //, colorShift=0;

   for(row=0; row<FB_HEIGHT; row++)
     f98:	9f 5f       	subi	r25, 0xFF	; 255
     f9a:	60 5f       	subi	r22, 0xF0	; 240
     f9c:	7f 4f       	sbci	r23, 0xFF	; 255
     f9e:	40 5f       	subi	r20, 0xF0	; 240
     fa0:	5f 4f       	sbci	r21, 0xFF	; 255
     fa2:	90 31       	cpi	r25, 0x10	; 16
     fa4:	01 f7       	brne	.-64     	; 0xf66 <smileyUpdate+0x72>
         else
            frameBufferChange(&imageChanged, row, col, imagePixel);
      }  

	return imageChanged;
}
     fa6:	df 91       	pop	r29
     fa8:	cf 91       	pop	r28
     faa:	08 95       	ret

00000fac <nonRSB_drawPix>:
{
   //uint8_t *setting = &(settingBuffer[rowNum][0]);
#if(defined(ROW_BUFFER) && ROW_BUFFER)
   uint8_t *color = &(rowBuffer[0]);
#else
	rowNum = rowNum*FB_HEIGHT / V_COUNT;
     fac:	24 e0       	ldi	r18, 0x04	; 4
     fae:	88 0f       	add	r24, r24
     fb0:	99 1f       	adc	r25, r25
     fb2:	2a 95       	dec	r18
     fb4:	e1 f7       	brne	.-8      	; 0xfae <nonRSB_drawPix+0x2>
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	73 e0       	ldi	r23, 0x03	; 3
     fba:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <__udivmodhi4>
     fbe:	fb 01       	movw	r30, r22
//	rowNum &= 0x0f;
	uint8_t *color = &(frameBuffer[rowNum][0]);
     fc0:	34 e0       	ldi	r19, 0x04	; 4
     fc2:	ee 0f       	add	r30, r30
     fc4:	ff 1f       	adc	r31, r31
     fc6:	3a 95       	dec	r19
     fc8:	e1 f7       	brne	.-8      	; 0xfc2 <nonRSB_drawPix+0x16>
     fca:	ec 5c       	subi	r30, 0xCC	; 204
     fcc:	fe 4f       	sbci	r31, 0xFE	; 254
	// WTF... this didn't work without DEonly_init();
	// despite the fact that writeColor() on the 161 sets DE?!
	// AND it worked on the Tiny861 without this?!
	// No... writeColor doesn't change one register, which needs to be set
	// for blue...
	DEonly_init();
     fce:	ad 9a       	sbi	0x15, 5	; 21
     fd0:	81 e0       	ldi	r24, 0x01	; 1
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	90 93 65 00 	sts	0x0065, r25
     fd8:	80 93 64 00 	sts	0x0064, r24
     fdc:	84 e0       	ldi	r24, 0x04	; 4
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	9f bd       	out	0x2f, r25	; 47
     fe2:	8e bd       	out	0x2e, r24	; 46
     fe4:	ad 98       	cbi	0x15, 5	; 21

   //Judging by some weird experiences re v21/22,
   // it's not entirely likely this will be predictable
   // it may try to recalculate the Z register between writeBlues...
   // hopefully not, for now. I should probably assemblify this
      writeColor(FALSE, *(color+0));
     fe6:	30 81       	ld	r19, Z
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
     fe8:	23 2f       	mov	r18, r19
     fea:	26 95       	lsr	r18
     fec:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
     fee:	82 2f       	mov	r24, r18
     ff0:	86 95       	lsr	r24
     ff2:	86 95       	lsr	r24
     ff4:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
     ff6:	94 e0       	ldi	r25, 0x04	; 4
     ff8:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
     ffa:	83 30       	cpi	r24, 0x03	; 3
     ffc:	09 f4       	brne	.+2      	; 0x1000 <nothingToDo_271>
     ffe:	98 e0       	ldi	r25, 0x08	; 8

00001000 <nothingToDo_271>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1000:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1002:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1004:	83 2f       	mov	r24, r19
    1006:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1008:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    100a:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    100c:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    100e:	90 93 4e 00 	sts	0x004E, r25
    1012:	80 93 60 00 	sts	0x0060, r24
    1016:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    101a:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    101c:	ad 98       	cbi	0x15, 5	; 21
    101e:	87 e0       	ldi	r24, 0x07	; 7
    1020:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1022:	00 00       	nop
      asm("nop");
    1024:	00 00       	nop
    1026:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1028:	00 97       	sbiw	r24, 0x00	; 0
    102a:	d9 f7       	brne	.-10     	; 0x1022 <nothingToDo_271+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    102c:	00 00       	nop
		case 3:
			asm("nop");
    102e:	00 00       	nop
		case 2:
			asm("nop");
    1030:	00 00       	nop
		case 1:
			asm("nop");
    1032:	00 00       	nop
      // (v29 has ~1/8in of noise, v30 has ~1pixel noise at the right edge)
//      TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
    1034:	31 81       	ldd	r19, Z+1	; 0x01
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1036:	23 2f       	mov	r18, r19
    1038:	26 95       	lsr	r18
    103a:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    103c:	82 2f       	mov	r24, r18
    103e:	86 95       	lsr	r24
    1040:	86 95       	lsr	r24
    1042:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1044:	94 e0       	ldi	r25, 0x04	; 4
    1046:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1048:	83 30       	cpi	r24, 0x03	; 3
    104a:	09 f4       	brne	.+2      	; 0x104e <nothingToDo_319>
    104c:	98 e0       	ldi	r25, 0x08	; 8

0000104e <nothingToDo_319>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    104e:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1050:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1052:	83 2f       	mov	r24, r19
    1054:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1056:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1058:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    105a:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    105c:	90 93 4e 00 	sts	0x004E, r25
    1060:	80 93 60 00 	sts	0x0060, r24
    1064:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1068:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    106a:	ad 98       	cbi	0x15, 5	; 21
    106c:	87 e0       	ldi	r24, 0x07	; 7
    106e:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1070:	00 00       	nop
      asm("nop");
    1072:	00 00       	nop
    1074:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	d9 f7       	brne	.-10     	; 0x1070 <nothingToDo_319+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    107a:	00 00       	nop
		case 3:
			asm("nop");
    107c:	00 00       	nop
		case 2:
			asm("nop");
    107e:	00 00       	nop
		case 1:
			asm("nop");
    1080:	00 00       	nop
//      TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
    1082:	32 81       	ldd	r19, Z+2	; 0x02
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1084:	23 2f       	mov	r18, r19
    1086:	26 95       	lsr	r18
    1088:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    108a:	82 2f       	mov	r24, r18
    108c:	86 95       	lsr	r24
    108e:	86 95       	lsr	r24
    1090:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1092:	94 e0       	ldi	r25, 0x04	; 4
    1094:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1096:	83 30       	cpi	r24, 0x03	; 3
    1098:	09 f4       	brne	.+2      	; 0x109c <nothingToDo_367>
    109a:	98 e0       	ldi	r25, 0x08	; 8

0000109c <nothingToDo_367>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    109c:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    109e:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    10a0:	83 2f       	mov	r24, r19
    10a2:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    10a4:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    10a6:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    10a8:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    10aa:	90 93 4e 00 	sts	0x004E, r25
    10ae:	80 93 60 00 	sts	0x0060, r24
    10b2:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    10b6:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    10b8:	ad 98       	cbi	0x15, 5	; 21
    10ba:	87 e0       	ldi	r24, 0x07	; 7
    10bc:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    10be:	00 00       	nop
      asm("nop");
    10c0:	00 00       	nop
    10c2:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    10c4:	00 97       	sbiw	r24, 0x00	; 0
    10c6:	d9 f7       	brne	.-10     	; 0x10be <nothingToDo_367+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    10c8:	00 00       	nop
		case 3:
			asm("nop");
    10ca:	00 00       	nop
		case 2:
			asm("nop");
    10cc:	00 00       	nop
		case 1:
			asm("nop");
    10ce:	00 00       	nop
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
    10d0:	33 81       	ldd	r19, Z+3	; 0x03
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    10d2:	23 2f       	mov	r18, r19
    10d4:	26 95       	lsr	r18
    10d6:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    10d8:	82 2f       	mov	r24, r18
    10da:	86 95       	lsr	r24
    10dc:	86 95       	lsr	r24
    10de:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    10e0:	94 e0       	ldi	r25, 0x04	; 4
    10e2:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    10e4:	83 30       	cpi	r24, 0x03	; 3
    10e6:	09 f4       	brne	.+2      	; 0x10ea <nothingToDo_415>
    10e8:	98 e0       	ldi	r25, 0x08	; 8

000010ea <nothingToDo_415>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    10ea:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    10ec:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    10ee:	83 2f       	mov	r24, r19
    10f0:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    10f2:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    10f4:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    10f6:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    10f8:	90 93 4e 00 	sts	0x004E, r25
    10fc:	80 93 60 00 	sts	0x0060, r24
    1100:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1104:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1106:	ad 98       	cbi	0x15, 5	; 21
    1108:	87 e0       	ldi	r24, 0x07	; 7
    110a:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    110c:	00 00       	nop
      asm("nop");
    110e:	00 00       	nop
    1110:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1112:	00 97       	sbiw	r24, 0x00	; 0
    1114:	d9 f7       	brne	.-10     	; 0x110c <nothingToDo_415+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1116:	00 00       	nop
		case 3:
			asm("nop");
    1118:	00 00       	nop
		case 2:
			asm("nop");
    111a:	00 00       	nop
		case 1:
			asm("nop");
    111c:	00 00       	nop
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
    111e:	34 81       	ldd	r19, Z+4	; 0x04
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1120:	23 2f       	mov	r18, r19
    1122:	26 95       	lsr	r18
    1124:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1126:	82 2f       	mov	r24, r18
    1128:	86 95       	lsr	r24
    112a:	86 95       	lsr	r24
    112c:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    112e:	94 e0       	ldi	r25, 0x04	; 4
    1130:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1132:	83 30       	cpi	r24, 0x03	; 3
    1134:	09 f4       	brne	.+2      	; 0x1138 <nothingToDo_463>
    1136:	98 e0       	ldi	r25, 0x08	; 8

00001138 <nothingToDo_463>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1138:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    113a:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    113c:	83 2f       	mov	r24, r19
    113e:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1140:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1142:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1144:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1146:	90 93 4e 00 	sts	0x004E, r25
    114a:	80 93 60 00 	sts	0x0060, r24
    114e:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1152:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1154:	ad 98       	cbi	0x15, 5	; 21
    1156:	87 e0       	ldi	r24, 0x07	; 7
    1158:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    115a:	00 00       	nop
      asm("nop");
    115c:	00 00       	nop
    115e:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1160:	00 97       	sbiw	r24, 0x00	; 0
    1162:	d9 f7       	brne	.-10     	; 0x115a <nothingToDo_463+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1164:	00 00       	nop
		case 3:
			asm("nop");
    1166:	00 00       	nop
		case 2:
			asm("nop");
    1168:	00 00       	nop
		case 1:
			asm("nop");
    116a:	00 00       	nop

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
    116c:	35 81       	ldd	r19, Z+5	; 0x05
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    116e:	23 2f       	mov	r18, r19
    1170:	26 95       	lsr	r18
    1172:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1174:	82 2f       	mov	r24, r18
    1176:	86 95       	lsr	r24
    1178:	86 95       	lsr	r24
    117a:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    117c:	94 e0       	ldi	r25, 0x04	; 4
    117e:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1180:	83 30       	cpi	r24, 0x03	; 3
    1182:	09 f4       	brne	.+2      	; 0x1186 <nothingToDo_511>
    1184:	98 e0       	ldi	r25, 0x08	; 8

00001186 <nothingToDo_511>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1186:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1188:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    118a:	83 2f       	mov	r24, r19
    118c:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    118e:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1190:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1192:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1194:	90 93 4e 00 	sts	0x004E, r25
    1198:	80 93 60 00 	sts	0x0060, r24
    119c:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    11a0:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    11a2:	ad 98       	cbi	0x15, 5	; 21
    11a4:	87 e0       	ldi	r24, 0x07	; 7
    11a6:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    11a8:	00 00       	nop
      asm("nop");
    11aa:	00 00       	nop
    11ac:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    11ae:	00 97       	sbiw	r24, 0x00	; 0
    11b0:	d9 f7       	brne	.-10     	; 0x11a8 <nothingToDo_511+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    11b2:	00 00       	nop
		case 3:
			asm("nop");
    11b4:	00 00       	nop
		case 2:
			asm("nop");
    11b6:	00 00       	nop
		case 1:
			asm("nop");
    11b8:	00 00       	nop
      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
    11ba:	36 81       	ldd	r19, Z+6	; 0x06
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    11bc:	23 2f       	mov	r18, r19
    11be:	26 95       	lsr	r18
    11c0:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    11c2:	82 2f       	mov	r24, r18
    11c4:	86 95       	lsr	r24
    11c6:	86 95       	lsr	r24
    11c8:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    11ca:	94 e0       	ldi	r25, 0x04	; 4
    11cc:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    11ce:	83 30       	cpi	r24, 0x03	; 3
    11d0:	09 f4       	brne	.+2      	; 0x11d4 <nothingToDo_559>
    11d2:	98 e0       	ldi	r25, 0x08	; 8

000011d4 <nothingToDo_559>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    11d4:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    11d6:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    11d8:	83 2f       	mov	r24, r19
    11da:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    11dc:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    11de:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    11e0:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    11e2:	90 93 4e 00 	sts	0x004E, r25
    11e6:	80 93 60 00 	sts	0x0060, r24
    11ea:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    11ee:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    11f0:	ad 98       	cbi	0x15, 5	; 21
    11f2:	87 e0       	ldi	r24, 0x07	; 7
    11f4:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    11f6:	00 00       	nop
      asm("nop");
    11f8:	00 00       	nop
    11fa:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    11fc:	00 97       	sbiw	r24, 0x00	; 0
    11fe:	d9 f7       	brne	.-10     	; 0x11f6 <nothingToDo_559+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1200:	00 00       	nop
		case 3:
			asm("nop");
    1202:	00 00       	nop
		case 2:
			asm("nop");
    1204:	00 00       	nop
		case 1:
			asm("nop");
    1206:	00 00       	nop
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
    1208:	37 81       	ldd	r19, Z+7	; 0x07
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    120a:	23 2f       	mov	r18, r19
    120c:	26 95       	lsr	r18
    120e:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1210:	82 2f       	mov	r24, r18
    1212:	86 95       	lsr	r24
    1214:	86 95       	lsr	r24
    1216:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1218:	94 e0       	ldi	r25, 0x04	; 4
    121a:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    121c:	83 30       	cpi	r24, 0x03	; 3
    121e:	09 f4       	brne	.+2      	; 0x1222 <nothingToDo_607>
    1220:	98 e0       	ldi	r25, 0x08	; 8

00001222 <nothingToDo_607>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1222:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1224:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1226:	83 2f       	mov	r24, r19
    1228:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    122a:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    122c:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    122e:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1230:	90 93 4e 00 	sts	0x004E, r25
    1234:	80 93 60 00 	sts	0x0060, r24
    1238:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    123c:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    123e:	ad 98       	cbi	0x15, 5	; 21
    1240:	87 e0       	ldi	r24, 0x07	; 7
    1242:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1244:	00 00       	nop
      asm("nop");
    1246:	00 00       	nop
    1248:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    124a:	00 97       	sbiw	r24, 0x00	; 0
    124c:	d9 f7       	brne	.-10     	; 0x1244 <nothingToDo_607+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    124e:	00 00       	nop
		case 3:
			asm("nop");
    1250:	00 00       	nop
		case 2:
			asm("nop");
    1252:	00 00       	nop
		case 1:
			asm("nop");
    1254:	00 00       	nop
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
    1256:	30 85       	ldd	r19, Z+8	; 0x08
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1258:	23 2f       	mov	r18, r19
    125a:	26 95       	lsr	r18
    125c:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    125e:	82 2f       	mov	r24, r18
    1260:	86 95       	lsr	r24
    1262:	86 95       	lsr	r24
    1264:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1266:	94 e0       	ldi	r25, 0x04	; 4
    1268:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    126a:	83 30       	cpi	r24, 0x03	; 3
    126c:	09 f4       	brne	.+2      	; 0x1270 <nothingToDo_655>
    126e:	98 e0       	ldi	r25, 0x08	; 8

00001270 <nothingToDo_655>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1270:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1272:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1274:	83 2f       	mov	r24, r19
    1276:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1278:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    127a:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    127c:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    127e:	90 93 4e 00 	sts	0x004E, r25
    1282:	80 93 60 00 	sts	0x0060, r24
    1286:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    128a:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    128c:	ad 98       	cbi	0x15, 5	; 21
    128e:	87 e0       	ldi	r24, 0x07	; 7
    1290:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1292:	00 00       	nop
      asm("nop");
    1294:	00 00       	nop
    1296:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1298:	00 97       	sbiw	r24, 0x00	; 0
    129a:	d9 f7       	brne	.-10     	; 0x1292 <nothingToDo_655+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    129c:	00 00       	nop
		case 3:
			asm("nop");
    129e:	00 00       	nop
		case 2:
			asm("nop");
    12a0:	00 00       	nop
		case 1:
			asm("nop");
    12a2:	00 00       	nop
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
		writeColor(TRUE, *(color+9));                         
    12a4:	31 85       	ldd	r19, Z+9	; 0x09
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    12a6:	23 2f       	mov	r18, r19
    12a8:	26 95       	lsr	r18
    12aa:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    12ac:	82 2f       	mov	r24, r18
    12ae:	86 95       	lsr	r24
    12b0:	86 95       	lsr	r24
    12b2:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    12b4:	94 e0       	ldi	r25, 0x04	; 4
    12b6:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    12b8:	83 30       	cpi	r24, 0x03	; 3
    12ba:	09 f4       	brne	.+2      	; 0x12be <nothingToDo_703>
    12bc:	98 e0       	ldi	r25, 0x08	; 8

000012be <nothingToDo_703>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    12be:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    12c0:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    12c2:	83 2f       	mov	r24, r19
    12c4:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    12c6:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    12c8:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    12ca:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    12cc:	90 93 4e 00 	sts	0x004E, r25
    12d0:	80 93 60 00 	sts	0x0060, r24
    12d4:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    12d8:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    12da:	ad 98       	cbi	0x15, 5	; 21
    12dc:	87 e0       	ldi	r24, 0x07	; 7
    12de:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    12e0:	00 00       	nop
      asm("nop");
    12e2:	00 00       	nop
    12e4:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    12e6:	00 97       	sbiw	r24, 0x00	; 0
    12e8:	d9 f7       	brne	.-10     	; 0x12e0 <nothingToDo_703+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    12ea:	00 00       	nop
		case 3:
			asm("nop");
    12ec:	00 00       	nop
		case 2:
			asm("nop");
    12ee:	00 00       	nop
		case 1:
			asm("nop");
    12f0:	00 00       	nop
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
		writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
    12f2:	32 85       	ldd	r19, Z+10	; 0x0a
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    12f4:	23 2f       	mov	r18, r19
    12f6:	26 95       	lsr	r18
    12f8:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    12fa:	82 2f       	mov	r24, r18
    12fc:	86 95       	lsr	r24
    12fe:	86 95       	lsr	r24
    1300:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1302:	94 e0       	ldi	r25, 0x04	; 4
    1304:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1306:	83 30       	cpi	r24, 0x03	; 3
    1308:	09 f4       	brne	.+2      	; 0x130c <nothingToDo_751>
    130a:	98 e0       	ldi	r25, 0x08	; 8

0000130c <nothingToDo_751>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    130c:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    130e:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1310:	83 2f       	mov	r24, r19
    1312:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1314:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1316:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1318:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    131a:	90 93 4e 00 	sts	0x004E, r25
    131e:	80 93 60 00 	sts	0x0060, r24
    1322:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1326:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1328:	ad 98       	cbi	0x15, 5	; 21
    132a:	87 e0       	ldi	r24, 0x07	; 7
    132c:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    132e:	00 00       	nop
      asm("nop");
    1330:	00 00       	nop
    1332:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1334:	00 97       	sbiw	r24, 0x00	; 0
    1336:	d9 f7       	brne	.-10     	; 0x132e <nothingToDo_751+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1338:	00 00       	nop
		case 3:
			asm("nop");
    133a:	00 00       	nop
		case 2:
			asm("nop");
    133c:	00 00       	nop
		case 1:
			asm("nop");
    133e:	00 00       	nop
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
		writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
    1340:	33 85       	ldd	r19, Z+11	; 0x0b
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1342:	23 2f       	mov	r18, r19
    1344:	26 95       	lsr	r18
    1346:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1348:	82 2f       	mov	r24, r18
    134a:	86 95       	lsr	r24
    134c:	86 95       	lsr	r24
    134e:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1350:	94 e0       	ldi	r25, 0x04	; 4
    1352:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    1354:	83 30       	cpi	r24, 0x03	; 3
    1356:	09 f4       	brne	.+2      	; 0x135a <nothingToDo_799>
    1358:	98 e0       	ldi	r25, 0x08	; 8

0000135a <nothingToDo_799>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    135a:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    135c:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    135e:	83 2f       	mov	r24, r19
    1360:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    1362:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1364:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1366:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1368:	90 93 4e 00 	sts	0x004E, r25
    136c:	80 93 60 00 	sts	0x0060, r24
    1370:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1374:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1376:	ad 98       	cbi	0x15, 5	; 21
    1378:	87 e0       	ldi	r24, 0x07	; 7
    137a:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    137c:	00 00       	nop
      asm("nop");
    137e:	00 00       	nop
    1380:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1382:	00 97       	sbiw	r24, 0x00	; 0
    1384:	d9 f7       	brne	.-10     	; 0x137c <nothingToDo_799+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1386:	00 00       	nop
		case 3:
			asm("nop");
    1388:	00 00       	nop
		case 2:
			asm("nop");
    138a:	00 00       	nop
		case 1:
			asm("nop");
    138c:	00 00       	nop
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
		writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
    138e:	34 85       	ldd	r19, Z+12	; 0x0c
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    1390:	23 2f       	mov	r18, r19
    1392:	26 95       	lsr	r18
    1394:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1396:	82 2f       	mov	r24, r18
    1398:	86 95       	lsr	r24
    139a:	86 95       	lsr	r24
    139c:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    139e:	94 e0       	ldi	r25, 0x04	; 4
    13a0:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    13a2:	83 30       	cpi	r24, 0x03	; 3
    13a4:	09 f4       	brne	.+2      	; 0x13a8 <nothingToDo_847>
    13a6:	98 e0       	ldi	r25, 0x08	; 8

000013a8 <nothingToDo_847>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    13a8:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    13aa:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    13ac:	83 2f       	mov	r24, r19
    13ae:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    13b0:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    13b2:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    13b4:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    13b6:	90 93 4e 00 	sts	0x004E, r25
    13ba:	80 93 60 00 	sts	0x0060, r24
    13be:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    13c2:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    13c4:	ad 98       	cbi	0x15, 5	; 21
    13c6:	87 e0       	ldi	r24, 0x07	; 7
    13c8:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    13ca:	00 00       	nop
      asm("nop");
    13cc:	00 00       	nop
    13ce:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    13d0:	00 97       	sbiw	r24, 0x00	; 0
    13d2:	d9 f7       	brne	.-10     	; 0x13ca <nothingToDo_847+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    13d4:	00 00       	nop
		case 3:
			asm("nop");
    13d6:	00 00       	nop
		case 2:
			asm("nop");
    13d8:	00 00       	nop
		case 1:
			asm("nop");
    13da:	00 00       	nop
      writeColor(TRUE, *(color+8));                         
		writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
    13dc:	35 85       	ldd	r19, Z+13	; 0x0d
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    13de:	23 2f       	mov	r18, r19
    13e0:	26 95       	lsr	r18
    13e2:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    13e4:	82 2f       	mov	r24, r18
    13e6:	86 95       	lsr	r24
    13e8:	86 95       	lsr	r24
    13ea:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    13ec:	94 e0       	ldi	r25, 0x04	; 4
    13ee:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    13f0:	83 30       	cpi	r24, 0x03	; 3
    13f2:	09 f4       	brne	.+2      	; 0x13f6 <nothingToDo_895>
    13f4:	98 e0       	ldi	r25, 0x08	; 8

000013f6 <nothingToDo_895>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    13f6:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    13f8:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    13fa:	83 2f       	mov	r24, r19
    13fc:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    13fe:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    1400:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1402:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1404:	90 93 4e 00 	sts	0x004E, r25
    1408:	80 93 60 00 	sts	0x0060, r24
    140c:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    1410:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1412:	ad 98       	cbi	0x15, 5	; 21
    1414:	87 e0       	ldi	r24, 0x07	; 7
    1416:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1418:	00 00       	nop
      asm("nop");
    141a:	00 00       	nop
    141c:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	d9 f7       	brne	.-10     	; 0x1418 <nothingToDo_895+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1422:	00 00       	nop
		case 3:
			asm("nop");
    1424:	00 00       	nop
		case 2:
			asm("nop");
    1426:	00 00       	nop
		case 1:
			asm("nop");
    1428:	00 00       	nop
		writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
      writeColor(TRUE, *(color+14));                         
    142a:	36 85       	ldd	r19, Z+14	; 0x0e
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    142c:	23 2f       	mov	r18, r19
    142e:	26 95       	lsr	r18
    1430:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1432:	82 2f       	mov	r24, r18
    1434:	86 95       	lsr	r24
    1436:	86 95       	lsr	r24
    1438:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    143a:	94 e0       	ldi	r25, 0x04	; 4
    143c:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    143e:	83 30       	cpi	r24, 0x03	; 3
    1440:	09 f4       	brne	.+2      	; 0x1444 <nothingToDo_943>
    1442:	98 e0       	ldi	r25, 0x08	; 8

00001444 <nothingToDo_943>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1444:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1446:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1448:	83 2f       	mov	r24, r19
    144a:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    144c:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    144e:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    1450:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    1452:	90 93 4e 00 	sts	0x004E, r25
    1456:	80 93 60 00 	sts	0x0060, r24
    145a:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    145e:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    1460:	ad 98       	cbi	0x15, 5	; 21
    1462:	87 e0       	ldi	r24, 0x07	; 7
    1464:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1466:	00 00       	nop
      asm("nop");
    1468:	00 00       	nop
    146a:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    146c:	00 97       	sbiw	r24, 0x00	; 0
    146e:	d9 f7       	brne	.-10     	; 0x1466 <nothingToDo_943+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    1470:	00 00       	nop
		case 3:
			asm("nop");
    1472:	00 00       	nop
		case 2:
			asm("nop");
    1474:	00 00       	nop
		case 1:
			asm("nop");
    1476:	00 00       	nop
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
      writeColor(TRUE, *(color+14));                         
      writeColor(TRUE, *(color+15));   
    1478:	37 85       	ldd	r19, Z+15	; 0x0f
	 uint8_t redVal = colorVal&0x03;
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
    147a:	23 2f       	mov	r18, r19
    147c:	26 95       	lsr	r18
    147e:	26 95       	lsr	r18
	 uint8_t greenVal = bgTemp&0x03;
	 uint8_t blueVal = (bgTemp>>2)&0x03;
    1480:	82 2f       	mov	r24, r18
    1482:	86 95       	lsr	r24
    1484:	86 95       	lsr	r24
    1486:	83 70       	andi	r24, 0x03	; 3
	 uint8_t greenOCR_val = (greenVal + 3);

	 //Blue is more difficult, it requires a test
	 // which, when compiled, would likely result in two branches that take
	 // different numbers of clock-cycles
	 uint8_t blueOCR_val = (blueVal + 4);
    1488:	94 e0       	ldi	r25, 0x04	; 4
    148a:	98 0f       	add	r25, r24
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    148c:	83 30       	cpi	r24, 0x03	; 3
    148e:	09 f4       	brne	.+2      	; 0x1492 <nothingToDo_991>
    1490:	98 e0       	ldi	r25, 0x08	; 8

00001492 <nothingToDo_991>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    1492:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    1494:	8d 9a       	sbi	0x11, 5	; 17
	 // Without doing this in ASM, we can't guarantee (and I've seen
	 // first-hand) that it can't happen that one OCR is written, the next
	 // is calculated, *then* the next is written.

	 //First, unpack the colors:
	 uint8_t redVal = colorVal&0x03;
    1496:	83 2f       	mov	r24, r19
    1498:	83 70       	andi	r24, 0x03	; 3

	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
    149a:	8e 5f       	subi	r24, 0xFE	; 254
	 //uint8_t greenVal = (colorVal>>2)&0x03;
	 //uint8_t blueVal = (colorVal>>4)&0x03;
	 //The above is optimized below by combining two of the
	 //blue-shifts... It should be smaller
	 uint8_t bgTemp = colorVal>>2;
	 uint8_t greenVal = bgTemp&0x03;
    149c:	23 70       	andi	r18, 0x03	; 3
	 //Now prep some variables for the register-values
	 // the actual registers will be written all at once at the end

	 //see setRed4() and setGreen4()...
	 uint8_t redOCR_val   = (redVal + 2);
	 uint8_t greenOCR_val = (greenVal + 3);
    149e:	2d 5f       	subi	r18, 0xFD	; 253
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    14a0:	90 93 4e 00 	sts	0x004E, r25
    14a4:	80 93 60 00 	sts	0x0060, r24
    14a8:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    14ac:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    14ae:	ad 98       	cbi	0x15, 5	; 21
    14b0:	87 e0       	ldi	r24, 0x07	; 7
    14b2:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    14b4:	00 00       	nop
      asm("nop");
    14b6:	00 00       	nop
    14b8:	01 97       	sbiw	r24, 0x01	; 1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    14ba:	00 97       	sbiw	r24, 0x00	; 0
    14bc:	d9 f7       	brne	.-10     	; 0x14b4 <nothingToDo_991+0x22>
		case 6:
			asm("nop");
		case 5:
			asm("nop");
		case 4:
			asm("nop");
    14be:	00 00       	nop
		case 3:
			asm("nop");
    14c0:	00 00       	nop
		case 2:
			asm("nop");
    14c2:	00 00       	nop
		case 1:
			asm("nop");
    14c4:	00 00       	nop
	 // written...
	 // See lvds161.c -> setBlue4()
	 // 
	 //This is NOT AT ALL optimized:
	 // But it is guaranteed to be exactly 3 cycles *in each branch*
__asm__ __volatile__
    14c6:	84 e0       	ldi	r24, 0x04	; 4
    14c8:	90 e0       	ldi	r25, 0x00	; 0
    14ca:	93 30       	cpi	r25, 0x03	; 3
    14cc:	09 f4       	brne	.+2      	; 0x14d0 <nothingToDo_1033>
    14ce:	88 e0       	ldi	r24, 0x08	; 8

000014d0 <nothingToDo_1033>:
	// write them to the registers
	// Locking/unlocking of the PSCs can't occur simultaneously,
	// so it's likely there will be a pixel or two of difference between the
	// transition from one value of blue to the next vs red/green's
	// transition
	lockPSC2();
    14d0:	ad 9a       	sbi	0x15, 5	; 21
	lockPSC0();
    14d2:	8d 9a       	sbi	0x11, 5	; 17
//"When addressing the I/O Registers as data space using LD and ST
// instructions, 0x20 must be added to these addresses"
//"For the Extended I/O space from 0x60-0xFF in SRAM, only the ST... and
//LD... instructions can be used"
// So, rather than using _SFR_IO_ADDR(), use _SFR_MEM_ADDR()
		__asm__ __volatile__
    14d4:	23 e0       	ldi	r18, 0x03	; 3
    14d6:	92 e0       	ldi	r25, 0x02	; 2
    14d8:	80 93 4e 00 	sts	0x004E, r24
    14dc:	90 93 60 00 	sts	0x0060, r25
    14e0:	20 93 42 00 	sts	0x0042, r18
			"M" (_SFR_MEM_ADDR(OCR2RAL)), //"%3" //0x2e (0x4e)
			"M" (_SFR_MEM_ADDR(OCR0SAL)), //"%4"	//(0x60)
			"M" (_SFR_MEM_ADDR(OCR0SBL)) //"%5"  //0x22 (0x42)

		);
	unlockPSC0();
    14e4:	8d 98       	cbi	0x11, 5	; 17
	unlockPSC2();
    14e6:	ad 98       	cbi	0x15, 5	; 21
		//a/o v62: (Original notes removed)
		//OCR1D controls RED... >=6 is full-red
		// Setting this here indicates where the drawing has completed
		// This is handy for determining timing, stretching, etc...
		//OCR1D = 6; //0;
		fullRed();
    14e8:	8d 9a       	sbi	0x11, 5	; 17
    14ea:	85 e0       	ldi	r24, 0x05	; 5
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	90 93 61 00 	sts	0x0061, r25
    14f2:	80 93 60 00 	sts	0x0060, r24
    14f6:	8d 98       	cbi	0x11, 5	; 17

		lvds_disableGreen_MakeClockInsensitiveToDT();

      //fullBlue();
      //Nada_fromDEonly();
		Nada_init();
    14f8:	ad 9a       	sbi	0x15, 5	; 21
    14fa:	82 e0       	ldi	r24, 0x02	; 2
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	90 93 65 00 	sts	0x0065, r25
    1502:	80 93 64 00 	sts	0x0064, r24
    1506:	84 e0       	ldi	r24, 0x04	; 4
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	9f bd       	out	0x2f, r25	; 47
    150c:	8e bd       	out	0x2e, r24	; 46
    150e:	ad 98       	cbi	0x15, 5	; 21
    1510:	08 95       	ret

00001512 <lcd_Init>:
//   (the fewer changes, the less likely we'll glitch...?)


void lcd_Init(void)
{
 	Nada_init();
    1512:	ad 9a       	sbi	0x15, 5	; 21
    1514:	82 e0       	ldi	r24, 0x02	; 2
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	90 93 65 00 	sts	0x0065, r25
    151c:	80 93 64 00 	sts	0x0064, r24
    1520:	84 e0       	ldi	r24, 0x04	; 4
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	9f bd       	out	0x2f, r25	; 47
    1526:	8e bd       	out	0x2e, r24	; 46
    1528:	ad 98       	cbi	0x15, 5	; 21
    152a:	08 95       	ret

0000152c <updateLCD>:

	//Hsync and Actually draw the pixels... (when DE is active)
	// This takes a LONG time and will occupy most of the CPU...
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
    152c:	40 91 15 01 	lds	r20, 0x0115
    1530:	80 91 12 01 	lds	r24, 0x0112
    1534:	90 91 13 01 	lds	r25, 0x0113
// rowNum is only used when DE is active...
//  and should be 0 at *drawn row* 0
void loadData(uint16_t rowNum, uint8_t dataEnable)
{
	//H Active pulse...
   if(vSync)
    1538:	20 91 14 01 	lds	r18, 0x0114
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
    153c:	ad 9a       	sbi	0x15, 5	; 21
// rowNum is only used when DE is active...
//  and should be 0 at *drawn row* 0
void loadData(uint16_t rowNum, uint8_t dataEnable)
{
	//H Active pulse...
   if(vSync)
    153e:	22 23       	and	r18, r18
    1540:	79 f1       	breq	.+94     	; 0x15a0 <updateLCD+0x74>
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
    1542:	26 e0       	ldi	r18, 0x06	; 6
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	30 93 65 00 	sts	0x0065, r19
    154a:	20 93 64 00 	sts	0x0064, r18
    154e:	3f bd       	out	0x2f, r19	; 47
    1550:	2e bd       	out	0x2e, r18	; 46
    1552:	ad 98       	cbi	0x15, 5	; 21
    1554:	26 e1       	ldi	r18, 0x16	; 22
    1556:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1558:	00 00       	nop
      asm("nop");
    155a:	00 00       	nop
    155c:	21 50       	subi	r18, 0x01	; 1
    155e:	31 09       	sbc	r19, r1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1560:	21 15       	cp	r18, r1
    1562:	31 05       	cpc	r19, r1
    1564:	c9 f7       	brne	.-14     	; 0x1558 <updateLCD+0x2c>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    1566:	00 00       	nop
		case 6:
			asm("nop");
    1568:	00 00       	nop
		case 5:
			asm("nop");
    156a:	00 00       	nop
		case 4:
			asm("nop");
    156c:	00 00       	nop
		case 3:
			asm("nop");
    156e:	00 00       	nop
		case 2:
			asm("nop");
    1570:	00 00       	nop
		case 1:
			asm("nop");
    1572:	00 00       	nop
      Hlow_Delay();
      Vsync_fromVplusH();
    1574:	ad 9a       	sbi	0x15, 5	; 21
    1576:	23 e0       	ldi	r18, 0x03	; 3
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	30 93 65 00 	sts	0x0065, r19
    157e:	20 93 64 00 	sts	0x0064, r18
    1582:	24 e0       	ldi	r18, 0x04	; 4
    1584:	30 e0       	ldi	r19, 0x00	; 0
    1586:	3f bd       	out	0x2f, r19	; 47
    1588:	2e bd       	out	0x2e, r18	; 46
    158a:	ad 98       	cbi	0x15, 5	; 21
    158c:	2b e0       	ldi	r18, 0x0B	; 11
    158e:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1590:	00 00       	nop
      asm("nop");
    1592:	00 00       	nop
    1594:	21 50       	subi	r18, 0x01	; 1
    1596:	31 09       	sbc	r19, r1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1598:	21 15       	cp	r18, r1
    159a:	31 05       	cpc	r19, r1
    159c:	c9 f7       	brne	.-14     	; 0x1590 <updateLCD+0x64>
    159e:	30 c0       	rjmp	.+96     	; 0x1600 <updateLCD+0xd4>
      HD_Delay();
   }
   else
   {
      Hsync_fromNada();
    15a0:	22 e0       	ldi	r18, 0x02	; 2
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	30 93 65 00 	sts	0x0065, r19
    15a8:	20 93 64 00 	sts	0x0064, r18
    15ac:	23 e0       	ldi	r18, 0x03	; 3
    15ae:	30 e0       	ldi	r19, 0x00	; 0
    15b0:	3f bd       	out	0x2f, r19	; 47
    15b2:	2e bd       	out	0x2e, r18	; 46
    15b4:	ad 98       	cbi	0x15, 5	; 21
    15b6:	26 e1       	ldi	r18, 0x16	; 22
    15b8:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    15ba:	00 00       	nop
      asm("nop");
    15bc:	00 00       	nop
    15be:	21 50       	subi	r18, 0x01	; 1
    15c0:	31 09       	sbc	r19, r1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    15c2:	21 15       	cp	r18, r1
    15c4:	31 05       	cpc	r19, r1
    15c6:	c9 f7       	brne	.-14     	; 0x15ba <updateLCD+0x8e>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    15c8:	00 00       	nop
		case 6:
			asm("nop");
    15ca:	00 00       	nop
		case 5:
			asm("nop");
    15cc:	00 00       	nop
		case 4:
			asm("nop");
    15ce:	00 00       	nop
		case 3:
			asm("nop");
    15d0:	00 00       	nop
		case 2:
			asm("nop");
    15d2:	00 00       	nop
		case 1:
			asm("nop");
    15d4:	00 00       	nop
      Hlow_Delay();
      Nada_fromHsync();
    15d6:	ad 9a       	sbi	0x15, 5	; 21
    15d8:	22 e0       	ldi	r18, 0x02	; 2
    15da:	30 e0       	ldi	r19, 0x00	; 0
    15dc:	30 93 65 00 	sts	0x0065, r19
    15e0:	20 93 64 00 	sts	0x0064, r18
    15e4:	24 e0       	ldi	r18, 0x04	; 4
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	3f bd       	out	0x2f, r19	; 47
    15ea:	2e bd       	out	0x2e, r18	; 46
    15ec:	ad 98       	cbi	0x15, 5	; 21
    15ee:	2b e0       	ldi	r18, 0x0B	; 11
    15f0:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    15f2:	00 00       	nop
      asm("nop");
    15f4:	00 00       	nop
    15f6:	21 50       	subi	r18, 0x01	; 1
    15f8:	31 09       	sbc	r19, r1
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    15fa:	21 15       	cp	r18, r1
    15fc:	31 05       	cpc	r19, r1
    15fe:	c9 f7       	brne	.-14     	; 0x15f2 <updateLCD+0xc6>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    1600:	00 00       	nop
		case 6:
			asm("nop");
    1602:	00 00       	nop
		case 5:
			asm("nop");
    1604:	00 00       	nop
		case 4:
			asm("nop");
    1606:	00 00       	nop
		case 3:
			asm("nop");
    1608:	00 00       	nop
		case 2:
			asm("nop");
    160a:	00 00       	nop
		case 1:
			asm("nop");
    160c:	00 00       	nop
      HD_Delay();
   }

   if(dataEnable)
    160e:	44 23       	and	r20, r20
    1610:	19 f0       	breq	.+6      	; 0x1618 <updateLCD+0xec>
{
	//a/o v67, this is used by FRAMEBUFFER_TESTING...
	//Old:
	//This hasn't been used in quite some time... 
	// it may not work at all anymore.
	nonRSB_drawPix(rowNum);
    1612:	86 97       	sbiw	r24, 0x26	; 38
    1614:	0e 94 d6 07 	call	0xfac	; 0xfac <nonRSB_drawPix>
	// This takes a LONG time and will occupy most of the CPU...
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);

	hsyncCount++;
    1618:	80 91 12 01 	lds	r24, 0x0112
    161c:	90 91 13 01 	lds	r25, 0x0113
    1620:	01 96       	adiw	r24, 0x01	; 1
    1622:	90 93 13 01 	sts	0x0113, r25
    1626:	80 93 12 01 	sts	0x0112, r24

	switch(hsyncCount)
    162a:	83 32       	cpi	r24, 0x23	; 35
    162c:	91 05       	cpc	r25, r1
    162e:	c9 f0       	breq	.+50     	; 0x1662 <updateLCD+0x136>
    1630:	50 f4       	brcc	.+20     	; 0x1646 <updateLCD+0x11a>
    1632:	83 30       	cpi	r24, 0x03	; 3
    1634:	91 05       	cpc	r25, r1
    1636:	39 f5       	brne	.+78     	; 0x1686 <updateLCD+0x15a>
	{
		//V Front Porch, begins with initLCD

		//Vsync H->L (Begin V-Sync)
		case T_DV:
			dataEnable = FALSE;
    1638:	10 92 15 01 	sts	0x0115, r1
			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = TRUE;
    163c:	21 e0       	ldi	r18, 0x01	; 1
    163e:	20 93 14 01 	sts	0x0114, r18
			Vsync_fromNada();
    1642:	ad 9a       	sbi	0x15, 5	; 21
    1644:	13 c0       	rjmp	.+38     	; 0x166c <updateLCD+0x140>
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);

	hsyncCount++;

	switch(hsyncCount)
    1646:	86 32       	cpi	r24, 0x26	; 38
    1648:	91 05       	cpc	r25, r1
    164a:	d1 f0       	breq	.+52     	; 0x1680 <updateLCD+0x154>
    164c:	86 32       	cpi	r24, 0x26	; 38
    164e:	93 40       	sbci	r25, 0x03	; 3
    1650:	d1 f4       	brne	.+52     	; 0x1686 <updateLCD+0x15a>
			dataEnable = TRUE;
			break;
		// All rows have been displayed
		// Return to V Front Porch
		case V_COUNT +(T_VD + T_Vlow + T_DV):
			dataEnable = FALSE;
    1652:	10 92 15 01 	sts	0x0115, r1
		//	break;
		//Frame complete
		//case HSYNC_COUNT_FRAME_COMPLETE:
			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
			hsyncCount = 0;
    1656:	10 92 13 01 	sts	0x0113, r1
    165a:	10 92 12 01 	sts	0x0112, r1
			}
#endif
			
//#warning "NewNote: WTF, are we relying on loadData to have properly set the mode?"
// Yeah, guess that makes sense... Must be Nada...
			frameComplete = TRUE;
    165e:	81 e0       	ldi	r24, 0x01	; 1
			break;
    1660:	08 95       	ret
		//	if(hfm_nextOutput(&modulator))
		//		colorOverride = 0xff;
		//	else
		//		colorOverride = 7;
			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = FALSE;
    1662:	10 92 14 01 	sts	0x0114, r1
			Nada_fromVsync();
    1666:	ad 9a       	sbi	0x15, 5	; 21
    1668:	82 e0       	ldi	r24, 0x02	; 2
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	90 93 65 00 	sts	0x0065, r25
    1670:	80 93 64 00 	sts	0x0064, r24
    1674:	84 e0       	ldi	r24, 0x04	; 4
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	9f bd       	out	0x2f, r25	; 47
    167a:	8e bd       	out	0x2e, r24	; 46
    167c:	ad 98       	cbi	0x15, 5	; 21
    167e:	03 c0       	rjmp	.+6      	; 0x1686 <updateLCD+0x15a>
			break;
		//Start of frame (DE active)
		case T_VD +(T_Vlow + T_DV):
			dataEnable = TRUE;
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	80 93 15 01 	sts	0x0115, r24
//  point to the "first" Hsync. This is handled in sdramThing2.0's code
// Used to be:
//SIGNAL(TIMER0_COMPA_vect)
uint8_t updateLCD(void)
{
	uint8_t frameComplete = FALSE;
    1686:	80 e0       	ldi	r24, 0x00	; 0
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...

	return frameComplete;
}
    1688:	08 95       	ret

0000168a <__vector_11>:
 //Nearly everything display-related happens in this interrupt
 // It even calls the functions that load (and calculate!) the data for the
 // next row.
 // So basically, the entire project is running via timer-interrupt.
 SIGNAL(HSYNC_TIMER_INTERRUPT_VECT) //TIMER0_COMPA_vect)
 {
    168a:	1f 92       	push	r1
    168c:	0f 92       	push	r0
    168e:	0f b6       	in	r0, 0x3f	; 63
    1690:	0f 92       	push	r0
    1692:	11 24       	eor	r1, r1
    1694:	2f 93       	push	r18
    1696:	3f 93       	push	r19
    1698:	4f 93       	push	r20
    169a:	5f 93       	push	r21
    169c:	6f 93       	push	r22
    169e:	7f 93       	push	r23
    16a0:	8f 93       	push	r24
    16a2:	9f 93       	push	r25
    16a4:	af 93       	push	r26
    16a6:	bf 93       	push	r27
    16a8:	ef 93       	push	r30
    16aa:	ff 93       	push	r31
									__attribute__((__always_inline__));

__inline__ \
coord_t xyt_nextOutput(xyt_t *line)
{
	xyt_update(line);
    16ac:	8f e1       	ldi	r24, 0x1F	; 31
    16ae:	91 e0       	ldi	r25, 0x01	; 1
    16b0:	0e 94 5e 06 	call	0xcbc	; 0xcbc <xyt_update>
	return line->output;
    16b4:	80 91 30 01 	lds	r24, 0x0130
    16b8:	90 91 31 01 	lds	r25, 0x0131
    16bc:	a0 91 32 01 	lds	r26, 0x0132
    16c0:	b0 91 33 01 	lds	r27, 0x0133
//	static uint8_t counter = 0;
//	static dms4day_t lastTime;

//	lastTime = dmsCount;

	dmsCount=xyt_nextOutput(&dmsLine);	
    16c4:	80 93 0d 01 	sts	0x010D, r24
    16c8:	90 93 0e 01 	sts	0x010E, r25
    16cc:	a0 93 0f 01 	sts	0x010F, r26
    16d0:	b0 93 10 01 	sts	0x0110, r27
#if(defined(_DMS_EXTERNALUPDATE_) && _DMS_EXTERNALUPDATE_)
	 dms_update();
#endif

	 if(!updateFrame)
    16d4:	80 91 05 01 	lds	r24, 0x0105
    16d8:	88 23       	and	r24, r24
    16da:	49 f0       	breq	.+18     	; 0x16ee <__vector_11+0x64>
	// drawPix is only called for drawn-rows (where DE is active, NOT for
	// Vblank rows)
	// H-Front-Porch is handled in the time between completion of this
	// interrupt and the next interrupt...

	if(updateLCD())
    16dc:	0e 94 96 0a 	call	0x152c	; 0x152c <updateLCD>
    16e0:	88 23       	and	r24, r24
    16e2:	29 f0       	breq	.+10     	; 0x16ee <__vector_11+0x64>
	{
		frameCount++;
    16e4:	80 91 11 01 	lds	r24, 0x0111
    16e8:	8f 5f       	subi	r24, 0xFF	; 255
    16ea:	80 93 11 01 	sts	0x0111, r24
	// to load a row to a row-buffer (as opposed to a frame-buffer)
	// thus, DE could gain more pixels because there would be fewer
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...
 }
    16ee:	ff 91       	pop	r31
    16f0:	ef 91       	pop	r30
    16f2:	bf 91       	pop	r27
    16f4:	af 91       	pop	r26
    16f6:	9f 91       	pop	r25
    16f8:	8f 91       	pop	r24
    16fa:	7f 91       	pop	r23
    16fc:	6f 91       	pop	r22
    16fe:	5f 91       	pop	r21
    1700:	4f 91       	pop	r20
    1702:	3f 91       	pop	r19
    1704:	2f 91       	pop	r18
    1706:	0f 90       	pop	r0
    1708:	0f be       	out	0x3f, r0	; 63
    170a:	0f 90       	pop	r0
    170c:	1f 90       	pop	r1
    170e:	18 95       	reti

00001710 <init_hsyncTimer>:
//Testing with values returned by hsyncTimerCalculator
//#define HSYNC_TIMER_OCRVAL	65

void init_hsyncTimer(void)
{
   HSYNC_TIMER_OCR = HSYNC_TIMER_OCRVAL; 
    1710:	85 e0       	ldi	r24, 0x05	; 5
    1712:	98 e0       	ldi	r25, 0x08	; 8
    1714:	90 93 8d 00 	sts	0x008D, r25
    1718:	80 93 8c 00 	sts	0x008C, r24
							//T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
   timer_setWGM(HSYNC_TIMER_NUM, WGM_CLR_ON_COMPARE);
    171c:	62 e0       	ldi	r22, 0x02	; 2
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	0e 94 ce 03 	call	0x79c	; 0x79c <timer_setWGM>
   timer_selectDivisor(HSYNC_TIMER_NUM, HSYNC_TIMER_CLKDIV); //CLKDIV1);
    1724:	60 e0       	ldi	r22, 0x00	; 0
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	0e 94 c0 03 	call	0x780	; 0x780 <timer_selectDivisor>
   timer_compareMatchIntEnable(HSYNC_TIMER_NUM, OUT_CHANNELA);
    172c:	41 e0       	ldi	r20, 0x01	; 1
    172e:	60 e0       	ldi	r22, 0x00	; 0
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	0c 94 fa 03 	jmp	0x7f4	; 0x7f4 <timer_compareMatchIntSetup>

00001736 <isNewFrame>:
{
	uint8_t newFrame = FALSE;

	static uint8_t lastFrameCount = 0;
#define FRAME_COUNT_LIMIT 0x03
	uint8_t thisFrameCount = frameCount&FRAME_COUNT_LIMIT;
    1736:	90 91 11 01 	lds	r25, 0x0111
    173a:	93 70       	andi	r25, 0x03	; 3

//		if(( (thisFrameCount==0) && (lastFrameCount==FRAME_COUNT_LIMIT) ))
	if(thisFrameCount != lastFrameCount)
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	20 91 16 01 	lds	r18, 0x0116
    1742:	92 13       	cpse	r25, r18
    1744:	01 c0       	rjmp	.+2      	; 0x1748 <isNewFrame+0x12>
    1746:	80 e0       	ldi	r24, 0x00	; 0
		newFrame = TRUE;

	lastFrameCount = thisFrameCount;
    1748:	90 93 16 01 	sts	0x0116, r25

	return newFrame;
}
    174c:	08 95       	ret

0000174e <frameBufferUpdate>:
            updateFrame = TRUE;
            lastUpdated = FALSE;
         }
      }
 #else
      if(isNewFrame())
    174e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <isNewFrame>
    1752:	81 11       	cpse	r24, r1
      {
         fb_updater();
    1754:	0c 94 7a 07 	jmp	0xef4	; 0xef4 <smileyUpdate>
    1758:	08 95       	ret

0000175a <main>:
	//one less than the actual count since it counts from 0...
	dmsNumUpdates = numUpdates;
#endif

//#warning "xyt requires incrementSize < numUpdates!"
	xyt_init(&dmsLine, incrementSize, numUpdates);
    175a:	01 e0       	ldi	r16, 0x01	; 1
    175c:	10 e0       	ldi	r17, 0x00	; 0
    175e:	20 e0       	ldi	r18, 0x00	; 0
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	41 e0       	ldi	r20, 0x01	; 1
    1764:	50 e0       	ldi	r21, 0x00	; 0
    1766:	60 e0       	ldi	r22, 0x00	; 0
    1768:	70 e0       	ldi	r23, 0x00	; 0
    176a:	8f e1       	ldi	r24, 0x1F	; 31
    176c:	91 e0       	ldi	r25, 0x01	; 1
    176e:	0e 94 c3 05 	call	0xb86	; 0xb86 <xyt_init>
#endif



#if(!defined(PWM_TESTING) || !PWM_TESTING)
	init_hsyncTimer();
    1772:	0e 94 88 0b 	call	0x1710	; 0x1710 <init_hsyncTimer>
#endif

	//This starts pretty late... watch out for WDT
	init_heartBeat();
    1776:	0e 94 29 04 	call	0x852	; 0x852 <init_heartBeat>

	setHeartRate(0);
    177a:	80 e0       	ldi	r24, 0x00	; 0
    177c:	0e 94 0c 04 	call	0x818	; 0x818 <setHeartRate>

	lvds_timerInit();
    1780:	0e 94 16 07 	call	0xe2c	; 0xe2c <lvds_timerInit>


//#if( (defined(FB_QUESTION) && FB_QUESTION) \
//	  ||	(defined(FB_SMILEY) && FB_SMILEY) )
#if( defined(FRAMEBUFFER_TESTING) && (FRAMEBUFFER_TESTING))
		frameBufferUpdate();
    1784:	0e 94 a7 0b 	call	0x174e	; 0x174e <frameBufferUpdate>
#endif

		heartUpdate();
    1788:	0e 94 98 04 	call	0x930	; 0x930 <heartUpdate>
    178c:	fb cf       	rjmp	.-10     	; 0x1784 <main+0x2a>

0000178e <__mulsi3>:
    178e:	db 01       	movw	r26, r22
    1790:	8f 93       	push	r24
    1792:	9f 93       	push	r25
    1794:	0e 94 21 0c 	call	0x1842	; 0x1842 <__muluhisi3>
    1798:	bf 91       	pop	r27
    179a:	af 91       	pop	r26
    179c:	a2 9f       	mul	r26, r18
    179e:	80 0d       	add	r24, r0
    17a0:	91 1d       	adc	r25, r1
    17a2:	a3 9f       	mul	r26, r19
    17a4:	90 0d       	add	r25, r0
    17a6:	b2 9f       	mul	r27, r18
    17a8:	90 0d       	add	r25, r0
    17aa:	11 24       	eor	r1, r1
    17ac:	08 95       	ret

000017ae <__udivmodhi4>:
    17ae:	aa 1b       	sub	r26, r26
    17b0:	bb 1b       	sub	r27, r27
    17b2:	51 e1       	ldi	r21, 0x11	; 17
    17b4:	07 c0       	rjmp	.+14     	; 0x17c4 <__udivmodhi4_ep>

000017b6 <__udivmodhi4_loop>:
    17b6:	aa 1f       	adc	r26, r26
    17b8:	bb 1f       	adc	r27, r27
    17ba:	a6 17       	cp	r26, r22
    17bc:	b7 07       	cpc	r27, r23
    17be:	10 f0       	brcs	.+4      	; 0x17c4 <__udivmodhi4_ep>
    17c0:	a6 1b       	sub	r26, r22
    17c2:	b7 0b       	sbc	r27, r23

000017c4 <__udivmodhi4_ep>:
    17c4:	88 1f       	adc	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	5a 95       	dec	r21
    17ca:	a9 f7       	brne	.-22     	; 0x17b6 <__udivmodhi4_loop>
    17cc:	80 95       	com	r24
    17ce:	90 95       	com	r25
    17d0:	bc 01       	movw	r22, r24
    17d2:	cd 01       	movw	r24, r26
    17d4:	08 95       	ret

000017d6 <__divmodhi4>:
    17d6:	97 fb       	bst	r25, 7
    17d8:	07 2e       	mov	r0, r23
    17da:	16 f4       	brtc	.+4      	; 0x17e0 <__divmodhi4+0xa>
    17dc:	00 94       	com	r0
    17de:	07 d0       	rcall	.+14     	; 0x17ee <__divmodhi4_neg1>
    17e0:	77 fd       	sbrc	r23, 7
    17e2:	09 d0       	rcall	.+18     	; 0x17f6 <__divmodhi4_neg2>
    17e4:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <__udivmodhi4>
    17e8:	07 fc       	sbrc	r0, 7
    17ea:	05 d0       	rcall	.+10     	; 0x17f6 <__divmodhi4_neg2>
    17ec:	3e f4       	brtc	.+14     	; 0x17fc <__divmodhi4_exit>

000017ee <__divmodhi4_neg1>:
    17ee:	90 95       	com	r25
    17f0:	81 95       	neg	r24
    17f2:	9f 4f       	sbci	r25, 0xFF	; 255
    17f4:	08 95       	ret

000017f6 <__divmodhi4_neg2>:
    17f6:	70 95       	com	r23
    17f8:	61 95       	neg	r22
    17fa:	7f 4f       	sbci	r23, 0xFF	; 255

000017fc <__divmodhi4_exit>:
    17fc:	08 95       	ret

000017fe <__udivmodsi4>:
    17fe:	a1 e2       	ldi	r26, 0x21	; 33
    1800:	1a 2e       	mov	r1, r26
    1802:	aa 1b       	sub	r26, r26
    1804:	bb 1b       	sub	r27, r27
    1806:	fd 01       	movw	r30, r26
    1808:	0d c0       	rjmp	.+26     	; 0x1824 <__udivmodsi4_ep>

0000180a <__udivmodsi4_loop>:
    180a:	aa 1f       	adc	r26, r26
    180c:	bb 1f       	adc	r27, r27
    180e:	ee 1f       	adc	r30, r30
    1810:	ff 1f       	adc	r31, r31
    1812:	a2 17       	cp	r26, r18
    1814:	b3 07       	cpc	r27, r19
    1816:	e4 07       	cpc	r30, r20
    1818:	f5 07       	cpc	r31, r21
    181a:	20 f0       	brcs	.+8      	; 0x1824 <__udivmodsi4_ep>
    181c:	a2 1b       	sub	r26, r18
    181e:	b3 0b       	sbc	r27, r19
    1820:	e4 0b       	sbc	r30, r20
    1822:	f5 0b       	sbc	r31, r21

00001824 <__udivmodsi4_ep>:
    1824:	66 1f       	adc	r22, r22
    1826:	77 1f       	adc	r23, r23
    1828:	88 1f       	adc	r24, r24
    182a:	99 1f       	adc	r25, r25
    182c:	1a 94       	dec	r1
    182e:	69 f7       	brne	.-38     	; 0x180a <__udivmodsi4_loop>
    1830:	60 95       	com	r22
    1832:	70 95       	com	r23
    1834:	80 95       	com	r24
    1836:	90 95       	com	r25
    1838:	9b 01       	movw	r18, r22
    183a:	ac 01       	movw	r20, r24
    183c:	bd 01       	movw	r22, r26
    183e:	cf 01       	movw	r24, r30
    1840:	08 95       	ret

00001842 <__muluhisi3>:
    1842:	0e 94 2c 0c 	call	0x1858	; 0x1858 <__umulhisi3>
    1846:	a5 9f       	mul	r26, r21
    1848:	90 0d       	add	r25, r0
    184a:	b4 9f       	mul	r27, r20
    184c:	90 0d       	add	r25, r0
    184e:	a4 9f       	mul	r26, r20
    1850:	80 0d       	add	r24, r0
    1852:	91 1d       	adc	r25, r1
    1854:	11 24       	eor	r1, r1
    1856:	08 95       	ret

00001858 <__umulhisi3>:
    1858:	a2 9f       	mul	r26, r18
    185a:	b0 01       	movw	r22, r0
    185c:	b3 9f       	mul	r27, r19
    185e:	c0 01       	movw	r24, r0
    1860:	a3 9f       	mul	r26, r19
    1862:	70 0d       	add	r23, r0
    1864:	81 1d       	adc	r24, r1
    1866:	11 24       	eor	r1, r1
    1868:	91 1d       	adc	r25, r1
    186a:	b2 9f       	mul	r27, r18
    186c:	70 0d       	add	r23, r0
    186e:	81 1d       	adc	r24, r1
    1870:	11 24       	eor	r1, r1
    1872:	91 1d       	adc	r25, r1
    1874:	08 95       	ret

00001876 <_exit>:
    1876:	f8 94       	cli

00001878 <__stop_program>:
    1878:	ff cf       	rjmp	.-2      	; 0x1878 <__stop_program>
