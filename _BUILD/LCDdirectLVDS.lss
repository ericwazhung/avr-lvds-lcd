
_BUILD/LCDdirectLVDS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d9a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005a  00800060  00001d9a  00001e2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000112  008000ba  008000ba  00001e88  2**0
                  ALLOC
  3 .stab         00004308  00000000  00000000  00001e88  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001b85  00000000  00000000  00006190  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	bd c3       	rjmp	.+1914   	; 0x77c <__ctors_end>
       2:	d7 c3       	rjmp	.+1966   	; 0x7b2 <__bad_interrupt>
       4:	d6 c3       	rjmp	.+1964   	; 0x7b2 <__bad_interrupt>
       6:	d5 c3       	rjmp	.+1962   	; 0x7b2 <__bad_interrupt>
       8:	d4 c3       	rjmp	.+1960   	; 0x7b2 <__bad_interrupt>
       a:	d3 c3       	rjmp	.+1958   	; 0x7b2 <__bad_interrupt>
       c:	d2 c3       	rjmp	.+1956   	; 0x7b2 <__bad_interrupt>
       e:	d1 c3       	rjmp	.+1954   	; 0x7b2 <__bad_interrupt>
      10:	d0 c3       	rjmp	.+1952   	; 0x7b2 <__bad_interrupt>
      12:	cf c3       	rjmp	.+1950   	; 0x7b2 <__bad_interrupt>
      14:	ce c3       	rjmp	.+1948   	; 0x7b2 <__bad_interrupt>
      16:	cd c3       	rjmp	.+1946   	; 0x7b2 <__bad_interrupt>
      18:	cc c3       	rjmp	.+1944   	; 0x7b2 <__bad_interrupt>
      1a:	cb c3       	rjmp	.+1942   	; 0x7b2 <__bad_interrupt>
      1c:	6c cd       	rjmp	.-1320   	; 0xfffffaf6 <__eeprom_end+0xff7efaf6>
      1e:	c9 c3       	rjmp	.+1938   	; 0x7b2 <__bad_interrupt>
      20:	c8 c3       	rjmp	.+1936   	; 0x7b2 <__bad_interrupt>
      22:	c7 c3       	rjmp	.+1934   	; 0x7b2 <__bad_interrupt>
      24:	c6 c3       	rjmp	.+1932   	; 0x7b2 <__bad_interrupt>
      26:	3a cb       	rjmp	.-2444   	; 0xfffff69c <__eeprom_end+0xff7ef69c>
      28:	39 cb       	rjmp	.-2446   	; 0xfffff69c <__eeprom_end+0xff7ef69c>
      2a:	38 cb       	rjmp	.-2448   	; 0xfffff69c <__eeprom_end+0xff7ef69c>
      2c:	37 cb       	rjmp	.-2450   	; 0xfffff69c <__eeprom_end+0xff7ef69c>
      2e:	26 cb       	rjmp	.-2484   	; 0xfffff67c <__eeprom_end+0xff7ef67c>
      30:	25 cb       	rjmp	.-2486   	; 0xfffff67c <__eeprom_end+0xff7ef67c>
      32:	24 cb       	rjmp	.-2488   	; 0xfffff67c <__eeprom_end+0xff7ef67c>
      34:	25 cb       	rjmp	.-2486   	; 0xfffff680 <__eeprom_end+0xff7ef680>
      36:	24 cb       	rjmp	.-2488   	; 0xfffff680 <__eeprom_end+0xff7ef680>
      38:	23 cb       	rjmp	.-2490   	; 0xfffff680 <__eeprom_end+0xff7ef680>
      3a:	24 cb       	rjmp	.-2488   	; 0xfffff684 <__eeprom_end+0xff7ef684>
      3c:	23 cb       	rjmp	.-2490   	; 0xfffff684 <__eeprom_end+0xff7ef684>
      3e:	22 cb       	rjmp	.-2492   	; 0xfffff684 <__eeprom_end+0xff7ef684>
      40:	23 cb       	rjmp	.-2490   	; 0xfffff688 <__eeprom_end+0xff7ef688>
      42:	22 cb       	rjmp	.-2492   	; 0xfffff688 <__eeprom_end+0xff7ef688>
      44:	21 cb       	rjmp	.-2494   	; 0xfffff688 <__eeprom_end+0xff7ef688>

00000046 <sineTable>:
      46:	00 00 92 01 24 03 b6 04 48 06 d9 07 6a 09 fb 0a     ....$...H...j...
      56:	8c 0c 1c 0e ab 0f 3a 11 c8 12 55 14 e2 15 6e 17     ......:...U...n.
      66:	f9 18 82 1a 0b 1c 93 1d 1a 1f 9f 20 23 22 a6 23     ........... #".#
      76:	28 25 a8 26 26 28 a3 29 1f 2b 99 2c 11 2e 87 2f     (%.&&(.).+.,.../
      86:	fb 30 6e 32 df 33 4d 35 ba 36 24 38 8c 39 f2 3a     .0n2.3M5.6$8.9.:
      96:	56 3c b8 3d 17 3f 73 40 ce 41 25 43 7a 44 cd 45     V<.=.?s@.A%CzD.E
      a6:	1c 47 69 48 b4 49 fb 4a 3f 4c 81 4d bf 4e fb 4f     .GiH.I.J?L.M.N.O
      b6:	33 51 68 52 9b 53 c9 54 f5 55 1d 57 42 58 64 59     3QhR.S.T.U.WBXdY
      c6:	82 5a 9c 5b b3 5c c7 5d d7 5e e3 5f eb 60 f0 61     .Z.[.\.].^._.`.a
      d6:	f1 62 ee 63 e8 64 dd 65 cf 66 bc 67 a6 68 8b 69     .b.c.d.e.f.g.h.i
      e6:	6d 6a 4a 6b 23 6c f8 6c c9 6d 96 6e 5e 6f 22 70     mjJk#l.l.m.n^o"p
      f6:	e2 70 9d 71 54 72 07 73 b5 73 5f 74 04 75 a5 75     .p.qTr.s.s_t.u.u
     106:	41 76 d8 76 6b 77 fa 77 84 78 09 79 89 79 05 7a     Av.vkw.w.x.y.y.z
     116:	7c 7a ee 7a 5c 7b c5 7b 29 7c 88 7c e3 7c 39 7d     |z.z\{.{)|.|.|9}
     126:	89 7d d5 7d 1d 7e 5f 7e 9c 7e d5 7e 09 7f 37 7f     .}.}.~_~.~.~..7.
     136:	61 7f 86 7f a6 7f c1 7f d8 7f e9 7f f5 7f fd 7f     a...............
     146:	ff 7f                                               ..

00000148 <header>:
     148:	4c 43 44 64 69 72 65 63 74 4c 56 44 53 36 35 20     LCDdirectLVDS65 
     158:	32 30 31 34 2d 30 33 2d 31 39 20 32 32 3a 35 34     2014-03-19 22:54
     168:	3a 35 35 00                                         :55.

0000016c <characters>:
     16c:	00 0c 36 36 0c 00 1c 06 18 06 00 00 00 00 00 60     ..66...........`
     17c:	1e 0c 1e 1e 38 3f 1c 3f 1e 1e 00 00 18 00 06 1e     ....8?.?........
     18c:	3e 0c 3f 3c 3f 7f 7f 3c 33 1e 78 67 0f 63 63 1c     >.?<?..<3.xg.cc.
     19c:	3f 1e 3f 1e 3f 33 33 63 63 33 7f 1e 03 1e 08 00     ?.?.?33cc3......
     1ac:	0c 00 07 00 38 00 1c 00 07 0c 18 07 0e 00 00 00     ....8...........
     1bc:	00 00 00 00 08 00 00 00 00 00 00 38 18 07 6e 0e     ...........8..n.
     1cc:	00 1e 36 36 3e 63 36 06 0c 0c 66 0c 00 00 00 30     ..66>c6...f....0
     1dc:	33 0f 33 33 3c 03 06 33 33 33 00 00 0c 00 0c 33     3.33<..333.....3
     1ec:	63 1e 66 66 36 46 46 66 33 0c 30 66 06 77 67 36     c.ff6FFf3.0f.wg6
     1fc:	66 33 66 33 2d 33 33 63 63 33 33 06 06 18 1c 00     f3f3-33cc33.....
     20c:	0c 00 06 00 30 00 36 00 06 00 00 06 0c 00 00 00     ....0.6.........
     21c:	00 00 00 00 0c 00 00 00 00 00 00 0c 18 0c 3b 13     ..............;.
     22c:	00 1e 36 7f 03 33 1c 03 06 18 3c 0c 00 00 00 18     ..6..3....<.....
     23c:	3b 0c 30 30 36 1f 03 30 33 33 0c 0c 06 3f 18 30     ;.006..033...?.0
     24c:	7b 33 66 03 66 16 16 03 33 0c 30 36 06 7f 6f 63     {3f.f...3.06..oc
     25c:	66 33 66 07 0c 33 33 63 36 33 19 06 0c 18 36 00     f3f..33c63....6.
     26c:	18 1e 3e 1e 30 1e 06 6e 36 0e 1e 66 0c 37 1f 1e     ..>.0..n6..f.7..
     27c:	3b 6e 1b 3e 3e 33 33 63 63 33 3f 0c 18 0c 00 39     ;n.>>33cc3?....9
     28c:	00 0c 00 36 1e 18 6e 00 06 18 ff 3f 00 3f 00 0c     ...6..n....?.?..
     29c:	3f 0c 1c 1c 33 30 1f 18 1e 3e 0c 0c 03 00 30 18     ?...30...>....0.
     2ac:	7b 33 3e 03 66 1e 1e 03 3f 0c 30 1e 06 6b 7b 63     {3>.f...?.0..k{c
     2bc:	3e 33 3e 1c 0c 33 33 6b 1c 1e 0c 06 18 18 63 00     >3>..33k......c.
     2cc:	00 30 66 33 3e 33 0f 33 6e 0c 18 36 0c 7f 33 33     .0f3>3.3n..6..33
     2dc:	66 33 36 03 0c 33 33 63 36 33 19 07 00 38 00 69     f36..33c63...8.i
     2ec:	00 0c 00 7f 30 0c 3b 00 06 18 3c 0c 00 00 00 06     ....0.;...<.....
     2fc:	37 0c 06 30 7f 30 33 0c 33 30 00 00 06 3f 18 0c     7..0.03.30...?..
     30c:	7b 3f 66 03 66 16 16 73 33 0c 33 36 46 63 73 63     {?f.f..s3.36Fcsc
     31c:	06 3b 1e 38 0c 33 33 7f 36 0c 46 06 30 18 00 00     .;.8.33.6.F.0...
     32c:	00 3e 66 03 33 3f 06 33 66 0c 18 1e 0c 6b 33 33     .>f.3?.3f....k33
     33c:	66 33 36 1e 0c 33 33 6b 1c 33 0c 0c 18 0c 00 0e     f36..33k.3......
     34c:	00 00 00 36 1f 66 33 00 0c 0c 66 0c 0e 00 0c 03     ...6.f3...f.....
     35c:	33 0c 33 33 30 33 33 06 33 18 0c 0e 0c 00 0c 00     3.33033.3.......
     36c:	03 33 66 66 36 46 06 66 33 0c 33 66 66 63 63 36     .3ff6F.f3.3ffcc6
     37c:	06 1e 36 33 0c 33 1e 77 63 0c 63 06 60 18 00 00     ..63.3.wc.c.`...
     38c:	00 33 66 33 33 03 06 3e 66 0c 18 36 0c 63 33 33     .3f33..>f..6.c33
     39c:	3e 3e 06 30 2c 33 1e 7f 36 3e 26 0c 18 0c 00 f3     >>.0,3..6>&.....
     3ac:	00 0c 00 36 0c 63 6e 00 18 06 00 00 0c 00 0c 01     ...6.cn.........
     3bc:	1e 3f 3f 1e 30 1e 1e 06 1e 0e 0c 0c 18 00 06 0c     .??.0...........
     3cc:	1e 33 3f 3c 3f 7f 0f 7c 33 1e 1e 67 7f 63 63 1c     .3?<?..|3..g.cc.
     3dc:	0f 38 67 1e 1e 3f 0c 63 63 1e 7f 1e 40 1e 00 00     .8g..?.cc...@...
     3ec:	00 6e 3d 1e 6e 1e 0f 30 67 1e 1b 67 1e 63 33 1e     .n=.n..0g..g.c3.
     3fc:	06 30 0f 1f 18 6e 0c 36 63 30 3f 38 18 07 00 46     .0...n.6c0?8...F
     40c:	00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00     ................
     41c:	00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 00     ................
     42c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     43c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff     ................
     44c:	00 00 00 00 00 00 00 1f 00 00 0e 00 00 00 00 00     ................
     45c:	0f 78 00 00 00 00 00 00 00 1f 00 00 00 00 00 f4     .x..............

0000046c <pgm_imageCOIN3>:
     46c:	00 00 00 00 00 c0 01 00 00 c0 01 00 00 f0 07 00     ................
     47c:	00 f0 07 00 00 f0 07 00 00 f0 07 00 00 f0 07 00     ................
     48c:	00 f0 07 00 00 f0 07 00 00 f0 07 00 00 f0 07 00     ................
     49c:	00 f0 07 00 00 c0 01 00 00 c0 01 00 00 00 00 00     ................

000004ac <pgm_imageCOIN>:
     4ac:	00 00 00 00 00 80 02 00 00 a0 0a 00 00 a8 2a 00     ..............*.
     4bc:	00 e8 29 00 00 ba a6 00 00 ba a6 00 00 ba a6 00     ..).............
     4cc:	00 ba a6 00 00 ba a6 00 00 ba a6 00 00 e8 29 00     ..............).
     4dc:	00 a8 2a 00 00 a0 0a 00 00 80 02 00 00 00 00 00     ..*.............

000004ec <pgm_paletteCOIN>:
     4ec:	25 02 07 2f                                         %../

000004f0 <pgm_imageGOOMBA>:
     4f0:	00 50 05 00 00 54 15 00 00 55 55 00 40 55 55 01     .P...T...UU.@UU.
     500:	d0 57 d5 07 54 5e b5 15 54 fe bf 15 55 6e b9 55     .W..T^..T...Un.U
     510:	55 6a a9 55 55 55 55 55 54 a9 6a 15 00 aa aa 00     Uj.UUUUUT.j.....
     520:	00 aa aa 0f c0 ab fa 3f c0 af fe 3f 00 bf ff 0f     .......?...?....

00000530 <pgm_paletteGOOMBA>:
     530:	04 02 27 00 04 02 27 00 05 02 27 00 07 02 27 00     ..'...'...'...'.
     540:	03 01 26 00 00 20 01 20                             ..&.. . 

00000548 <pgm_imageQ>:
     548:	54 55 55 15 a9 aa aa ea b9 aa aa ee a9 56 a5 ea     TUU..........V..
     558:	a9 f5 97 ea a9 b5 d6 ea a9 b5 d6 ea a9 be d5 ea     ................
     568:	a9 6a fd ea a9 6a ad ea a9 aa af ea a9 6a a9 ea     .j...j.......j..
     578:	a9 6a ad ea b9 aa af ee a9 aa aa ea ff ff ff ff     .j..............

00000588 <pgm_paletteQ>:
     588:	25 02 07 00 25 02 02 00 25 02 01 00                 %...%...%...

00000594 <pgm_imageFLOWER>:
     594:	00 55 55 00 50 55 55 05 54 aa aa 15 a5 fe bf 5a     .UU.PUU.T......Z
     5a4:	a5 fe bf 5a 54 aa aa 15 50 55 55 05 00 55 55 00     ...ZT...PUU..UU.
     5b4:	00 40 01 00 15 40 01 54 54 40 01 15 54 41 41 15     .@...@.TT@..TAA.
     5c4:	50 45 51 05 50 45 51 05 40 55 55 01 00 50 05 00     PEQ.PEQ.@UU..P..

000005d4 <pgm_paletteFLOWER>:
     5d4:	25 04 00 00 25 2f 07 04 25 17 02 00 25 07 05 02     %...%/..%...%...

000005e4 <pgm_imageDEADGOOMBA>:
     5e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     5f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 50 05 00     .............P..
     604:	40 55 55 01 d4 5f f5 17 a5 fa af 5a 55 55 55 55     @UU.._.....ZUUUU
     614:	80 aa aa 02 80 aa aa 02 f0 0f f0 3f 00 00 00 00     ...........?....

00000624 <pgm_paletteDEADGOOMBA>:
     624:	25 02 27 00                                         %.'.

00000628 <pgm_imageSOLID>:
     628:	fc ff ff 3f 57 55 55 d5 77 55 55 dd 57 55 55 d5     ...?WUU.wUU.WUU.
     638:	57 55 55 d5 57 55 55 d5 57 55 55 d5 57 55 55 d5     WUU.WUU.WUU.WUU.
     648:	57 55 55 d5 57 55 55 d5 57 55 55 d5 57 55 55 d5     WUU.WUU.WUU.WUU.
     658:	57 55 55 d5 77 55 55 dd 57 55 55 d5 fc ff ff 3f     WUU.wUU.WUU....?

00000668 <pgm_paletteSOLID>:
     668:	25 02 00 00                                         %...

0000066c <pgm_imageSHROOM>:
     66c:	00 50 05 00 00 54 29 00 00 55 aa 00 40 55 aa 02     .P...T)..U..@U..
     67c:	50 55 a9 05 94 5a 55 15 a4 6a 55 15 a5 6a 55 5a     PU...ZU..jU..jUZ
     68c:	a5 6a 55 6a 95 5a 55 69 55 55 55 55 a4 fe bf 1a     .jUj.ZUiUUUU....
     69c:	00 ff ff 00 00 ff df 00 00 ff df 00 00 fc 37 00     ..............7.

000006ac <pgm_palette1UP>:
     6ac:	25 07 04 2f                                         %../

000006b0 <pgm_paletteBIG>:
     6b0:	25 07 02 2f                                         %../

000006b4 <pgm_imageSTAR>:
     6b4:	00 40 01 00 00 40 01 00 00 50 05 00 00 50 05 00     .@...@...P...P..
     6c4:	00 54 15 00 54 55 55 15 54 65 59 15 50 65 59 05     .T..TUU.TeY.PeY.
     6d4:	40 65 59 01 00 55 55 00 00 55 55 00 40 55 55 01     @eY..UU..UU.@UU.
     6e4:	40 55 55 01 40 15 54 01 50 01 40 05 50 00 00 05     @UU.@.T.P.@.P...

000006f4 <pgm_paletteSTAR>:
     6f4:	25 07 02 00 25 02 00 00                             %...%...

000006fc <pgm_imageCOIN1>:
     6fc:	00 00 00 00 00 80 01 00 00 80 01 00 00 60 05 00     .............`..
     70c:	00 60 05 00 00 60 05 00 00 60 05 00 00 70 05 00     .`...`...`...p..
     71c:	00 70 05 00 00 60 05 00 00 60 05 00 00 60 05 00     .p...`...`...`..
     72c:	00 60 05 00 00 80 01 00 00 80 01 00 00 00 00 00     .`..............

0000073c <pgm_imageCOIN2>:
     73c:	00 00 00 00 00 80 00 00 00 80 00 00 00 80 00 00     ................
     74c:	00 80 00 00 00 80 00 00 00 80 00 00 00 c0 00 00     ................
     75c:	00 c0 00 00 00 80 00 00 00 80 00 00 00 80 00 00     ................
     76c:	00 80 00 00 00 80 00 00 00 80 00 00 00 00 00 00     ................

0000077c <__ctors_end>:
     77c:	11 24       	eor	r1, r1
     77e:	1f be       	out	0x3f, r1	; 63
     780:	cf e5       	ldi	r28, 0x5F	; 95
     782:	d2 e0       	ldi	r29, 0x02	; 2
     784:	de bf       	out	0x3e, r29	; 62
     786:	cd bf       	out	0x3d, r28	; 61

00000788 <__do_copy_data>:
     788:	10 e0       	ldi	r17, 0x00	; 0
     78a:	a0 e6       	ldi	r26, 0x60	; 96
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	ea e9       	ldi	r30, 0x9A	; 154
     790:	fd e1       	ldi	r31, 0x1D	; 29
     792:	02 c0       	rjmp	.+4      	; 0x798 <__do_copy_data+0x10>
     794:	05 90       	lpm	r0, Z+
     796:	0d 92       	st	X+, r0
     798:	aa 3b       	cpi	r26, 0xBA	; 186
     79a:	b1 07       	cpc	r27, r17
     79c:	d9 f7       	brne	.-10     	; 0x794 <__do_copy_data+0xc>

0000079e <__do_clear_bss>:
     79e:	11 e0       	ldi	r17, 0x01	; 1
     7a0:	aa eb       	ldi	r26, 0xBA	; 186
     7a2:	b0 e0       	ldi	r27, 0x00	; 0
     7a4:	01 c0       	rjmp	.+2      	; 0x7a8 <.do_clear_bss_start>

000007a6 <.do_clear_bss_loop>:
     7a6:	1d 92       	st	X+, r1

000007a8 <.do_clear_bss_start>:
     7a8:	ac 3c       	cpi	r26, 0xCC	; 204
     7aa:	b1 07       	cpc	r27, r17
     7ac:	e1 f7       	brne	.-8      	; 0x7a6 <.do_clear_bss_loop>
     7ae:	38 da       	rcall	.-2960   	; 0xfffffc20 <__eeprom_end+0xff7efc20>
     7b0:	f2 ca       	rjmp	.-2588   	; 0xfffffd96 <__eeprom_end+0xff7efd96>

000007b2 <__bad_interrupt>:
     7b2:	26 cc       	rjmp	.-1972   	; 0x0 <__vectors>

000007b4 <hfm_setup>:

//Mainly just for setting up the maxPower (divisor)
// [can] use hfm_setPower otherwise...
// can't tell how to get away without using hfm_setup once
void hfm_setup(hfm_t *modulator, uint8_t power, uint8_t maxPower)
{
     7b4:	fc 01       	movw	r30, r24
	modulator->desiredSum = 0;
     7b6:	11 82       	std	Z+1, r1	; 0x01
     7b8:	10 82       	st	Z, r1
	modulator->maxPower = maxPower;
     7ba:	42 83       	std	Z+2, r20	; 0x02
{
	//Don't allow power values > 1, otherwise who knows what'll happen...
	//(This is probably unnecessary, but whatev)
	//It's not, actually, if power's greater than maxPower, the values never reset
	// This is trouble, e.g. in heartbeat, where modulator.power is read
	if(power <= (modulator->maxPower))
     7bc:	82 81       	ldd	r24, Z+2	; 0x02
     7be:	86 17       	cp	r24, r22
     7c0:	10 f0       	brcs	.+4      	; 0x7c6 <hfm_setup+0x12>
		modulator->power = power;
     7c2:	63 83       	std	Z+3, r22	; 0x03
     7c4:	08 95       	ret
	else
		modulator->power = modulator->maxPower;
     7c6:	82 81       	ldd	r24, Z+2	; 0x02
     7c8:	83 83       	std	Z+3, r24	; 0x03
     7ca:	08 95       	ret

000007cc <hfm_setPower>:
// This needs to be set, initially! 
//   either init it in the hfm variable declaration
//   or use hfm_setup (ideal)
// however, sometimes it needs to be variable, thus hfm_setup (above)
void hfm_setPower(hfm_t	*modulator, uint8_t power)
{
     7cc:	fc 01       	movw	r30, r24
	//Don't allow power values > 1, otherwise who knows what'll happen...
	//(This is probably unnecessary, but whatev)
	//It's not, actually, if power's greater than maxPower, the values never reset
	// This is trouble, e.g. in heartbeat, where modulator.power is read
	if(power <= (modulator->maxPower))
     7ce:	82 81       	ldd	r24, Z+2	; 0x02
     7d0:	86 17       	cp	r24, r22
     7d2:	10 f0       	brcs	.+4      	; 0x7d8 <hfm_setPower+0xc>
		modulator->power = power;
     7d4:	63 83       	std	Z+3, r22	; 0x03
     7d6:	08 95       	ret
	else
		modulator->power = modulator->maxPower;
     7d8:	82 81       	ldd	r24, Z+2	; 0x02
     7da:	83 83       	std	Z+3, r24	; 0x03
     7dc:	08 95       	ret

000007de <hfm_nextOutput>:
}

//Returns 0 if the "output" should be "off" in this cycle
//		  1 if the "output" should be "on"  in this cycle
uint8_t hfm_nextOutput(hfm_t *modulator)
{
     7de:	fc 01       	movw	r30, r24
	// IF desired == 255, we want it never to clr...
	//		but running will be 0 the first time
	//		and we'll therefore if... set == good
	//		and later we'll runningSum == desiredSum (above) 
	//    and reset and if again
	if(modulator->desiredSum > 0)
     7e0:	80 81       	ld	r24, Z
     7e2:	91 81       	ldd	r25, Z+1	; 0x01
     7e4:	18 16       	cp	r1, r24
     7e6:	19 06       	cpc	r1, r25
     7e8:	14 f0       	brlt	.+4      	; 0x7ee <hfm_nextOutput+0x10>
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	08 c0       	rjmp	.+16     	; 0x7fe <hfm_nextOutput+0x20>
	{
		(modulator->desiredSum) -= (modulator->maxPower); //0xff;
     7ee:	80 81       	ld	r24, Z
     7f0:	91 81       	ldd	r25, Z+1	; 0x01
     7f2:	22 81       	ldd	r18, Z+2	; 0x02
     7f4:	82 1b       	sub	r24, r18
     7f6:	91 09       	sbc	r25, r1
     7f8:	91 83       	std	Z+1, r25	; 0x01
     7fa:	80 83       	st	Z, r24
     7fc:	81 e0       	ldi	r24, 0x01	; 1
	{
		//Don't modify runningSum, wait until desiredSum catches up...
		toReturn = FALSE;
	}
	
	(modulator->desiredSum) += (modulator->power);
     7fe:	20 81       	ld	r18, Z
     800:	31 81       	ldd	r19, Z+1	; 0x01
     802:	93 81       	ldd	r25, Z+3	; 0x03
     804:	29 0f       	add	r18, r25
     806:	31 1d       	adc	r19, r1
     808:	31 83       	std	Z+1, r19	; 0x01
     80a:	20 83       	st	Z, r18
		modulator->runningSum = 0;
		modulator->desiredSum = 0;
	}
*/	
	return toReturn;
}
     80c:	08 95       	ret

0000080e <adc_select>:
	// see Figure 21.5
	//"Note that the conversion starts on the following rising ADC clock edge after 
	// ADSC is written. The user is thus advised not to write new channel or reference
	// selection values to ADMUX until one ADC clock cycle after ADSC is written. 

	writeMasked(adcNum, ADC_SELECT_MASK, ADMUX);
     80e:	97 b1       	in	r25, 0x07	; 7
     810:	8f 71       	andi	r24, 0x1F	; 31
     812:	90 7e       	andi	r25, 0xE0	; 224
     814:	89 2b       	or	r24, r25
     816:	87 b9       	out	0x07, r24	; 7
}
     818:	08 95       	ret

0000081a <adc_startConversion>:
	//  The ADSC bit will be read as one during a conversion, 
	//  independently of how the conversion was started."
	//  actually, it would return true /always/ during free-running mode

	//Check state-machine... might be better to use ADIF...?
	return getbit(ADSC, ADCSRA);
     81a:	86 b1       	in	r24, 0x06	; 6

//Return TRUE on error (if there was a previous conversion in progress...)
uint8_t adc_startConversion(void)
{
	//Check if a conversion is already in progress...
	if(adc_isBusy())
     81c:	80 74       	andi	r24, 0x40	; 64
     81e:	11 f0       	breq	.+4      	; 0x824 <adc_startConversion+0xa>
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	08 95       	ret
	// until a conversion is started. Once the conversion starts, the channel and 
	// reference selection is locked to ensure a sufficient sampling time for the ADC."
	
	//"In Single Conversion mode, write this bit to one to start each conversion."
	// BEWARE: calling this will CLEAR the conversion-complete indicator
	setbit(ADSC, ADCSRA);
     824:	36 9a       	sbi	0x06, 6	; 6
     826:	80 e0       	ldi	r24, 0x00	; 0
	return FALSE;
}
     828:	08 95       	ret

0000082a <adc_init>:
	// (i.e. a 3.3V voltage regulator output)
	//Technically, these values are reset-defaults, but just make sure
	//!!!According to attiny861, these values set VCC as the voltage ref
	//   NOT an external reference. So the above note seems odd...
	// This IS what I want on the Tiny861 threePinIDer...
	clrbit(REFS0, ADMUX);
     82a:	3e 98       	cbi	0x07, 6	; 7
	clrbit(REFS1, ADMUX);
     82c:	3f 98       	cbi	0x07, 7	; 7
	
	//Use right-adjusted output
	// so values read from the 2-byte register are:
	//	8-bits in the Low reg, and 2 in the High reg
	clrbit(ADLAR, ADMUX);
     82e:	3d 98       	cbi	0x07, 5	; 7

	//Enable the ADC
	// (see description for noise cancelling techniques)
	setbit(ADEN, ADCSRA);
     830:	37 9a       	sbi	0x06, 7	; 6
	
	//Don't use Auto Triggering
	// (@@@ could use a timer, etc.)
	clrbit(ADATE, ADCSRA);
     832:	35 98       	cbi	0x06, 5	; 6
	// "ADIF is cleared by writing a logical one to the flag."
	// " BEWARE that if doing a Read-Modify-Write on ADCSRA, a pending interrupt can be disabled. "
	//   because the flag may be 1 when read, and re-writing 1 clears it.
	//   ???could get around this by using a special set/clrbit instruction which would always write 0
	//   to this bit...
	setbit(ADIF, ADCSRA);
     834:	34 9a       	sbi	0x06, 4	; 6
	
	//make sure the interrupt is not enabled...
	clrbit(ADIE, ADCSRA);
     836:	33 98       	cbi	0x06, 3	; 6
}

void adc_setPrescaler(uint8_t adps)
{
	//This will clear the conversion-complete flag!
	writeMasked(adps, ADPS_MASK, ADCSRA);
     838:	86 b1       	in	r24, 0x06	; 6
     83a:	87 60       	ori	r24, 0x07	; 7
     83c:	86 b9       	out	0x06, r24	; 6
	// see Figure 21.5
	//"Note that the conversion starts on the following rising ADC clock edge after 
	// ADSC is written. The user is thus advised not to write new channel or reference
	// selection values to ADMUX until one ADC clock cycle after ADSC is written. 

	writeMasked(adcNum, ADC_SELECT_MASK, ADMUX);
     83e:	87 b1       	in	r24, 0x07	; 7
     840:	8f 61       	ori	r24, 0x1F	; 31
     842:	87 b9       	out	0x07, r24	; 7
	//Start a conversion so it will be initialized for the next...
	//"The first conversion after ADSC has been written 
	// after the ADC has been enabled ... 
	// will take 25 ADC clock cycles instead of the normal 13. 
	// This first conversion performs initialization of the ADC. "
	adc_startConversion();
     844:	ea df       	rcall	.-44     	; 0x81a <adc_startConversion>
	//  The ADSC bit will be read as one during a conversion, 
	//  independently of how the conversion was started."
	//  actually, it would return true /always/ during free-running mode

	//Check state-machine... might be better to use ADIF...?
	return getbit(ADSC, ADCSRA);
     846:	86 b1       	in	r24, 0x06	; 6
	// will take 25 ADC clock cycles instead of the normal 13. 
	// This first conversion performs initialization of the ADC. "
	adc_startConversion();

	//Wait for the initialization to complete for lockstepping...
	while(adc_isBusy())
     848:	80 74       	andi	r24, 0x40	; 64
     84a:	e9 f7       	brne	.-6      	; 0x846 <adc_init+0x1c>
	{}
}
     84c:	08 95       	ret

0000084e <adc_getValue>:
//Return the last value read by the ADC
// check if adc_isBusy is true before reading, in lockstep...
// Since ADLAR is cleared, it will be the low ten bits 
uint16_t adc_getValue(void)
{
	return ADC;
     84e:	24 b1       	in	r18, 0x04	; 4
     850:	35 b1       	in	r19, 0x05	; 5
	//reading both values takes longer and some other things mentioned in the manual
	// (i.e. it might be more efficient to only read one byte if acceptable)
	// unless only reading ADCH: "ADCL must be read first, then ADCH"
	//!!! Might want to verify this occurs properly in the assembly code
	
}
     852:	c9 01       	movw	r24, r18
     854:	08 95       	ret

00000856 <adc_isBusy>:
	//  The ADSC bit will be read as one during a conversion, 
	//  independently of how the conversion was started."
	//  actually, it would return true /always/ during free-running mode

	//Check state-machine... might be better to use ADIF...?
	return getbit(ADSC, ADCSRA);
     856:	86 b1       	in	r24, 0x06	; 6
     858:	82 95       	swap	r24
     85a:	86 95       	lsr	r24
     85c:	86 95       	lsr	r24
}
     85e:	81 70       	andi	r24, 0x01	; 1
     860:	08 95       	ret

00000862 <adc_setPrescaler>:

void adc_setPrescaler(uint8_t adps)
{
	//This will clear the conversion-complete flag!
	writeMasked(adps, ADPS_MASK, ADCSRA);
     862:	96 b1       	in	r25, 0x06	; 6
     864:	87 70       	andi	r24, 0x07	; 7
     866:	98 7f       	andi	r25, 0xF8	; 248
     868:	89 2b       	or	r24, r25
     86a:	86 b9       	out	0x06, r24	; 6
}
     86c:	08 95       	ret

0000086e <adc_takeInput>:
	uint8_t bitNum = inputNum;

#ifdef _AVR_IOTNx61_H_
	//ATTINYx61's have AREFD at bit 3, rather than ADC3D
	// the following ADC inputs are shifted 
	if(inputNum > 2)
     86e:	83 30       	cpi	r24, 0x03	; 3
     870:	80 f0       	brcs	.+32     	; 0x892 <adc_takeInput+0x24>

	//Analog inputs 7-10 are selected in DIDR1 and shifted...
	// 7 is bit 4, 10 is bit 7...
	//CURRENTLY ONLY: channels 0-7 are usable in this version
	// THIS NOTE SHOULD BE INVALID AS OF 0.19.
	if(inputNum >= 7)
     872:	87 30       	cpi	r24, 0x07	; 7
     874:	10 f4       	brcc	.+4      	; 0x87a <adc_takeInput+0xc>

#ifdef _AVR_IOTNx61_H_
	//ATTINYx61's have AREFD at bit 3, rather than ADC3D
	// the following ADC inputs are shifted 
	if(inputNum > 2)
		bitNum = inputNum + 1;
     876:	8f 5f       	subi	r24, 0xFF	; 255
     878:	0c c0       	rjmp	.+24     	; 0x892 <adc_takeInput+0x24>
	//CURRENTLY ONLY: channels 0-7 are usable in this version
	// THIS NOTE SHOULD BE INVALID AS OF 0.19.
	if(inputNum >= 7)
	{
		bitNum = inputNum - 3;
		setbit(bitNum, DIDR1);
     87a:	92 b1       	in	r25, 0x02	; 2
     87c:	83 50       	subi	r24, 0x03	; 3
     87e:	21 e0       	ldi	r18, 0x01	; 1
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	02 c0       	rjmp	.+4      	; 0x888 <adc_takeInput+0x1a>
     884:	22 0f       	add	r18, r18
     886:	33 1f       	adc	r19, r19
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <adc_takeInput+0x16>
     88c:	92 2b       	or	r25, r18
     88e:	92 b9       	out	0x02, r25	; 2
		return;
     890:	08 95       	ret
	}
#endif

	if(bitNum <= 7)
		setbit(bitNum, DIDR0);
     892:	91 b1       	in	r25, 0x01	; 1
     894:	21 e0       	ldi	r18, 0x01	; 1
     896:	30 e0       	ldi	r19, 0x00	; 0
     898:	02 c0       	rjmp	.+4      	; 0x89e <adc_takeInput+0x30>
     89a:	22 0f       	add	r18, r18
     89c:	33 1f       	adc	r19, r19
     89e:	8a 95       	dec	r24
     8a0:	e2 f7       	brpl	.-8      	; 0x89a <adc_takeInput+0x2c>
     8a2:	92 2b       	or	r25, r18
     8a4:	91 b9       	out	0x01, r25	; 1
     8a6:	08 95       	ret

000008a8 <timer_selectDivisor>:
	uint8_t csbits;
	
  #if defined(CSOBS)
	if(timerNum == 0 || timerNum == 1 || timerNum == 3)//IS_CSTYP(timerNum) || IS_CSOBS(timerNum))
  #else
	if(IS_CSTYP(timerNum))
     8a8:	82 30       	cpi	r24, 0x02	; 2
     8aa:	28 f5       	brcc	.+74     	; 0x8f6 <timer_selectDivisor+0x4e>
  #endif
	{
		switch(clockDiv)
     8ac:	66 30       	cpi	r22, 0x06	; 6
     8ae:	81 f0       	breq	.+32     	; 0x8d0 <timer_selectDivisor+0x28>
     8b0:	67 30       	cpi	r22, 0x07	; 7
     8b2:	28 f4       	brcc	.+10     	; 0x8be <timer_selectDivisor+0x16>
     8b4:	66 23       	and	r22, r22
     8b6:	51 f0       	breq	.+20     	; 0x8cc <timer_selectDivisor+0x24>
     8b8:	63 30       	cpi	r22, 0x03	; 3
     8ba:	e9 f4       	brne	.+58     	; 0x8f6 <timer_selectDivisor+0x4e>
     8bc:	05 c0       	rjmp	.+10     	; 0x8c8 <timer_selectDivisor+0x20>
     8be:	68 30       	cpi	r22, 0x08	; 8
     8c0:	49 f0       	breq	.+18     	; 0x8d4 <timer_selectDivisor+0x2c>
     8c2:	6a 30       	cpi	r22, 0x0A	; 10
     8c4:	c1 f4       	brne	.+48     	; 0x8f6 <timer_selectDivisor+0x4e>
     8c6:	08 c0       	rjmp	.+16     	; 0x8d8 <timer_selectDivisor+0x30>
     8c8:	92 e0       	ldi	r25, 0x02	; 2
     8ca:	07 c0       	rjmp	.+14     	; 0x8da <timer_selectDivisor+0x32>
     8cc:	91 e0       	ldi	r25, 0x01	; 1
     8ce:	05 c0       	rjmp	.+10     	; 0x8da <timer_selectDivisor+0x32>
     8d0:	93 e0       	ldi	r25, 0x03	; 3
			case CLKDIV8:
				csbits = CSTYP_DIV8;
				break;
			case CLKDIV64:
				csbits = CSTYP_DIV64;	
				break;
     8d2:	03 c0       	rjmp	.+6      	; 0x8da <timer_selectDivisor+0x32>
     8d4:	94 e0       	ldi	r25, 0x04	; 4
			case CLKDIV256:
				csbits = CSTYP_DIV256;	
				break;
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <timer_selectDivisor+0x32>
     8d8:	95 e0       	ldi	r25, 0x05	; 5
     8da:	97 70       	andi	r25, 0x07	; 7
	}
  #endif
	else 
		return 1;	

	switch(timerNum)
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	29 f0       	breq	.+10     	; 0x8ea <timer_selectDivisor+0x42>
	{
		//Assume Timer0 and Timer1 exist (see setWGM)
		case 0:
			writeMasked(csbits, CSMASK, T0_CSReg);
     8e0:	83 b7       	in	r24, 0x33	; 51
     8e2:	88 7f       	andi	r24, 0xF8	; 248
     8e4:	89 2b       	or	r24, r25
     8e6:	83 bf       	out	0x33, r24	; 51
     8e8:	04 c0       	rjmp	.+8      	; 0x8f2 <timer_selectDivisor+0x4a>
			break;
		case 1:
			writeMasked(csbits, CSMASK, T1_CSReg);
     8ea:	8f b5       	in	r24, 0x2f	; 47
     8ec:	88 7f       	andi	r24, 0xF8	; 248
     8ee:	89 2b       	or	r24, r25
     8f0:	8f bd       	out	0x2f, r24	; 47
     8f2:	80 e0       	ldi	r24, 0x00	; 0
			break;
     8f4:	08 95       	ret
     8f6:	81 e0       	ldi	r24, 0x01	; 1
			return 1;
			break;
	}
	
	return 0;
}
     8f8:	08 95       	ret

000008fa <timer_setWGM>:
//	wgmLb *= 0xff;
//	wgmHb *= 0xff;

	//Make sure the chosen WGM will be written to the WGM bits properly, as implemented below...
	// Only modes 0-3 are implemented...
	if(wgm > 0x03)
     8fa:	64 30       	cpi	r22, 0x04	; 4
     8fc:	f0 f4       	brcc	.+60     	; 0x93a <timer_setWGM+0x40>
		return 1;
	
	switch(timerNum)
     8fe:	88 23       	and	r24, r24
     900:	19 f0       	breq	.+6      	; 0x908 <timer_setWGM+0xe>
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	d1 f4       	brne	.+52     	; 0x93a <timer_setWGM+0x40>
     906:	0a c0       	rjmp	.+20     	; 0x91c <timer_setWGM+0x22>
#ifdef _AVR_IOTNx61_H_
			//TinyX61s' Timer0 is an exception...
			// It only has WGM00, which serves the same functionality as
			// most others' WGM01 (when their WGM00 == 0)
			// (No PWM)
			if(wgmLb)
     908:	86 2f       	mov	r24, r22
     90a:	81 70       	andi	r24, 0x01	; 1
     90c:	b1 f4       	brne	.+44     	; 0x93a <timer_setWGM+0x40>
				return 1;

			//Whatever .stab is, this single change reduces it by 36Bytes
			writebit(WGM00, T0_WGMReg, wgmHb);
     90e:	62 70       	andi	r22, 0x02	; 2
     910:	11 f0       	breq	.+4      	; 0x916 <timer_setWGM+0x1c>
     912:	a8 9a       	sbi	0x15, 0	; 21
     914:	01 c0       	rjmp	.+2      	; 0x918 <timer_setWGM+0x1e>
     916:	a8 98       	cbi	0x15, 0	; 21
     918:	85 b3       	in	r24, 0x15	; 21
     91a:	0d c0       	rjmp	.+26     	; 0x936 <timer_setWGM+0x3c>
     91c:	61 30       	cpi	r22, 0x01	; 1
     91e:	19 f4       	brne	.+6      	; 0x926 <timer_setWGM+0x2c>
					wgmHb = 0;
					break;
			}

			//NOTE: TinyX61s' WGM bits are both in TCCR1D (very unusual)
			writebit(WGM10, TCCR1D, wgmLb);
     920:	86 b5       	in	r24, 0x26	; 38
     922:	81 60       	ori	r24, 0x01	; 1
     924:	02 c0       	rjmp	.+4      	; 0x92a <timer_setWGM+0x30>
     926:	86 b5       	in	r24, 0x26	; 38
     928:	8e 7f       	andi	r24, 0xFE	; 254
     92a:	86 bd       	out	0x26, r24	; 38
     92c:	86 b5       	in	r24, 0x26	; 38
			writebit(WGM11, TCCR1D, wgmHb);
     92e:	86 b5       	in	r24, 0x26	; 38
     930:	8d 7f       	andi	r24, 0xFD	; 253
     932:	86 bd       	out	0x26, r24	; 38
     934:	86 b5       	in	r24, 0x26	; 38
     936:	80 e0       	ldi	r24, 0x00	; 0
     938:	08 95       	ret
     93a:	81 e0       	ldi	r24, 0x01	; 1
			return 1;
			break;
	}
	
	return 0;
}
     93c:	08 95       	ret

0000093e <timer_init>:

//Roughly equivalent to the ol' Init_timerX(clkDiv, wgm)
//Return 0 if no error...
#if (!defined(TIMER_INIT_UNUSED) || !TIMER_INIT_UNUSED)
uint8_t timer_init(uint8_t timerNum, uint8_t clockDiv, uint8_t wgm)
{
     93e:	0f 93       	push	r16
     940:	1f 93       	push	r17
     942:	18 2f       	mov	r17, r24
     944:	06 2f       	mov	r16, r22
	//set the waveform mode
	ERR_HANDLE_NUM(1,				\
     946:	64 2f       	mov	r22, r20
     948:	d8 df       	rcall	.-80     	; 0x8fa <timer_setWGM>
     94a:	88 23       	and	r24, r24
     94c:	11 f0       	breq	.+4      	; 0x952 <timer_init+0x14>
     94e:	80 61       	ori	r24, 0x10	; 16
     950:	05 c0       	rjmp	.+10     	; 0x95c <timer_init+0x1e>
		timer_setWGM(timerNum, wgm)	);

	//select the clock
	ERR_HANDLE_NUM(2,							\
     952:	81 2f       	mov	r24, r17
     954:	60 2f       	mov	r22, r16
     956:	a8 df       	rcall	.-176    	; 0x8a8 <timer_selectDivisor>
     958:	81 11       	cpse	r24, r1
     95a:	80 62       	ori	r24, 0x20	; 32
		timer_selectDivisor(timerNum, clockDiv)	);
		
	return 0;
}
     95c:	1f 91       	pop	r17
     95e:	0f 91       	pop	r16
     960:	08 95       	ret

00000962 <timer_compareMatchIntSetup>:
uint8_t timer_compareMatchIntSetup(uint8_t timerNum, uint8_t outputChannel,\
	  												uint8_t enable)
{
	uint8_t channelNum;

	if(timerNum >= MAXTIMERS)
     962:	84 30       	cpi	r24, 0x04	; 4
     964:	10 f0       	brcs	.+4      	; 0x96a <timer_compareMatchIntSetup+0x8>
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	08 95       	ret
		return 1;

	if(outputChannel >= 2) //MAXCHANNELSPERTIMER)
     96a:	62 30       	cpi	r22, 0x02	; 2
     96c:	10 f0       	brcs	.+4      	; 0x972 <timer_compareMatchIntSetup+0x10>
     96e:	82 e0       	ldi	r24, 0x02	; 2
     970:	08 95       	ret
     972:	44 23       	and	r20, r20
     974:	11 f0       	breq	.+4      	; 0x97a <timer_compareMatchIntSetup+0x18>
     976:	41 e0       	ldi	r20, 0x01	; 1
	channelNum = (timerNum<<4) + outputChannel;

	//Don't clear interrupts before disabling this one, or that defeats the purpose!
	// But do clear so we don't get unexpected overflows on init
	if(enable)
		cli();
     978:	f8 94       	cli
	
	switch(channelNum)
     97a:	82 95       	swap	r24
     97c:	80 7f       	andi	r24, 0xF0	; 240
     97e:	86 0f       	add	r24, r22
     980:	81 30       	cpi	r24, 0x01	; 1
     982:	a1 f0       	breq	.+40     	; 0x9ac <timer_compareMatchIntSetup+0x4a>
     984:	81 30       	cpi	r24, 0x01	; 1
     986:	30 f0       	brcs	.+12     	; 0x994 <timer_compareMatchIntSetup+0x32>
     988:	80 31       	cpi	r24, 0x10	; 16
     98a:	e1 f0       	breq	.+56     	; 0x9c4 <timer_compareMatchIntSetup+0x62>
     98c:	81 31       	cpi	r24, 0x11	; 17
     98e:	31 f1       	breq	.+76     	; 0x9dc <timer_compareMatchIntSetup+0x7a>
     990:	83 e0       	ldi	r24, 0x03	; 3
     992:	08 95       	ret
			break;
	   #endif
	   #if defined(OCIE0A)
		case 0x00:
//			setbit(OCIE0A, T0_TIMSK);
			writebit(OCIE0A, T0_TIMSK, enable);
     994:	44 23       	and	r20, r20
     996:	19 f0       	breq	.+6      	; 0x99e <timer_compareMatchIntSetup+0x3c>
     998:	89 b7       	in	r24, 0x39	; 57
     99a:	80 61       	ori	r24, 0x10	; 16
     99c:	02 c0       	rjmp	.+4      	; 0x9a2 <timer_compareMatchIntSetup+0x40>
     99e:	89 b7       	in	r24, 0x39	; 57
     9a0:	8f 7e       	andi	r24, 0xEF	; 239
     9a2:	89 bf       	out	0x39, r24	; 57
     9a4:	89 b7       	in	r24, 0x39	; 57
			// My OCD bit me in the ass, this was set to TIMSK by mistake(?)
			setbit(OCF0A, T0_TIFR);
     9a6:	88 b7       	in	r24, 0x38	; 56
     9a8:	80 61       	ori	r24, 0x10	; 16
     9aa:	23 c0       	rjmp	.+70     	; 0x9f2 <timer_compareMatchIntSetup+0x90>
			break;
	   #endif
	   #if defined(OCIE0B)
		case 0x01:
//			setbit(OCIE0B, T0_TIMSK);
			writebit(OCIE0B, T0_TIMSK, enable);
     9ac:	44 23       	and	r20, r20
     9ae:	19 f0       	breq	.+6      	; 0x9b6 <timer_compareMatchIntSetup+0x54>
     9b0:	89 b7       	in	r24, 0x39	; 57
     9b2:	88 60       	ori	r24, 0x08	; 8
     9b4:	02 c0       	rjmp	.+4      	; 0x9ba <timer_compareMatchIntSetup+0x58>
     9b6:	89 b7       	in	r24, 0x39	; 57
     9b8:	87 7f       	andi	r24, 0xF7	; 247
     9ba:	89 bf       	out	0x39, r24	; 57
     9bc:	89 b7       	in	r24, 0x39	; 57
			// As was this...
			setbit(OCF0B, T0_TIFR);
     9be:	88 b7       	in	r24, 0x38	; 56
     9c0:	88 60       	ori	r24, 0x08	; 8
     9c2:	17 c0       	rjmp	.+46     	; 0x9f2 <timer_compareMatchIntSetup+0x90>
			break;
	   #endif
	   #if defined(OCIE1A)
		case 0x10:
//			setbit(OCIE1A, T1_TIMSK);
			writebit(OCIE1A, T1_TIMSK, enable);
     9c4:	44 23       	and	r20, r20
     9c6:	19 f0       	breq	.+6      	; 0x9ce <timer_compareMatchIntSetup+0x6c>
     9c8:	89 b7       	in	r24, 0x39	; 57
     9ca:	80 64       	ori	r24, 0x40	; 64
     9cc:	02 c0       	rjmp	.+4      	; 0x9d2 <timer_compareMatchIntSetup+0x70>
     9ce:	89 b7       	in	r24, 0x39	; 57
     9d0:	8f 7b       	andi	r24, 0xBF	; 191
     9d2:	89 bf       	out	0x39, r24	; 57
     9d4:	89 b7       	in	r24, 0x39	; 57
			setbit(OCF1A, T1_TIFR);
     9d6:	88 b7       	in	r24, 0x38	; 56
     9d8:	80 64       	ori	r24, 0x40	; 64
     9da:	0b c0       	rjmp	.+22     	; 0x9f2 <timer_compareMatchIntSetup+0x90>
			break;
	   #endif
	   #if defined(OCIE1B)
		case 0x11:
//			setbit(OCIE1B, T1_TIMSK);
			writebit(OCIE1B, T1_TIMSK, enable);
     9dc:	44 23       	and	r20, r20
     9de:	19 f0       	breq	.+6      	; 0x9e6 <timer_compareMatchIntSetup+0x84>
     9e0:	89 b7       	in	r24, 0x39	; 57
     9e2:	80 62       	ori	r24, 0x20	; 32
     9e4:	02 c0       	rjmp	.+4      	; 0x9ea <timer_compareMatchIntSetup+0x88>
     9e6:	89 b7       	in	r24, 0x39	; 57
     9e8:	8f 7d       	andi	r24, 0xDF	; 223
     9ea:	89 bf       	out	0x39, r24	; 57
     9ec:	89 b7       	in	r24, 0x39	; 57
			setbit(OCF1B, T1_TIFR);
     9ee:	88 b7       	in	r24, 0x38	; 56
     9f0:	80 62       	ori	r24, 0x20	; 32
     9f2:	88 bf       	out	0x38, r24	; 56
			break;
	}
	
	//Don't reenable interrupts here if disabling... just leave them as they were....
	// but do enable for init...
	if(enable)
     9f4:	44 23       	and	r20, r20
     9f6:	11 f4       	brne	.+4      	; 0x9fc <timer_compareMatchIntSetup+0x9a>
     9f8:	80 e0       	ldi	r24, 0x00	; 0
     9fa:	08 95       	ret
		sei();
     9fc:	78 94       	sei
     9fe:	80 e0       	ldi	r24, 0x00	; 0
	
	return 0;
}
     a00:	08 95       	ret

00000a02 <quadrantizeTheta>:
// negative values returned here are to be absoluted, first
// but they indicate that the resulting sine value is to be negated
theta_t quadrantizeTheta(theta_t theta)
{

	theta %= SINE_2PI;
     a02:	60 e0       	ldi	r22, 0x00	; 0
     a04:	72 e0       	ldi	r23, 0x02	; 2
     a06:	b4 d9       	rcall	.-3224   	; 0xfffffd70 <__eeprom_end+0xff7efd70>
     a08:	9c 01       	movw	r18, r24

	if(theta < 0)
     a0a:	37 ff       	sbrs	r19, 7
     a0c:	02 c0       	rjmp	.+4      	; 0xa12 <quadrantizeTheta+0x10>
		theta = SINE_2PI + theta;
     a0e:	20 50       	subi	r18, 0x00	; 0
     a10:	3e 4f       	sbci	r19, 0xFE	; 254

//For more accurate realtimeishness, it might be worthwhile to reverse this order...
	
	//in the first quadrant, just take the sine value from the table
	if(theta < SINE_SIZE-1) //128)
     a12:	20 38       	cpi	r18, 0x80	; 128
     a14:	31 05       	cpc	r19, r1
     a16:	8c f0       	brlt	.+34     	; 0xa3a <quadrantizeTheta+0x38>
	{
		//theta=theta;
	}	
	//in the second quadrant, mirror theta and subtract the offset
	else if(theta < SINE_SIZE2) //256)
     a18:	2f 3f       	cpi	r18, 0xFF	; 255
     a1a:	31 05       	cpc	r19, r1
     a1c:	29 f0       	breq	.+10     	; 0xa28 <quadrantizeTheta+0x26>
     a1e:	24 f0       	brlt	.+8      	; 0xa28 <quadrantizeTheta+0x26>
	{
		theta=SINE_SIZE2-theta;
		//return pgm_read_sine(sineTable[SINE_SIZE2-theta]); //256-theta]);
	}
	//in the third quadrant, mirror the value and subtract the offset
	else if(theta < SINE_SIZE3) //384)
     a20:	51 e0       	ldi	r21, 0x01	; 1
     a22:	20 38       	cpi	r18, 0x80	; 128
     a24:	35 07       	cpc	r19, r21
     a26:	3c f4       	brge	.+14     	; 0xa36 <quadrantizeTheta+0x34>
	{
		theta=-(theta-SINE_SIZE2);
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	91 e0       	ldi	r25, 0x01	; 1
     a2c:	ac 01       	movw	r20, r24
     a2e:	42 1b       	sub	r20, r18
     a30:	53 0b       	sbc	r21, r19
     a32:	9a 01       	movw	r18, r20
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <quadrantizeTheta+0x38>
		//return -(sine_t)pgm_read_sine(sineTable[theta-SINE_SIZE2]); //256]);
	}
	//in the fourth quadrant, mirror both theta and the value and subtract the offset...
	else
	{
		theta=-(SINE_SIZE4-theta);
     a36:	20 50       	subi	r18, 0x00	; 0
     a38:	32 40       	sbci	r19, 0x02	; 2
		//negative=TRUE;
		//return -(sine_t)pgm_read_sine(sineTable[SINE_SIZE4-theta]); //512-theta]);
	}

	return theta;
}
     a3a:	c9 01       	movw	r24, r18
     a3c:	08 95       	ret

00000a3e <sineRaw>:
//output is a value between -INT32_MAX and INT32_MAX (representing sin values -1 to 1)
sine_t sineRaw(theta_t theta)
{
	uint8_t negative=FALSE;

	theta = quadrantizeTheta(theta);
     a3e:	e1 df       	rcall	.-62     	; 0xa02 <quadrantizeTheta>

	//This reduced code-size from 3860 to 3838
*/
	//adding quadrantizeTheta increased it to 3844
	// but should be dramatic in combination with sineRaw8
	if(theta < 0)
     a40:	97 fd       	sbrc	r25, 7
     a42:	02 c0       	rjmp	.+4      	; 0xa48 <sineRaw+0xa>
     a44:	40 e0       	ldi	r20, 0x00	; 0
     a46:	04 c0       	rjmp	.+8      	; 0xa50 <sineRaw+0x12>
	{
		theta = -theta;
     a48:	90 95       	com	r25
     a4a:	81 95       	neg	r24
     a4c:	9f 4f       	sbci	r25, 0xFF	; 255
     a4e:	41 e0       	ldi	r20, 0x01	; 1
		negative=TRUE;
	}

	sine_t sine=pgm_read_sine(sineTable[theta]);
     a50:	fc 01       	movw	r30, r24
     a52:	ee 0f       	add	r30, r30
     a54:	ff 1f       	adc	r31, r31
     a56:	ea 5b       	subi	r30, 0xBA	; 186
     a58:	ff 4f       	sbci	r31, 0xFF	; 255
     a5a:	25 91       	lpm	r18, Z+
     a5c:	34 91       	lpm	r19, Z
	
	if(negative)
     a5e:	44 23       	and	r20, r20
     a60:	19 f0       	breq	.+6      	; 0xa68 <sineRaw+0x2a>
		sine = -sine;
     a62:	30 95       	com	r19
     a64:	21 95       	neg	r18
     a66:	3f 4f       	sbci	r19, 0xFF	; 255
	return sine;
}
     a68:	c9 01       	movw	r24, r18
     a6a:	08 95       	ret

00000a6c <sineRaw8>:
	   return -(int8_t)pgm_read_sine8(sineTable[SINE_SIZE4-theta]); 
	*/

	//And doing this here, reduced from 3844 to 3770
	uint8_t negative = FALSE;
	theta=quadrantizeTheta(theta);
     a6c:	ca df       	rcall	.-108    	; 0xa02 <quadrantizeTheta>

	if(theta < 0)
     a6e:	97 fd       	sbrc	r25, 7
     a70:	02 c0       	rjmp	.+4      	; 0xa76 <sineRaw8+0xa>
     a72:	20 e0       	ldi	r18, 0x00	; 0
     a74:	04 c0       	rjmp	.+8      	; 0xa7e <sineRaw8+0x12>
	{
		theta = -theta;
     a76:	90 95       	com	r25
     a78:	81 95       	neg	r24
     a7a:	9f 4f       	sbci	r25, 0xFF	; 255
     a7c:	21 e0       	ldi	r18, 0x01	; 1
		negative = TRUE;
	}

	int8_t sine=pgm_read_sine8(sineTable[theta]);
     a7e:	fc 01       	movw	r30, r24
     a80:	ee 0f       	add	r30, r30
     a82:	ff 1f       	adc	r31, r31
     a84:	e9 5b       	subi	r30, 0xB9	; 185
     a86:	ff 4f       	sbci	r31, 0xFF	; 255
     a88:	84 91       	lpm	r24, Z

	if(negative)
     a8a:	21 11       	cpse	r18, r1
		sine = -sine;
     a8c:	81 95       	neg	r24
	return sine;
}
     a8e:	08 95       	ret

00000a90 <pll_enable>:
   // this is 64MHz/512=125kHz
   // The benefit of such high PWM frequency is the low RC values necessary
   //  for filtering to DC.
   // "To change Timer/Counter1 to the async mode follow this procedure"
   // 1: Enable the PLL
   setbit(PLLE, PLLCSR);
     a90:	89 b5       	in	r24, 0x29	; 41
     a92:	82 60       	ori	r24, 0x02	; 2
     a94:	89 bd       	out	0x29, r24	; 41
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     a96:	80 e9       	ldi	r24, 0x90	; 144
     a98:	91 e0       	ldi	r25, 0x01	; 1
     a9a:	01 97       	sbiw	r24, 0x01	; 1
     a9c:	f1 f7       	brne	.-4      	; 0xa9a <pll_enable+0xa>
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <pll_enable+0x12>
   _delay_us(100);
//   dmsWait(1);
   // 3: Poll PLOCK until it is set...
   while(!getbit(PLOCK, PLLCSR))
   {
      asm("nop");
     aa0:	00 00       	nop
   // 2: Wait 100us for the PLL to stabilize
   // (can't use dmsWait since the timer updating the dmsCount hasn't yet been started!)
   _delay_us(100);
//   dmsWait(1);
   // 3: Poll PLOCK until it is set...
   while(!getbit(PLOCK, PLLCSR))
     aa2:	09 b4       	in	r0, 0x29	; 41
     aa4:	00 fe       	sbrs	r0, 0
     aa6:	fc cf       	rjmp	.-8      	; 0xaa0 <pll_enable+0x10>
   {
      asm("nop");
   }
   // 4: Set the PCKE bit to enable async mode
   setbit(PCKE, PLLCSR);
     aa8:	89 b5       	in	r24, 0x29	; 41
     aaa:	84 60       	ori	r24, 0x04	; 4
     aac:	89 bd       	out	0x29, r24	; 41

}
     aae:	08 95       	ret

00000ab0 <lvds_timerInit>:
   //Timer1 is used for LVDS (in PLL clocking mode)
  
     //pll_enable();   
   
   //We want it to count 7 bits, 0-6 and reset at 7
   OCR1C = 6;
     ab0:	86 e0       	ldi	r24, 0x06	; 6
     ab2:	8b bd       	out	0x2b, r24	; 43

   //We want the clock to go low at TCNT=0 and high at TCNT=4
   CLOCK_OCR = 3; //2; //3;
     ab4:	83 e0       	ldi	r24, 0x03	; 3
     ab6:	8c bd       	out	0x2c, r24	; 44
   //PLL is 4MHz*8 = 32MHz
   // then TimerClockDivisor=8 gives 4MHz
   pll_enable();
   #define SLOW_LVDS_TEST TRUE
#elif (defined(OSCCAL_VAL))
   OSCCAL = OSCCAL_VAL;
     ab8:	8f ef       	ldi	r24, 0xFF	; 255
     aba:	81 bf       	out	0x31, r24	; 49
   //  (horizontally... pre LVDS_PRESCALER affecting DOTS_TO_CYC)
   //  so accessing *all* pixels in a row would make it even slower...
   // Further, it didn't seem to be paying attention to the fact that
   // the same pixels are drawn on multiple rows...
   // WTF? (the image was scaled, proportionately! 1pix x 1pix)
   pll_enable();
     abc:	e9 df       	rcall	.-46     	; 0xa90 <pll_enable>
   pll_enable();
   //#warning "The PLL configuration code is not in here yet!"
#endif

   //Set the Timer1 clock prescaler...
   writeMasked(CSBITS, 
     abe:	8f b5       	in	r24, 0x2f	; 47
     ac0:	80 7f       	andi	r24, 0xF0	; 240
     ac2:	81 60       	ori	r24, 0x01	; 1
     ac4:	8f bd       	out	0x2f, r24	; 47
               TCCR1B);

   //Set the DeadTime prescaler (no prescaling, same speed as TCNT1)...
   // Allegedly this is prescaled from the PCK (or CK)
   //    NOT from the Timer1 prescaler...
   writeMasked(DTPSBITS,
     ac6:	8f b5       	in	r24, 0x2f	; 47
     ac8:	8f 7c       	andi	r24, 0xCF	; 207
     aca:	8f bd       	out	0x2f, r24	; 47
 
   //FastPWM
//Now Handled in lvds_xxxOnCompare():

   //These are also written below (excluding PWM1D)
   setbit(PWM1A, TCCR1A);  //Enable PWM on OC1A for DVH
     acc:	80 b7       	in	r24, 0x30	; 48
     ace:	82 60       	ori	r24, 0x02	; 2
     ad0:	80 bf       	out	0x30, r24	; 48
                           //Need to do the same for other channels
  
   setbit(PWM1B, TCCR1A);  //Enable PWM on OC1B for CLOCK 
     ad2:	80 b7       	in	r24, 0x30	; 48
     ad4:	81 60       	ori	r24, 0x01	; 1
     ad6:	80 bf       	out	0x30, r24	; 48

   setbit(PWM1D, TCCR1C);
     ad8:	87 b5       	in	r24, 0x27	; 39
     ada:	81 60       	ori	r24, 0x01	; 1
     adc:	87 bd       	out	0x27, r24	; 39

   //PWM1D is not in TCCR1A...

   setoutPORT(PB1, PORTB);   //+OC1A, DVH/BLUE, MISO (usually heart)
     ade:	b9 9a       	sbi	0x17, 1	; 23
//   setoutPORT(PB0, PORTB);   //-OC1A    MOSI unused
   setoutPORT(PB2, PORTB); //-OC1B, -GREEN    (INVERTED) SCK
     ae0:	ba 9a       	sbi	0x17, 2	; 23
   setoutPORT(PB3, PORTB); //+OC1B Clock (OC1B, not inverted)
     ae2:	bb 9a       	sbi	0x17, 3	; 23
   setoutPORT(PB5, PORTB); //+OC1D, RED
     ae4:	bd 9a       	sbi	0x17, 5	; 23


   writeMasked(((0<<WGM11) | (0<<WGM10)), //FastPWM (combined with above)
     ae6:	86 b5       	in	r24, 0x26	; 38
     ae8:	8c 7f       	andi	r24, 0xFC	; 252
     aea:	86 bd       	out	0x26, r24	; 38
//            | (0<<COM1B1) | (1<<COM1B0) 
//            | (1<<PWM1A) | (1<<PWM1B) )
//#define lvds_ComplementaryClrOnCompare() \ //
   //Do TCCR1C first, because it contains shadow-bits of TCCR1A that I
   // don't want to have to rewrite...
   TCCR1C = ( (1<<COM1D1) | (0<<COM1D0)
     aec:	89 e0       	ldi	r24, 0x09	; 9
     aee:	87 bd       	out	0x27, r24	; 39
 clock is affected by Dead-Times... Still a bit vague.
*/
//	TCCR1A = ( (0<<COM1A1) | (1<<COM1A0) 
//            | (1<<COM1B1) | (0<<COM1B0) //Don't use complementary for CLK
//            | (1<<PWM1A) | (1<<PWM1B) );
	lvds_disableGreen_MakeClockInsensitiveToDT();
     af0:	83 e6       	ldi	r24, 0x63	; 99
     af2:	80 bf       	out	0x30, r24	; 48
   // PWM inversion must be enabled:

   //inverted with PWM1X
//   setbit(PWM1X, TCCR1B);
 
    Nada_init();
     af4:	80 e3       	ldi	r24, 0x30	; 48
     af6:	84 bd       	out	0x24, r24	; 36
     af8:	84 e0       	ldi	r24, 0x04	; 4
     afa:	8d bd       	out	0x2d, r24	; 45
}
     afc:	08 95       	ret

00000afe <setColor>:
//This was #if'd into existence with IMAGE_BUFFER, but since it's only been
// used with frameBuffer, and since IMAGE_BUFFER is somewhat entangled with
// newer stuff, I'm putting it here and NOT including this file, (yet)
void setColor(uint8_t red, uint8_t green, uint8_t blue, 
               uint8_t row, uint8_t col)
{
     afe:	0f 93       	push	r16
   red = (red > 3) ? 3 : red;
   green = (green > 3) ? 3 : green;
   blue = (blue > 3) ? 3 : blue;

   frameBuffer[row][col] = red | ((green)<<2) | ((blue)<<4);
     b00:	e2 2f       	mov	r30, r18
     b02:	f0 e0       	ldi	r31, 0x00	; 0
     b04:	24 e0       	ldi	r18, 0x04	; 4
     b06:	ee 0f       	add	r30, r30
     b08:	ff 1f       	adc	r31, r31
     b0a:	2a 95       	dec	r18
     b0c:	e1 f7       	brne	.-8      	; 0xb06 <setColor+0x8>
     b0e:	e0 0f       	add	r30, r16
     b10:	f1 1d       	adc	r31, r1
     b12:	e4 53       	subi	r30, 0x34	; 52
     b14:	ff 4f       	sbci	r31, 0xFF	; 255
     b16:	64 30       	cpi	r22, 0x04	; 4
     b18:	08 f0       	brcs	.+2      	; 0xb1c <setColor+0x1e>
     b1a:	63 e0       	ldi	r22, 0x03	; 3
     b1c:	70 e0       	ldi	r23, 0x00	; 0
     b1e:	66 0f       	add	r22, r22
     b20:	77 1f       	adc	r23, r23
     b22:	66 0f       	add	r22, r22
     b24:	77 1f       	adc	r23, r23
     b26:	84 30       	cpi	r24, 0x04	; 4
     b28:	08 f0       	brcs	.+2      	; 0xb2c <setColor+0x2e>
     b2a:	83 e0       	ldi	r24, 0x03	; 3
     b2c:	86 2b       	or	r24, r22
     b2e:	44 30       	cpi	r20, 0x04	; 4
     b30:	08 f0       	brcs	.+2      	; 0xb34 <setColor+0x36>
     b32:	43 e0       	ldi	r20, 0x03	; 3
     b34:	42 95       	swap	r20
     b36:	40 7f       	andi	r20, 0xF0	; 240
     b38:	48 2b       	or	r20, r24
     b3a:	40 83       	st	Z, r20
}
     b3c:	0f 91       	pop	r16
     b3e:	08 95       	ret

00000b40 <frameBufferInit>:
//               ), r, c);
      }
   }
*/

}
     b40:	08 95       	ret

00000b42 <nonRSB_drawPix>:
{
   //uint8_t *setting = &(settingBuffer[rowNum][0]);
#if(defined(ROW_BUFFER) && ROW_BUFFER)
   uint8_t *color = &(rowBuffer[0]);
#else
	rowNum = rowNum*FB_HEIGHT / V_COUNT;
     b42:	44 e0       	ldi	r20, 0x04	; 4
     b44:	88 0f       	add	r24, r24
     b46:	99 1f       	adc	r25, r25
     b48:	4a 95       	dec	r20
     b4a:	e1 f7       	brne	.-8      	; 0xb44 <nonRSB_drawPix+0x2>
     b4c:	60 e0       	ldi	r22, 0x00	; 0
     b4e:	73 e0       	ldi	r23, 0x03	; 3
     b50:	fb d8       	rcall	.-3594   	; 0xfffffd48 <__eeprom_end+0xff7efd48>
     b52:	fb 01       	movw	r30, r22
//	rowNum &= 0x0f;
	uint8_t *color = &(frameBuffer[rowNum][0]);
     b54:	34 e0       	ldi	r19, 0x04	; 4
     b56:	ee 0f       	add	r30, r30
     b58:	ff 1f       	adc	r31, r31
     b5a:	3a 95       	dec	r19
     b5c:	e1 f7       	brne	.-8      	; 0xb56 <nonRSB_drawPix+0x14>
     b5e:	e4 53       	subi	r30, 0x34	; 52
     b60:	ff 4f       	sbci	r31, 0xFF	; 255

   //Judging by some weird experiences re v21/22,
   // it's not entirely likely this will be predictable
   // it may try to recalculate the Z register between writeBlues...
   // hopefully not, for now. I should probably assemblify this
      writeColor(FALSE, *(color+0));
     b62:	80 81       	ld	r24, Z
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     b64:	98 2f       	mov	r25, r24
     b66:	93 70       	andi	r25, 0x03	; 3
     b68:	41 f4       	brne	.+16     	; 0xb7a <red1tst_161>
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	00 00       	nop
     b6e:	00 00       	nop
     b70:	00 00       	nop
     b72:	00 00       	nop
     b74:	00 00       	nop
     b76:	00 00       	nop
     b78:	0d c0       	rjmp	.+26     	; 0xb94 <end_161>

00000b7a <red1tst_161>:
     b7a:	91 30       	cpi	r25, 0x01	; 1
     b7c:	29 f4       	brne	.+10     	; 0xb88 <red23_161>
     b7e:	00 00       	nop
     b80:	00 00       	nop
     b82:	00 00       	nop
     b84:	93 e0       	ldi	r25, 0x03	; 3
     b86:	06 c0       	rjmp	.+12     	; 0xb94 <end_161>

00000b88 <red23_161>:
     b88:	92 30       	cpi	r25, 0x02	; 2
     b8a:	11 f4       	brne	.+4      	; 0xb90 <red3_161>
     b8c:	94 e0       	ldi	r25, 0x04	; 4
     b8e:	02 c0       	rjmp	.+4      	; 0xb94 <end_161>

00000b90 <red3_161>:
     b90:	96 e0       	ldi	r25, 0x06	; 6
     b92:	00 00       	nop

00000b94 <end_161>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     b94:	28 2f       	mov	r18, r24
     b96:	2c 70       	andi	r18, 0x0C	; 12
     b98:	41 f4       	brne	.+16     	; 0xbaa <grn4tst_162>
     b9a:	20 e0       	ldi	r18, 0x00	; 0
     b9c:	00 00       	nop
     b9e:	00 00       	nop
     ba0:	00 00       	nop
     ba2:	00 00       	nop
     ba4:	00 00       	nop
     ba6:	00 00       	nop
     ba8:	0d c0       	rjmp	.+26     	; 0xbc4 <end_162>

00000baa <grn4tst_162>:
     baa:	24 30       	cpi	r18, 0x04	; 4
     bac:	29 f4       	brne	.+10     	; 0xbb8 <grn8C_162>
     bae:	21 e0       	ldi	r18, 0x01	; 1
     bb0:	00 00       	nop
     bb2:	00 00       	nop
     bb4:	00 00       	nop
     bb6:	06 c0       	rjmp	.+12     	; 0xbc4 <end_162>

00000bb8 <grn8C_162>:
     bb8:	28 30       	cpi	r18, 0x08	; 8
     bba:	11 f4       	brne	.+4      	; 0xbc0 <grn3_162>
     bbc:	22 e0       	ldi	r18, 0x02	; 2
     bbe:	02 c0       	rjmp	.+4      	; 0xbc4 <end_162>

00000bc0 <grn3_162>:
     bc0:	23 e0       	ldi	r18, 0x03	; 3
     bc2:	00 00       	nop

00000bc4 <end_162>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     bc4:	88 2f       	mov	r24, r24
     bc6:	80 73       	andi	r24, 0x30	; 48
     bc8:	29 f4       	brne	.+10     	; 0xbd4 <blu1tst_163>
     bca:	84 e0       	ldi	r24, 0x04	; 4
     bcc:	00 00       	nop
     bce:	00 00       	nop
     bd0:	00 00       	nop
     bd2:	06 c0       	rjmp	.+12     	; 0xbe0 <end_163>

00000bd4 <blu1tst_163>:
     bd4:	80 31       	cpi	r24, 0x10	; 16
     bd6:	11 f4       	brne	.+4      	; 0xbdc <blu23_163>
     bd8:	85 e0       	ldi	r24, 0x05	; 5
     bda:	02 c0       	rjmp	.+4      	; 0xbe0 <end_163>

00000bdc <blu23_163>:
     bdc:	86 e0       	ldi	r24, 0x06	; 6
     bde:	00 00       	nop

00000be0 <end_163>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     be0:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     be2:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     be4:	8d bd       	out	0x2d, r24	; 45
   // it's not entirely likely this will be predictable
   // it may try to recalculate the Z register between writeBlues...
   // hopefully not, for now. I should probably assemblify this
      writeColor(FALSE, *(color+0));

		lvds_enableGreen_MakeClockSensitiveToDT();
     be6:	83 e5       	ldi	r24, 0x53	; 83
     be8:	80 bf       	out	0x30, r24	; 48
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     bee:	00 00       	nop
      asm("nop");
     bf0:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     bf2:	01 96       	adiw	r24, 0x01	; 1
     bf4:	89 30       	cpi	r24, 0x09	; 9
     bf6:	91 05       	cpc	r25, r1
     bf8:	d1 f7       	brne	.-12     	; 0xbee <end_163+0xe>
      // (v29 has ~1/8in of noise, v30 has ~1pixel noise at the right edge)
//      TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
     bfa:	81 81       	ldd	r24, Z+1	; 0x01
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     bfc:	98 2f       	mov	r25, r24
     bfe:	93 70       	andi	r25, 0x03	; 3
     c00:	41 f4       	brne	.+16     	; 0xc12 <red1tst_187>
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	00 00       	nop
     c06:	00 00       	nop
     c08:	00 00       	nop
     c0a:	00 00       	nop
     c0c:	00 00       	nop
     c0e:	00 00       	nop
     c10:	0d c0       	rjmp	.+26     	; 0xc2c <end_187>

00000c12 <red1tst_187>:
     c12:	91 30       	cpi	r25, 0x01	; 1
     c14:	29 f4       	brne	.+10     	; 0xc20 <red23_187>
     c16:	00 00       	nop
     c18:	00 00       	nop
     c1a:	00 00       	nop
     c1c:	93 e0       	ldi	r25, 0x03	; 3
     c1e:	06 c0       	rjmp	.+12     	; 0xc2c <end_187>

00000c20 <red23_187>:
     c20:	92 30       	cpi	r25, 0x02	; 2
     c22:	11 f4       	brne	.+4      	; 0xc28 <red3_187>
     c24:	94 e0       	ldi	r25, 0x04	; 4
     c26:	02 c0       	rjmp	.+4      	; 0xc2c <end_187>

00000c28 <red3_187>:
     c28:	96 e0       	ldi	r25, 0x06	; 6
     c2a:	00 00       	nop

00000c2c <end_187>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     c2c:	28 2f       	mov	r18, r24
     c2e:	2c 70       	andi	r18, 0x0C	; 12
     c30:	41 f4       	brne	.+16     	; 0xc42 <grn4tst_188>
     c32:	20 e0       	ldi	r18, 0x00	; 0
     c34:	00 00       	nop
     c36:	00 00       	nop
     c38:	00 00       	nop
     c3a:	00 00       	nop
     c3c:	00 00       	nop
     c3e:	00 00       	nop
     c40:	0d c0       	rjmp	.+26     	; 0xc5c <end_188>

00000c42 <grn4tst_188>:
     c42:	24 30       	cpi	r18, 0x04	; 4
     c44:	29 f4       	brne	.+10     	; 0xc50 <grn8C_188>
     c46:	21 e0       	ldi	r18, 0x01	; 1
     c48:	00 00       	nop
     c4a:	00 00       	nop
     c4c:	00 00       	nop
     c4e:	06 c0       	rjmp	.+12     	; 0xc5c <end_188>

00000c50 <grn8C_188>:
     c50:	28 30       	cpi	r18, 0x08	; 8
     c52:	11 f4       	brne	.+4      	; 0xc58 <grn3_188>
     c54:	22 e0       	ldi	r18, 0x02	; 2
     c56:	02 c0       	rjmp	.+4      	; 0xc5c <end_188>

00000c58 <grn3_188>:
     c58:	23 e0       	ldi	r18, 0x03	; 3
     c5a:	00 00       	nop

00000c5c <end_188>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     c5c:	88 2f       	mov	r24, r24
     c5e:	80 73       	andi	r24, 0x30	; 48
     c60:	29 f4       	brne	.+10     	; 0xc6c <blu1tst_189>
     c62:	84 e0       	ldi	r24, 0x04	; 4
     c64:	00 00       	nop
     c66:	00 00       	nop
     c68:	00 00       	nop
     c6a:	06 c0       	rjmp	.+12     	; 0xc78 <end_189>

00000c6c <blu1tst_189>:
     c6c:	80 31       	cpi	r24, 0x10	; 16
     c6e:	11 f4       	brne	.+4      	; 0xc74 <blu23_189>
     c70:	85 e0       	ldi	r24, 0x05	; 5
     c72:	02 c0       	rjmp	.+4      	; 0xc78 <end_189>

00000c74 <blu23_189>:
     c74:	86 e0       	ldi	r24, 0x06	; 6
     c76:	00 00       	nop

00000c78 <end_189>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     c78:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     c7a:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     c7c:	8d bd       	out	0x2d, r24	; 45
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     c82:	00 00       	nop
      asm("nop");
     c84:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     c86:	01 96       	adiw	r24, 0x01	; 1
     c88:	89 30       	cpi	r24, 0x09	; 9
     c8a:	91 05       	cpc	r25, r1
     c8c:	d1 f7       	brne	.-12     	; 0xc82 <end_189+0xa>
//      TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
     c8e:	82 81       	ldd	r24, Z+2	; 0x02
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     c90:	98 2f       	mov	r25, r24
     c92:	93 70       	andi	r25, 0x03	; 3
     c94:	41 f4       	brne	.+16     	; 0xca6 <red1tst_211>
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	00 00       	nop
     c9a:	00 00       	nop
     c9c:	00 00       	nop
     c9e:	00 00       	nop
     ca0:	00 00       	nop
     ca2:	00 00       	nop
     ca4:	0d c0       	rjmp	.+26     	; 0xcc0 <end_211>

00000ca6 <red1tst_211>:
     ca6:	91 30       	cpi	r25, 0x01	; 1
     ca8:	29 f4       	brne	.+10     	; 0xcb4 <red23_211>
     caa:	00 00       	nop
     cac:	00 00       	nop
     cae:	00 00       	nop
     cb0:	93 e0       	ldi	r25, 0x03	; 3
     cb2:	06 c0       	rjmp	.+12     	; 0xcc0 <end_211>

00000cb4 <red23_211>:
     cb4:	92 30       	cpi	r25, 0x02	; 2
     cb6:	11 f4       	brne	.+4      	; 0xcbc <red3_211>
     cb8:	94 e0       	ldi	r25, 0x04	; 4
     cba:	02 c0       	rjmp	.+4      	; 0xcc0 <end_211>

00000cbc <red3_211>:
     cbc:	96 e0       	ldi	r25, 0x06	; 6
     cbe:	00 00       	nop

00000cc0 <end_211>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     cc0:	28 2f       	mov	r18, r24
     cc2:	2c 70       	andi	r18, 0x0C	; 12
     cc4:	41 f4       	brne	.+16     	; 0xcd6 <grn4tst_212>
     cc6:	20 e0       	ldi	r18, 0x00	; 0
     cc8:	00 00       	nop
     cca:	00 00       	nop
     ccc:	00 00       	nop
     cce:	00 00       	nop
     cd0:	00 00       	nop
     cd2:	00 00       	nop
     cd4:	0d c0       	rjmp	.+26     	; 0xcf0 <end_212>

00000cd6 <grn4tst_212>:
     cd6:	24 30       	cpi	r18, 0x04	; 4
     cd8:	29 f4       	brne	.+10     	; 0xce4 <grn8C_212>
     cda:	21 e0       	ldi	r18, 0x01	; 1
     cdc:	00 00       	nop
     cde:	00 00       	nop
     ce0:	00 00       	nop
     ce2:	06 c0       	rjmp	.+12     	; 0xcf0 <end_212>

00000ce4 <grn8C_212>:
     ce4:	28 30       	cpi	r18, 0x08	; 8
     ce6:	11 f4       	brne	.+4      	; 0xcec <grn3_212>
     ce8:	22 e0       	ldi	r18, 0x02	; 2
     cea:	02 c0       	rjmp	.+4      	; 0xcf0 <end_212>

00000cec <grn3_212>:
     cec:	23 e0       	ldi	r18, 0x03	; 3
     cee:	00 00       	nop

00000cf0 <end_212>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     cf0:	88 2f       	mov	r24, r24
     cf2:	80 73       	andi	r24, 0x30	; 48
     cf4:	29 f4       	brne	.+10     	; 0xd00 <blu1tst_213>
     cf6:	84 e0       	ldi	r24, 0x04	; 4
     cf8:	00 00       	nop
     cfa:	00 00       	nop
     cfc:	00 00       	nop
     cfe:	06 c0       	rjmp	.+12     	; 0xd0c <end_213>

00000d00 <blu1tst_213>:
     d00:	80 31       	cpi	r24, 0x10	; 16
     d02:	11 f4       	brne	.+4      	; 0xd08 <blu23_213>
     d04:	85 e0       	ldi	r24, 0x05	; 5
     d06:	02 c0       	rjmp	.+4      	; 0xd0c <end_213>

00000d08 <blu23_213>:
     d08:	86 e0       	ldi	r24, 0x06	; 6
     d0a:	00 00       	nop

00000d0c <end_213>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     d0c:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     d0e:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     d10:	8d bd       	out	0x2d, r24	; 45
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     d16:	00 00       	nop
      asm("nop");
     d18:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     d1a:	01 96       	adiw	r24, 0x01	; 1
     d1c:	89 30       	cpi	r24, 0x09	; 9
     d1e:	91 05       	cpc	r25, r1
     d20:	d1 f7       	brne	.-12     	; 0xd16 <end_213+0xa>
//               | (0<<COM1B1) | (1<<COM1B0)
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
     d22:	83 81       	ldd	r24, Z+3	; 0x03
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     d24:	98 2f       	mov	r25, r24
     d26:	93 70       	andi	r25, 0x03	; 3
     d28:	41 f4       	brne	.+16     	; 0xd3a <red1tst_235>
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	00 00       	nop
     d2e:	00 00       	nop
     d30:	00 00       	nop
     d32:	00 00       	nop
     d34:	00 00       	nop
     d36:	00 00       	nop
     d38:	0d c0       	rjmp	.+26     	; 0xd54 <end_235>

00000d3a <red1tst_235>:
     d3a:	91 30       	cpi	r25, 0x01	; 1
     d3c:	29 f4       	brne	.+10     	; 0xd48 <red23_235>
     d3e:	00 00       	nop
     d40:	00 00       	nop
     d42:	00 00       	nop
     d44:	93 e0       	ldi	r25, 0x03	; 3
     d46:	06 c0       	rjmp	.+12     	; 0xd54 <end_235>

00000d48 <red23_235>:
     d48:	92 30       	cpi	r25, 0x02	; 2
     d4a:	11 f4       	brne	.+4      	; 0xd50 <red3_235>
     d4c:	94 e0       	ldi	r25, 0x04	; 4
     d4e:	02 c0       	rjmp	.+4      	; 0xd54 <end_235>

00000d50 <red3_235>:
     d50:	96 e0       	ldi	r25, 0x06	; 6
     d52:	00 00       	nop

00000d54 <end_235>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     d54:	28 2f       	mov	r18, r24
     d56:	2c 70       	andi	r18, 0x0C	; 12
     d58:	41 f4       	brne	.+16     	; 0xd6a <grn4tst_236>
     d5a:	20 e0       	ldi	r18, 0x00	; 0
     d5c:	00 00       	nop
     d5e:	00 00       	nop
     d60:	00 00       	nop
     d62:	00 00       	nop
     d64:	00 00       	nop
     d66:	00 00       	nop
     d68:	0d c0       	rjmp	.+26     	; 0xd84 <end_236>

00000d6a <grn4tst_236>:
     d6a:	24 30       	cpi	r18, 0x04	; 4
     d6c:	29 f4       	brne	.+10     	; 0xd78 <grn8C_236>
     d6e:	21 e0       	ldi	r18, 0x01	; 1
     d70:	00 00       	nop
     d72:	00 00       	nop
     d74:	00 00       	nop
     d76:	06 c0       	rjmp	.+12     	; 0xd84 <end_236>

00000d78 <grn8C_236>:
     d78:	28 30       	cpi	r18, 0x08	; 8
     d7a:	11 f4       	brne	.+4      	; 0xd80 <grn3_236>
     d7c:	22 e0       	ldi	r18, 0x02	; 2
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <end_236>

00000d80 <grn3_236>:
     d80:	23 e0       	ldi	r18, 0x03	; 3
     d82:	00 00       	nop

00000d84 <end_236>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     d84:	88 2f       	mov	r24, r24
     d86:	80 73       	andi	r24, 0x30	; 48
     d88:	29 f4       	brne	.+10     	; 0xd94 <blu1tst_237>
     d8a:	84 e0       	ldi	r24, 0x04	; 4
     d8c:	00 00       	nop
     d8e:	00 00       	nop
     d90:	00 00       	nop
     d92:	06 c0       	rjmp	.+12     	; 0xda0 <end_237>

00000d94 <blu1tst_237>:
     d94:	80 31       	cpi	r24, 0x10	; 16
     d96:	11 f4       	brne	.+4      	; 0xd9c <blu23_237>
     d98:	85 e0       	ldi	r24, 0x05	; 5
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <end_237>

00000d9c <blu23_237>:
     d9c:	86 e0       	ldi	r24, 0x06	; 6
     d9e:	00 00       	nop

00000da0 <end_237>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     da0:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     da2:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     da4:	8d bd       	out	0x2d, r24	; 45
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     daa:	00 00       	nop
      asm("nop");
     dac:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     dae:	01 96       	adiw	r24, 0x01	; 1
     db0:	89 30       	cpi	r24, 0x09	; 9
     db2:	91 05       	cpc	r25, r1
     db4:	d1 f7       	brne	.-12     	; 0xdaa <end_237+0xa>
//               | (1<<PWM1A) | (1<<PWM1B) );

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
     db6:	84 81       	ldd	r24, Z+4	; 0x04
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     db8:	98 2f       	mov	r25, r24
     dba:	93 70       	andi	r25, 0x03	; 3
     dbc:	41 f4       	brne	.+16     	; 0xdce <red1tst_259>
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	00 00       	nop
     dc2:	00 00       	nop
     dc4:	00 00       	nop
     dc6:	00 00       	nop
     dc8:	00 00       	nop
     dca:	00 00       	nop
     dcc:	0d c0       	rjmp	.+26     	; 0xde8 <end_259>

00000dce <red1tst_259>:
     dce:	91 30       	cpi	r25, 0x01	; 1
     dd0:	29 f4       	brne	.+10     	; 0xddc <red23_259>
     dd2:	00 00       	nop
     dd4:	00 00       	nop
     dd6:	00 00       	nop
     dd8:	93 e0       	ldi	r25, 0x03	; 3
     dda:	06 c0       	rjmp	.+12     	; 0xde8 <end_259>

00000ddc <red23_259>:
     ddc:	92 30       	cpi	r25, 0x02	; 2
     dde:	11 f4       	brne	.+4      	; 0xde4 <red3_259>
     de0:	94 e0       	ldi	r25, 0x04	; 4
     de2:	02 c0       	rjmp	.+4      	; 0xde8 <end_259>

00000de4 <red3_259>:
     de4:	96 e0       	ldi	r25, 0x06	; 6
     de6:	00 00       	nop

00000de8 <end_259>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     de8:	28 2f       	mov	r18, r24
     dea:	2c 70       	andi	r18, 0x0C	; 12
     dec:	41 f4       	brne	.+16     	; 0xdfe <grn4tst_260>
     dee:	20 e0       	ldi	r18, 0x00	; 0
     df0:	00 00       	nop
     df2:	00 00       	nop
     df4:	00 00       	nop
     df6:	00 00       	nop
     df8:	00 00       	nop
     dfa:	00 00       	nop
     dfc:	0d c0       	rjmp	.+26     	; 0xe18 <end_260>

00000dfe <grn4tst_260>:
     dfe:	24 30       	cpi	r18, 0x04	; 4
     e00:	29 f4       	brne	.+10     	; 0xe0c <grn8C_260>
     e02:	21 e0       	ldi	r18, 0x01	; 1
     e04:	00 00       	nop
     e06:	00 00       	nop
     e08:	00 00       	nop
     e0a:	06 c0       	rjmp	.+12     	; 0xe18 <end_260>

00000e0c <grn8C_260>:
     e0c:	28 30       	cpi	r18, 0x08	; 8
     e0e:	11 f4       	brne	.+4      	; 0xe14 <grn3_260>
     e10:	22 e0       	ldi	r18, 0x02	; 2
     e12:	02 c0       	rjmp	.+4      	; 0xe18 <end_260>

00000e14 <grn3_260>:
     e14:	23 e0       	ldi	r18, 0x03	; 3
     e16:	00 00       	nop

00000e18 <end_260>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     e18:	88 2f       	mov	r24, r24
     e1a:	80 73       	andi	r24, 0x30	; 48
     e1c:	29 f4       	brne	.+10     	; 0xe28 <blu1tst_261>
     e1e:	84 e0       	ldi	r24, 0x04	; 4
     e20:	00 00       	nop
     e22:	00 00       	nop
     e24:	00 00       	nop
     e26:	06 c0       	rjmp	.+12     	; 0xe34 <end_261>

00000e28 <blu1tst_261>:
     e28:	80 31       	cpi	r24, 0x10	; 16
     e2a:	11 f4       	brne	.+4      	; 0xe30 <blu23_261>
     e2c:	85 e0       	ldi	r24, 0x05	; 5
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <end_261>

00000e30 <blu23_261>:
     e30:	86 e0       	ldi	r24, 0x06	; 6
     e32:	00 00       	nop

00000e34 <end_261>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     e34:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     e36:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     e38:	8d bd       	out	0x2d, r24	; 45
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     e3e:	00 00       	nop
      asm("nop");
     e40:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     e42:	01 96       	adiw	r24, 0x01	; 1
     e44:	89 30       	cpi	r24, 0x09	; 9
     e46:	91 05       	cpc	r25, r1
     e48:	d1 f7       	brne	.-12     	; 0xe3e <end_261+0xa>

      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
     e4a:	85 81       	ldd	r24, Z+5	; 0x05
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     e4c:	98 2f       	mov	r25, r24
     e4e:	93 70       	andi	r25, 0x03	; 3
     e50:	41 f4       	brne	.+16     	; 0xe62 <red1tst_283>
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	00 00       	nop
     e56:	00 00       	nop
     e58:	00 00       	nop
     e5a:	00 00       	nop
     e5c:	00 00       	nop
     e5e:	00 00       	nop
     e60:	0d c0       	rjmp	.+26     	; 0xe7c <end_283>

00000e62 <red1tst_283>:
     e62:	91 30       	cpi	r25, 0x01	; 1
     e64:	29 f4       	brne	.+10     	; 0xe70 <red23_283>
     e66:	00 00       	nop
     e68:	00 00       	nop
     e6a:	00 00       	nop
     e6c:	93 e0       	ldi	r25, 0x03	; 3
     e6e:	06 c0       	rjmp	.+12     	; 0xe7c <end_283>

00000e70 <red23_283>:
     e70:	92 30       	cpi	r25, 0x02	; 2
     e72:	11 f4       	brne	.+4      	; 0xe78 <red3_283>
     e74:	94 e0       	ldi	r25, 0x04	; 4
     e76:	02 c0       	rjmp	.+4      	; 0xe7c <end_283>

00000e78 <red3_283>:
     e78:	96 e0       	ldi	r25, 0x06	; 6
     e7a:	00 00       	nop

00000e7c <end_283>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     e7c:	28 2f       	mov	r18, r24
     e7e:	2c 70       	andi	r18, 0x0C	; 12
     e80:	41 f4       	brne	.+16     	; 0xe92 <grn4tst_284>
     e82:	20 e0       	ldi	r18, 0x00	; 0
     e84:	00 00       	nop
     e86:	00 00       	nop
     e88:	00 00       	nop
     e8a:	00 00       	nop
     e8c:	00 00       	nop
     e8e:	00 00       	nop
     e90:	0d c0       	rjmp	.+26     	; 0xeac <end_284>

00000e92 <grn4tst_284>:
     e92:	24 30       	cpi	r18, 0x04	; 4
     e94:	29 f4       	brne	.+10     	; 0xea0 <grn8C_284>
     e96:	21 e0       	ldi	r18, 0x01	; 1
     e98:	00 00       	nop
     e9a:	00 00       	nop
     e9c:	00 00       	nop
     e9e:	06 c0       	rjmp	.+12     	; 0xeac <end_284>

00000ea0 <grn8C_284>:
     ea0:	28 30       	cpi	r18, 0x08	; 8
     ea2:	11 f4       	brne	.+4      	; 0xea8 <grn3_284>
     ea4:	22 e0       	ldi	r18, 0x02	; 2
     ea6:	02 c0       	rjmp	.+4      	; 0xeac <end_284>

00000ea8 <grn3_284>:
     ea8:	23 e0       	ldi	r18, 0x03	; 3
     eaa:	00 00       	nop

00000eac <end_284>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     eac:	88 2f       	mov	r24, r24
     eae:	80 73       	andi	r24, 0x30	; 48
     eb0:	29 f4       	brne	.+10     	; 0xebc <blu1tst_285>
     eb2:	84 e0       	ldi	r24, 0x04	; 4
     eb4:	00 00       	nop
     eb6:	00 00       	nop
     eb8:	00 00       	nop
     eba:	06 c0       	rjmp	.+12     	; 0xec8 <end_285>

00000ebc <blu1tst_285>:
     ebc:	80 31       	cpi	r24, 0x10	; 16
     ebe:	11 f4       	brne	.+4      	; 0xec4 <blu23_285>
     ec0:	85 e0       	ldi	r24, 0x05	; 5
     ec2:	02 c0       	rjmp	.+4      	; 0xec8 <end_285>

00000ec4 <blu23_285>:
     ec4:	86 e0       	ldi	r24, 0x06	; 6
     ec6:	00 00       	nop

00000ec8 <end_285>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     ec8:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     eca:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     ecc:	8d bd       	out	0x2d, r24	; 45
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     ed2:	00 00       	nop
      asm("nop");
     ed4:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     ed6:	01 96       	adiw	r24, 0x01	; 1
     ed8:	89 30       	cpi	r24, 0x09	; 9
     eda:	91 05       	cpc	r25, r1
     edc:	d1 f7       	brne	.-12     	; 0xed2 <end_285+0xa>
      writeColor(TRUE, *(color+1));    
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
     ede:	86 81       	ldd	r24, Z+6	; 0x06
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     ee0:	98 2f       	mov	r25, r24
     ee2:	93 70       	andi	r25, 0x03	; 3
     ee4:	41 f4       	brne	.+16     	; 0xef6 <red1tst_307>
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	00 00       	nop
     eea:	00 00       	nop
     eec:	00 00       	nop
     eee:	00 00       	nop
     ef0:	00 00       	nop
     ef2:	00 00       	nop
     ef4:	0d c0       	rjmp	.+26     	; 0xf10 <end_307>

00000ef6 <red1tst_307>:
     ef6:	91 30       	cpi	r25, 0x01	; 1
     ef8:	29 f4       	brne	.+10     	; 0xf04 <red23_307>
     efa:	00 00       	nop
     efc:	00 00       	nop
     efe:	00 00       	nop
     f00:	93 e0       	ldi	r25, 0x03	; 3
     f02:	06 c0       	rjmp	.+12     	; 0xf10 <end_307>

00000f04 <red23_307>:
     f04:	92 30       	cpi	r25, 0x02	; 2
     f06:	11 f4       	brne	.+4      	; 0xf0c <red3_307>
     f08:	94 e0       	ldi	r25, 0x04	; 4
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <end_307>

00000f0c <red3_307>:
     f0c:	96 e0       	ldi	r25, 0x06	; 6
     f0e:	00 00       	nop

00000f10 <end_307>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     f10:	28 2f       	mov	r18, r24
     f12:	2c 70       	andi	r18, 0x0C	; 12
     f14:	41 f4       	brne	.+16     	; 0xf26 <grn4tst_308>
     f16:	20 e0       	ldi	r18, 0x00	; 0
     f18:	00 00       	nop
     f1a:	00 00       	nop
     f1c:	00 00       	nop
     f1e:	00 00       	nop
     f20:	00 00       	nop
     f22:	00 00       	nop
     f24:	0d c0       	rjmp	.+26     	; 0xf40 <end_308>

00000f26 <grn4tst_308>:
     f26:	24 30       	cpi	r18, 0x04	; 4
     f28:	29 f4       	brne	.+10     	; 0xf34 <grn8C_308>
     f2a:	21 e0       	ldi	r18, 0x01	; 1
     f2c:	00 00       	nop
     f2e:	00 00       	nop
     f30:	00 00       	nop
     f32:	06 c0       	rjmp	.+12     	; 0xf40 <end_308>

00000f34 <grn8C_308>:
     f34:	28 30       	cpi	r18, 0x08	; 8
     f36:	11 f4       	brne	.+4      	; 0xf3c <grn3_308>
     f38:	22 e0       	ldi	r18, 0x02	; 2
     f3a:	02 c0       	rjmp	.+4      	; 0xf40 <end_308>

00000f3c <grn3_308>:
     f3c:	23 e0       	ldi	r18, 0x03	; 3
     f3e:	00 00       	nop

00000f40 <end_308>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     f40:	88 2f       	mov	r24, r24
     f42:	80 73       	andi	r24, 0x30	; 48
     f44:	29 f4       	brne	.+10     	; 0xf50 <blu1tst_309>
     f46:	84 e0       	ldi	r24, 0x04	; 4
     f48:	00 00       	nop
     f4a:	00 00       	nop
     f4c:	00 00       	nop
     f4e:	06 c0       	rjmp	.+12     	; 0xf5c <end_309>

00000f50 <blu1tst_309>:
     f50:	80 31       	cpi	r24, 0x10	; 16
     f52:	11 f4       	brne	.+4      	; 0xf58 <blu23_309>
     f54:	85 e0       	ldi	r24, 0x05	; 5
     f56:	02 c0       	rjmp	.+4      	; 0xf5c <end_309>

00000f58 <blu23_309>:
     f58:	86 e0       	ldi	r24, 0x06	; 6
     f5a:	00 00       	nop

00000f5c <end_309>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     f5c:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     f5e:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     f60:	8d bd       	out	0x2d, r24	; 45
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     f66:	00 00       	nop
      asm("nop");
     f68:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     f6a:	01 96       	adiw	r24, 0x01	; 1
     f6c:	89 30       	cpi	r24, 0x09	; 9
     f6e:	91 05       	cpc	r25, r1
     f70:	d1 f7       	brne	.-12     	; 0xf66 <end_309+0xa>
      writeColor(TRUE, *(color+2));    
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
     f72:	87 81       	ldd	r24, Z+7	; 0x07
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     f74:	98 2f       	mov	r25, r24
     f76:	93 70       	andi	r25, 0x03	; 3
     f78:	41 f4       	brne	.+16     	; 0xf8a <red1tst_331>
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	00 00       	nop
     f7e:	00 00       	nop
     f80:	00 00       	nop
     f82:	00 00       	nop
     f84:	00 00       	nop
     f86:	00 00       	nop
     f88:	0d c0       	rjmp	.+26     	; 0xfa4 <end_331>

00000f8a <red1tst_331>:
     f8a:	91 30       	cpi	r25, 0x01	; 1
     f8c:	29 f4       	brne	.+10     	; 0xf98 <red23_331>
     f8e:	00 00       	nop
     f90:	00 00       	nop
     f92:	00 00       	nop
     f94:	93 e0       	ldi	r25, 0x03	; 3
     f96:	06 c0       	rjmp	.+12     	; 0xfa4 <end_331>

00000f98 <red23_331>:
     f98:	92 30       	cpi	r25, 0x02	; 2
     f9a:	11 f4       	brne	.+4      	; 0xfa0 <red3_331>
     f9c:	94 e0       	ldi	r25, 0x04	; 4
     f9e:	02 c0       	rjmp	.+4      	; 0xfa4 <end_331>

00000fa0 <red3_331>:
     fa0:	96 e0       	ldi	r25, 0x06	; 6
     fa2:	00 00       	nop

00000fa4 <end_331>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
     fa4:	28 2f       	mov	r18, r24
     fa6:	2c 70       	andi	r18, 0x0C	; 12
     fa8:	41 f4       	brne	.+16     	; 0xfba <grn4tst_332>
     faa:	20 e0       	ldi	r18, 0x00	; 0
     fac:	00 00       	nop
     fae:	00 00       	nop
     fb0:	00 00       	nop
     fb2:	00 00       	nop
     fb4:	00 00       	nop
     fb6:	00 00       	nop
     fb8:	0d c0       	rjmp	.+26     	; 0xfd4 <end_332>

00000fba <grn4tst_332>:
     fba:	24 30       	cpi	r18, 0x04	; 4
     fbc:	29 f4       	brne	.+10     	; 0xfc8 <grn8C_332>
     fbe:	21 e0       	ldi	r18, 0x01	; 1
     fc0:	00 00       	nop
     fc2:	00 00       	nop
     fc4:	00 00       	nop
     fc6:	06 c0       	rjmp	.+12     	; 0xfd4 <end_332>

00000fc8 <grn8C_332>:
     fc8:	28 30       	cpi	r18, 0x08	; 8
     fca:	11 f4       	brne	.+4      	; 0xfd0 <grn3_332>
     fcc:	22 e0       	ldi	r18, 0x02	; 2
     fce:	02 c0       	rjmp	.+4      	; 0xfd4 <end_332>

00000fd0 <grn3_332>:
     fd0:	23 e0       	ldi	r18, 0x03	; 3
     fd2:	00 00       	nop

00000fd4 <end_332>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
     fd4:	88 2f       	mov	r24, r24
     fd6:	80 73       	andi	r24, 0x30	; 48
     fd8:	29 f4       	brne	.+10     	; 0xfe4 <blu1tst_333>
     fda:	84 e0       	ldi	r24, 0x04	; 4
     fdc:	00 00       	nop
     fde:	00 00       	nop
     fe0:	00 00       	nop
     fe2:	06 c0       	rjmp	.+12     	; 0xff0 <end_333>

00000fe4 <blu1tst_333>:
     fe4:	80 31       	cpi	r24, 0x10	; 16
     fe6:	11 f4       	brne	.+4      	; 0xfec <blu23_333>
     fe8:	85 e0       	ldi	r24, 0x05	; 5
     fea:	02 c0       	rjmp	.+4      	; 0xff0 <end_333>

00000fec <blu23_333>:
     fec:	86 e0       	ldi	r24, 0x06	; 6
     fee:	00 00       	nop

00000ff0 <end_333>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
     ff0:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
     ff2:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
     ff4:	8d bd       	out	0x2d, r24	; 45
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
     ffa:	00 00       	nop
      asm("nop");
     ffc:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
     ffe:	01 96       	adiw	r24, 0x01	; 1
    1000:	89 30       	cpi	r24, 0x09	; 9
    1002:	91 05       	cpc	r25, r1
    1004:	d1 f7       	brne	.-12     	; 0xffa <end_333+0xa>
      writeColor(TRUE, *(color+3)); 
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
    1006:	80 85       	ldd	r24, Z+8	; 0x08
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1008:	98 2f       	mov	r25, r24
    100a:	93 70       	andi	r25, 0x03	; 3
    100c:	41 f4       	brne	.+16     	; 0x101e <red1tst_355>
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	00 00       	nop
    1012:	00 00       	nop
    1014:	00 00       	nop
    1016:	00 00       	nop
    1018:	00 00       	nop
    101a:	00 00       	nop
    101c:	0d c0       	rjmp	.+26     	; 0x1038 <end_355>

0000101e <red1tst_355>:
    101e:	91 30       	cpi	r25, 0x01	; 1
    1020:	29 f4       	brne	.+10     	; 0x102c <red23_355>
    1022:	00 00       	nop
    1024:	00 00       	nop
    1026:	00 00       	nop
    1028:	93 e0       	ldi	r25, 0x03	; 3
    102a:	06 c0       	rjmp	.+12     	; 0x1038 <end_355>

0000102c <red23_355>:
    102c:	92 30       	cpi	r25, 0x02	; 2
    102e:	11 f4       	brne	.+4      	; 0x1034 <red3_355>
    1030:	94 e0       	ldi	r25, 0x04	; 4
    1032:	02 c0       	rjmp	.+4      	; 0x1038 <end_355>

00001034 <red3_355>:
    1034:	96 e0       	ldi	r25, 0x06	; 6
    1036:	00 00       	nop

00001038 <end_355>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1038:	28 2f       	mov	r18, r24
    103a:	2c 70       	andi	r18, 0x0C	; 12
    103c:	41 f4       	brne	.+16     	; 0x104e <grn4tst_356>
    103e:	20 e0       	ldi	r18, 0x00	; 0
    1040:	00 00       	nop
    1042:	00 00       	nop
    1044:	00 00       	nop
    1046:	00 00       	nop
    1048:	00 00       	nop
    104a:	00 00       	nop
    104c:	0d c0       	rjmp	.+26     	; 0x1068 <end_356>

0000104e <grn4tst_356>:
    104e:	24 30       	cpi	r18, 0x04	; 4
    1050:	29 f4       	brne	.+10     	; 0x105c <grn8C_356>
    1052:	21 e0       	ldi	r18, 0x01	; 1
    1054:	00 00       	nop
    1056:	00 00       	nop
    1058:	00 00       	nop
    105a:	06 c0       	rjmp	.+12     	; 0x1068 <end_356>

0000105c <grn8C_356>:
    105c:	28 30       	cpi	r18, 0x08	; 8
    105e:	11 f4       	brne	.+4      	; 0x1064 <grn3_356>
    1060:	22 e0       	ldi	r18, 0x02	; 2
    1062:	02 c0       	rjmp	.+4      	; 0x1068 <end_356>

00001064 <grn3_356>:
    1064:	23 e0       	ldi	r18, 0x03	; 3
    1066:	00 00       	nop

00001068 <end_356>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    1068:	88 2f       	mov	r24, r24
    106a:	80 73       	andi	r24, 0x30	; 48
    106c:	29 f4       	brne	.+10     	; 0x1078 <blu1tst_357>
    106e:	84 e0       	ldi	r24, 0x04	; 4
    1070:	00 00       	nop
    1072:	00 00       	nop
    1074:	00 00       	nop
    1076:	06 c0       	rjmp	.+12     	; 0x1084 <end_357>

00001078 <blu1tst_357>:
    1078:	80 31       	cpi	r24, 0x10	; 16
    107a:	11 f4       	brne	.+4      	; 0x1080 <blu23_357>
    107c:	85 e0       	ldi	r24, 0x05	; 5
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <end_357>

00001080 <blu23_357>:
    1080:	86 e0       	ldi	r24, 0x06	; 6
    1082:	00 00       	nop

00001084 <end_357>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1084:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    1086:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    1088:	8d bd       	out	0x2d, r24	; 45
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    108e:	00 00       	nop
      asm("nop");
    1090:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1092:	01 96       	adiw	r24, 0x01	; 1
    1094:	89 30       	cpi	r24, 0x09	; 9
    1096:	91 05       	cpc	r25, r1
    1098:	d1 f7       	brne	.-12     	; 0x108e <end_357+0xa>
      writeColor(TRUE, *(color+4));    
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
      writeColor(TRUE, *(color+9));                         
    109a:	81 85       	ldd	r24, Z+9	; 0x09
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    109c:	98 2f       	mov	r25, r24
    109e:	93 70       	andi	r25, 0x03	; 3
    10a0:	41 f4       	brne	.+16     	; 0x10b2 <red1tst_379>
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	00 00       	nop
    10a6:	00 00       	nop
    10a8:	00 00       	nop
    10aa:	00 00       	nop
    10ac:	00 00       	nop
    10ae:	00 00       	nop
    10b0:	0d c0       	rjmp	.+26     	; 0x10cc <end_379>

000010b2 <red1tst_379>:
    10b2:	91 30       	cpi	r25, 0x01	; 1
    10b4:	29 f4       	brne	.+10     	; 0x10c0 <red23_379>
    10b6:	00 00       	nop
    10b8:	00 00       	nop
    10ba:	00 00       	nop
    10bc:	93 e0       	ldi	r25, 0x03	; 3
    10be:	06 c0       	rjmp	.+12     	; 0x10cc <end_379>

000010c0 <red23_379>:
    10c0:	92 30       	cpi	r25, 0x02	; 2
    10c2:	11 f4       	brne	.+4      	; 0x10c8 <red3_379>
    10c4:	94 e0       	ldi	r25, 0x04	; 4
    10c6:	02 c0       	rjmp	.+4      	; 0x10cc <end_379>

000010c8 <red3_379>:
    10c8:	96 e0       	ldi	r25, 0x06	; 6
    10ca:	00 00       	nop

000010cc <end_379>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    10cc:	28 2f       	mov	r18, r24
    10ce:	2c 70       	andi	r18, 0x0C	; 12
    10d0:	41 f4       	brne	.+16     	; 0x10e2 <grn4tst_380>
    10d2:	20 e0       	ldi	r18, 0x00	; 0
    10d4:	00 00       	nop
    10d6:	00 00       	nop
    10d8:	00 00       	nop
    10da:	00 00       	nop
    10dc:	00 00       	nop
    10de:	00 00       	nop
    10e0:	0d c0       	rjmp	.+26     	; 0x10fc <end_380>

000010e2 <grn4tst_380>:
    10e2:	24 30       	cpi	r18, 0x04	; 4
    10e4:	29 f4       	brne	.+10     	; 0x10f0 <grn8C_380>
    10e6:	21 e0       	ldi	r18, 0x01	; 1
    10e8:	00 00       	nop
    10ea:	00 00       	nop
    10ec:	00 00       	nop
    10ee:	06 c0       	rjmp	.+12     	; 0x10fc <end_380>

000010f0 <grn8C_380>:
    10f0:	28 30       	cpi	r18, 0x08	; 8
    10f2:	11 f4       	brne	.+4      	; 0x10f8 <grn3_380>
    10f4:	22 e0       	ldi	r18, 0x02	; 2
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <end_380>

000010f8 <grn3_380>:
    10f8:	23 e0       	ldi	r18, 0x03	; 3
    10fa:	00 00       	nop

000010fc <end_380>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    10fc:	88 2f       	mov	r24, r24
    10fe:	80 73       	andi	r24, 0x30	; 48
    1100:	29 f4       	brne	.+10     	; 0x110c <blu1tst_381>
    1102:	84 e0       	ldi	r24, 0x04	; 4
    1104:	00 00       	nop
    1106:	00 00       	nop
    1108:	00 00       	nop
    110a:	06 c0       	rjmp	.+12     	; 0x1118 <end_381>

0000110c <blu1tst_381>:
    110c:	80 31       	cpi	r24, 0x10	; 16
    110e:	11 f4       	brne	.+4      	; 0x1114 <blu23_381>
    1110:	85 e0       	ldi	r24, 0x05	; 5
    1112:	02 c0       	rjmp	.+4      	; 0x1118 <end_381>

00001114 <blu23_381>:
    1114:	86 e0       	ldi	r24, 0x06	; 6
    1116:	00 00       	nop

00001118 <end_381>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1118:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    111a:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    111c:	8d bd       	out	0x2d, r24	; 45
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1122:	00 00       	nop
      asm("nop");
    1124:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1126:	01 96       	adiw	r24, 0x01	; 1
    1128:	89 30       	cpi	r24, 0x09	; 9
    112a:	91 05       	cpc	r25, r1
    112c:	d1 f7       	brne	.-12     	; 0x1122 <end_381+0xa>
      writeColor(TRUE, *(color+5));                
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
      writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
    112e:	82 85       	ldd	r24, Z+10	; 0x0a
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1130:	98 2f       	mov	r25, r24
    1132:	93 70       	andi	r25, 0x03	; 3
    1134:	41 f4       	brne	.+16     	; 0x1146 <red1tst_403>
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	00 00       	nop
    113a:	00 00       	nop
    113c:	00 00       	nop
    113e:	00 00       	nop
    1140:	00 00       	nop
    1142:	00 00       	nop
    1144:	0d c0       	rjmp	.+26     	; 0x1160 <end_403>

00001146 <red1tst_403>:
    1146:	91 30       	cpi	r25, 0x01	; 1
    1148:	29 f4       	brne	.+10     	; 0x1154 <red23_403>
    114a:	00 00       	nop
    114c:	00 00       	nop
    114e:	00 00       	nop
    1150:	93 e0       	ldi	r25, 0x03	; 3
    1152:	06 c0       	rjmp	.+12     	; 0x1160 <end_403>

00001154 <red23_403>:
    1154:	92 30       	cpi	r25, 0x02	; 2
    1156:	11 f4       	brne	.+4      	; 0x115c <red3_403>
    1158:	94 e0       	ldi	r25, 0x04	; 4
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <end_403>

0000115c <red3_403>:
    115c:	96 e0       	ldi	r25, 0x06	; 6
    115e:	00 00       	nop

00001160 <end_403>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1160:	28 2f       	mov	r18, r24
    1162:	2c 70       	andi	r18, 0x0C	; 12
    1164:	41 f4       	brne	.+16     	; 0x1176 <grn4tst_404>
    1166:	20 e0       	ldi	r18, 0x00	; 0
    1168:	00 00       	nop
    116a:	00 00       	nop
    116c:	00 00       	nop
    116e:	00 00       	nop
    1170:	00 00       	nop
    1172:	00 00       	nop
    1174:	0d c0       	rjmp	.+26     	; 0x1190 <end_404>

00001176 <grn4tst_404>:
    1176:	24 30       	cpi	r18, 0x04	; 4
    1178:	29 f4       	brne	.+10     	; 0x1184 <grn8C_404>
    117a:	21 e0       	ldi	r18, 0x01	; 1
    117c:	00 00       	nop
    117e:	00 00       	nop
    1180:	00 00       	nop
    1182:	06 c0       	rjmp	.+12     	; 0x1190 <end_404>

00001184 <grn8C_404>:
    1184:	28 30       	cpi	r18, 0x08	; 8
    1186:	11 f4       	brne	.+4      	; 0x118c <grn3_404>
    1188:	22 e0       	ldi	r18, 0x02	; 2
    118a:	02 c0       	rjmp	.+4      	; 0x1190 <end_404>

0000118c <grn3_404>:
    118c:	23 e0       	ldi	r18, 0x03	; 3
    118e:	00 00       	nop

00001190 <end_404>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    1190:	88 2f       	mov	r24, r24
    1192:	80 73       	andi	r24, 0x30	; 48
    1194:	29 f4       	brne	.+10     	; 0x11a0 <blu1tst_405>
    1196:	84 e0       	ldi	r24, 0x04	; 4
    1198:	00 00       	nop
    119a:	00 00       	nop
    119c:	00 00       	nop
    119e:	06 c0       	rjmp	.+12     	; 0x11ac <end_405>

000011a0 <blu1tst_405>:
    11a0:	80 31       	cpi	r24, 0x10	; 16
    11a2:	11 f4       	brne	.+4      	; 0x11a8 <blu23_405>
    11a4:	85 e0       	ldi	r24, 0x05	; 5
    11a6:	02 c0       	rjmp	.+4      	; 0x11ac <end_405>

000011a8 <blu23_405>:
    11a8:	86 e0       	ldi	r24, 0x06	; 6
    11aa:	00 00       	nop

000011ac <end_405>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    11ac:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    11ae:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    11b0:	8d bd       	out	0x2d, r24	; 45
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    11b6:	00 00       	nop
      asm("nop");
    11b8:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    11ba:	01 96       	adiw	r24, 0x01	; 1
    11bc:	89 30       	cpi	r24, 0x09	; 9
    11be:	91 05       	cpc	r25, r1
    11c0:	d1 f7       	brne	.-12     	; 0x11b6 <end_405+0xa>
      writeColor(TRUE, *(color+6));  
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
      writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
    11c2:	83 85       	ldd	r24, Z+11	; 0x0b
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    11c4:	98 2f       	mov	r25, r24
    11c6:	93 70       	andi	r25, 0x03	; 3
    11c8:	41 f4       	brne	.+16     	; 0x11da <red1tst_427>
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	00 00       	nop
    11ce:	00 00       	nop
    11d0:	00 00       	nop
    11d2:	00 00       	nop
    11d4:	00 00       	nop
    11d6:	00 00       	nop
    11d8:	0d c0       	rjmp	.+26     	; 0x11f4 <end_427>

000011da <red1tst_427>:
    11da:	91 30       	cpi	r25, 0x01	; 1
    11dc:	29 f4       	brne	.+10     	; 0x11e8 <red23_427>
    11de:	00 00       	nop
    11e0:	00 00       	nop
    11e2:	00 00       	nop
    11e4:	93 e0       	ldi	r25, 0x03	; 3
    11e6:	06 c0       	rjmp	.+12     	; 0x11f4 <end_427>

000011e8 <red23_427>:
    11e8:	92 30       	cpi	r25, 0x02	; 2
    11ea:	11 f4       	brne	.+4      	; 0x11f0 <red3_427>
    11ec:	94 e0       	ldi	r25, 0x04	; 4
    11ee:	02 c0       	rjmp	.+4      	; 0x11f4 <end_427>

000011f0 <red3_427>:
    11f0:	96 e0       	ldi	r25, 0x06	; 6
    11f2:	00 00       	nop

000011f4 <end_427>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    11f4:	28 2f       	mov	r18, r24
    11f6:	2c 70       	andi	r18, 0x0C	; 12
    11f8:	41 f4       	brne	.+16     	; 0x120a <grn4tst_428>
    11fa:	20 e0       	ldi	r18, 0x00	; 0
    11fc:	00 00       	nop
    11fe:	00 00       	nop
    1200:	00 00       	nop
    1202:	00 00       	nop
    1204:	00 00       	nop
    1206:	00 00       	nop
    1208:	0d c0       	rjmp	.+26     	; 0x1224 <end_428>

0000120a <grn4tst_428>:
    120a:	24 30       	cpi	r18, 0x04	; 4
    120c:	29 f4       	brne	.+10     	; 0x1218 <grn8C_428>
    120e:	21 e0       	ldi	r18, 0x01	; 1
    1210:	00 00       	nop
    1212:	00 00       	nop
    1214:	00 00       	nop
    1216:	06 c0       	rjmp	.+12     	; 0x1224 <end_428>

00001218 <grn8C_428>:
    1218:	28 30       	cpi	r18, 0x08	; 8
    121a:	11 f4       	brne	.+4      	; 0x1220 <grn3_428>
    121c:	22 e0       	ldi	r18, 0x02	; 2
    121e:	02 c0       	rjmp	.+4      	; 0x1224 <end_428>

00001220 <grn3_428>:
    1220:	23 e0       	ldi	r18, 0x03	; 3
    1222:	00 00       	nop

00001224 <end_428>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    1224:	88 2f       	mov	r24, r24
    1226:	80 73       	andi	r24, 0x30	; 48
    1228:	29 f4       	brne	.+10     	; 0x1234 <blu1tst_429>
    122a:	84 e0       	ldi	r24, 0x04	; 4
    122c:	00 00       	nop
    122e:	00 00       	nop
    1230:	00 00       	nop
    1232:	06 c0       	rjmp	.+12     	; 0x1240 <end_429>

00001234 <blu1tst_429>:
    1234:	80 31       	cpi	r24, 0x10	; 16
    1236:	11 f4       	brne	.+4      	; 0x123c <blu23_429>
    1238:	85 e0       	ldi	r24, 0x05	; 5
    123a:	02 c0       	rjmp	.+4      	; 0x1240 <end_429>

0000123c <blu23_429>:
    123c:	86 e0       	ldi	r24, 0x06	; 6
    123e:	00 00       	nop

00001240 <end_429>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1240:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    1242:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    1244:	8d bd       	out	0x2d, r24	; 45
    1246:	80 e0       	ldi	r24, 0x00	; 0
    1248:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    124a:	00 00       	nop
      asm("nop");
    124c:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    124e:	01 96       	adiw	r24, 0x01	; 1
    1250:	89 30       	cpi	r24, 0x09	; 9
    1252:	91 05       	cpc	r25, r1
    1254:	d1 f7       	brne	.-12     	; 0x124a <end_429+0xa>
      writeColor(TRUE, *(color+7));                         
      writeColor(TRUE, *(color+8));                         
      writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
    1256:	84 85       	ldd	r24, Z+12	; 0x0c
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1258:	98 2f       	mov	r25, r24
    125a:	93 70       	andi	r25, 0x03	; 3
    125c:	41 f4       	brne	.+16     	; 0x126e <red1tst_451>
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	00 00       	nop
    1262:	00 00       	nop
    1264:	00 00       	nop
    1266:	00 00       	nop
    1268:	00 00       	nop
    126a:	00 00       	nop
    126c:	0d c0       	rjmp	.+26     	; 0x1288 <end_451>

0000126e <red1tst_451>:
    126e:	91 30       	cpi	r25, 0x01	; 1
    1270:	29 f4       	brne	.+10     	; 0x127c <red23_451>
    1272:	00 00       	nop
    1274:	00 00       	nop
    1276:	00 00       	nop
    1278:	93 e0       	ldi	r25, 0x03	; 3
    127a:	06 c0       	rjmp	.+12     	; 0x1288 <end_451>

0000127c <red23_451>:
    127c:	92 30       	cpi	r25, 0x02	; 2
    127e:	11 f4       	brne	.+4      	; 0x1284 <red3_451>
    1280:	94 e0       	ldi	r25, 0x04	; 4
    1282:	02 c0       	rjmp	.+4      	; 0x1288 <end_451>

00001284 <red3_451>:
    1284:	96 e0       	ldi	r25, 0x06	; 6
    1286:	00 00       	nop

00001288 <end_451>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1288:	28 2f       	mov	r18, r24
    128a:	2c 70       	andi	r18, 0x0C	; 12
    128c:	41 f4       	brne	.+16     	; 0x129e <grn4tst_452>
    128e:	20 e0       	ldi	r18, 0x00	; 0
    1290:	00 00       	nop
    1292:	00 00       	nop
    1294:	00 00       	nop
    1296:	00 00       	nop
    1298:	00 00       	nop
    129a:	00 00       	nop
    129c:	0d c0       	rjmp	.+26     	; 0x12b8 <end_452>

0000129e <grn4tst_452>:
    129e:	24 30       	cpi	r18, 0x04	; 4
    12a0:	29 f4       	brne	.+10     	; 0x12ac <grn8C_452>
    12a2:	21 e0       	ldi	r18, 0x01	; 1
    12a4:	00 00       	nop
    12a6:	00 00       	nop
    12a8:	00 00       	nop
    12aa:	06 c0       	rjmp	.+12     	; 0x12b8 <end_452>

000012ac <grn8C_452>:
    12ac:	28 30       	cpi	r18, 0x08	; 8
    12ae:	11 f4       	brne	.+4      	; 0x12b4 <grn3_452>
    12b0:	22 e0       	ldi	r18, 0x02	; 2
    12b2:	02 c0       	rjmp	.+4      	; 0x12b8 <end_452>

000012b4 <grn3_452>:
    12b4:	23 e0       	ldi	r18, 0x03	; 3
    12b6:	00 00       	nop

000012b8 <end_452>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    12b8:	88 2f       	mov	r24, r24
    12ba:	80 73       	andi	r24, 0x30	; 48
    12bc:	29 f4       	brne	.+10     	; 0x12c8 <blu1tst_453>
    12be:	84 e0       	ldi	r24, 0x04	; 4
    12c0:	00 00       	nop
    12c2:	00 00       	nop
    12c4:	00 00       	nop
    12c6:	06 c0       	rjmp	.+12     	; 0x12d4 <end_453>

000012c8 <blu1tst_453>:
    12c8:	80 31       	cpi	r24, 0x10	; 16
    12ca:	11 f4       	brne	.+4      	; 0x12d0 <blu23_453>
    12cc:	85 e0       	ldi	r24, 0x05	; 5
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <end_453>

000012d0 <blu23_453>:
    12d0:	86 e0       	ldi	r24, 0x06	; 6
    12d2:	00 00       	nop

000012d4 <end_453>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    12d4:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    12d6:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    12d8:	8d bd       	out	0x2d, r24	; 45
    12da:	80 e0       	ldi	r24, 0x00	; 0
    12dc:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    12de:	00 00       	nop
      asm("nop");
    12e0:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    12e2:	01 96       	adiw	r24, 0x01	; 1
    12e4:	89 30       	cpi	r24, 0x09	; 9
    12e6:	91 05       	cpc	r25, r1
    12e8:	d1 f7       	brne	.-12     	; 0x12de <end_453+0xa>
      writeColor(TRUE, *(color+8));                         
      writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
    12ea:	85 85       	ldd	r24, Z+13	; 0x0d
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    12ec:	98 2f       	mov	r25, r24
    12ee:	93 70       	andi	r25, 0x03	; 3
    12f0:	41 f4       	brne	.+16     	; 0x1302 <red1tst_475>
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	00 00       	nop
    12f6:	00 00       	nop
    12f8:	00 00       	nop
    12fa:	00 00       	nop
    12fc:	00 00       	nop
    12fe:	00 00       	nop
    1300:	0d c0       	rjmp	.+26     	; 0x131c <end_475>

00001302 <red1tst_475>:
    1302:	91 30       	cpi	r25, 0x01	; 1
    1304:	29 f4       	brne	.+10     	; 0x1310 <red23_475>
    1306:	00 00       	nop
    1308:	00 00       	nop
    130a:	00 00       	nop
    130c:	93 e0       	ldi	r25, 0x03	; 3
    130e:	06 c0       	rjmp	.+12     	; 0x131c <end_475>

00001310 <red23_475>:
    1310:	92 30       	cpi	r25, 0x02	; 2
    1312:	11 f4       	brne	.+4      	; 0x1318 <red3_475>
    1314:	94 e0       	ldi	r25, 0x04	; 4
    1316:	02 c0       	rjmp	.+4      	; 0x131c <end_475>

00001318 <red3_475>:
    1318:	96 e0       	ldi	r25, 0x06	; 6
    131a:	00 00       	nop

0000131c <end_475>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    131c:	28 2f       	mov	r18, r24
    131e:	2c 70       	andi	r18, 0x0C	; 12
    1320:	41 f4       	brne	.+16     	; 0x1332 <grn4tst_476>
    1322:	20 e0       	ldi	r18, 0x00	; 0
    1324:	00 00       	nop
    1326:	00 00       	nop
    1328:	00 00       	nop
    132a:	00 00       	nop
    132c:	00 00       	nop
    132e:	00 00       	nop
    1330:	0d c0       	rjmp	.+26     	; 0x134c <end_476>

00001332 <grn4tst_476>:
    1332:	24 30       	cpi	r18, 0x04	; 4
    1334:	29 f4       	brne	.+10     	; 0x1340 <grn8C_476>
    1336:	21 e0       	ldi	r18, 0x01	; 1
    1338:	00 00       	nop
    133a:	00 00       	nop
    133c:	00 00       	nop
    133e:	06 c0       	rjmp	.+12     	; 0x134c <end_476>

00001340 <grn8C_476>:
    1340:	28 30       	cpi	r18, 0x08	; 8
    1342:	11 f4       	brne	.+4      	; 0x1348 <grn3_476>
    1344:	22 e0       	ldi	r18, 0x02	; 2
    1346:	02 c0       	rjmp	.+4      	; 0x134c <end_476>

00001348 <grn3_476>:
    1348:	23 e0       	ldi	r18, 0x03	; 3
    134a:	00 00       	nop

0000134c <end_476>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    134c:	88 2f       	mov	r24, r24
    134e:	80 73       	andi	r24, 0x30	; 48
    1350:	29 f4       	brne	.+10     	; 0x135c <blu1tst_477>
    1352:	84 e0       	ldi	r24, 0x04	; 4
    1354:	00 00       	nop
    1356:	00 00       	nop
    1358:	00 00       	nop
    135a:	06 c0       	rjmp	.+12     	; 0x1368 <end_477>

0000135c <blu1tst_477>:
    135c:	80 31       	cpi	r24, 0x10	; 16
    135e:	11 f4       	brne	.+4      	; 0x1364 <blu23_477>
    1360:	85 e0       	ldi	r24, 0x05	; 5
    1362:	02 c0       	rjmp	.+4      	; 0x1368 <end_477>

00001364 <blu23_477>:
    1364:	86 e0       	ldi	r24, 0x06	; 6
    1366:	00 00       	nop

00001368 <end_477>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1368:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    136a:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    136c:	8d bd       	out	0x2d, r24	; 45
    136e:	80 e0       	ldi	r24, 0x00	; 0
    1370:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1372:	00 00       	nop
      asm("nop");
    1374:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1376:	01 96       	adiw	r24, 0x01	; 1
    1378:	89 30       	cpi	r24, 0x09	; 9
    137a:	91 05       	cpc	r25, r1
    137c:	d1 f7       	brne	.-12     	; 0x1372 <end_477+0xa>
      writeColor(TRUE, *(color+9));                         
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
      writeColor(TRUE, *(color+14));                         
    137e:	86 85       	ldd	r24, Z+14	; 0x0e
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1380:	98 2f       	mov	r25, r24
    1382:	93 70       	andi	r25, 0x03	; 3
    1384:	41 f4       	brne	.+16     	; 0x1396 <red1tst_499>
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	00 00       	nop
    138a:	00 00       	nop
    138c:	00 00       	nop
    138e:	00 00       	nop
    1390:	00 00       	nop
    1392:	00 00       	nop
    1394:	0d c0       	rjmp	.+26     	; 0x13b0 <end_499>

00001396 <red1tst_499>:
    1396:	91 30       	cpi	r25, 0x01	; 1
    1398:	29 f4       	brne	.+10     	; 0x13a4 <red23_499>
    139a:	00 00       	nop
    139c:	00 00       	nop
    139e:	00 00       	nop
    13a0:	93 e0       	ldi	r25, 0x03	; 3
    13a2:	06 c0       	rjmp	.+12     	; 0x13b0 <end_499>

000013a4 <red23_499>:
    13a4:	92 30       	cpi	r25, 0x02	; 2
    13a6:	11 f4       	brne	.+4      	; 0x13ac <red3_499>
    13a8:	94 e0       	ldi	r25, 0x04	; 4
    13aa:	02 c0       	rjmp	.+4      	; 0x13b0 <end_499>

000013ac <red3_499>:
    13ac:	96 e0       	ldi	r25, 0x06	; 6
    13ae:	00 00       	nop

000013b0 <end_499>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    13b0:	28 2f       	mov	r18, r24
    13b2:	2c 70       	andi	r18, 0x0C	; 12
    13b4:	41 f4       	brne	.+16     	; 0x13c6 <grn4tst_500>
    13b6:	20 e0       	ldi	r18, 0x00	; 0
    13b8:	00 00       	nop
    13ba:	00 00       	nop
    13bc:	00 00       	nop
    13be:	00 00       	nop
    13c0:	00 00       	nop
    13c2:	00 00       	nop
    13c4:	0d c0       	rjmp	.+26     	; 0x13e0 <end_500>

000013c6 <grn4tst_500>:
    13c6:	24 30       	cpi	r18, 0x04	; 4
    13c8:	29 f4       	brne	.+10     	; 0x13d4 <grn8C_500>
    13ca:	21 e0       	ldi	r18, 0x01	; 1
    13cc:	00 00       	nop
    13ce:	00 00       	nop
    13d0:	00 00       	nop
    13d2:	06 c0       	rjmp	.+12     	; 0x13e0 <end_500>

000013d4 <grn8C_500>:
    13d4:	28 30       	cpi	r18, 0x08	; 8
    13d6:	11 f4       	brne	.+4      	; 0x13dc <grn3_500>
    13d8:	22 e0       	ldi	r18, 0x02	; 2
    13da:	02 c0       	rjmp	.+4      	; 0x13e0 <end_500>

000013dc <grn3_500>:
    13dc:	23 e0       	ldi	r18, 0x03	; 3
    13de:	00 00       	nop

000013e0 <end_500>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    13e0:	88 2f       	mov	r24, r24
    13e2:	80 73       	andi	r24, 0x30	; 48
    13e4:	29 f4       	brne	.+10     	; 0x13f0 <blu1tst_501>
    13e6:	84 e0       	ldi	r24, 0x04	; 4
    13e8:	00 00       	nop
    13ea:	00 00       	nop
    13ec:	00 00       	nop
    13ee:	06 c0       	rjmp	.+12     	; 0x13fc <end_501>

000013f0 <blu1tst_501>:
    13f0:	80 31       	cpi	r24, 0x10	; 16
    13f2:	11 f4       	brne	.+4      	; 0x13f8 <blu23_501>
    13f4:	85 e0       	ldi	r24, 0x05	; 5
    13f6:	02 c0       	rjmp	.+4      	; 0x13fc <end_501>

000013f8 <blu23_501>:
    13f8:	86 e0       	ldi	r24, 0x06	; 6
    13fa:	00 00       	nop

000013fc <end_501>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    13fc:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    13fe:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    1400:	8d bd       	out	0x2d, r24	; 45
    1402:	80 e0       	ldi	r24, 0x00	; 0
    1404:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1406:	00 00       	nop
      asm("nop");
    1408:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	89 30       	cpi	r24, 0x09	; 9
    140e:	91 05       	cpc	r25, r1
    1410:	d1 f7       	brne	.-12     	; 0x1406 <end_501+0xa>
      writeColor(TRUE, *(color+10));                         
      writeColor(TRUE, *(color+11));                         
      writeColor(TRUE, *(color+12));                         
      writeColor(TRUE, *(color+13));                         
      writeColor(TRUE, *(color+14));                         
      writeColor(TRUE, *(color+15));   
    1412:	87 85       	ldd	r24, Z+15	; 0x0f
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1414:	98 2f       	mov	r25, r24
    1416:	93 70       	andi	r25, 0x03	; 3
    1418:	41 f4       	brne	.+16     	; 0x142a <red1tst_523>
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	00 00       	nop
    141e:	00 00       	nop
    1420:	00 00       	nop
    1422:	00 00       	nop
    1424:	00 00       	nop
    1426:	00 00       	nop
    1428:	0d c0       	rjmp	.+26     	; 0x1444 <end_523>

0000142a <red1tst_523>:
    142a:	91 30       	cpi	r25, 0x01	; 1
    142c:	29 f4       	brne	.+10     	; 0x1438 <red23_523>
    142e:	00 00       	nop
    1430:	00 00       	nop
    1432:	00 00       	nop
    1434:	93 e0       	ldi	r25, 0x03	; 3
    1436:	06 c0       	rjmp	.+12     	; 0x1444 <end_523>

00001438 <red23_523>:
    1438:	92 30       	cpi	r25, 0x02	; 2
    143a:	11 f4       	brne	.+4      	; 0x1440 <red3_523>
    143c:	94 e0       	ldi	r25, 0x04	; 4
    143e:	02 c0       	rjmp	.+4      	; 0x1444 <end_523>

00001440 <red3_523>:
    1440:	96 e0       	ldi	r25, 0x06	; 6
    1442:	00 00       	nop

00001444 <end_523>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    1444:	28 2f       	mov	r18, r24
    1446:	2c 70       	andi	r18, 0x0C	; 12
    1448:	41 f4       	brne	.+16     	; 0x145a <grn4tst_524>
    144a:	20 e0       	ldi	r18, 0x00	; 0
    144c:	00 00       	nop
    144e:	00 00       	nop
    1450:	00 00       	nop
    1452:	00 00       	nop
    1454:	00 00       	nop
    1456:	00 00       	nop
    1458:	0d c0       	rjmp	.+26     	; 0x1474 <end_524>

0000145a <grn4tst_524>:
    145a:	24 30       	cpi	r18, 0x04	; 4
    145c:	29 f4       	brne	.+10     	; 0x1468 <grn8C_524>
    145e:	21 e0       	ldi	r18, 0x01	; 1
    1460:	00 00       	nop
    1462:	00 00       	nop
    1464:	00 00       	nop
    1466:	06 c0       	rjmp	.+12     	; 0x1474 <end_524>

00001468 <grn8C_524>:
    1468:	28 30       	cpi	r18, 0x08	; 8
    146a:	11 f4       	brne	.+4      	; 0x1470 <grn3_524>
    146c:	22 e0       	ldi	r18, 0x02	; 2
    146e:	02 c0       	rjmp	.+4      	; 0x1474 <end_524>

00001470 <grn3_524>:
    1470:	23 e0       	ldi	r18, 0x03	; 3
    1472:	00 00       	nop

00001474 <end_524>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    1474:	88 2f       	mov	r24, r24
    1476:	80 73       	andi	r24, 0x30	; 48
    1478:	29 f4       	brne	.+10     	; 0x1484 <blu1tst_525>
    147a:	84 e0       	ldi	r24, 0x04	; 4
    147c:	00 00       	nop
    147e:	00 00       	nop
    1480:	00 00       	nop
    1482:	06 c0       	rjmp	.+12     	; 0x1490 <end_525>

00001484 <blu1tst_525>:
    1484:	80 31       	cpi	r24, 0x10	; 16
    1486:	11 f4       	brne	.+4      	; 0x148c <blu23_525>
    1488:	85 e0       	ldi	r24, 0x05	; 5
    148a:	02 c0       	rjmp	.+4      	; 0x1490 <end_525>

0000148c <blu23_525>:
    148c:	86 e0       	ldi	r24, 0x06	; 6
    148e:	00 00       	nop

00001490 <end_525>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1490:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    1492:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    1494:	8d bd       	out	0x2d, r24	; 45
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	90 e0       	ldi	r25, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    149a:	00 00       	nop
      asm("nop");
    149c:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    149e:	01 96       	adiw	r24, 0x01	; 1
    14a0:	89 30       	cpi	r24, 0x09	; 9
    14a2:	91 05       	cpc	r25, r1
    14a4:	d1 f7       	brne	.-12     	; 0x149a <end_525+0xa>
#else
 #define FOUR_SHADES_NOPS "\n\t"
#endif

   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	98 2f       	mov	r25, r24
    14aa:	93 70       	andi	r25, 0x03	; 3
    14ac:	41 f4       	brne	.+16     	; 0x14be <red1tst_547>
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	00 00       	nop
    14b2:	00 00       	nop
    14b4:	00 00       	nop
    14b6:	00 00       	nop
    14b8:	00 00       	nop
    14ba:	00 00       	nop
    14bc:	0d c0       	rjmp	.+26     	; 0x14d8 <end_547>

000014be <red1tst_547>:
    14be:	91 30       	cpi	r25, 0x01	; 1
    14c0:	29 f4       	brne	.+10     	; 0x14cc <red23_547>
    14c2:	00 00       	nop
    14c4:	00 00       	nop
    14c6:	00 00       	nop
    14c8:	93 e0       	ldi	r25, 0x03	; 3
    14ca:	06 c0       	rjmp	.+12     	; 0x14d8 <end_547>

000014cc <red23_547>:
    14cc:	92 30       	cpi	r25, 0x02	; 2
    14ce:	11 f4       	brne	.+4      	; 0x14d4 <red3_547>
    14d0:	94 e0       	ldi	r25, 0x04	; 4
    14d2:	02 c0       	rjmp	.+4      	; 0x14d8 <end_547>

000014d4 <red3_547>:
    14d4:	96 e0       	ldi	r25, 0x06	; 6
    14d6:	00 00       	nop

000014d8 <end_547>:
      dt=1;
   else //0x06, 0x0C
      dt=3;
*/
   //Each branch is 9 cycles... (12 with FOUR_SHADES)
__asm__ __volatile__
    14d8:	28 2f       	mov	r18, r24
    14da:	2c 70       	andi	r18, 0x0C	; 12
    14dc:	41 f4       	brne	.+16     	; 0x14ee <grn4tst_548>
    14de:	20 e0       	ldi	r18, 0x00	; 0
    14e0:	00 00       	nop
    14e2:	00 00       	nop
    14e4:	00 00       	nop
    14e6:	00 00       	nop
    14e8:	00 00       	nop
    14ea:	00 00       	nop
    14ec:	0d c0       	rjmp	.+26     	; 0x1508 <end_548>

000014ee <grn4tst_548>:
    14ee:	24 30       	cpi	r18, 0x04	; 4
    14f0:	29 f4       	brne	.+10     	; 0x14fc <grn8C_548>
    14f2:	21 e0       	ldi	r18, 0x01	; 1
    14f4:	00 00       	nop
    14f6:	00 00       	nop
    14f8:	00 00       	nop
    14fa:	06 c0       	rjmp	.+12     	; 0x1508 <end_548>

000014fc <grn8C_548>:
    14fc:	28 30       	cpi	r18, 0x08	; 8
    14fe:	11 f4       	brne	.+4      	; 0x1504 <grn3_548>
    1500:	22 e0       	ldi	r18, 0x02	; 2
    1502:	02 c0       	rjmp	.+4      	; 0x1508 <end_548>

00001504 <grn3_548>:
    1504:	23 e0       	ldi	r18, 0x03	; 3
    1506:	00 00       	nop

00001508 <end_548>:
   else //0x20, 0x30
      ocra=6;
*/

   //Each branch is 9 cycles...
__asm__ __volatile__
    1508:	88 2f       	mov	r24, r24
    150a:	80 73       	andi	r24, 0x30	; 48
    150c:	29 f4       	brne	.+10     	; 0x1518 <blu1tst_549>
    150e:	84 e0       	ldi	r24, 0x04	; 4
    1510:	00 00       	nop
    1512:	00 00       	nop
    1514:	00 00       	nop
    1516:	06 c0       	rjmp	.+12     	; 0x1524 <end_549>

00001518 <blu1tst_549>:
    1518:	80 31       	cpi	r24, 0x10	; 16
    151a:	11 f4       	brne	.+4      	; 0x1520 <blu23_549>
    151c:	85 e0       	ldi	r24, 0x05	; 5
    151e:	02 c0       	rjmp	.+4      	; 0x1524 <end_549>

00001520 <blu23_549>:
    1520:	86 e0       	ldi	r24, 0x06	; 6
    1522:	00 00       	nop

00001524 <end_549>:
     //,  "d0"  (ocra)     //ocra is also used for andi, and is %2
   );

#endif //SETTING vs. FRAMEBUFFER

   DT1 = dt;
    1524:	24 bd       	out	0x24, r18	; 36
   OCR1D = ocrd;
    1526:	9a bd       	out	0x2a, r25	; 42
   OCR1A = ocra;
    1528:	8d bd       	out	0x2d, r24	; 45

		//a/o v62: (Original notes removed)
		//OCR1D controls RED... >=6 is full-red
		// Setting this here indicates where the drawing has completed
		// This is handy for determining timing, stretching, etc...
		OCR1D = 6; //0;
    152a:	86 e0       	ldi	r24, 0x06	; 6
    152c:	8a bd       	out	0x2a, r24	; 42
      // Since Nada, V, and H DT's might be bad for clocking.
//		TCCR1A = ( (0<<COM1A1) | (1<<COM1A0)
//         | (1<<COM1B1) | (0<<COM1B0)
//         | (1<<PWM1A) | (1<<PWM1B) );

		lvds_disableGreen_MakeClockInsensitiveToDT();
    152e:	83 e6       	ldi	r24, 0x63	; 99
    1530:	80 bf       	out	0x30, r24	; 48

      //fullBlue();
      //Nada_fromDEonly();
		Nada_init();
    1532:	80 e3       	ldi	r24, 0x30	; 48
    1534:	84 bd       	out	0x24, r24	; 36
    1536:	84 e0       	ldi	r24, 0x04	; 4
    1538:	8d bd       	out	0x2d, r24	; 45
}
    153a:	08 95       	ret

0000153c <setSpriteSkyColorOverride>:
sprite_t *skyOverrideSprite = NULL;
//uint8_t skyOverridePalette;

void setSpriteSkyColorOverride(sprite_t *sprite) //, uint8_t palette)
{
	skyOverrideSprite = sprite;
    153c:	90 93 bb 00 	sts	0x00BB, r25
    1540:	80 93 ba 00 	sts	0x00BA, r24
//	skyOverridePalette = palette;
}
    1544:	08 95       	ret

00001546 <getRawPixelVal>:

uint8_t getRawPixelVal(sprite_t *sprite, uint8_t row, uint8_t col)
{

	return
		(((pgm_read_byte((uint8_t *)(&(sprite->p_image[ \
    1546:	24 2f       	mov	r18, r20
    1548:	26 95       	lsr	r18
    154a:	26 95       	lsr	r18
    154c:	70 e0       	ldi	r23, 0x00	; 0
    154e:	66 0f       	add	r22, r22
    1550:	77 1f       	adc	r23, r23
    1552:	66 0f       	add	r22, r22
    1554:	77 1f       	adc	r23, r23
    1556:	62 0f       	add	r22, r18
    1558:	71 1d       	adc	r23, r1
    155a:	dc 01       	movw	r26, r24
    155c:	ed 91       	ld	r30, X+
    155e:	fc 91       	ld	r31, X
    1560:	11 97       	sbiw	r26, 0x01	; 1
    1562:	e6 0f       	add	r30, r22
    1564:	f7 1f       	adc	r31, r23
    1566:	84 91       	lpm	r24, Z
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	50 e0       	ldi	r21, 0x00	; 0
    156c:	43 70       	andi	r20, 0x03	; 3
    156e:	50 70       	andi	r21, 0x00	; 0
    1570:	44 0f       	add	r20, r20
    1572:	55 1f       	adc	r21, r21
    1574:	02 c0       	rjmp	.+4      	; 0x157a <getRawPixelVal+0x34>
    1576:	95 95       	asr	r25
    1578:	87 95       	ror	r24
    157a:	4a 95       	dec	r20
    157c:	e2 f7       	brpl	.-8      	; 0x1576 <getRawPixelVal+0x30>
					(row)*PACKED_BYTES_PER_ROW + (col)/PIXELS_PER_PACKAGE])))\
		  )>>((col)%PIXELS_PER_PACKAGE)*(PACKED_BITS_PER_PIXEL))&0x03);
}
    157e:	83 70       	andi	r24, 0x03	; 3
    1580:	08 95       	ret

00001582 <rawPixValToGimpColorVal>:

uint8_t rawPixValToGimpColorVal(uint8_t rawPixelVal, sprite_t *sprite, 
																			uint8_t palette)
{
	return 
	pgm_read_byte(
    1582:	50 e0       	ldi	r21, 0x00	; 0
    1584:	44 0f       	add	r20, r20
    1586:	55 1f       	adc	r21, r21
    1588:	44 0f       	add	r20, r20
    158a:	55 1f       	adc	r21, r21
    158c:	48 0f       	add	r20, r24
    158e:	51 1d       	adc	r21, r1
    1590:	db 01       	movw	r26, r22
    1592:	14 96       	adiw	r26, 0x04	; 4
    1594:	ed 91       	ld	r30, X+
    1596:	fc 91       	ld	r31, X
    1598:	15 97       	sbiw	r26, 0x05	; 5
    159a:	e4 0f       	add	r30, r20
    159c:	f5 1f       	adc	r31, r21
    159e:	84 91       	lpm	r24, Z
			(uint8_t *)(&(sprite->p_palette[ (palette)*4 + rawPixelVal ])));
}
    15a0:	08 95       	ret

000015a2 <getGimpColorVal>:

//This doesn't exactly work as expected... see drawSpriteRow for a better
//implementation
uint8_t getGimpColorVal(sprite_t *sprite, uint8_t palette, uint8_t row, 
																			 	uint8_t col)
{
    15a2:	1f 93       	push	r17
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ec 01       	movw	r28, r24
    15aa:	16 2f       	mov	r17, r22
	//No shit, this entire function was a single "line" of code, at one
	//point... (broken up a/o v63)

	//This is the value as-seen in the icon's .h file... (0-3)
	uint8_t rawPixelVal = getRawPixelVal(sprite, row, col);
    15ac:	64 2f       	mov	r22, r20
    15ae:	42 2f       	mov	r20, r18
    15b0:	ca df       	rcall	.-108    	; 0x1546 <getRawPixelVal>


	//The sky is always 0, as of recently (v63)
	// That's not to say the same color isn't used for other purposes
	// this isn't that smart...
	if((rawPixelVal == 0) && (skyOverrideSprite != NULL))
    15b2:	88 23       	and	r24, r24
    15b4:	41 f4       	brne	.+16     	; 0x15c6 <getGimpColorVal+0x24>
    15b6:	20 91 ba 00 	lds	r18, 0x00BA
    15ba:	30 91 bb 00 	lds	r19, 0x00BB
    15be:	21 15       	cp	r18, r1
    15c0:	31 05       	cpc	r19, r1
    15c2:	09 f0       	breq	.+2      	; 0x15c6 <getGimpColorVal+0x24>
    15c4:	e9 01       	movw	r28, r18

uint8_t rawPixValToGimpColorVal(uint8_t rawPixelVal, sprite_t *sprite, 
																			uint8_t palette)
{
	return 
	pgm_read_byte(
    15c6:	21 2f       	mov	r18, r17
    15c8:	30 e0       	ldi	r19, 0x00	; 0
    15ca:	22 0f       	add	r18, r18
    15cc:	33 1f       	adc	r19, r19
    15ce:	22 0f       	add	r18, r18
    15d0:	33 1f       	adc	r19, r19
    15d2:	28 0f       	add	r18, r24
    15d4:	31 1d       	adc	r19, r1
    15d6:	ec 81       	ldd	r30, Y+4	; 0x04
    15d8:	fd 81       	ldd	r31, Y+5	; 0x05
    15da:	e2 0f       	add	r30, r18
    15dc:	f3 1f       	adc	r31, r19
    15de:	84 91       	lpm	r24, Z
	}

	return rawPixValToGimpColorVal(rawPixelVal, sprite, palette); 
//	pgm_read_byte(
//			(uint8_t *)(&(sprite->p_palette[ (palette)*4 + rawPixelVal ])));
}
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	08 95       	ret

000015e8 <getRawPixelValCOIN>:
uint8_t getRawPixelValCOIN(uint8_t spritePhase, uint8_t row, uint8_t col)
{
	uint8_t * p_image;

	//Is this better accomplished as a switch-statement or with math...?
	switch(spritePhase%8)
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	87 70       	andi	r24, 0x07	; 7
    15ec:	90 70       	andi	r25, 0x00	; 0
    15ee:	86 30       	cpi	r24, 0x06	; 6
    15f0:	91 05       	cpc	r25, r1
    15f2:	18 f0       	brcs	.+6      	; 0x15fa <getRawPixelValCOIN+0x12>
    15f4:	8c e6       	ldi	r24, 0x6C	; 108
    15f6:	94 e0       	ldi	r25, 0x04	; 4
    15f8:	07 c0       	rjmp	.+14     	; 0x1608 <getRawPixelValCOIN+0x20>
    15fa:	fc 01       	movw	r30, r24
    15fc:	ee 0f       	add	r30, r30
    15fe:	ff 1f       	adc	r31, r31
    1600:	ee 55       	subi	r30, 0x5E	; 94
    1602:	ff 4f       	sbci	r31, 0xFF	; 255
    1604:	80 81       	ld	r24, Z
    1606:	91 81       	ldd	r25, Z+1	; 0x01
			p_image = pgm_imageCOIN3;
			break;
	}	

   return
      (((pgm_read_byte((uint8_t *)(&(p_image[ \
    1608:	24 2f       	mov	r18, r20
    160a:	26 95       	lsr	r18
    160c:	26 95       	lsr	r18
    160e:	e6 2f       	mov	r30, r22
    1610:	f0 e0       	ldi	r31, 0x00	; 0
    1612:	ee 0f       	add	r30, r30
    1614:	ff 1f       	adc	r31, r31
    1616:	ee 0f       	add	r30, r30
    1618:	ff 1f       	adc	r31, r31
    161a:	e2 0f       	add	r30, r18
    161c:	f1 1d       	adc	r31, r1
    161e:	e8 0f       	add	r30, r24
    1620:	f9 1f       	adc	r31, r25
    1622:	e4 91       	lpm	r30, Z
    1624:	8e 2f       	mov	r24, r30
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	50 e0       	ldi	r21, 0x00	; 0
    162a:	43 70       	andi	r20, 0x03	; 3
    162c:	50 70       	andi	r21, 0x00	; 0
    162e:	44 0f       	add	r20, r20
    1630:	55 1f       	adc	r21, r21
    1632:	02 c0       	rjmp	.+4      	; 0x1638 <getRawPixelValCOIN+0x50>
    1634:	95 95       	asr	r25
    1636:	87 95       	ror	r24
    1638:	4a 95       	dec	r20
    163a:	e2 f7       	brpl	.-8      	; 0x1634 <getRawPixelValCOIN+0x4c>
               (row)*PACKED_BYTES_PER_ROW + (col)/PIXELS_PER_PACKAGE])))\
        )>>((col)%PIXELS_PER_PACKAGE)*(PACKED_BITS_PER_PIXEL))&0x03);
}  
    163c:	83 70       	andi	r24, 0x03	; 3
    163e:	08 95       	ret

00001640 <getSpritePalette>:

}

uint8_t getSpritePalette(sprite_t *p_thisSprite, uint8_t spritePhase,
																	uint8_t spriteRow)
{
    1640:	fc 01       	movw	r30, r24
    1642:	86 2f       	mov	r24, r22

	uint8_t thePalette;
	
	
	if(p_thisSprite == &spriteFLOWER)
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	e8 37       	cpi	r30, 0x78	; 120
    1648:	f9 07       	cpc	r31, r25
    164a:	61 f4       	brne	.+24     	; 0x1664 <getSpritePalette+0x24>
	{
		if(spriteRow<FLOWER_PALETTE1_ROW)
    164c:	48 30       	cpi	r20, 0x08	; 8
    164e:	30 f5       	brcc	.+76     	; 0x169c <getSpritePalette+0x5c>
			//data = getGimpColorVal(&spriteFLOWER,
			  thePalette = spritePhase%(spriteFLOWER.numPalettes-1) + 1; 
    1650:	20 91 7e 00 	lds	r18, 0x007E
    1654:	30 e0       	ldi	r19, 0x00	; 0
    1656:	21 50       	subi	r18, 0x01	; 1
    1658:	30 40       	sbci	r19, 0x00	; 0
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	b9 01       	movw	r22, r18
    165e:	88 d3       	rcall	.+1808   	; 0x1d70 <__divmodhi4>
    1660:	8f 5f       	subi	r24, 0xFF	; 255
    1662:	08 95       	ret
					 //spriteRow, qCol);
		else
			thePalette = 0;
			//data = getGimpColorVal(&spriteFLOWER, 0, spriteRow, qCol);
	}
	else if(p_thisSprite == &spriteGOOMBA)
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	ea 36       	cpi	r30, 0x6A	; 106
    1668:	f9 07       	cpc	r31, r25
    166a:	a1 f4       	brne	.+40     	; 0x1694 <getSpritePalette+0x54>
		//uint8_t palette; // = qCount * p_thisSprite->numPalettes / 16;
		//if(palette >= p_thisSprite->numPalettes)
		//	palette = p_thisSprite->numPalettes-1;

			
		switch(spritePhase)
    166c:	e6 2f       	mov	r30, r22
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	e0 31       	cpi	r30, 0x10	; 16
    1672:	f1 05       	cpc	r31, r1
    1674:	58 f4       	brcc	.+22     	; 0x168c <getSpritePalette+0x4c>
    1676:	ed 5e       	subi	r30, 0xED	; 237
    1678:	ff 4f       	sbci	r31, 0xFF	; 255
    167a:	09 94       	ijmp
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	08 95       	ret
    1680:	82 e0       	ldi	r24, 0x02	; 2
					break;
				case 7:
				case 8:
				case 9:
					thePalette = 2;
					break;
    1682:	08 95       	ret
    1684:	83 e0       	ldi	r24, 0x03	; 3
				case 10:
				case 11:
				case 12:
					thePalette = 3;
					break;
    1686:	08 95       	ret
    1688:	84 e0       	ldi	r24, 0x04	; 4
				case 13:
				case 14:
				case 15:
					thePalette = 4;
					break;
    168a:	08 95       	ret
				default:
					thePalette = p_thisSprite->numPalettes-1;
    168c:	80 91 70 00 	lds	r24, 0x0070
    1690:	81 50       	subi	r24, 0x01	; 1
    1692:	08 95       	ret
		//data = getGimpColorVal(&spriteGOOMBA, palette, spriteRow, gCol);
	}
	else
	{
		//data = getGimpColorVal(p_thisSprite, 
		  thePalette = spritePhase%p_thisSprite->numPalettes;
    1694:	66 81       	ldd	r22, Z+6	; 0x06
    1696:	4c d3       	rcall	.+1688   	; 0x1d30 <__udivmodqi4>
    1698:	89 2f       	mov	r24, r25
    169a:	08 95       	ret
    169c:	80 e0       	ldi	r24, 0x00	; 0
						//spriteRow, qCol);
	}

	return thePalette;
}
    169e:	08 95       	ret

000016a0 <getSpritePhase>:
// vOffset is whether the sprite is above the frame-buffer or below...
// centered = 0
// so, e.g. vOffset = spriteRow - rowToDrawAt
uint8_t getSpritePhase(sprite_t *p_thisSprite, uint8_t qCount, int8_t
		vOffset)
{
    16a0:	9c 01       	movw	r18, r24
    16a2:	86 2f       	mov	r24, r22
	uint8_t spritePhase = qCount;

	if(p_thisSprite == &spriteQ)
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	21 37       	cpi	r18, 0x71	; 113
    16a8:	39 07       	cpc	r19, r25
    16aa:	61 f4       	brne	.+24     	; 0x16c4 <getSpritePhase+0x24>
	{
		switch(spritePhase%12)
    16ac:	6c e0       	ldi	r22, 0x0C	; 12
    16ae:	40 d3       	rcall	.+1664   	; 0x1d30 <__udivmodqi4>
    16b0:	9c 30       	cpi	r25, 0x0C	; 12
    16b2:	10 f0       	brcs	.+4      	; 0x16b8 <getSpritePhase+0x18>
    16b4:	82 e0       	ldi	r24, 0x02	; 2
    16b6:	08 95       	ret
    16b8:	e9 2f       	mov	r30, r25
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	e2 55       	subi	r30, 0x52	; 82
    16be:	ff 4f       	sbci	r31, 0xFF	; 255
    16c0:	80 81       	ld	r24, Z
    16c2:	08 95       	ret
				break;
		}

	}
	//else if(p_thisSprite == &spriteCOIN) //handled in getRowPixelValCOIN()
	else if(p_thisSprite == &spriteGOOMBA)
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	2a 36       	cpi	r18, 0x6A	; 106
    16c8:	39 07       	cpc	r19, r25
    16ca:	51 f4       	brne	.+20     	; 0x16e0 <getSpritePhase+0x40>
	{
		if (vOffset < 0) //(spriteRow < rowToDrawAt)
    16cc:	47 ff       	sbrs	r20, 7
    16ce:	02 c0       	rjmp	.+4      	; 0x16d4 <getSpritePhase+0x34>
    16d0:	80 e0       	ldi	r24, 0x00	; 0
    16d2:	04 c0       	rjmp	.+8      	; 0x16dc <getSpritePhase+0x3c>
			spritePhase = 0;
		if (vOffset > 0) //(spriteRow > rowToDrawAt)
    16d4:	44 23       	and	r20, r20
    16d6:	11 f0       	breq	.+4      	; 0x16dc <getSpritePhase+0x3c>
    16d8:	80 e3       	ldi	r24, 0x30	; 48
    16da:	08 95       	ret
			spritePhase = GOOMBA_QCOUNT;
		else
			spritePhase /=3;
    16dc:	63 e0       	ldi	r22, 0x03	; 3
    16de:	28 d3       	rcall	.+1616   	; 0x1d30 <__udivmodqi4>

	}

	return spritePhase;

}
    16e0:	08 95       	ret

000016e2 <drawSpriteRow>:
// This does *NOT* handle COIN... use getRowPixelValCOIN() instead.
void drawSpriteRow(sprite_t *p_thisSprite, uint8_t qCount,
															//uint8_t spritePhase,
													  int8_t spriteRow, 
													  uint8_t rowToDrawAt)
{
    16e2:	4f 92       	push	r4
    16e4:	5f 92       	push	r5
    16e6:	6f 92       	push	r6
    16e8:	7f 92       	push	r7
    16ea:	8f 92       	push	r8
    16ec:	9f 92       	push	r9
    16ee:	af 92       	push	r10
    16f0:	bf 92       	push	r11
    16f2:	cf 92       	push	r12
    16f4:	df 92       	push	r13
    16f6:	ef 92       	push	r14
    16f8:	ff 92       	push	r15
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	ec 01       	movw	r28, r24
    1704:	56 2e       	mov	r5, r22
    1706:	14 2f       	mov	r17, r20
    1708:	c2 2e       	mov	r12, r18
	uint8_t qCol;

	uint8_t spritePhase;

	spritePhase = getSpritePhase(p_thisSprite, qCount, 
    170a:	a4 2e       	mov	r10, r20
    170c:	a2 1a       	sub	r10, r18
    170e:	4a 2d       	mov	r20, r10
    1710:	c7 df       	rcall	.-114    	; 0x16a0 <getSpritePhase>
    1712:	b8 2e       	mov	r11, r24
												((int8_t)spriteRow - rowToDrawAt) );

	//This may get overridden (for the sky)
	uint8_t thePalette = getSpritePalette(p_thisSprite, spritePhase,
    1714:	ce 01       	movw	r24, r28
    1716:	6b 2d       	mov	r22, r11
    1718:	41 2f       	mov	r20, r17
    171a:	92 df       	rcall	.-220    	; 0x1640 <getSpritePalette>
    171c:	78 2e       	mov	r7, r24
    171e:	dd 24       	eor	r13, r13
    1720:	e4 e0       	ldi	r30, 0x04	; 4
    1722:	cc 0c       	add	r12, r12
    1724:	dd 1c       	adc	r13, r13
    1726:	ea 95       	dec	r30
    1728:	e1 f7       	brne	.-8      	; 0x1722 <drawSpriteRow+0x40>
    172a:	8c ec       	ldi	r24, 0xCC	; 204
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	c8 0e       	add	r12, r24
    1730:	d9 1e       	adc	r13, r25
    1732:	00 e0       	ldi	r16, 0x00	; 0

		if(p_thisSprite == &spriteGOOMBA)
		{
			//uint8_t gCol = qCol;
			//Goomba moves by flipping horizontally...
			if((spritePhase < 16) && (spritePhase & 0x01))
    1734:	8b 2c       	mov	r8, r11
    1736:	99 24       	eor	r9, r9
    1738:	91 e0       	ldi	r25, 0x01	; 1
    173a:	89 22       	and	r8, r25
    173c:	99 24       	eor	r9, r9
    173e:	7f e0       	ldi	r23, 0x0F	; 15
    1740:	67 2e       	mov	r6, r23
		{
			p_spriteForColor = skyOverrideSprite;
			int8_t vOffset = spriteRow - rowToDrawAt;

			if (skyOverrideSprite != p_thisSprite)
				vOffset = -vOffset;
    1742:	4a 2c       	mov	r4, r10
    1744:	41 94       	neg	r4
      //  pgm_read_byte((uint8_t *)(&((p_image)[(qRow)*Q_WIDTH+(qCol)])));
      uint8_t data;
		uint8_t theCol = qCol;


		if(p_thisSprite == &spriteGOOMBA)
    1746:	a0 e0       	ldi	r26, 0x00	; 0
    1748:	ca 36       	cpi	r28, 0x6A	; 106
    174a:	da 07       	cpc	r29, r26
    174c:	49 f4       	brne	.+18     	; 0x1760 <drawSpriteRow+0x7e>
		{
			//uint8_t gCol = qCol;
			//Goomba moves by flipping horizontally...
			if((spritePhase < 16) && (spritePhase & 0x01))
    174e:	bf e0       	ldi	r27, 0x0F	; 15
    1750:	bb 15       	cp	r27, r11
    1752:	30 f0       	brcs	.+12     	; 0x1760 <drawSpriteRow+0x7e>
    1754:	81 14       	cp	r8, r1
    1756:	91 04       	cpc	r9, r1
    1758:	19 f0       	breq	.+6      	; 0x1760 <drawSpriteRow+0x7e>
    175a:	46 2d       	mov	r20, r6
    175c:	40 1b       	sub	r20, r16
    175e:	01 c0       	rjmp	.+2      	; 0x1762 <drawSpriteRow+0x80>
    1760:	40 2f       	mov	r20, r16



		uint8_t rawPixVal;

		if((spriteRow < 0) || (spriteRow >= Q_HEIGHT))
    1762:	10 31       	cpi	r17, 0x10	; 16
    1764:	80 f4       	brcc	.+32     	; 0x1786 <drawSpriteRow+0xa4>
			rawPixVal = 0;
		else if(p_thisSprite == &spriteCOIN)
    1766:	e0 e0       	ldi	r30, 0x00	; 0
    1768:	c2 36       	cpi	r28, 0x62	; 98
    176a:	de 07       	cpc	r29, r30
    176c:	21 f4       	brne	.+8      	; 0x1776 <drawSpriteRow+0x94>
			rawPixVal = getRawPixelValCOIN(spritePhase, spriteRow, theCol);
    176e:	8b 2d       	mov	r24, r11
    1770:	61 2f       	mov	r22, r17
    1772:	3a df       	rcall	.-396    	; 0x15e8 <getRawPixelValCOIN>
    1774:	03 c0       	rjmp	.+6      	; 0x177c <drawSpriteRow+0x9a>
		else
			rawPixVal = getRawPixelVal(p_thisSprite, spriteRow, theCol);
    1776:	ce 01       	movw	r24, r28
    1778:	61 2f       	mov	r22, r17
    177a:	e5 de       	rcall	.-566    	; 0x1546 <getRawPixelVal>


		sprite_t *p_spriteForColor = p_thisSprite;
		uint8_t paletteForColor = thePalette;

		if( (rawPixVal == 0) && (skyOverrideSprite != NULL) )
    177c:	88 23       	and	r24, r24
    177e:	19 f0       	breq	.+6      	; 0x1786 <drawSpriteRow+0xa4>
    1780:	27 2d       	mov	r18, r7
    1782:	7e 01       	movw	r14, r28
    1784:	19 c0       	rjmp	.+50     	; 0x17b8 <drawSpriteRow+0xd6>
    1786:	e0 90 ba 00 	lds	r14, 0x00BA
    178a:	f0 90 bb 00 	lds	r15, 0x00BB
    178e:	e1 14       	cp	r14, r1
    1790:	f1 04       	cpc	r15, r1
    1792:	19 f4       	brne	.+6      	; 0x179a <drawSpriteRow+0xb8>
    1794:	27 2d       	mov	r18, r7
    1796:	7e 01       	movw	r14, r28
    1798:	0e c0       	rjmp	.+28     	; 0x17b6 <drawSpriteRow+0xd4>
		{
			p_spriteForColor = skyOverrideSprite;
			int8_t vOffset = spriteRow - rowToDrawAt;

			if (skyOverrideSprite != p_thisSprite)
    179a:	ec 16       	cp	r14, r28
    179c:	fd 06       	cpc	r15, r29
    179e:	11 f4       	brne	.+4      	; 0x17a4 <drawSpriteRow+0xc2>
    17a0:	4a 2d       	mov	r20, r10
    17a2:	01 c0       	rjmp	.+2      	; 0x17a6 <drawSpriteRow+0xc4>
				vOffset = -vOffset;
    17a4:	44 2d       	mov	r20, r4

			uint8_t spritePhaseForColor = 
						getSpritePhase(p_spriteForColor, qCount, vOffset);
    17a6:	c7 01       	movw	r24, r14
    17a8:	65 2d       	mov	r22, r5
    17aa:	7a df       	rcall	.-268    	; 0x16a0 <getSpritePhase>
    17ac:	68 2f       	mov	r22, r24
									//				(spriteRow - rowToDrawAta)); 
			paletteForColor = getSpritePalette(p_spriteForColor, 
    17ae:	c7 01       	movw	r24, r14
    17b0:	41 2f       	mov	r20, r17
    17b2:	46 df       	rcall	.-372    	; 0x1640 <getSpritePalette>
    17b4:	28 2f       	mov	r18, r24
    17b6:	80 e0       	ldi	r24, 0x00	; 0

uint8_t rawPixValToGimpColorVal(uint8_t rawPixelVal, sprite_t *sprite, 
																			uint8_t palette)
{
	return 
	pgm_read_byte(
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	22 0f       	add	r18, r18
    17bc:	33 1f       	adc	r19, r19
    17be:	22 0f       	add	r18, r18
    17c0:	33 1f       	adc	r19, r19
    17c2:	28 0f       	add	r18, r24
    17c4:	31 1d       	adc	r19, r1
    17c6:	d7 01       	movw	r26, r14
    17c8:	14 96       	adiw	r26, 0x04	; 4
    17ca:	ed 91       	ld	r30, X+
    17cc:	fc 91       	ld	r31, X
    17ce:	15 97       	sbiw	r26, 0x05	; 5
    17d0:	e2 0f       	add	r30, r18
    17d2:	f3 1f       	adc	r31, r19
    17d4:	84 91       	lpm	r24, Z


		data = rawPixValToGimpColorVal(rawPixVal, p_spriteForColor,
																		paletteForColor); 
		
      data = gimpPixelValToLColor(data);
    17d6:	28 2f       	mov	r18, r24
    17d8:	30 e0       	ldi	r19, 0x00	; 0
    17da:	20 73       	andi	r18, 0x30	; 48
    17dc:	30 70       	andi	r19, 0x00	; 0
    17de:	20 32       	cpi	r18, 0x20	; 32
    17e0:	31 05       	cpc	r19, r1
    17e2:	0c f0       	brlt	.+2      	; 0x17e6 <drawSpriteRow+0x104>
    17e4:	80 5f       	subi	r24, 0xF0	; 240

		frameBuffer[rowToDrawAt][qCol] = data;
    17e6:	f6 01       	movw	r30, r12
    17e8:	81 93       	st	Z+, r24
    17ea:	6f 01       	movw	r12, r30

	//This may get overridden (for the sky)
	uint8_t thePalette = getSpritePalette(p_thisSprite, spritePhase,
																				spriteRow);
	
	for(qCol=0; qCol<Q_WIDTH; qCol++)
    17ec:	0f 5f       	subi	r16, 0xFF	; 255
    17ee:	00 31       	cpi	r16, 0x10	; 16
    17f0:	09 f0       	breq	.+2      	; 0x17f4 <drawSpriteRow+0x112>
    17f2:	a9 cf       	rjmp	.-174    	; 0x1746 <drawSpriteRow+0x64>
		
      data = gimpPixelValToLColor(data);

		frameBuffer[rowToDrawAt][qCol] = data;
	}
}
    17f4:	df 91       	pop	r29
    17f6:	cf 91       	pop	r28
    17f8:	1f 91       	pop	r17
    17fa:	0f 91       	pop	r16
    17fc:	ff 90       	pop	r15
    17fe:	ef 90       	pop	r14
    1800:	df 90       	pop	r13
    1802:	cf 90       	pop	r12
    1804:	bf 90       	pop	r11
    1806:	af 90       	pop	r10
    1808:	9f 90       	pop	r9
    180a:	8f 90       	pop	r8
    180c:	7f 90       	pop	r7
    180e:	6f 90       	pop	r6
    1810:	5f 90       	pop	r5
    1812:	4f 90       	pop	r4
    1814:	08 95       	ret

00001816 <fbQuestion_update>:
void drawSpriteRow(sprite_t *p_thisSprite, uint8_t spritePhase,
													  int8_t spriteRow, 
													  uint8_t rowToDrawAt);

void fbQuestion_update(void) //uint8_t triggerDetected)
{
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	cf 93       	push	r28
    181c:	df 93       	push	r29
	callCount++;
    181e:	80 91 bc 00 	lds	r24, 0x00BC
    1822:	8f 5f       	subi	r24, 0xFF	; 255
    1824:	80 93 bc 00 	sts	0x00BC, r24
//#define Q_STRETCHTOP   1//0//28//2
//#define Q_STRETCHDIV 5//30//3
//   hfm_t colincrementer_hfm;
//   hfm_setup(&colincrementer_hfm, Q_STRETCHTOP, Q_STRETCHDIV);

	if(p_nextSprite == NULL)
    1828:	80 91 be 00 	lds	r24, 0x00BE
    182c:	90 91 bf 00 	lds	r25, 0x00BF
    1830:	00 97       	sbiw	r24, 0x00	; 0
    1832:	09 f0       	breq	.+2      	; 0x1836 <fbQuestion_update+0x20>
    1834:	46 c0       	rjmp	.+140    	; 0x18c2 <fbQuestion_update+0xac>
	{
#if(!defined(STAY_ON_IT) || !STAY_ON_IT)
	if(p_selectedSprite == &spriteDEADGOOMBA)
    1836:	80 91 60 00 	lds	r24, 0x0060
    183a:	90 91 61 00 	lds	r25, 0x0061
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	8f 37       	cpi	r24, 0x7F	; 127
    1842:	92 07       	cpc	r25, r18
    1844:	51 f4       	brne	.+20     	; 0x185a <fbQuestion_update+0x44>
	{
		if(qCount >= 16)
    1846:	80 91 bd 00 	lds	r24, 0x00BD
    184a:	80 31       	cpi	r24, 0x10	; 16
    184c:	d0 f1       	brcs	.+116    	; 0x18c2 <fbQuestion_update+0xac>
		{
			qCount = Q_QSTART; //0;
    184e:	87 e0       	ldi	r24, 0x07	; 7
    1850:	80 93 bd 00 	sts	0x00BD, r24
			p_nextSprite = &spriteQ;
    1854:	81 e7       	ldi	r24, 0x71	; 113
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	30 c0       	rjmp	.+96     	; 0x18ba <fbQuestion_update+0xa4>
		}
	}
	else if(p_selectedSprite == &spriteGOOMBA)
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	8a 36       	cpi	r24, 0x6A	; 106
    185e:	92 07       	cpc	r25, r18
    1860:	29 f4       	brne	.+10     	; 0x186c <fbQuestion_update+0x56>
	{
		if(qCount >= GOOMBA_QCOUNT)
    1862:	80 91 bd 00 	lds	r24, 0x00BD
    1866:	80 33       	cpi	r24, 0x30	; 48
    1868:	60 f1       	brcs	.+88     	; 0x18c2 <fbQuestion_update+0xac>
    186a:	23 c0       	rjmp	.+70     	; 0x18b2 <fbQuestion_update+0x9c>
		{
			qCount = 0;
			p_nextSprite = &spriteSOLID;
		}
	}
	else if(p_selectedSprite == &spriteCOIN)
    186c:	20 e0       	ldi	r18, 0x00	; 0
    186e:	82 36       	cpi	r24, 0x62	; 98
    1870:	92 07       	cpc	r25, r18
    1872:	29 f4       	brne	.+10     	; 0x187e <fbQuestion_update+0x68>
	{
		if(qCount >= 8)
    1874:	80 91 bd 00 	lds	r24, 0x00BD
    1878:	88 30       	cpi	r24, 0x08	; 8
    187a:	18 f1       	brcs	.+70     	; 0x18c2 <fbQuestion_update+0xac>
    187c:	1a c0       	rjmp	.+52     	; 0x18b2 <fbQuestion_update+0x9c>
		{
			qCount = 0;
			p_nextSprite = &spriteSOLID;
		}
	}
	else if(p_selectedSprite == &spriteSOLID)
    187e:	20 e0       	ldi	r18, 0x00	; 0
    1880:	86 38       	cpi	r24, 0x86	; 134
    1882:	92 07       	cpc	r25, r18
    1884:	71 f4       	brne	.+28     	; 0x18a2 <fbQuestion_update+0x8c>
	{
		if(qCount >= 8)
    1886:	80 91 bd 00 	lds	r24, 0x00BD
    188a:	88 30       	cpi	r24, 0x08	; 8
    188c:	d0 f0       	brcs	.+52     	; 0x18c2 <fbQuestion_update+0xac>
		{
			qCount = Q_QSTART; //0;
    188e:	87 e0       	ldi	r24, 0x07	; 7
    1890:	80 93 bd 00 	sts	0x00BD, r24
			p_selectedSprite = &spriteQ;
    1894:	81 e7       	ldi	r24, 0x71	; 113
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	90 93 61 00 	sts	0x0061, r25
    189c:	80 93 60 00 	sts	0x0060, r24
    18a0:	10 c0       	rjmp	.+32     	; 0x18c2 <fbQuestion_update+0xac>
		}
	}
	else if(p_selectedSprite != &spriteQ)
    18a2:	20 e0       	ldi	r18, 0x00	; 0
    18a4:	81 37       	cpi	r24, 0x71	; 113
    18a6:	92 07       	cpc	r25, r18
    18a8:	61 f0       	breq	.+24     	; 0x18c2 <fbQuestion_update+0xac>
	{
		if(qCount >= 16)
    18aa:	80 91 bd 00 	lds	r24, 0x00BD
    18ae:	80 31       	cpi	r24, 0x10	; 16
    18b0:	40 f0       	brcs	.+16     	; 0x18c2 <fbQuestion_update+0xac>
		{
			qCount = 0;
    18b2:	10 92 bd 00 	sts	0x00BD, r1
			//if(p_selectedSprite != &spriteSOLID)
				p_nextSprite = &spriteSOLID;
    18b6:	86 e8       	ldi	r24, 0x86	; 134
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	90 93 bf 00 	sts	0x00BF, r25
    18be:	80 93 be 00 	sts	0x00BE, r24
	//       _____                               ___
	//      |     |     _____         __        /___\
	//      |  ?  | -> |     |  ->  _/__\_  ->   |_|
	//      |_____|    |  ?  |     |      |

	if(p_nextSprite != NULL)
    18c2:	80 91 be 00 	lds	r24, 0x00BE
    18c6:	90 91 bf 00 	lds	r25, 0x00BF
    18ca:	00 97       	sbiw	r24, 0x00	; 0
    18cc:	09 f4       	brne	.+2      	; 0x18d0 <fbQuestion_update+0xba>
    18ce:	68 c0       	rjmp	.+208    	; 0x19a0 <fbQuestion_update+0x18a>
	{

		setSpriteSkyColorOverride(p_selectedSprite);
    18d0:	80 91 60 00 	lds	r24, 0x0060
    18d4:	90 91 61 00 	lds	r25, 0x0061
sprite_t *skyOverrideSprite = NULL;
//uint8_t skyOverridePalette;

void setSpriteSkyColorOverride(sprite_t *sprite) //, uint8_t palette)
{
	skyOverrideSprite = sprite;
    18d8:	90 93 bb 00 	sts	0x00BB, r25
    18dc:	80 93 ba 00 	sts	0x00BA, r24

		if(p_selectedSprite == &spriteQ) 
    18e0:	20 e0       	ldi	r18, 0x00	; 0
    18e2:	81 37       	cpi	r24, 0x71	; 113
    18e4:	92 07       	cpc	r25, r18
    18e6:	f1 f4       	brne	.+60     	; 0x1924 <fbQuestion_update+0x10e>
    18e8:	10 e0       	ldi	r17, 0x00	; 0
    18ea:	0a c0       	rjmp	.+20     	; 0x1900 <fbQuestion_update+0xea>

			//Draw the top of the next sprite...
			for(qRow=0; qRow<qCount; qRow++)
			{
				spriteRow = qRow - (16 - qCount);
				drawSpriteRow(p_nextSprite, qCount, spriteRow, qRow);
    18ec:	46 2f       	mov	r20, r22
    18ee:	40 51       	subi	r20, 0x10	; 16
    18f0:	41 0f       	add	r20, r17
    18f2:	80 91 be 00 	lds	r24, 0x00BE
    18f6:	90 91 bf 00 	lds	r25, 0x00BF
    18fa:	21 2f       	mov	r18, r17
    18fc:	f2 de       	rcall	.-540    	; 0x16e2 <drawSpriteRow>
		if(p_selectedSprite == &spriteQ) 
		{
			uint8_t spriteRow;

			//Draw the top of the next sprite...
			for(qRow=0; qRow<qCount; qRow++)
    18fe:	1f 5f       	subi	r17, 0xFF	; 255
    1900:	60 91 bd 00 	lds	r22, 0x00BD
    1904:	16 17       	cp	r17, r22
    1906:	90 f3       	brcs	.-28     	; 0x18ec <fbQuestion_update+0xd6>
    1908:	00 e0       	ldi	r16, 0x00	; 0
    190a:	09 c0       	rjmp	.+18     	; 0x191e <fbQuestion_update+0x108>
			// so rather than changing p_selectedSprite, let's just override
			// it here
			spriteRow = 0;
			for( ; qRow<Q_HEIGHT; qRow++)
			{
				drawSpriteRow(&spriteSOLID, qCount, spriteRow, qRow);
    190c:	86 e8       	ldi	r24, 0x86	; 134
    190e:	90 e0       	ldi	r25, 0x00	; 0
    1910:	60 91 bd 00 	lds	r22, 0x00BD
    1914:	40 2f       	mov	r20, r16
    1916:	21 2f       	mov	r18, r17
    1918:	e4 de       	rcall	.-568    	; 0x16e2 <drawSpriteRow>
				spriteRow++;
    191a:	0f 5f       	subi	r16, 0xFF	; 255
			// become solid... but in most cases using p_selectedSprite==SOLID
			// results in a transition straight to Q...
			// so rather than changing p_selectedSprite, let's just override
			// it here
			spriteRow = 0;
			for( ; qRow<Q_HEIGHT; qRow++)
    191c:	1f 5f       	subi	r17, 0xFF	; 255
    191e:	10 31       	cpi	r17, 0x10	; 16
    1920:	a8 f3       	brcs	.-22     	; 0x190c <fbQuestion_update+0xf6>
    1922:	28 c0       	rjmp	.+80     	; 0x1974 <fbQuestion_update+0x15e>
			
		}
		else
		{
			uint8_t displayRow;
			uint8_t spriteRow = qCount; 
    1924:	00 91 bd 00 	lds	r16, 0x00BD
    1928:	10 e0       	ldi	r17, 0x00	; 0

			for(displayRow = 0; displayRow < (Q_HEIGHT-qCount); displayRow++)
    192a:	c0 e1       	ldi	r28, 0x10	; 16
    192c:	d0 e0       	ldi	r29, 0x00	; 0
    192e:	09 c0       	rjmp	.+18     	; 0x1942 <fbQuestion_update+0x12c>
			{
				drawSpriteRow(p_selectedSprite, qCount, spriteRow, displayRow);
    1930:	41 2f       	mov	r20, r17
    1932:	40 0f       	add	r20, r16
    1934:	80 91 60 00 	lds	r24, 0x0060
    1938:	90 91 61 00 	lds	r25, 0x0061
    193c:	21 2f       	mov	r18, r17
    193e:	d1 de       	rcall	.-606    	; 0x16e2 <drawSpriteRow>
		else
		{
			uint8_t displayRow;
			uint8_t spriteRow = qCount; 

			for(displayRow = 0; displayRow < (Q_HEIGHT-qCount); displayRow++)
    1940:	1f 5f       	subi	r17, 0xFF	; 255
    1942:	60 91 bd 00 	lds	r22, 0x00BD
    1946:	21 2f       	mov	r18, r17
    1948:	30 e0       	ldi	r19, 0x00	; 0
    194a:	ce 01       	movw	r24, r28
    194c:	86 1b       	sub	r24, r22
    194e:	91 09       	sbc	r25, r1
    1950:	28 17       	cp	r18, r24
    1952:	39 07       	cpc	r19, r25
    1954:	6c f3       	brlt	.-38     	; 0x1930 <fbQuestion_update+0x11a>
    1956:	00 e0       	ldi	r16, 0x00	; 0
    1958:	0b c0       	rjmp	.+22     	; 0x1970 <fbQuestion_update+0x15a>
			}
	
			spriteRow = 0;
			for( ; displayRow<Q_HEIGHT; displayRow++)
			{
				drawSpriteRow(p_nextSprite, qCount, spriteRow, displayRow);
    195a:	80 91 be 00 	lds	r24, 0x00BE
    195e:	90 91 bf 00 	lds	r25, 0x00BF
    1962:	60 91 bd 00 	lds	r22, 0x00BD
    1966:	40 2f       	mov	r20, r16
    1968:	21 2f       	mov	r18, r17
    196a:	bb de       	rcall	.-650    	; 0x16e2 <drawSpriteRow>
					//				displayRow-(Q_HEIGHT-1-qCount), displayRow);

				spriteRow++;
    196c:	0f 5f       	subi	r16, 0xFF	; 255
									//				displayRow+qCount, displayRow);
				spriteRow++;
			}
	
			spriteRow = 0;
			for( ; displayRow<Q_HEIGHT; displayRow++)
    196e:	1f 5f       	subi	r17, 0xFF	; 255
    1970:	10 31       	cpi	r17, 0x10	; 16
    1972:	98 f3       	brcs	.-26     	; 0x195a <fbQuestion_update+0x144>

				spriteRow++;
			}
		}

		qCount++;
    1974:	80 91 bd 00 	lds	r24, 0x00BD
    1978:	8f 5f       	subi	r24, 0xFF	; 255
    197a:	80 93 bd 00 	sts	0x00BD, r24
		if(qCount >= Q_HEIGHT)
    197e:	80 31       	cpi	r24, 0x10	; 16
    1980:	48 f1       	brcs	.+82     	; 0x19d4 <fbQuestion_update+0x1be>
		{
			qCount = 0;
    1982:	10 92 bd 00 	sts	0x00BD, r1
			p_selectedSprite = p_nextSprite;
    1986:	80 91 be 00 	lds	r24, 0x00BE
    198a:	90 91 bf 00 	lds	r25, 0x00BF
    198e:	90 93 61 00 	sts	0x0061, r25
    1992:	80 93 60 00 	sts	0x0060, r24
			p_nextSprite = NULL;
    1996:	10 92 bf 00 	sts	0x00BF, r1
    199a:	10 92 be 00 	sts	0x00BE, r1
    199e:	1a c0       	rjmp	.+52     	; 0x19d4 <fbQuestion_update+0x1be>
    19a0:	10 92 bb 00 	sts	0x00BB, r1
    19a4:	10 92 ba 00 	sts	0x00BA, r1
    19a8:	10 e0       	ldi	r17, 0x00	; 0
	else //we only have a selectedSprite (nextSprite is NULL)
	{
		setSpriteSkyColorOverride(NULL);

		for(qRow=0; qRow<Q_HEIGHT; qRow++)
			drawSpriteRow(p_selectedSprite, qCount, qRow, qRow);
    19aa:	80 91 60 00 	lds	r24, 0x0060
    19ae:	90 91 61 00 	lds	r25, 0x0061
    19b2:	60 91 bd 00 	lds	r22, 0x00BD
    19b6:	41 2f       	mov	r20, r17
    19b8:	21 2f       	mov	r18, r17
    19ba:	93 de       	rcall	.-730    	; 0x16e2 <drawSpriteRow>
	} //end of nextSprite Handling...
	else //we only have a selectedSprite (nextSprite is NULL)
	{
		setSpriteSkyColorOverride(NULL);

		for(qRow=0; qRow<Q_HEIGHT; qRow++)
    19bc:	1f 5f       	subi	r17, 0xFF	; 255
    19be:	10 31       	cpi	r17, 0x10	; 16
    19c0:	a1 f7       	brne	.-24     	; 0x19aa <fbQuestion_update+0x194>
			drawSpriteRow(p_selectedSprite, qCount, qRow, qRow);

		qCount++;
    19c2:	80 91 bd 00 	lds	r24, 0x00BD
    19c6:	8f 5f       	subi	r24, 0xFF	; 255
    19c8:	80 93 bd 00 	sts	0x00BD, r24
		//the only case where qCount should cycle is spriteQ...
		// its value is %12, so could either reset it at 12, or this.. whatev
		// To avoid a glitch every 21 cycles.
		if(qCount >= ((255 / 12) * 12))
    19cc:	8c 3f       	cpi	r24, 0xFC	; 252
    19ce:	10 f0       	brcs	.+4      	; 0x19d4 <fbQuestion_update+0x1be>
			qCount = 0;
    19d0:	10 92 bd 00 	sts	0x00BD, r1
	}

}
    19d4:	df 91       	pop	r29
    19d6:	cf 91       	pop	r28
    19d8:	1f 91       	pop	r17
    19da:	0f 91       	pop	r16
    19dc:	08 95       	ret

000019de <lcd_Init>:
//   (the fewer changes, the less likely we'll glitch...?)


void lcd_Init(void)
{
 	Nada_init();
    19de:	80 e3       	ldi	r24, 0x30	; 48
    19e0:	84 bd       	out	0x24, r24	; 36
    19e2:	84 e0       	ldi	r24, 0x04	; 4
    19e4:	8d bd       	out	0x2d, r24	; 45
}
    19e6:	08 95       	ret

000019e8 <updateLCD>:

	//Hsync and Actually draw the pixels... (when DE is active)
	// This takes a LONG time and will occupy most of the CPU...
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);
    19e8:	80 91 c2 00 	lds	r24, 0x00C2
    19ec:	90 91 c3 00 	lds	r25, 0x00C3
    19f0:	40 91 c0 00 	lds	r20, 0x00C0
// rowNum is only used when DE is active...
//  and should be 0 at *drawn row* 0
void loadData(uint16_t rowNum, uint8_t dataEnable)
{
	//H Active pulse...
   if(vSync)
    19f4:	20 91 c1 00 	lds	r18, 0x00C1
    19f8:	22 23       	and	r18, r18
    19fa:	e9 f0       	breq	.+58     	; 0x1a36 <updateLCD+0x4e>
   {
		//Vsync_fromNada() is called at the end of the last interupt
      VplusH_fromVsync();
    19fc:	1d bc       	out	0x2d, r1	; 45
    19fe:	20 e0       	ldi	r18, 0x00	; 0
    1a00:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1a02:	00 00       	nop
      asm("nop");
    1a04:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1a06:	2f 5f       	subi	r18, 0xFF	; 255
    1a08:	3f 4f       	sbci	r19, 0xFF	; 255
    1a0a:	26 31       	cpi	r18, 0x16	; 22
    1a0c:	31 05       	cpc	r19, r1
    1a0e:	c9 f7       	brne	.-14     	; 0x1a02 <updateLCD+0x1a>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    1a10:	00 00       	nop
		case 6:
			asm("nop");
    1a12:	00 00       	nop
		case 5:
			asm("nop");
    1a14:	00 00       	nop
		case 4:
			asm("nop");
    1a16:	00 00       	nop
		case 3:
			asm("nop");
    1a18:	00 00       	nop
		case 2:
			asm("nop");
    1a1a:	00 00       	nop
		case 1:
			asm("nop");
    1a1c:	00 00       	nop
      Hlow_Delay();
      Vsync_fromVplusH();
    1a1e:	25 e0       	ldi	r18, 0x05	; 5
    1a20:	2d bd       	out	0x2d, r18	; 45
    1a22:	20 e0       	ldi	r18, 0x00	; 0
    1a24:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1a26:	00 00       	nop
      asm("nop");
    1a28:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1a2a:	2f 5f       	subi	r18, 0xFF	; 255
    1a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a2e:	2b 30       	cpi	r18, 0x0B	; 11
    1a30:	31 05       	cpc	r19, r1
    1a32:	c9 f7       	brne	.-14     	; 0x1a26 <updateLCD+0x3e>
    1a34:	1d c0       	rjmp	.+58     	; 0x1a70 <updateLCD+0x88>
      HD_Delay();
   }
   else
   {
      Hsync_fromNada();
    1a36:	23 e0       	ldi	r18, 0x03	; 3
    1a38:	2d bd       	out	0x2d, r18	; 45
    1a3a:	20 e0       	ldi	r18, 0x00	; 0
    1a3c:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1a3e:	00 00       	nop
      asm("nop");
    1a40:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1a42:	2f 5f       	subi	r18, 0xFF	; 255
    1a44:	3f 4f       	sbci	r19, 0xFF	; 255
    1a46:	26 31       	cpi	r18, 0x16	; 22
    1a48:	31 05       	cpc	r19, r1
    1a4a:	c9 f7       	brne	.-14     	; 0x1a3e <updateLCD+0x56>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    1a4c:	00 00       	nop
		case 6:
			asm("nop");
    1a4e:	00 00       	nop
		case 5:
			asm("nop");
    1a50:	00 00       	nop
		case 4:
			asm("nop");
    1a52:	00 00       	nop
		case 3:
			asm("nop");
    1a54:	00 00       	nop
		case 2:
			asm("nop");
    1a56:	00 00       	nop
		case 1:
			asm("nop");
    1a58:	00 00       	nop
      Hlow_Delay();
      Nada_fromHsync();
    1a5a:	24 e0       	ldi	r18, 0x04	; 4
    1a5c:	2d bd       	out	0x2d, r18	; 45
    1a5e:	20 e0       	ldi	r18, 0x00	; 0
    1a60:	30 e0       	ldi	r19, 0x00	; 0
         asm("nop");
      }
   */
      //Apparently this loop will optimize-out without this:
      // Obviously, one instruction each...
      asm("nop");
    1a62:	00 00       	nop
      asm("nop");
    1a64:	00 00       	nop
   // Each loop is 7 cycles, make it 8 by adding an extra nop and we can
   // use >> instead of / for calculations...
   // +7 assures rounding-up...
#warning "This loop seems to be optimizing out!"
   //for(i=0; i<((numCyc+7)>>3); i++)
   for(i=0; i<numLoops; i++)
    1a66:	2f 5f       	subi	r18, 0xFF	; 255
    1a68:	3f 4f       	sbci	r19, 0xFF	; 255
    1a6a:	2b 30       	cpi	r18, 0x0B	; 11
    1a6c:	31 05       	cpc	r19, r1
    1a6e:	c9 f7       	brne	.-14     	; 0x1a62 <updateLCD+0x7a>
	//thing...
	// but doing-so might make optimization more difficult...?
	switch(loopRemainder)
	{
		case 7:
			asm("nop");
    1a70:	00 00       	nop
		case 6:
			asm("nop");
    1a72:	00 00       	nop
		case 5:
			asm("nop");
    1a74:	00 00       	nop
		case 4:
			asm("nop");
    1a76:	00 00       	nop
		case 3:
			asm("nop");
    1a78:	00 00       	nop
		case 2:
			asm("nop");
    1a7a:	00 00       	nop
		case 1:
			asm("nop");
    1a7c:	00 00       	nop
      HD_Delay();
   }

   if(dataEnable)
    1a7e:	44 23       	and	r20, r20
    1a80:	11 f0       	breq	.+4      	; 0x1a86 <updateLCD+0x9e>
//#include "nonRSB_drawPix.c"
void drawPix(uint16_t rowNum)
{
	//This hasn't been used in quite some time... 
	// it may not work at all anymore.
	nonRSB_drawPix(rowNum);
    1a82:	86 97       	sbiw	r24, 0x26	; 38
    1a84:	5e d8       	rcall	.-3908   	; 0xb42 <nonRSB_drawPix>
	// This takes a LONG time and will occupy most of the CPU...
	//  ... IN THIS INTERRUPT
	//loadData(((hsyncCount-T_VD-T_Vlow)>>3)&31, dataEnable,colorOverride);
	loadData(hsyncCount-T_DV-T_VD-T_Vlow, dataEnable);

	hsyncCount++;
    1a86:	80 91 c2 00 	lds	r24, 0x00C2
    1a8a:	90 91 c3 00 	lds	r25, 0x00C3
    1a8e:	01 96       	adiw	r24, 0x01	; 1
    1a90:	90 93 c3 00 	sts	0x00C3, r25
    1a94:	80 93 c2 00 	sts	0x00C2, r24

	switch(hsyncCount)
    1a98:	83 32       	cpi	r24, 0x23	; 35
    1a9a:	91 05       	cpc	r25, r1
    1a9c:	c1 f0       	breq	.+48     	; 0x1ace <updateLCD+0xe6>
    1a9e:	84 32       	cpi	r24, 0x24	; 36
    1aa0:	91 05       	cpc	r25, r1
    1aa2:	20 f4       	brcc	.+8      	; 0x1aac <updateLCD+0xc4>
    1aa4:	83 30       	cpi	r24, 0x03	; 3
    1aa6:	91 05       	cpc	r25, r1
    1aa8:	e1 f4       	brne	.+56     	; 0x1ae2 <updateLCD+0xfa>
    1aaa:	08 c0       	rjmp	.+16     	; 0x1abc <updateLCD+0xd4>
    1aac:	86 32       	cpi	r24, 0x26	; 38
    1aae:	91 05       	cpc	r25, r1
    1ab0:	a9 f0       	breq	.+42     	; 0x1adc <updateLCD+0xf4>
    1ab2:	23 e0       	ldi	r18, 0x03	; 3
    1ab4:	86 32       	cpi	r24, 0x26	; 38
    1ab6:	92 07       	cpc	r25, r18
    1ab8:	a1 f4       	brne	.+40     	; 0x1ae2 <updateLCD+0xfa>
    1aba:	15 c0       	rjmp	.+42     	; 0x1ae6 <updateLCD+0xfe>
	{
		//V Front Porch, begins with initLCD

		//Vsync H->L (Begin V-Sync)
		case T_DV:
			dataEnable = FALSE;
    1abc:	10 92 c0 00 	sts	0x00C0, r1
			//clrpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = TRUE;
    1ac0:	81 e0       	ldi	r24, 0x01	; 1
    1ac2:	80 93 c1 00 	sts	0x00C1, r24
			Vsync_fromNada();
    1ac6:	80 e4       	ldi	r24, 0x40	; 64
    1ac8:	84 bd       	out	0x24, r24	; 36
    1aca:	85 e0       	ldi	r24, 0x05	; 5
    1acc:	05 c0       	rjmp	.+10     	; 0x1ad8 <updateLCD+0xf0>
		//	if(hfm_nextOutput(&modulator))
		//		colorOverride = 0xff;
		//	else
		//		colorOverride = 7;
			//setpinPORT(VSYNC_PIN, VSYNC_PORT);
			vSync = FALSE;
    1ace:	10 92 c1 00 	sts	0x00C1, r1
			Nada_fromVsync();
    1ad2:	80 e3       	ldi	r24, 0x30	; 48
    1ad4:	84 bd       	out	0x24, r24	; 36
    1ad6:	84 e0       	ldi	r24, 0x04	; 4
    1ad8:	8d bd       	out	0x2d, r24	; 45
    1ada:	03 c0       	rjmp	.+6      	; 0x1ae2 <updateLCD+0xfa>
			break;
		//Start of frame (DE active)
		case T_VD +(T_Vlow + T_DV):
			dataEnable = TRUE;
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	80 93 c0 00 	sts	0x00C0, r24
    1ae2:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1ae4:	08 95       	ret
		// All rows have been displayed
		// Return to V Front Porch
		case V_COUNT +(T_VD + T_Vlow + T_DV):
			dataEnable = FALSE;
    1ae6:	10 92 c0 00 	sts	0x00C0, r1
		//	break;
		//Frame complete
		//case HSYNC_COUNT_FRAME_COMPLETE:
			//T_DV +(V_COUNT+T_VD+T_Vlow) + FRAME_UPDATE_DELAY:
			hsyncCount = 0;
    1aea:	10 92 c3 00 	sts	0x00C3, r1
    1aee:	10 92 c2 00 	sts	0x00C2, r1
    1af2:	81 e0       	ldi	r24, 0x01	; 1
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...

	return frameComplete;
}
    1af4:	08 95       	ret

00001af6 <__vector_14>:
//Nearly everything display-related happens in this interrupt
// It even calls the functions that load (and calculate!) the data for the
// next row.
// So basically, the entire project is running via timer-interrupt.
SIGNAL(TIMER0_COMPA_vect)
{
    1af6:	1f 92       	push	r1
    1af8:	0f 92       	push	r0
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	0f 92       	push	r0
    1afe:	11 24       	eor	r1, r1
    1b00:	2f 93       	push	r18
    1b02:	3f 93       	push	r19
    1b04:	4f 93       	push	r20
    1b06:	5f 93       	push	r21
    1b08:	6f 93       	push	r22
    1b0a:	7f 93       	push	r23
    1b0c:	8f 93       	push	r24
    1b0e:	9f 93       	push	r25
    1b10:	af 93       	push	r26
    1b12:	bf 93       	push	r27
    1b14:	ef 93       	push	r30
    1b16:	ff 93       	push	r31
	// drawPix is only called for drawn-rows (where DE is active, NOT for
	// Vblank rows)
	// H-Front-Porch is handled in the time between completion of this
	// interrupt and the next interrupt...

	if(updateLCD())
    1b18:	67 df       	rcall	.-306    	; 0x19e8 <updateLCD>
    1b1a:	88 23       	and	r24, r24
    1b1c:	29 f0       	breq	.+10     	; 0x1b28 <__vector_14+0x32>
	{
		frameCount++;
    1b1e:	80 91 c4 00 	lds	r24, 0x00C4
    1b22:	8f 5f       	subi	r24, 0xFF	; 255
    1b24:	80 93 c4 00 	sts	0x00C4, r24
	// to load a row to a row-buffer (as opposed to a frame-buffer)
	// thus, DE could gain more pixels because there would be fewer
	// calculations to determine the memory location to write from
	// This effect has since been minimized
	// BUT loadRow might be necessary for program-memory-based images...
}
    1b28:	ff 91       	pop	r31
    1b2a:	ef 91       	pop	r30
    1b2c:	bf 91       	pop	r27
    1b2e:	af 91       	pop	r26
    1b30:	9f 91       	pop	r25
    1b32:	8f 91       	pop	r24
    1b34:	7f 91       	pop	r23
    1b36:	6f 91       	pop	r22
    1b38:	5f 91       	pop	r21
    1b3a:	4f 91       	pop	r20
    1b3c:	3f 91       	pop	r19
    1b3e:	2f 91       	pop	r18
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	0f 90       	pop	r0
    1b46:	1f 90       	pop	r1
    1b48:	18 95       	reti

00001b4a <fbQuestion_hitDetected>:
sprite_t *p_selectedSprite = &spriteCOIN; //GOOMBA; //FLOWER; //&spriteQ;
sprite_t *p_nextSprite = NULL;

void fbQuestion_hitDetected(void)
{
	if( (p_selectedSprite == &spriteQ)
    1b4a:	80 91 60 00 	lds	r24, 0x0060
    1b4e:	90 91 61 00 	lds	r25, 0x0061
    1b52:	20 e0       	ldi	r18, 0x00	; 0
    1b54:	81 37       	cpi	r24, 0x71	; 113
    1b56:	92 07       	cpc	r25, r18
    1b58:	09 f0       	breq	.+2      	; 0x1b5c <fbQuestion_hitDetected+0x12>
    1b5a:	42 c0       	rjmp	.+132    	; 0x1be0 <fbQuestion_hitDetected+0x96>
    1b5c:	80 91 be 00 	lds	r24, 0x00BE
    1b60:	90 91 bf 00 	lds	r25, 0x00BF
    1b64:	00 97       	sbiw	r24, 0x00	; 0
    1b66:	09 f0       	breq	.+2      	; 0x1b6a <fbQuestion_hitDetected+0x20>
    1b68:	4d c0       	rjmp	.+154    	; 0x1c04 <fbQuestion_hitDetected+0xba>
#if (!defined(IMMEDIATE) || !IMMEDIATE)
	    && (p_nextSprite == NULL)
#endif
	  )
	{
		qCount = 0;
    1b6a:	10 92 bd 00 	sts	0x00BD, r1
#ifndef RANDOM_OVERRIDE
		//Just trying to get some randomness up in hea
		switch(((adc_getValue()*3+callCount+qCount))%8)
    1b6e:	6f d6       	rcall	.+3294   	; 0x284e <__data_load_end+0xa5a>
    1b70:	40 91 bd 00 	lds	r20, 0x00BD
    1b74:	20 91 bc 00 	lds	r18, 0x00BC
    1b78:	30 e0       	ldi	r19, 0x00	; 0
    1b7a:	24 0f       	add	r18, r20
    1b7c:	31 1d       	adc	r19, r1
    1b7e:	63 e0       	ldi	r22, 0x03	; 3
    1b80:	70 e0       	ldi	r23, 0x00	; 0
    1b82:	c4 d0       	rcall	.+392    	; 0x1d0c <__mulhi3>
    1b84:	28 0f       	add	r18, r24
    1b86:	39 1f       	adc	r19, r25
    1b88:	27 70       	andi	r18, 0x07	; 7
    1b8a:	30 70       	andi	r19, 0x00	; 0
    1b8c:	22 30       	cpi	r18, 0x02	; 2
    1b8e:	31 05       	cpc	r19, r1
    1b90:	b9 f0       	breq	.+46     	; 0x1bc0 <fbQuestion_hitDetected+0x76>
    1b92:	23 30       	cpi	r18, 0x03	; 3
    1b94:	31 05       	cpc	r19, r1
    1b96:	38 f4       	brcc	.+14     	; 0x1ba6 <fbQuestion_hitDetected+0x5c>
    1b98:	21 15       	cp	r18, r1
    1b9a:	31 05       	cpc	r19, r1
    1b9c:	59 f0       	breq	.+22     	; 0x1bb4 <fbQuestion_hitDetected+0x6a>
    1b9e:	21 30       	cpi	r18, 0x01	; 1
    1ba0:	31 05       	cpc	r19, r1
    1ba2:	b9 f4       	brne	.+46     	; 0x1bd2 <fbQuestion_hitDetected+0x88>
    1ba4:	0a c0       	rjmp	.+20     	; 0x1bba <fbQuestion_hitDetected+0x70>
    1ba6:	23 30       	cpi	r18, 0x03	; 3
    1ba8:	31 05       	cpc	r19, r1
    1baa:	69 f0       	breq	.+26     	; 0x1bc6 <fbQuestion_hitDetected+0x7c>
    1bac:	24 30       	cpi	r18, 0x04	; 4
    1bae:	31 05       	cpc	r19, r1
    1bb0:	81 f4       	brne	.+32     	; 0x1bd2 <fbQuestion_hitDetected+0x88>
    1bb2:	0c c0       	rjmp	.+24     	; 0x1bcc <fbQuestion_hitDetected+0x82>
#else
		switch(RANDOM_OVERRIDE)
#endif
		{
			case 0:
				p_nextSprite = &spriteFLOWER;
    1bb4:	88 e7       	ldi	r24, 0x78	; 120
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	0e c0       	rjmp	.+28     	; 0x1bd6 <fbQuestion_hitDetected+0x8c>
				break;
			case 1:
				p_nextSprite = &sprite1UP;
    1bba:	8d e8       	ldi	r24, 0x8D	; 141
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	0b c0       	rjmp	.+22     	; 0x1bd6 <fbQuestion_hitDetected+0x8c>
				break;
			case 2:
				p_nextSprite = &spriteBIG;
    1bc0:	84 e9       	ldi	r24, 0x94	; 148
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	08 c0       	rjmp	.+16     	; 0x1bd6 <fbQuestion_hitDetected+0x8c>
				break;
			case 3:
				p_nextSprite = &spriteSTAR;
    1bc6:	8b e9       	ldi	r24, 0x9B	; 155
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	05 c0       	rjmp	.+10     	; 0x1bd6 <fbQuestion_hitDetected+0x8c>
				break;
			case 4:
				p_nextSprite = &spriteGOOMBA;
    1bcc:	8a e6       	ldi	r24, 0x6A	; 106
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	02 c0       	rjmp	.+4      	; 0x1bd6 <fbQuestion_hitDetected+0x8c>
				break;
			case 7:
				p_selectedSprite = &spriteSOLID;
				break;
*/			default:
				p_nextSprite = &spriteCOIN;
    1bd2:	82 e6       	ldi	r24, 0x62	; 98
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	90 93 bf 00 	sts	0x00BF, r25
    1bda:	80 93 be 00 	sts	0x00BE, r24
    1bde:	08 95       	ret
	//briefly before scroll-back-to-question starts...
	// so there's no reason to test for KILLABLE
	// since it can't be killed when it's scrolling.
	// There's probably a tiny fraction of a second window where it is
	// possible to hit it when it's blue, and kill it... but it's TINY.
	else if( (p_selectedSprite == &spriteGOOMBA)
    1be0:	20 e0       	ldi	r18, 0x00	; 0
    1be2:	8a 36       	cpi	r24, 0x6A	; 106
    1be4:	92 07       	cpc	r25, r18
    1be6:	71 f4       	brne	.+28     	; 0x1c04 <fbQuestion_hitDetected+0xba>
    1be8:	80 91 be 00 	lds	r24, 0x00BE
    1bec:	90 91 bf 00 	lds	r25, 0x00BF
    1bf0:	00 97       	sbiw	r24, 0x00	; 0
    1bf2:	41 f4       	brne	.+16     	; 0x1c04 <fbQuestion_hitDetected+0xba>
				&& (p_nextSprite == NULL) )
//			   && ((qCount > 0) && (qCount < 16)) )
//			   && (qCount < GOOMBA_KILLABLE_QCOUNT) )
	{
		qCount = 0;
    1bf4:	10 92 bd 00 	sts	0x00BD, r1
		p_selectedSprite = &spriteDEADGOOMBA;
    1bf8:	8f e7       	ldi	r24, 0x7F	; 127
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	90 93 61 00 	sts	0x0061, r25
    1c00:	80 93 60 00 	sts	0x0060, r24
    1c04:	08 95       	ret

00001c06 <init_timer0Hsync>:
//Testing with values returned by timer0Calculator
//#define TIMER0_OCRVAL	65

void init_timer0Hsync(void)
{
   OCR0A = TIMER0_OCRVAL; //T_Hlow_CYC + T_HD_CYC + T_DE_CYC + T_DH_CYC;
    1c06:	82 e2       	ldi	r24, 0x22	; 34
    1c08:	83 bb       	out	0x13, r24	; 19
   timer_setWGM(0, WGM_CLR_ON_COMPARE);
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	62 e0       	ldi	r22, 0x02	; 2
    1c0e:	75 d6       	rcall	.+3306   	; 0x28fa <__data_load_end+0xb06>
   timer_selectDivisor(0, TIMER0_CLKDIV); //CLKDIV1);
    1c10:	80 e0       	ldi	r24, 0x00	; 0
    1c12:	66 e0       	ldi	r22, 0x06	; 6
    1c14:	49 d6       	rcall	.+3218   	; 0x28a8 <__data_load_end+0xab4>
   timer_compareMatchIntEnable(0, OUT_CHANNELA);
    1c16:	80 e0       	ldi	r24, 0x00	; 0
    1c18:	60 e0       	ldi	r22, 0x00	; 0
    1c1a:	41 e0       	ldi	r20, 0x01	; 1
    1c1c:	a2 d6       	rcall	.+3396   	; 0x2962 <__data_load_end+0xb6e>
}
    1c1e:	08 95       	ret

00001c20 <main>:
#endif
#endif


int main(void)
{
    1c20:	cf 92       	push	r12
    1c22:	df 92       	push	r13
    1c24:	ef 92       	push	r14
    1c26:	ff 92       	push	r15
    1c28:	0f 93       	push	r16
    1c2a:	1f 93       	push	r17
	racer_init();
#endif

#if ( (defined(BLUE_ADC) && BLUE_ADC) \
		|| (defined(FB_QUESTION) && FB_QUESTION) )
	adc_takeInput(6);
    1c2c:	86 e0       	ldi	r24, 0x06	; 6
    1c2e:	1f d6       	rcall	.+3134   	; 0x286e <__data_load_end+0xa7a>
	adc_init();
    1c30:	fc d5       	rcall	.+3064   	; 0x282a <__data_load_end+0xa36>
	adc_select(6);
    1c32:	86 e0       	ldi	r24, 0x06	; 6
    1c34:	ec d5       	rcall	.+3032   	; 0x280e <__data_load_end+0xa1a>
#endif

#if(defined(SEG_TET) && SEG_TET)
	tetInit(3);
#endif
	init_timer0Hsync();
    1c36:	e7 df       	rcall	.-50     	; 0x1c06 <init_timer0Hsync>
	//This starts pretty late... watch out for WDT
	init_heartBeat();

	setHeartRate(0);

	lvds_timerInit();
    1c38:	3b d7       	rcall	.+3702   	; 0x2ab0 <__data_load_end+0xcbc>

	// MUCH Of this is outside the screen...


#if(defined(FB_QUESTION) && FB_QUESTION)
	adc_startConversion();
    1c3a:	ef d5       	rcall	.+3038   	; 0x281a <__data_load_end+0xa26>
#define ADC_DETECTION_THRESHOLD	15 //20 //38 //(1024*125/3300)
					if(absDiff > ADC_DETECTION_THRESHOLD)
						fbQuestion_hitDetected();
				}
				adcAvg = 0;
				avgCount=1;
    1c3c:	11 e0       	ldi	r17, 0x01	; 1
	{
#if(defined(FB_QUESTION) && FB_QUESTION)
		static int32_t adcAvg = 0;
		static uint16_t adcVal;
		static uint8_t avgCount = 100;
		if(!adc_isBusy())
    1c3e:	0b d6       	rcall	.+3094   	; 0x2856 <__data_load_end+0xa62>
    1c40:	88 23       	and	r24, r24
    1c42:	09 f0       	breq	.+2      	; 0x1c46 <main+0x26>
    1c44:	59 c0       	rjmp	.+178    	; 0x1cf8 <main+0xd8>
		{
			adcVal = adc_getValue();
    1c46:	03 d6       	rcall	.+3078   	; 0x284e <__data_load_end+0xa5a>
    1c48:	90 93 c7 00 	sts	0x00C7, r25
    1c4c:	80 93 c6 00 	sts	0x00C6, r24
			
			adc_startConversion();
    1c50:	e4 d5       	rcall	.+3016   	; 0x281a <__data_load_end+0xa26>


			if(avgCount > 1)
    1c52:	90 91 69 00 	lds	r25, 0x0069
    1c56:	92 30       	cpi	r25, 0x02	; 2
    1c58:	20 f0       	brcs	.+8      	; 0x1c62 <main+0x42>
				avgCount--;
    1c5a:	91 50       	subi	r25, 0x01	; 1
    1c5c:	90 93 69 00 	sts	0x0069, r25
    1c60:	4b c0       	rjmp	.+150    	; 0x1cf8 <main+0xd8>
    1c62:	20 91 c6 00 	lds	r18, 0x00C6
    1c66:	30 91 c7 00 	lds	r19, 0x00C7
    1c6a:	c0 90 c8 00 	lds	r12, 0x00C8
    1c6e:	d0 90 c9 00 	lds	r13, 0x00C9
    1c72:	e0 90 ca 00 	lds	r14, 0x00CA
    1c76:	f0 90 cb 00 	lds	r15, 0x00CB
			else if(avgCount == 1)
    1c7a:	91 30       	cpi	r25, 0x01	; 1
    1c7c:	89 f4       	brne	.+34     	; 0x1ca0 <main+0x80>
			{
				avgCount=0;
    1c7e:	10 92 69 00 	sts	0x0069, r1
				adcAvg += adcVal;
    1c82:	40 e0       	ldi	r20, 0x00	; 0
    1c84:	50 e0       	ldi	r21, 0x00	; 0
    1c86:	2c 0d       	add	r18, r12
    1c88:	3d 1d       	adc	r19, r13
    1c8a:	4e 1d       	adc	r20, r14
    1c8c:	5f 1d       	adc	r21, r15
    1c8e:	20 93 c8 00 	sts	0x00C8, r18
    1c92:	30 93 c9 00 	sts	0x00C9, r19
    1c96:	40 93 ca 00 	sts	0x00CA, r20
    1c9a:	50 93 cb 00 	sts	0x00CB, r21
    1c9e:	2c c0       	rjmp	.+88     	; 0x1cf8 <main+0xd8>
			else if(avgCount == 0)
			{
				//After the first case, the average should be somewhere
				//'round the ADC Val... then after subtracting the current
				//adcVal, we should be close to zero...
				adcAvg -= adcVal;
    1ca0:	c9 01       	movw	r24, r18
    1ca2:	a0 e0       	ldi	r26, 0x00	; 0
    1ca4:	b0 e0       	ldi	r27, 0x00	; 0
    1ca6:	a7 01       	movw	r20, r14
    1ca8:	96 01       	movw	r18, r12
    1caa:	28 1b       	sub	r18, r24
    1cac:	39 0b       	sbc	r19, r25
    1cae:	4a 0b       	sbc	r20, r26
    1cb0:	5b 0b       	sbc	r21, r27
    1cb2:	da 01       	movw	r26, r20
    1cb4:	c9 01       	movw	r24, r18
    1cb6:	20 93 c8 00 	sts	0x00C8, r18
    1cba:	30 93 c9 00 	sts	0x00C9, r19
    1cbe:	40 93 ca 00 	sts	0x00CA, r20
    1cc2:	50 93 cb 00 	sts	0x00CB, r21
					// If there's a lot of change, it will be positive...
					// the ADC is ten-bits, so 3.3V/1024 = .003V per LSB
					// Of course, a spike isn't instantaneous...
					// .2V is measurable on the 'scope, currently...
#define ADC_DETECTION_THRESHOLD	15 //20 //38 //(1024*125/3300)
					if(absDiff > ADC_DETECTION_THRESHOLD)
    1cc6:	57 ff       	sbrs	r21, 7
    1cc8:	07 c0       	rjmp	.+14     	; 0x1cd8 <main+0xb8>
    1cca:	b0 95       	com	r27
    1ccc:	a0 95       	com	r26
    1cce:	90 95       	com	r25
    1cd0:	81 95       	neg	r24
    1cd2:	9f 4f       	sbci	r25, 0xFF	; 255
    1cd4:	af 4f       	sbci	r26, 0xFF	; 255
    1cd6:	bf 4f       	sbci	r27, 0xFF	; 255
    1cd8:	80 31       	cpi	r24, 0x10	; 16
    1cda:	91 05       	cpc	r25, r1
    1cdc:	a1 05       	cpc	r26, r1
    1cde:	b1 05       	cpc	r27, r1
    1ce0:	0c f0       	brlt	.+2      	; 0x1ce4 <main+0xc4>
						fbQuestion_hitDetected();
    1ce2:	33 df       	rcall	.-410    	; 0x1b4a <fbQuestion_hitDetected>
				}
				adcAvg = 0;
    1ce4:	10 92 c8 00 	sts	0x00C8, r1
    1ce8:	10 92 c9 00 	sts	0x00C9, r1
    1cec:	10 92 ca 00 	sts	0x00CA, r1
    1cf0:	10 92 cb 00 	sts	0x00CB, r1
				avgCount=1;
    1cf4:	10 93 69 00 	sts	0x0069, r17
		}

		//static uint32_t count = 0;
		static uint8_t lastFrameCount = 0;
#define FRAME_COUNT_LIMIT 0x03
		uint8_t thisFrameCount = frameCount&FRAME_COUNT_LIMIT;
    1cf8:	00 91 c4 00 	lds	r16, 0x00C4
    1cfc:	03 70       	andi	r16, 0x03	; 3

//		if(( (thisFrameCount==0) && (lastFrameCount==FRAME_COUNT_LIMIT) ))
		if(thisFrameCount != lastFrameCount)
    1cfe:	80 91 c5 00 	lds	r24, 0x00C5
    1d02:	08 13       	cpse	r16, r24
		{
			fbQuestion_update();
    1d04:	88 dd       	rcall	.-1264   	; 0x1816 <fbQuestion_update>
		}

		lastFrameCount = thisFrameCount;
    1d06:	00 93 c5 00 	sts	0x00C5, r16
#endif
		heartUpdate();
	}
    1d0a:	99 cf       	rjmp	.-206    	; 0x1c3e <main+0x1e>

00001d0c <__mulhi3>:
    1d0c:	55 27       	eor	r21, r21
    1d0e:	00 24       	eor	r0, r0

00001d10 <__mulhi3_loop>:
    1d10:	80 ff       	sbrs	r24, 0
    1d12:	02 c0       	rjmp	.+4      	; 0x1d18 <__mulhi3_skip1>
    1d14:	06 0e       	add	r0, r22
    1d16:	57 1f       	adc	r21, r23

00001d18 <__mulhi3_skip1>:
    1d18:	66 0f       	add	r22, r22
    1d1a:	77 1f       	adc	r23, r23
    1d1c:	61 15       	cp	r22, r1
    1d1e:	71 05       	cpc	r23, r1
    1d20:	21 f0       	breq	.+8      	; 0x1d2a <__mulhi3_exit>
    1d22:	96 95       	lsr	r25
    1d24:	87 95       	ror	r24
    1d26:	00 97       	sbiw	r24, 0x00	; 0
    1d28:	99 f7       	brne	.-26     	; 0x1d10 <__mulhi3_loop>

00001d2a <__mulhi3_exit>:
    1d2a:	95 2f       	mov	r25, r21
    1d2c:	80 2d       	mov	r24, r0
    1d2e:	08 95       	ret

00001d30 <__udivmodqi4>:
    1d30:	99 1b       	sub	r25, r25
    1d32:	79 e0       	ldi	r23, 0x09	; 9
    1d34:	04 c0       	rjmp	.+8      	; 0x1d3e <__udivmodqi4_ep>

00001d36 <__udivmodqi4_loop>:
    1d36:	99 1f       	adc	r25, r25
    1d38:	96 17       	cp	r25, r22
    1d3a:	08 f0       	brcs	.+2      	; 0x1d3e <__udivmodqi4_ep>
    1d3c:	96 1b       	sub	r25, r22

00001d3e <__udivmodqi4_ep>:
    1d3e:	88 1f       	adc	r24, r24
    1d40:	7a 95       	dec	r23
    1d42:	c9 f7       	brne	.-14     	; 0x1d36 <__udivmodqi4_loop>
    1d44:	80 95       	com	r24
    1d46:	08 95       	ret

00001d48 <__udivmodhi4>:
    1d48:	aa 1b       	sub	r26, r26
    1d4a:	bb 1b       	sub	r27, r27
    1d4c:	51 e1       	ldi	r21, 0x11	; 17
    1d4e:	07 c0       	rjmp	.+14     	; 0x1d5e <__udivmodhi4_ep>

00001d50 <__udivmodhi4_loop>:
    1d50:	aa 1f       	adc	r26, r26
    1d52:	bb 1f       	adc	r27, r27
    1d54:	a6 17       	cp	r26, r22
    1d56:	b7 07       	cpc	r27, r23
    1d58:	10 f0       	brcs	.+4      	; 0x1d5e <__udivmodhi4_ep>
    1d5a:	a6 1b       	sub	r26, r22
    1d5c:	b7 0b       	sbc	r27, r23

00001d5e <__udivmodhi4_ep>:
    1d5e:	88 1f       	adc	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	5a 95       	dec	r21
    1d64:	a9 f7       	brne	.-22     	; 0x1d50 <__udivmodhi4_loop>
    1d66:	80 95       	com	r24
    1d68:	90 95       	com	r25
    1d6a:	bc 01       	movw	r22, r24
    1d6c:	cd 01       	movw	r24, r26
    1d6e:	08 95       	ret

00001d70 <__divmodhi4>:
    1d70:	97 fb       	bst	r25, 7
    1d72:	09 2e       	mov	r0, r25
    1d74:	07 26       	eor	r0, r23
    1d76:	0a d0       	rcall	.+20     	; 0x1d8c <__divmodhi4_neg1>
    1d78:	77 fd       	sbrc	r23, 7
    1d7a:	04 d0       	rcall	.+8      	; 0x1d84 <__divmodhi4_neg2>
    1d7c:	e5 df       	rcall	.-54     	; 0x1d48 <__udivmodhi4>
    1d7e:	06 d0       	rcall	.+12     	; 0x1d8c <__divmodhi4_neg1>
    1d80:	00 20       	and	r0, r0
    1d82:	1a f4       	brpl	.+6      	; 0x1d8a <__divmodhi4_exit>

00001d84 <__divmodhi4_neg2>:
    1d84:	70 95       	com	r23
    1d86:	61 95       	neg	r22
    1d88:	7f 4f       	sbci	r23, 0xFF	; 255

00001d8a <__divmodhi4_exit>:
    1d8a:	08 95       	ret

00001d8c <__divmodhi4_neg1>:
    1d8c:	f6 f7       	brtc	.-4      	; 0x1d8a <__divmodhi4_exit>
    1d8e:	90 95       	com	r25
    1d90:	81 95       	neg	r24
    1d92:	9f 4f       	sbci	r25, 0xFF	; 255
    1d94:	08 95       	ret

00001d96 <_exit>:
    1d96:	f8 94       	cli

00001d98 <__stop_program>:
    1d98:	ff cf       	rjmp	.-2      	; 0x1d98 <__stop_program>
